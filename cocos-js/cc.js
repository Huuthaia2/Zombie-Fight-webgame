System.register([], (function(e, t) {
    "use strict";
    return {
        execute: function() {
            e({
                BitMask: Je,
                CCClass: qt,
                CacheMode: void 0,
                DebugMode: void 0,
                Enum: $e,
                Eventify: _i,
                HorizontalTextAlignment: void 0,
                InstanceMaterialType: void 0,
                Overflow: void 0,
                SystemEventType: void 0,
                VerticalTextAlignment: void 0,
                WorldNode3DToLocalNodeUI: Sy,
                WorldNode3DToWorldNodeUI: Ey,
                absMax: gn,
                absMaxComponent: mn,
                approx: $t,
                assert: m,
                assertID: I,
                bezier: vL,
                bezierByTime: CL,
                ccenum: nt,
                clamp: en,
                clamp01: tn,
                color: Sn,
                computeRatioByType: IL,
                createDefaultPipeline: kC,
                deserialize: bd,
                earcut: DQ,
                equals: Jt,
                error: p,
                errorID: b,
                find: UP,
                fragmentText: DW,
                getBaselineOffset: function() {
                    return 0
                },
                getError: P,
                getPathFromRoot: function(e, t) {
                    for (var n = e, i = ""; null !== n && n !== t;) i = n.name + "/" + i, n = n.parent;
                    return i.slice(0, -1)
                },
                getWorldTransformUntilRoot: WB,
                instantiate: PR,
                inverseLerp: pn,
                isCustomTargetModifier: QB,
                isDisplayStats: O,
                isElementModifier: ZB,
                isPropertyModifier: KB,
                isUnicodeCJK: wW,
                isUnicodeSpace: IW,
                isValid: ri,
                lerp: nn,
                log: f,
                logID: T,
                markAsWarning: void 0,
                mat4: Un,
                murmurhash2_32_gc: vc,
                nextPow2: _n,
                pingPong: dn,
                pseudoRandom: ln,
                pseudoRandomRange: un,
                pseudoRandomRangeInt: hn,
                quat: Mn,
                randomRange: sn,
                randomRangeInt: cn,
                rect: Zn,
                removeProperty: void 0,
                repeat: fn,
                replaceProperty: void 0,
                safeMeasureText: PW,
                sampleAnimationCurve: wL,
                setDefaultLogTimes: function(e) {
                    e > 0 && (j = e)
                },
                setDisplayStats: D,
                size: Yn,
                toDegree: on,
                toRadian: rn,
                tween: yne,
                tweenUtil: Sne,
                v2: Vn,
                v3: xn,
                v4: jn,
                warn: d,
                warnID: x
            });
            var n = "undefined" == typeof window ? global : window,
                i = e("cclegacy", {
                    _global: n
                });
            i.internal = {}, n.CC_BUILD = !0, n.CC_TEST = !1, n.CC_EDITOR = false, n.CC_PREVIEW = !1, n.CC_DEV = !1, n.CC_DEBUG = !1, n.CC_JSB = !1, n.CC_BYTEDANCE = !1, n.CC_WECHAT = !1, n.CC_ALIPAY = !1, n.CC_XIAOMI = !1, n.CC_BAIDU = !1, n.CC_COCOSPLAY = !1, n.CC_HUAWEI = !1, n.CC_OPPO = !1, n.CC_VIVO = !1, n.CC_MINIGAME = !1, n.CC_RUNTIME_BASED = !1, n.CC_SUPPORT_JIT = !0;
            var r = e("VERSION", "3.1");
            n.CocosEngine = i.ENGINE_VERSION = r, n.cc = i;
            var o = "https://github.com/cocos-creator/engine/blob/3d/EngineErrorMap.md",
                a = null,
                s = console.log.bind(console),
                c = s,
                l = s,
                u = function(e, t) {
                    if (!e) {
                        for (var n = arguments.length, i = new Array(n > 2 ? n - 2 : 0), r = 2; r < n; r++) i[r - 2] = arguments[r];
                        console.log("ASSERT: " + _.apply(void 0, [t].concat(i)))
                    }
                },
                h = s;

            function _(e) {
                for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++) n[r - 1] = arguments[r];
                return i.js.formatStr.apply(null, [e].concat(n))
            }

            function f(e) {
                for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++) n[i - 1] = arguments[i];
                return s.apply(void 0, [e].concat(n))
            }

            function d(e) {
                for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++) n[i - 1] = arguments[i];
                return c.apply(void 0, [e].concat(n))
            }

            function p(e) {
                for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++) n[i - 1] = arguments[i];
                return l.apply(void 0, [e].concat(n))
            }

            function m(e, t) {
                for (var n = arguments.length, i = new Array(n > 2 ? n - 2 : 0), r = 2; r < n; r++) i[r - 2] = arguments[r];
                return u.apply(void 0, [e, t].concat(i))
            }

            function g() {
                return h.apply(void 0, arguments)
            }

            function v(e) {
                if (s = c = l = u = h = function() {}, e !== R.NONE) {
                    if (e > R.ERROR) {
                        var t = function(e) {
                            if (i.game.canvas) {
                                if (!a) {
                                    var t = document.createElement("Div");
                                    t.setAttribute("id", "logInfoDiv"), t.setAttribute("width", "200"), t.setAttribute("height", i.game.canvas.height);
                                    var n = t.style;
                                    n.zIndex = "99999", n.position = "absolute", n.top = n.left = "0", (a = document.createElement("textarea")).setAttribute("rows", "20"), a.setAttribute("cols", "30"), a.setAttribute("disabled", "true");
                                    var r = a.style;
                                    r.backgroundColor = "transparent", r.borderBottom = "1px solid #cccccc", r.borderTopWidth = r.borderLeftWidth = r.borderRightWidth = "0px", r.borderTopStyle = r.borderLeftStyle = r.borderRightStyle = "none", r.padding = "0px", r.margin = "0px", t.appendChild(a), i.game.canvas.parentNode.appendChild(t)
                                }
                                a.value = a.value + e + "\r\n", a.scrollTop = a.scrollHeight
                            }
                        };
                        l = function(e) {
                            for (var n = arguments.length, i = new Array(n > 1 ? n - 1 : 0), r = 1; r < n; r++) i[r - 1] = arguments[r];
                            t("ERROR :  " + _.apply(void 0, [e].concat(i)))
                        }, u = function(e, n) {
                            if (!e) {
                                for (var i = arguments.length, r = new Array(i > 2 ? i - 2 : 0), o = 2; o < i; o++) r[o - 2] = arguments[o];
                                t("ASSERT: " + _.apply(void 0, [n].concat(r)))
                            }
                        }, e !== R.ERROR_FOR_WEB_PAGE && (c = function(e) {
                            for (var n = arguments.length, i = new Array(n > 1 ? n - 1 : 0), r = 1; r < n; r++) i[r - 1] = arguments[r];
                            t("WARN :  " + _.apply(void 0, [e].concat(i)))
                        }), e === R.INFO_FOR_WEB_PAGE && (s = function(e) {
                            for (var n = arguments.length, i = new Array(n > 1 ? n - 1 : 0), r = 1; r < n; r++) i[r - 1] = arguments[r];
                            t(_.apply(void 0, [e].concat(i)))
                        })
                    } else console && (console.error || (console.error = console.log), console.warn || (console.warn = console.log), l = console.error.bind ? console.error.bind(console) : function(e) {
                        for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++) n[i - 1] = arguments[i];
                        return console.error.apply(console, [e].concat(n))
                    }, u = function(e, t) {
                        if (!e) {
                            for (var n = arguments.length, i = new Array(n > 2 ? n - 2 : 0), r = 2; r < n; r++) i[r - 2] = arguments[r];
                            var o = _.apply(void 0, [t].concat(i));
                            throw new Error(o)
                        }
                    });
                    if (e !== R.ERROR && (c = console.warn.bind ? console.warn.bind(console) : function(e) {
                            for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++) n[i - 1] = arguments[i];
                            return console.warn.apply(console, [e].concat(n))
                        }), e === R.INFO && (s = console.log.bind ? console.log.bind(console) : function(e) {
                            for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++) n[i - 1] = arguments[i];
                            return console.log.apply(console, [e].concat(n))
                        }), e <= R.VERBOSE && "function" == typeof console.debug) {
                        var n = console.debug;
                        h = function() {
                            return n.apply(void 0, arguments)
                        }
                    }
                }
            }

            function y(e) {
                p(e.stack || e)
            }

            function S(e) {
                return function(t) {
                    for (var n = e + " " + t + ", please go to " + o + "#" + t + " to see details.", i = arguments.length, r = new Array(i > 1 ? i - 1 : 0), a = 1; a < i; a++) r[a - 1] = arguments[a];
                    return 0 === r.length ? n : n + " Arguments: " + r.join(", ")
                }
            }
            var E = S("Log");

            function T(e) {
                for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++) n[i - 1] = arguments[i];
                f(E.apply(void 0, [e].concat(n)))
            }
            var A = S("Warning");

            function x(e) {
                for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++) n[i - 1] = arguments[i];
                d(A.apply(void 0, [e].concat(n)))
            }
            var C = S("Error");

            function b(e) {
                for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++) n[i - 1] = arguments[i];
                p(C.apply(void 0, [e].concat(n)))
            }
            var R, w = S("Assert");

            function I(e, t) {
                if (!e) {
                    for (var n = arguments.length, i = new Array(n > 2 ? n - 2 : 0), r = 2; r < n; r++) i[r - 2] = arguments[r];
                    m(!1, w.apply(void 0, [t].concat(i)))
                }
            }

            function P(e) {
                for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++) n[i - 1] = arguments[i];
                return C.apply(void 0, [e].concat(n))
            }

            function O() {
                return !!i.profiler && i.profiler.isShowingStats()
            }

            function D(e) {
                i.profiler && (e ? i.profiler.showStats() : i.profiler.hideStats(), i.game.config.showFPS = !!e)
            }! function(e) {
                e[e.NONE = 0] = "NONE", e[e.VERBOSE = 1] = "VERBOSE", e[e.INFO = 2] = "INFO", e[e.WARN = 3] = "WARN", e[e.ERROR = 4] = "ERROR", e[e.INFO_FOR_WEB_PAGE = 5] = "INFO_FOR_WEB_PAGE", e[e.WARN_FOR_WEB_PAGE = 6] = "WARN_FOR_WEB_PAGE", e[e.ERROR_FOR_WEB_PAGE = 7] = "ERROR_FOR_WEB_PAGE"
            }(R || (R = e("DebugMode", {})));
            var N = Object.freeze({
                __proto__: null,
                log: f,
                warn: d,
                error: p,
                assert: m,
                debug: g,
                _resetDebugSetting: v,
                _throw: y,
                logID: T,
                warnID: x,
                errorID: b,
                assertID: I,
                get DebugMode() {
                    return R
                },
                getError: P,
                isDisplayStats: O,
                setDisplayStats: D
            });

            function M(e) {
                var t, n;
                return t = (e > 65535) << 4, t |= n = ((e >>>= t) > 255) << 3, t |= n = ((e >>>= n) > 15) << 2, (t |= n = ((e >>>= n) > 3) << 1) | (e >>>= n) >> 1
            }

            function L(e) {
                var t = 32;
                return (e &= -e) && t--, 65535 & e && (t -= 16), 16711935 & e && (t -= 8), 252645135 & e && (t -= 4), 858993459 & e && (t -= 2), 1431655765 & e && (t -= 1), t
            }

            function B(e) {
                return e += 0 === e, --e, e |= e >>> 1, e |= e >>> 2, e |= e >>> 4, e |= e >>> 8, 1 + (e |= e >>> 16)
            }
            var F = new Array(256);
            ! function(e) {
                for (var t = 0; t < 256; ++t) {
                    var n = t,
                        i = t,
                        r = 7;
                    for (n >>>= 1; n; n >>>= 1) i <<= 1, i |= 1 & n, --r;
                    e[t] = i << r & 255
                }
            }(F);
            var z = Object.freeze({
                __proto__: null,
                INT_BITS: 32,
                INT_MAX: 2147483647,
                INT_MIN: -2147483648,
                sign: function(e) {
                    return (e > 0) - (e < 0)
                },
                abs: function(e) {
                    var t = e >> 31;
                    return (e ^ t) - t
                },
                min: function(e, t) {
                    return t ^ (e ^ t) & -(e < t)
                },
                max: function(e, t) {
                    return e ^ (e ^ t) & -(e < t)
                },
                isPow2: function(e) {
                    return !(e & e - 1 || !e)
                },
                log2: M,
                log10: function(e) {
                    return e >= 1e9 ? 9 : e >= 1e8 ? 8 : e >= 1e7 ? 7 : e >= 1e6 ? 6 : e >= 1e5 ? 5 : e >= 1e4 ? 4 : e >= 1e3 ? 3 : e >= 100 ? 2 : e >= 10 ? 1 : 0
                },
                popCount: function(e) {
                    return 16843009 * ((e = (858993459 & (e -= e >>> 1 & 1431655765)) + (e >>> 2 & 858993459)) + (e >>> 4) & 252645135) >>> 24
                },
                countTrailingZeros: L,
                nextPow2: B,
                prevPow2: function(e) {
                    return e |= e >>> 1, e |= e >>> 2, e |= e >>> 4, e |= e >>> 8, (e |= e >>> 16) - (e >>> 1)
                },
                parity: function(e) {
                    return e ^= e >>> 16, e ^= e >>> 8, e ^= e >>> 4, 27030 >>> (e &= 15) & 1
                },
                reverse: function(e) {
                    return F[255 & e] << 24 | F[e >>> 8 & 255] << 16 | F[e >>> 16 & 255] << 8 | F[e >>> 24 & 255]
                },
                interleave2: function(e, t) {
                    return (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e &= 65535) | e << 8)) | e << 4)) | e << 2)) | e << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t &= 65535) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1
                },
                deinterleave2: function(e, t) {
                    return (e = 65535 & ((e = 16711935 & ((e = 252645135 & ((e = 858993459 & ((e = e >>> t & 1431655765) | e >>> 1)) | e >>> 2)) | e >>> 4)) | e >>> 16)) << 16 >> 16
                },
                interleave3: function(e, t, n) {
                    return e = 1227133513 & ((e = 3272356035 & ((e = 251719695 & ((e = 4278190335 & ((e &= 1023) | e << 16)) | e << 8)) | e << 4)) | e << 2), (e |= (t = 1227133513 & ((t = 3272356035 & ((t = 251719695 & ((t = 4278190335 & ((t &= 1023) | t << 16)) | t << 8)) | t << 4)) | t << 2)) << 1) | (n = 1227133513 & ((n = 3272356035 & ((n = 251719695 & ((n = 4278190335 & ((n &= 1023) | n << 16)) | n << 8)) | n << 4)) | n << 2)) << 2
                },
                deinterleave3: function(e, t) {
                    return (e = 1023 & ((e = 4278190335 & ((e = 251719695 & ((e = 3272356035 & ((e = e >>> t & 1227133513) | e >>> 2)) | e >>> 4)) | e >>> 8)) | e >>> 16)) << 22 >> 22
                },
                nextCombination: function(e) {
                    var t = e | e - 1;
                    return t + 1 | (~t & -~t) - 1 >>> L(e) + 1
                }
            });
            e("bits", z);
            var U, G, H, k, V, W, j = 10,
                q = 0,
                X = new Map;

            function Y(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var i = t[n];
                    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
                }
            }

            function K(e, t, n) {
                return t && Y(e.prototype, t), n && Y(e, n), e
            }

            function Z() {
                return (Z = Object.assign || function(e) {
                    for (var t = 1; t < arguments.length; t++) {
                        var n = arguments[t];
                        for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i])
                    }
                    return e
                }).apply(this, arguments)
            }

            function Q(e, t) {
                e.prototype = Object.create(t.prototype), e.prototype.constructor = e, J(e, t)
            }

            function J(e, t) {
                return (J = Object.setPrototypeOf || function(e, t) {
                    return e.__proto__ = t, e
                })(e, t)
            }

            function $(e) {
                if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return e
            }

            function ee(e, t) {
                (null == t || t > e.length) && (t = e.length);
                for (var n = 0, i = new Array(t); n < t; n++) i[n] = e[n];
                return i
            }

            function te(e, t) {
                var n;
                if ("undefined" == typeof Symbol || null == e[Symbol.iterator]) {
                    if (Array.isArray(e) || (n = function(e, t) {
                            if (e) {
                                if ("string" == typeof e) return ee(e, t);
                                var n = Object.prototype.toString.call(e).slice(8, -1);
                                return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? ee(e, t) : void 0
                            }
                        }(e)) || t && e && "number" == typeof e.length) {
                        n && (e = n);
                        var i = 0;
                        return function() {
                            return i >= e.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: e[i++]
                            }
                        }
                    }
                    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                }
                return (n = e[Symbol.iterator]()).next.bind(n)
            }

            function ne(e, t, n, i) {
                n && Object.defineProperty(e, t, {
                    enumerable: n.enumerable,
                    configurable: n.configurable,
                    writable: n.writable,
                    value: n.initializer ? n.initializer.call(i) : void 0
                })
            }

            function ie(e, t, n, i, r) {
                var o = {};
                return Object.keys(i).forEach((function(e) {
                    o[e] = i[e]
                })), o.enumerable = !!o.enumerable, o.configurable = !!o.configurable, ("value" in o || o.initializer) && (o.writable = !0), o = n.slice().reverse().reduce((function(n, i) {
                    return i(e, t, n) || n
                }), o), r && void 0 !== o.initializer && (o.value = o.initializer ? o.initializer.call(r) : void 0, o.initializer = void 0), void 0 === o.initializer && (Object.defineProperty(e, t, o), o = null), o
            }
            k = function(e, t, n, i, r, o, a) {
                var s = X.get(o);
                s && s.logTimes > s.count && (r("'%s' is deprecated, please use '%s' instead. " + a, e + "." + t, n + "." + i), s.count++)
            }, U = e("replaceProperty", (function(e, t, n) {
                null != e && n.forEach((function(n) {
                    var i = q++;
                    X.set(i, {
                        id: i,
                        count: 0,
                        logTimes: void 0 !== n.logTimes ? n.logTimes : j
                    });
                    var r = null != n.target ? n.target : e,
                        o = null != n.newName ? n.newName : n.name,
                        a = null != n.targetName ? n.targetName : t,
                        s = r === e,
                        c = n.suggest ? "(" + n.suggest + ")" : "";
                    if (null != n.customFunction) e[n.name] = function() {
                        var e;
                        return k(t, n.name, a, o, d, i, c), (e = n.customFunction).call.apply(e, [this].concat(Array.prototype.slice.call(arguments)))
                    };
                    else if (null != n.customSetter || null != n.customGetter) {
                        var l = null != n.customSetter,
                            u = null != n.customGetter;
                        l && u ? Object.defineProperty(e, n.name, {
                            get: function() {
                                return k(t, n.name, a, o, d, i, c), n.customGetter.call(this)
                            },
                            set: function(e) {
                                k(t, n.name, a, o, d, i, c), n.customSetter.call(this, e)
                            },
                            enumerable: !1
                        }) : l ? Object.defineProperty(e, n.name, {
                            set: function(e) {
                                k(t, n.name, a, o, d, i, c), n.customSetter.call(this, e)
                            },
                            enumerable: !1
                        }) : u && Object.defineProperty(e, n.name, {
                            get: function() {
                                return k(t, n.name, a, o, d, i, c), n.customGetter.call(this)
                            },
                            enumerable: !1
                        })
                    } else Object.defineProperty(e, n.name, {
                        get: function() {
                            return k(t, n.name, a, o, d, i, c), s ? this[o] : r[o]
                        },
                        set: function(e) {
                            k(t, n.name, a, o, d, i, c), s ? this[o] = e : r[o] = e
                        },
                        enumerable: !1
                    })
                }))
            })), W = function(e, t, n, i, r) {
                var o = X.get(i);
                o && o.logTimes > o.count && (n("'%s' has been removed. " + r, e + "." + t), o.count++)
            }, G = e("removeProperty", (function(e, t, n) {
                null != e && n.forEach((function(n) {
                    var i = q++;
                    X.set(i, {
                        id: i,
                        count: 0,
                        logTimes: void 0 !== n.logTimes ? n.logTimes : j
                    });
                    var r = n.suggest ? "(" + n.suggest + ")" : "";
                    Object.defineProperty(e, n.name, {
                        get: function() {
                            return W(t, n.name, p, i, r)
                        },
                        set: function() {
                            W(t, n.name, p, i, r)
                        },
                        enumerable: !1
                    })
                }))
            })), V = function(e, t, n, i, r) {
                var o = X.get(i);
                o && o.logTimes > o.count && (n("'%s' is deprecated. " + r, e + "." + t), o.count++)
            }, H = e("markAsWarning", (function(e, t, n) {
                if (null != e) {
                    var i = function(t, n, i, r, o, a) {
                        if (t.get) {
                            var s = t.get;
                            t.get = function() {
                                return V(n, i, r, o, a), s.call(this)
                            }
                        }
                        if (t.set) {
                            var c = t.set;
                            t.set = function(e) {
                                V(n, i, r, o, a), c.call(this, e)
                            }
                        }
                        Object.defineProperty(e, i, t)
                    };
                    n.forEach((function(n) {
                        var r = n.name,
                            o = Object.getOwnPropertyDescriptor(e, r);
                        if (o && o.configurable) {
                            var a = q++;
                            X.set(a, {
                                id: a,
                                count: 0,
                                logTimes: void 0 !== n.logTimes ? n.logTimes : j
                            });
                            var s = n.suggest ? "(" + n.suggest + ")" : "";
                            if (null != o.value)
                                if ("function" == typeof o.value) {
                                    var c = o.value;
                                    e[r] = function() {
                                        return V(t, r, d, a, s), c.call.apply(c, [this].concat(Array.prototype.slice.call(arguments)))
                                    }
                                } else i(o, t, r, d, a, s);
                            else i(o, t, r, d, a, s);
                            Object.defineProperty(e, r, {
                                enumerable: !1
                            })
                        }
                    }))
                }
            }));
            var re = function() {
                function e(e) {
                    this.i = 0, this.array = e
                }
                var t = e.prototype;
                return t.remove = function(e) {
                    var t = this.array.indexOf(e);
                    t >= 0 && this.removeAt(t)
                }, t.removeAt = function(e) {
                    this.array.splice(e, 1), e <= this.i && --this.i
                }, t.fastRemove = function(e) {
                    var t = this.array.indexOf(e);
                    t >= 0 && this.fastRemoveAt(t)
                }, t.fastRemoveAt = function(e) {
                    var t = this.array;
                    t[e] = t[t.length - 1], --t.length, e <= this.i && --this.i
                }, t.push = function(e) {
                    this.array.push(e)
                }, K(e, [{
                    key: "length",
                    get: function() {
                        return this.array.length
                    },
                    set: function(e) {
                        this.array.length = e, this.i >= e && (this.i = e - 1)
                    }
                }]), e
            }();

            function oe(e, t) {
                e.splice(t, 1)
            }

            function ae(e, t) {
                var n = e.length;
                t < 0 || t >= n || (e[t] = e[n - 1], e.length = n - 1)
            }

            function se(e, t) {
                var n = e.indexOf(t);
                return n >= 0 && (oe(e, n), !0)
            }

            function ce(e, t) {
                return e.indexOf(t) >= 0
            }
            var le = Object.freeze({
                    __proto__: null,
                    removeAt: oe,
                    fastRemoveAt: ae,
                    remove: se,
                    fastRemove: function(e, t) {
                        var n = e.indexOf(t);
                        n >= 0 && (e[n] = e[e.length - 1], --e.length)
                    },
                    removeIf: function(e, t) {
                        var n = e.findIndex(t);
                        if (n >= 0) {
                            var i = e[n];
                            return oe(e, n), i
                        }
                    },
                    verifyType: function(e, t) {
                        if (e && e.length > 0)
                            for (var n, i = te(e); !(n = i()).done;)
                                if (!(n.value instanceof t)) return T(1300), !1;
                        return !0
                    },
                    removeArray: function(e, t) {
                        for (var n = 0, i = t.length; n < i; n++) se(e, t[n])
                    },
                    appendObjectsAt: function(e, t, n) {
                        return e.splice.apply(e, [n, 0].concat(t)), e
                    },
                    contains: ce,
                    copy: function(e) {
                        for (var t = e.length, n = new Array(t), i = 0; i < t; i += 1) n[i] = e[i];
                        return n
                    },
                    MutableForwardIterator: re
                }),
                ue = function() {
                    function e(e) {
                        this.id = void 0, this.prefix = void 0, this.id = 0 | 998 * Math.random(), this.prefix = e ? e + "." : ""
                    }
                    return e.prototype.getNewId = function() {
                        return this.prefix + ++this.id
                    }, e
                }();
            ue.global = new ue("global");
            var he = new ue("TmpCId."),
                _e = "undefined" == typeof Symbol ? "__aliases__" : Symbol("[[Aliases]]"),
                fe = "__cid__";

            function de(e) {
                return "number" == typeof e || e instanceof Number
            }

            function pe(e) {
                return "string" == typeof e || e instanceof String
            }

            function me(e) {
                for (var t in e) return !1;
                return !0
            }
            var ge, ve = (ge = {
                    value: void 0,
                    enumerable: !1,
                    writable: !1,
                    configurable: !0
                }, function(e, t, n, i, r) {
                    ge.value = n, ge.writable = i, ge.enumerable = r, Object.defineProperty(e, t, ge), ge.value = void 0
                }),
                ye = function() {
                    var e = {
                        get: void 0,
                        set: void 0,
                        enumerable: !1
                    };
                    return function(t, n, i, r, o, a) {
                        void 0 === o && (o = !1), void 0 === a && (a = !1), "boolean" == typeof r && (o = r, r = void 0), e.get = i, e.set = r, e.enumerable = o, e.configurable = a, Object.defineProperty(t, n, e), e.get = void 0, e.set = void 0
                    }
                }(),
                Se = function() {
                    var e = {
                        get: void 0,
                        enumerable: !1,
                        configurable: !1
                    };
                    return function(t, n, i, r, o) {
                        e.get = i, e.enumerable = r, e.configurable = o, Object.defineProperty(t, n, e), e.get = void 0
                    }
                }(),
                Ee = function() {
                    var e = {
                        set: void 0,
                        enumerable: !1,
                        configurable: !1
                    };
                    return function(t, n, i, r, o) {
                        e.set = i, e.enumerable = r, e.configurable = o, Object.defineProperty(t, n, e), e.set = void 0
                    }
                }();

            function Te(e) {
                var t = Object.create(null);
                return e && (t["."] = 1, t["/"] = 1, delete t["."], delete t["/"]), t
            }

            function Ae(e) {
                if ("function" == typeof e) {
                    var t = e.prototype;
                    if (t && t.hasOwnProperty("__classname__") && t.__classname__) return t.__classname__;
                    var n = "";
                    if (e.name && (n = e.name), e.toString) {
                        var i, r = e.toString();
                        (i = "[" === r.charAt(0) ? r.match(/\[\w+\s*(\w+)\]/) : r.match(/function\s*(\w+)/)) && 2 === i.length && (n = i[1])
                    }
                    return "Object" !== n ? n : ""
                }
                return e && e.constructor ? Ae(e.constructor) : ""
            }

            function xe(e, t, n, i) {
                var r = /([^.]+)$/,
                    o = r.exec(t)[0],
                    a = r.exec(n)[0];

                function s() {
                    return this[a]
                }
                i ? ye(e, o, s, (function(e) {
                    this[a] = e
                })) : Se(e, o, s)
            }

            function Ce(e, t, n, i) {
                for (var r in n) xe(e, t + "." + r, n[r], i)
            }
            var be = /(%d)|(%s)/,
                Re = /%s/;

            function we(e) {
                for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++) n[i - 1] = arguments[i];
                if (0 === arguments.length) return "";
                if (0 === n.length) return "" + e;
                var r = "string" == typeof e && be.test(e);
                if (r)
                    for (var o, a = te(n); !(o = a()).done;) {
                        var s = o.value,
                            c = "number" == typeof s ? be : Re;
                        if (c.test(e)) {
                            var l = "" + s;
                            e = e.replace(c, l)
                        } else e += " " + s
                    } else
                        for (var u, h = te(n); !(u = h()).done;) {
                            var _ = u.value;
                            e += " " + _
                        }
                return e
            }

            function Ie() {
                for (var e = arguments.length - 1, t = new Array(e), n = 0; n < e; ++n) t[n] = arguments[n + 1];
                return t
            }

            function Pe(e, t) {
                for (; e;) {
                    var n = Object.getOwnPropertyDescriptor(e, t);
                    if (n) return n;
                    e = Object.getPrototypeOf(e)
                }
                return null
            }

            function Oe(e, t, n) {
                var i = Pe(t, e);
                i && Object.defineProperty(n, e, i)
            }

            function De(e) {
                e = e || {};
                for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++) n[i - 1] = arguments[i];
                for (var r = 0, o = n; r < o.length; r++) {
                    var a = o[r];
                    if (a) {
                        if ("object" != typeof a) {
                            b(5402, a);
                            continue
                        }
                        for (var s in a) s in e || Oe(s, a, e)
                    }
                }
                return e
            }

            function Ne(e) {
                e = e || {};
                for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++) n[i - 1] = arguments[i];
                for (var r = 0, o = n; r < o.length; r++) {
                    var a = o[r];
                    if (a) {
                        if ("object" != typeof a) {
                            b(5403, a);
                            continue
                        }
                        for (var s in a) Oe(s, a, e)
                    }
                }
                return e
            }

            function Me(e, t) {
                for (var n in t) t.hasOwnProperty(n) && (e[n] = t[n]);
                return e.prototype = Object.create(t.prototype, {
                    constructor: {
                        value: e,
                        writable: !0,
                        configurable: !0
                    }
                }), e
            }

            function Le(e) {
                var t = e.prototype,
                    n = t && Object.getPrototypeOf(t);
                return n && n.constructor
            }

            function Be(e, t) {
                if (e && t) {
                    if ("function" != typeof e) return !1;
                    if ("function" != typeof t) return !1;
                    if (e === t) return !0;
                    for (;;) {
                        if (!(e = Le(e))) return !1;
                        if (e === t) return !0
                    }
                }
                return !1
            }

            function Fe(e) {
                for (var t = 0, n = Object.keys(e); t < n.length; t++) delete e[n[t]]
            }
            var ze = Te(!0),
                Ue = Te(!0);

            function Ge(e, t) {
                return function(n, i) {
                    if (i.prototype.hasOwnProperty(e) && delete t[i.prototype[e]], ve(i.prototype, e, n), n) {
                        var r = t[n];
                        r && r !== i ? p("A Class already exists with the same " + e + ' : "' + n + '".') : t[n] = i
                    }
                }
            }
            var He = Ge("__cid__", ze),
                ke = Ge("__classname__", Ue);

            function Ve(e, t) {
                if (ke(e, t), !t.prototype.hasOwnProperty(fe)) {
                    var n = e || he.getNewId();
                    n && He(n, t)
                }
            }

            function We(e, t) {
                var n = Ue[t],
                    i = ze[t],
                    r = !0;
                if (n && n !== e && (p('"' + t + '" has already been set as name or alias of another class.'), r = !1), i && i !== e && (p('"' + t + '" has already been set as id or alias of another class.'), r = !1), r) {
                    var o = e[_e];
                    o || (o = [], e[_e] = o), o.push(t), Ue[t] = e, ze[t] = e
                }
            }

            function je() {
                for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
                for (var i = 0, r = t; i < r.length; i++) {
                    var o = r[i],
                        a = o.prototype,
                        s = a.__cid__;
                    s && delete ze[s];
                    var c = a.__classname__;
                    c && delete Ue[c];
                    var l = a[_e];
                    if (l)
                        for (var u = 0; u < l.length; ++u) {
                            var h = l[u];
                            delete Ue[h], delete ze[h]
                        }
                }
            }

            function qe(e) {
                return ze[e]
            }

            function Xe(e) {
                return Ue[e]
            }

            function Ye(e, t) {
                if (t = void 0 === t || t, "function" == typeof e && e.prototype.hasOwnProperty(fe)) return e.prototype.__cid__;
                if (e && e.constructor) {
                    var n = e.constructor.prototype;
                    if (n && n.hasOwnProperty(fe)) return e.__cid__
                }
                return ""
            }
            var Ke = function() {
                    var e = t.prototype;

                    function t(e, t) {
                        this.count = void 0, this._pool = void 0, this._cleanup = void 0;
                        var n = void 0 === t ? e : t,
                            i = void 0 === t ? null : e;
                        this.count = 0, this._pool = new Array(n), this._cleanup = i
                    }
                    return e.get = function() {
                        return this._get()
                    }, e._get = function() {
                        if (this.count > 0) {
                            --this.count;
                            var e = this._pool[this.count];
                            return this._pool[this.count] = null, e
                        }
                        return null
                    }, e.put = function(e) {
                        var t = this._pool;
                        if (this.count < t.length) {
                            if (this._cleanup && !1 === this._cleanup(e)) return;
                            t[this.count] = e, ++this.count
                        }
                    }, e.resize = function(e) {
                        e >= 0 && (this._pool.length = e, this.count > e && (this.count = e))
                    }, t
                }(),
                Ze = le,
                Qe = {
                    IDGenerator: ue,
                    Pool: Ke,
                    array: le,
                    isNumber: de,
                    isString: pe,
                    isEmptyObject: me,
                    getPropertyDescriptor: Pe,
                    addon: De,
                    mixin: Ne,
                    extend: Me,
                    getSuper: Le,
                    isChildClassOf: Be,
                    clear: Fe,
                    value: ve,
                    getset: ye,
                    get: Se,
                    set: Ee,
                    unregisterClass: je,
                    getClassName: Ae,
                    setClassName: Ve,
                    setClassAlias: We,
                    getClassByName: Xe,
                    get _registeredClassNames() {
                        return Z({}, Ue)
                    },
                    set _registeredClassNames(e) {
                        Fe(Ue), Object.assign(Ue, e)
                    },
                    get _registeredClassIds() {
                        return Z({}, ze)
                    },
                    set _registeredClassIds(e) {
                        Fe(ze), Object.assign(ze, e)
                    },
                    _getClassId: Ye,
                    _setClassId: He,
                    _getClassById: qe,
                    obsolete: xe,
                    obsoletes: Ce,
                    formatStr: we,
                    shiftArguments: Ie,
                    createMap: Te
                };

            function Je(e) {
                if ("__bitmask__" in e) return e;
                ve(e, "__bitmask__", null, !0);
                for (var t = -1, n = Object.keys(e), i = 0; i < n.length; i++) {
                    var r = n[i],
                        o = e[r];
                    if (-1 === o) o = ++t, e[r] = o;
                    else if ("number" == typeof o) t = o;
                    else if ("string" == typeof o && Number.isInteger(parseFloat(r))) continue;
                    var a = "" + o;
                    r !== a && ve(e, a, r)
                }
                return e
            }

            function $e(e) {
                return "__enums__" in e ? e : (ve(e, "__enums__", null, !0), $e.update(e))
            }

            function et(e) {
                e.hasOwnProperty("__enums__")
            }

            function tt(e) {
                et(e);
                var t = e.__enums__ || [];
                for (var n in t.length = 0, e) {
                    var i = e[n];
                    Number.isInteger(i) && t.push({
                        name: n,
                        value: i
                    })
                }
                return t.sort((function(e, t) {
                    return e.value - t.value
                })), e.__enums__ = t, t
            }

            function nt(e) {
                "__enums__" in e || ve(e, "__enums__", null, !0)
            }
            i.js = Qe, e("js", Object.freeze({
                __proto__: null,
                array: Ze,
                js: Qe,
                IDGenerator: ue,
                Pool: Ke,
                isNumber: de,
                isString: pe,
                isEmptyObject: me,
                value: ve,
                getset: ye,
                get: Se,
                set: Ee,
                createMap: Te,
                getClassName: Ae,
                obsolete: xe,
                obsoletes: Ce,
                formatStr: we,
                shiftArguments: Ie,
                getPropertyDescriptor: Pe,
                addon: De,
                mixin: Ne,
                extend: Me,
                getSuper: Le,
                isChildClassOf: Be,
                clear: Fe,
                _idToClass: ze,
                _nameToClass: Ue,
                _setClassId: He,
                setClassName: Ve,
                setClassAlias: We,
                unregisterClass: je,
                _getClassById: qe,
                getClassByName: Xe,
                _getClassId: Ye
            })), Je.isBitMask = function(e) {
                return e && e.hasOwnProperty("__bitmask__")
            }, Je.getList = function(e) {
                if (e.__bitmask__) return e.__bitmask__;
                var t = e.__bitmask__ = [];
                for (var n in e) {
                    var i = e[n];
                    Number.isInteger(i) && t.push({
                        name: n,
                        value: i
                    })
                }
                return t.sort((function(e, t) {
                    return e.value - t.value
                })), t
            }, i.BitMask = Je, $e.update = function(e) {
                for (var t = -1, n = Object.keys(e), i = 0; i < n.length; i++) {
                    var r = n[i],
                        o = e[r];
                    if (-1 === o) o = ++t, e[r] = o;
                    else if ("number" == typeof o) t = o;
                    else if ("string" == typeof o && Number.isInteger(parseFloat(r))) continue;
                    var a = "" + o;
                    r !== a && ve(e, a, r)
                }
                return Array.isArray(e.__enums__) && tt(e), e
            }, $e || ($e = e("Enum", {})), $e.isEnum = function(e) {
                return e && e.hasOwnProperty("__enums__")
            }, $e.getList = function(e) {
                return et(e), e.__enums__ ? e.__enums__ : tt(e)
            }, i.Enum = $e;
            var it = e("ValueType", function() {
                function e() {}
                var t = e.prototype;
                return t.clone = function() {
                    return b(100, Ae(this) + ".clone"), this
                }, t.equals = function() {
                    return !1
                }, t.set = function() {
                    b(100, Ae(this) + ".set")
                }, t.toString = function() {
                    return "" + {}
                }, e
            }());
            Ve("cc.ValueType", it), i.ValueType = it;
            var rt = e("macro", {
                SUPPORT_TEXTURE_FORMATS: [".astc", ".pkm", ".pvr", ".webp", ".jpg", ".jpeg", ".bmp", ".png"],
                KEY: {
                    none: 0,
                    back: 6,
                    menu: 18,
                    backspace: 8,
                    tab: 9,
                    enter: 13,
                    shift: 16,
                    ctrl: 17,
                    alt: 18,
                    pause: 19,
                    capslock: 20,
                    escape: 27,
                    space: 32,
                    pageup: 33,
                    pagedown: 34,
                    end: 35,
                    home: 36,
                    left: 37,
                    up: 38,
                    right: 39,
                    down: 40,
                    select: 41,
                    insert: 45,
                    Delete: 46,
                    0: 48,
                    1: 49,
                    2: 50,
                    3: 51,
                    4: 52,
                    5: 53,
                    6: 54,
                    7: 55,
                    8: 56,
                    9: 57,
                    a: 65,
                    b: 66,
                    c: 67,
                    d: 68,
                    e: 69,
                    f: 70,
                    g: 71,
                    h: 72,
                    i: 73,
                    j: 74,
                    k: 75,
                    l: 76,
                    m: 77,
                    n: 78,
                    o: 79,
                    p: 80,
                    q: 81,
                    r: 82,
                    s: 83,
                    t: 84,
                    u: 85,
                    v: 86,
                    w: 87,
                    x: 88,
                    y: 89,
                    z: 90,
                    num0: 96,
                    num1: 97,
                    num2: 98,
                    num3: 99,
                    num4: 100,
                    num5: 101,
                    num6: 102,
                    num7: 103,
                    num8: 104,
                    num9: 105,
                    "*": 106,
                    "+": 107,
                    "-": 109,
                    numdel: 110,
                    "/": 111,
                    f1: 112,
                    f2: 113,
                    f3: 114,
                    f4: 115,
                    f5: 116,
                    f6: 117,
                    f7: 118,
                    f8: 119,
                    f9: 120,
                    f10: 121,
                    f11: 122,
                    f12: 123,
                    numlock: 144,
                    scrolllock: 145,
                    ";": 186,
                    semicolon: 186,
                    equal: 187,
                    "=": 187,
                    ",": 188,
                    comma: 188,
                    dash: 189,
                    ".": 190,
                    period: 190,
                    forwardslash: 191,
                    grave: 192,
                    "[": 219,
                    openbracket: 219,
                    backslash: 220,
                    "]": 221,
                    closebracket: 221,
                    quote: 222,
                    dpadLeft: 1e3,
                    dpadRight: 1001,
                    dpadUp: 1003,
                    dpadDown: 1004,
                    dpadCenter: 1005
                },
                RAD: Math.PI / 180,
                DEG: 180 / Math.PI,
                REPEAT_FOREVER: Number.MAX_VALUE - 1,
                FLT_EPSILON: 1.192092896e-7,
                ORIENTATION_PORTRAIT: 1,
                ORIENTATION_LANDSCAPE: 2,
                ORIENTATION_AUTO: 3,
                ENABLE_TILEDMAP_CULLING: !0,
                TOUCH_TIMEOUT: 5e3,
                ENABLE_TRANSPARENT_CANVAS: !1,
                ENABLE_WEBGL_ANTIALIAS: !0,
                CLEANUP_IMAGE_CACHE: !1,
                ENABLE_MULTI_TOUCH: !0,
                MAX_LABEL_CANVAS_POOL_SIZE: 20
            });
            i.macro = rt;
            for (var ot = /^(?:cc|dragonBones|sp|ccsg)\..+/, at = new Array(123), st = 0; st < 123; ++st) at[st] = 64;
            for (var ct = 0; ct < 64; ++ct) at["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charCodeAt(ct)] = ct;
            var lt = at;

            function ut(e, t, n) {
                function i(e, t, n, i) {
                    var r = Object.getOwnPropertyDescriptor(e, t);
                    if (r) r.get && (e[n] = r.get), r.set && i && (e[i] = r.set);
                    else {
                        var o = e[n];
                        ye(e, t, o, e[i])
                    }
                }
                for (var r, o = e.prototype, a = 0; a < t.length; a++) {
                    var s = (r = t[a])[0].toUpperCase() + r.slice(1);
                    i(o, r, "get" + s, "set" + s)
                }
                for (r in n) {
                    var c = n[r];
                    i(o, r, c[0], c[1])
                }
            }

            function ht(e, t, n, i) {
                var r = e[t];
                r ? Array.isArray(r) ? i ? (r.push(r[0]), r[0] = n) : r.push(n) : e[t] = i ? [n, r] : [r, n] : e[t] = n
            }

            function _t(e, t) {
                if ("function" == typeof e.contains) return e.contains(t);
                if ("function" == typeof e.compareDocumentPosition) return !!(16 & e.compareDocumentPosition(t));
                var n = t.parentNode;
                if (n)
                    do {
                        if (n === e) return !0;
                        n = n.parentNode
                    } while (null !== n);
                return !1
            }

            function ft(e) {
                return "object" == typeof window && "function" == typeof Node ? e instanceof Node : e && "object" == typeof e && "number" == typeof e.nodeType && "string" == typeof e.nodeName
            }

            function dt(e, t, n) {
                e && setTimeout((function() {
                    e(t, n)
                }), 0)
            }

            function pt(e) {
                return !(!e || e.constructor !== Object) && me(e)
            }

            function mt(e, t, n) {
                if (t > n) {
                    var i = t;
                    t = n, n = i
                }
                return e < t ? t : e < n ? e : n
            }

            function gt(e) {
                return e * rt.RAD
            }

            function vt(e) {
                return e * rt.DEG
            }
            i.misc = {
                BUILTIN_CLASSID_RE: ot,
                BASE64_VALUES: lt,
                propertyDefine: ut,
                pushToMap: ht,
                contains: _t,
                isDomNode: ft,
                callInNextTick: dt,
                isPlainEmptyObj_DEV: pt,
                clampf: mt,
                degreesToRadians: gt,
                radiansToDegrees: vt
            }, e("misc", Object.freeze({
                __proto__: null,
                BUILTIN_CLASSID_RE: ot,
                BASE64_VALUES: lt,
                propertyDefine: ut,
                pushToMap: ht,
                contains: _t,
                isDomNode: ft,
                callInNextTick: dt,
                tryCatchFunctor_EDITOR: function(e) {
                    return Function("target", "try {\n  target." + e + "();\n}\ncatch (e) {\n  cc._throw(e);\n}")
                },
                isPlainEmptyObj_DEV: pt,
                clampf: mt,
                degreesToRadians: gt,
                radiansToDegrees: vt
            }));
            var yt = "$_$";

            function St(e, t) {
                var n = t ? Object.create(t) : {};
                return ve(e, "__attrs__", n), n
            }

            function Et(e) {
                if ("function" != typeof e) return St(e, At(e.constructor));
                for (var t, n = i.Class.getInheritanceChain(e), r = n.length - 1; r >= 0; r--) {
                    var o = n[r];
                    o.hasOwnProperty("__attrs__") && o.__attrs__ || St(o, (t = n[r + 1]) && t.__attrs__)
                }
                return St(e, (t = n[0]) && t.__attrs__), e.__attrs__
            }

            function Tt(e, t) {
                var n = At(e),
                    i = t + yt,
                    r = {};
                for (var o in n) o.startsWith(i) && (r[o.slice(i.length)] = n[o]);
                return r
            }

            function At(e) {
                return e.hasOwnProperty("__attrs__") && e.__attrs__ || Et(e)
            }

            function xt(e, t, n, i) {
                At(e)[t + yt + n] = i
            }
            var Ct = function() {
                    function e(e, t) {
                        this.name = void 0, this.default = void 0, this.name = e, this.default = t
                    }
                    return e.prototype.toString = function() {
                        return this.name
                    }, e
                }(),
                bt = e("CCInteger", new Ct("Integer", 0));
            i.Integer = bt, i.CCInteger = bt;
            var Rt = e("CCFloat", new Ct("Float", 0));
            i.Float = Rt, i.CCFloat = Rt;
            var wt = e("CCBoolean", new Ct("Boolean", !1));
            i.Boolean = wt, i.CCBoolean = wt;
            var It = e("CCString", new Ct("String", ""));

            function Pt(e, t) {
                return function(n, i) {
                    var r = '"' + Ae(n) + "." + i + '"',
                        o = Tt(n, i),
                        a = o.type;
                    if (a === bt || a === Rt ? a = "Number" : a !== It && a !== wt || (a = "" + a), a === e) {
                        if (o.hasOwnProperty("default")) {
                            var s = o.default;
                            if (void 0 !== s && !Array.isArray(s) && !pt(s)) {
                                var c = typeof s,
                                    l = e.toLowerCase();
                                if (c === l)
                                    if ("object" === l) {
                                        if (!s || s instanceof o.ctor) return;
                                        x(3605, r, Ae(o.ctor))
                                    } else "Number" !== e && x(3606, t, r, e);
                                else {
                                    if ("function" === c) return;
                                    e === It.default && null == s ? x(3607, r) : x(3611, t, r, c)
                                }
                                delete o.type
                            }
                        }
                    } else x(3604, r)
                }
            }
            i.String = It, i.CCString = It;
            var Ot = Object.freeze({
                    __proto__: null,
                    DELIMETER: yt,
                    createAttrsSingle: St,
                    createAttrs: Et,
                    attr: Tt,
                    getClassAttrs: At,
                    setClassAttr: xt,
                    PrimitiveType: Ct,
                    CCInteger: bt,
                    CCFloat: Rt,
                    CCBoolean: wt,
                    CCString: It,
                    getTypeChecker_ET: Pt,
                    getObjTypeChecker_ET: function(e) {
                        return function(t, n) {
                            Pt("Object", "type")(t, n);
                            var r = At(t)[n + yt + "default"],
                                o = i.Class.getDefault(r);
                            if (!Array.isArray(o) && Be(e, i.ValueType)) {
                                var a = Ae(e),
                                    s = we('No need to specify the "type" of "%s.%s" because %s is a child class of ValueType.', Ae(t), n, a);
                                r ? f(s) : x(3612, s, a, Ae(t), n, a)
                            }
                        }
                    }
                }),
                Dt = {
                    default: {},
                    serializable: {},
                    editorOnly: {},
                    formerlySerializedAs: {}
                };

            function Nt(e, t, n, i) {
                if (!e.get && !e.set && e.hasOwnProperty("default")) {
                    var r = "_N$" + t;
                    e.get = function() {
                        return this[r]
                    }, e.set = function(e) {
                        var t = this[r];
                        this[r] = e, n.call(this, t)
                    };
                    var o = {};
                    for (var a in i[r] = o, Dt) {
                        var s = Dt[a];
                        e.hasOwnProperty(a) && (o[a] = e[a], s.canUsedInGet || delete e[a])
                    }
                }
            }

            function Mt(e, t, n, r) {
                if (Array.isArray(t)) {
                    if (!(t.length > 0)) return b(5508, n, r);
                    e.type = t = t[0]
                }
                "function" == typeof t && (t === String ? e.type = i.String : t === Boolean ? e.type = i.Boolean : t === Number && (e.type = i.Float))
            }

            function Lt(e, t, n) {
                var i = e ? {
                    _short: !0
                } : {
                    _short: !0,
                    default: t
                };
                return n && (i.type = n), i
            }

            function Bt(e, t) {
                if (!e || e.constructor !== Object) {
                    if (Array.isArray(e) && e.length > 0) return Lt(t, [], e);
                    if ("function" == typeof e) {
                        var n = e;
                        return Lt(t, Be(n, i.ValueType) ? new n : null, n)
                    }
                    return Lt(t, e instanceof Ct ? e.default : e)
                }
                return null
            }
            var Ft = [];

            function zt() {
                return Ft[Ft.length - 1]
            }
            i._RF = {
                push: function(e, t, n, i) {
                    void 0 === n && (n = t, t = ""), Ft.push({
                        uuid: t,
                        script: n,
                        module: e,
                        exports: e.exports,
                        beh: null,
                        importMeta: i
                    })
                },
                pop: function() {
                    var e = Ft.pop(),
                        t = e.module,
                        n = t.exports;
                    if (n === e.exports) {
                        for (var i in n) return;
                        t.exports = n = e.cls
                    }
                },
                peek: zt
            };
            var Ut = yt,
                Gt = {
                    datas: null,
                    push: function(e) {
                        if (this.datas) this.datas.push(e);
                        else {
                            this.datas = [e];
                            var t = this;
                            setTimeout((function() {
                                t.init()
                            }), 0)
                        }
                    },
                    init: function() {
                        var e = this.datas;
                        if (e) {
                            for (var t = 0; t < e.length; ++t) {
                                var n = e[t],
                                    i = n.cls,
                                    r = n.props;
                                "function" == typeof r && (r = r());
                                var o = Ae(i);
                                r ? jt(i, o, r, i.$super, n.mixins) : b(3633, o)
                            }
                            this.datas = null
                        }
                    }
                };

            function Ht(e, t, n, i) {
                ! function(e, t) {
                    ! function(e, t) {
                        e.indexOf(t) < 0 && e.push(t)
                    }(e.__props__, t)
                }(e, n), Yt(e, i, t, n)
            }

            function kt(e, t, n, i) {
                var r = i.get;
                i.set, r && (Yt(e, i, t, n), xt(e, n, "serializable", !1))
            }

            function Vt(e) {
                return "function" == typeof e ? e() : e
            }

            function Wt(e, t, n) {
                for (var i in t) e.hasOwnProperty(i) || n && !n(i) || Object.defineProperty(e, i, Pe(t, i))
            }

            function jt(e, t, n, i, r) {
                if (e.__props__ = [], i && i.__props__ && (e.__props__ = i.__props__.slice()), r)
                    for (var o = 0; o < r.length; ++o) {
                        var a = r[o];
                        a.__props__ && (e.__props__ = e.__props__.concat(a.__props__.filter((function(t) {
                            return e.__props__.indexOf(t) < 0
                        }))))
                    }
                if (n)
                    for (var s in function(e, t) {
                            for (var n in e) {
                                var i = e[n],
                                    r = Bt(i, !1);
                                if (r && (i = e[n] = r), i) {
                                    var o = i.notify;
                                    o && Nt(i, n, o, e), "type" in i && Mt(i, i.type, t, n)
                                }
                            }
                        }(n, t), n) {
                        var c = n[s];
                        c.get || c.set ? kt(e, t, s, c) : Ht(e, t, s, c)
                    }
                var l = At(e);
                e.__values__ = e.__props__.filter((function(e) {
                    return !1 !== l[e + Ut + "serializable"]
                }))
            }

            function qt(e) {
                var t = e.name,
                    n = e.extends,
                    r = e.mixins,
                    o = function(e, t, n, r) {
                        var o = i.Component,
                            a = zt();
                        if (a && Be(t, o)) {
                            if (Be(a.cls, o)) return b(3615), null;
                            e = e || a.script
                        }
                        var s = function(e, t, n, i) {
                            var r = i.ctor,
                                o = [r],
                                a = r;
                            ve(a, "__ctors__", o.length > 0 ? o : null, !0);
                            var s = a.prototype;
                            if (t && (a.$super = t), n) {
                                for (var c = n.length - 1; c >= 0; c--) {
                                    var l = n[c];
                                    Wt(s, l.prototype), qt._isCCClass(l) && Wt(At(a), At(l))
                                }
                                s.constructor = a
                            }
                            return Ve(e, a), a
                        }(e, t, n, r);
                        if (a)
                            if (Be(t, o)) {
                                var c = a.uuid;
                                c && He(c, s), a.cls = s
                            } else Be(a.cls, o) || (a.cls = s);
                        return s
                    }(t, n, r, e);
                t || (t = i.js.getClassName(o)), o._sealed = !0, n && (n._sealed = !1);
                var a = e.properties;
                "function" == typeof a || n && null === n.__props__ || r && r.some((function(e) {
                    return null === e.__props__
                })) ? (Gt.push({
                    cls: o,
                    props: a,
                    mixins: r
                }), o.__props__ = o.__values__ = null) : jt(o, t, a, n, e.mixins);
                var s = e.editor;
                return s && Be(n, i.Component) && i.Component._registerEditorProps(o, s), o
            }
            qt._isCCClass = function(e) {
                var t;
                return null == e || null === (t = e.hasOwnProperty) || void 0 === t ? void 0 : t.call(e, "__ctors__")
            }, qt.fastDefine = function(e, t, n) {
                Ve(e, t);
                for (var i = t.__props__ = t.__values__ = Object.keys(n), r = At(t), o = 0; o < i.length; o++) {
                    var a = i[o];
                    r[a + Ut + "visible"] = !1, r[a + Ut + "default"] = n[a]
                }
            }, qt.Attr = Ot, qt.attr = Tt, qt.getInheritanceChain = function(e) {
                for (var t = []; e = Le(e);) e !== Object && t.push(e);
                return t
            };
            var Xt = {
                Integer: "Number",
                Float: "Number",
                Boolean: "Boolean",
                String: "String"
            };

            function Yt(e, t, n, i) {
                var r = null,
                    o = "";

                function a() {
                    return o = i + Ut, r = At(e)
                }
                "type" in t && void 0 === t.type && x(3660, i, n);
                var s = t.type;
                s && (Xt[s] ? (r || a())[o + "type"] = s : "Object" === s || ("object" == typeof s ? $e.isEnum(s) ? ((r || a())[o + "type"] = "Enum", r[o + "enumList"] = $e.getList(s)) : Je.isBitMask(s) && ((r || a())[o + "type"] = "BitMask", r[o + "bitmaskList"] = Je.getList(s)) : "function" == typeof s && ((r || a())[o + "type"] = "Object", r[o + "ctor"] = s))), "default" in t && ((r || a())[o + "default"] = t.default);
                var c, l = function(e, n) {
                    if (e in t) {
                        var i = t[e];
                        typeof i === n && ((r || a())[o + e] = i)
                    }
                };
                t.editorOnly && ((r || a())[o + "editorOnly"] = !0), t.__noImplicit ? (r || a())[o + "serializable"] = null !== (c = t.serializable) && void 0 !== c && c : !1 === t.serializable && ((r || a())[o + "serializable"] = !1), l("formerlySerializedAs", "string");
                var u = t.range;
                u && Array.isArray(u) && u.length >= 2 && ((r || a())[o + "min"] = u[0], r[o + "max"] = u[1], u.length > 2 && (r[o + "step"] = u[2])), l("min", "number"), l("max", "number"), l("step", "number")
            }
            qt.isArray = function(e) {
                return e = Vt(e), Array.isArray(e)
            }, qt.getDefault = Vt, qt.escapeForJS = function(e) {
                return JSON.stringify(e).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029")
            }, qt.IDENTIFIER_RE = /^[A-Za-z_$][0-9A-Za-z_$]*$/, qt.getNewValueTypeCode = function(e) {
                for (var t = Ae(e), n = e.constructor, i = "new " + t + "(", r = 0; r < n.__props__.length; r++) i += e[n.__props__[r]], r < n.__props__.length - 1 && (i += ",");
                return i + ")"
            }, i.Class = qt;
            var Kt = Math.PI / 180,
                Zt = 180 / Math.PI,
                Qt = e("EPSILON", 1e-6);

            function Jt(e, t) {
                return Math.abs(e - t) <= Qt * Math.max(1, Math.abs(e), Math.abs(t))
            }

            function $t(e, t, n) {
                return n = n || Qt, Math.abs(e - t) <= n
            }

            function en(e, t, n) {
                if (t > n) {
                    var i = t;
                    t = n, n = i
                }
                return e < t ? t : e > n ? n : e
            }

            function tn(e) {
                return e < 0 ? 0 : e > 1 ? 1 : e
            }

            function nn(e, t, n) {
                return e + (t - e) * n
            }

            function rn(e) {
                return e * Kt
            }

            function on(e) {
                return e * Zt
            }
            var an = e("random", Math.random);

            function sn(e, t) {
                return Math.random() * (t - e) + e
            }

            function cn(e, t) {
                return Math.floor(sn(e, t))
            }

            function ln(e) {
                return (e = (9301 * e + 49297) % 233280) / 233280
            }

            function un(e, t, n) {
                return ln(e) * (n - t) + t
            }

            function hn(e, t, n) {
                return Math.floor(un(e, t, n))
            }

            function _n(e) {
                return --e, e |= e >> 1, e |= e >> 2, e |= e >> 4, e |= e >> 8, e |= e >> 16, ++e
            }

            function fn(e, t) {
                return e - Math.floor(e / t) * t
            }

            function dn(e, t) {
                return e = fn(e, 2 * t), t - Math.abs(e - t)
            }

            function pn(e, t, n) {
                return (n - e) / (t - e)
            }

            function mn(e) {
                return Math.abs(e.x) > Math.abs(e.y) ? Math.abs(e.x) > Math.abs(e.z) ? e.x : e.z : Math.abs(e.y) > Math.abs(e.z) ? e.y : e.z
            }

            function gn(e, t) {
                return Math.abs(e) > Math.abs(t) ? e : t
            }
            var vn = 1 / 255,
                yn = e("Color", function(e) {
                    function t(t, n, i, r) {
                        var o;
                        return (o = e.call(this) || this)._val = 0, "string" == typeof t ? o.fromHEX(t) : void 0 !== n ? o.set(t, n, i, r) : o.set(t), o
                    }
                    Q(t, e), t.clone = function(e) {
                        var n = new t;
                        return e._val ? n._val = e._val : n._val = (e.a << 24 >>> 0) + (e.b << 16) + (e.g << 8) + e.r, n
                    }, t.copy = function(e, t) {
                        return e.r = t.r, e.g = t.g, e.b = t.b, e.a = t.a, e
                    }, t.set = function(e, t, n, i, r) {
                        return e.r = t, e.g = n, e.b = i, e.a = r, e
                    }, t.fromHEX = function(e, t) {
                        return t = 0 === t.indexOf("#") ? t.substring(1) : t, e.r = parseInt(t.substr(0, 2), 16) || 0, e.g = parseInt(t.substr(2, 2), 16) || 0, e.b = parseInt(t.substr(4, 2), 16) || 0, e.a = parseInt(t.substr(6, 2), 16) || 255, e._val = (e.a << 24 >>> 0) + (e.b << 16) + (e.g << 8) + e.r, e
                    }, t.add = function(e, t, n) {
                        return e.r = t.r + n.r, e.g = t.g + n.g, e.b = t.b + n.b, e.a = t.a + n.a, e
                    }, t.subtract = function(e, t, n) {
                        return e.r = t.r - n.r, e.g = t.g - n.g, e.b = t.b - n.b, e.a = t.a - n.a, e
                    }, t.multiply = function(e, t, n) {
                        return e.r = t.r * n.r, e.g = t.g * n.g, e.b = t.b * n.b, e.a = t.a * n.a, e
                    }, t.divide = function(e, t, n) {
                        return e.r = t.r / n.r, e.g = t.g / n.g, e.b = t.b / n.b, e.a = t.a / n.a, e
                    }, t.scale = function(e, t, n) {
                        return e.r = t.r * n, e.g = t.g * n, e.b = t.b * n, e.a = t.a * n, e
                    }, t.lerp = function(e, t, n, i) {
                        var r = t.r,
                            o = t.g,
                            a = t.b,
                            s = t.a;
                        return r += (n.r - r) * i, o += (n.g - o) * i, a += (n.b - a) * i, s += (n.a - s) * i, e._val = Math.floor((s << 24 >>> 0) + (a << 16) + (o << 8) + r), e
                    }, t.toArray = function(e, n, i) {
                        void 0 === i && (i = 0);
                        var r = n instanceof t || n.a > 1 ? 1 / 255 : 1;
                        return e[i + 0] = n.r * r, e[i + 1] = n.g * r, e[i + 2] = n.b * r, e[i + 3] = n.a * r, e
                    }, t.fromArray = function(e, t, n) {
                        return void 0 === n && (n = 0), t.r = 255 * e[n + 0], t.g = 255 * e[n + 1], t.b = 255 * e[n + 2], t.a = 255 * e[n + 3], t
                    }, t.strictEquals = function(e, t) {
                        return e.r === t.r && e.g === t.g && e.b === t.b && e.a === t.a
                    }, t.equals = function(e, t, n) {
                        return void 0 === n && (n = Qt), Math.abs(e.r - t.r) <= n * Math.max(1, Math.abs(e.r), Math.abs(t.r)) && Math.abs(e.g - t.g) <= n * Math.max(1, Math.abs(e.g), Math.abs(t.g)) && Math.abs(e.b - t.b) <= n * Math.max(1, Math.abs(e.b), Math.abs(t.b)) && Math.abs(e.a - t.a) <= n * Math.max(1, Math.abs(e.a), Math.abs(t.a))
                    }, t.hex = function(e) {
                        return (255 * e.r << 24 | 255 * e.g << 16 | 255 * e.b << 8 | 255 * e.a) >>> 0
                    };
                    var n = t.prototype;
                    return n.clone = function() {
                        var e = new t;
                        return e._val = this._val, e
                    }, n.equals = function(e) {
                        return e && this._val === e._val
                    }, n.lerp = function(e, t) {
                        var n = this.r,
                            i = this.g,
                            r = this.b,
                            o = this.a;
                        return n += (e.r - n) * t, i += (e.g - i) * t, r += (e.b - r) * t, o += (e.a - o) * t, this._val = Math.floor((o << 24 >>> 0) + (r << 16) + (i << 8) + n), this
                    }, n.toString = function() {
                        return "rgba(" + this.r.toFixed() + ", " + this.g.toFixed() + ", " + this.b.toFixed() + ", " + this.a.toFixed() + ")"
                    }, n.toCSS = function(e) {
                        return void 0 === e && (e = "rgba"), "rgba" === e ? "rgba(" + this.r + "," + this.g + "," + this.b + "," + (this.a * vn).toFixed(2) + ")" : "rgb" === e ? "rgb(" + this.r + "," + this.g + "," + this.b + ")" : "#" + this.toHEX(e)
                    }, n.fromHEX = function(e) {
                        e = 0 === e.indexOf("#") ? e.substring(1) : e;
                        var t = parseInt(e.substr(0, 2), 16) || 0,
                            n = parseInt(e.substr(2, 2), 16) || 0,
                            i = parseInt(e.substr(4, 2), 16) || 0,
                            r = parseInt(e.substr(6, 2), 16) || 255;
                        return this._val = (r << 24 >>> 0) + (i << 16) + (n << 8) + (0 | t), this
                    }, n.toHEX = function(e) {
                        void 0 === e && (e = "#rrggbb");
                        var t = "0",
                            n = [(this.r < 16 ? t : "") + this.r.toString(16), (this.g < 16 ? t : "") + this.g.toString(16), (this.b < 16 ? t : "") + this.b.toString(16)];
                        return "#rgb" === e ? (n[0] = n[0][0], n[1] = n[1][0], n[2] = n[2][0]) : "#rrggbbaa" === e && n.push((this.a < 16 ? t : "") + this.a.toString(16)), n.join("")
                    }, n.toRGBValue = function() {
                        return 16777215 & this._val
                    }, n.fromHSV = function(e, t, n) {
                        var i = 0,
                            r = 0,
                            o = 0;
                        if (0 === t) i = r = o = n;
                        else if (0 === n) i = r = o = 0;
                        else {
                            1 === e && (e = 0), e *= 6;
                            var a = Math.floor(e),
                                s = e - a,
                                c = n * (1 - t),
                                l = n * (1 - t * s),
                                u = n * (1 - t * (1 - s));
                            switch (a) {
                                case 0:
                                    i = n, r = u, o = c;
                                    break;
                                case 1:
                                    i = l, r = n, o = c;
                                    break;
                                case 2:
                                    i = c, r = n, o = u;
                                    break;
                                case 3:
                                    i = c, r = l, o = n;
                                    break;
                                case 4:
                                    i = u, r = c, o = n;
                                    break;
                                case 5:
                                    i = n, r = c, o = l
                            }
                        }
                        return i *= 255, r *= 255, o *= 255, this._val = (this.a << 24 >>> 0) + (o << 16) + (r << 8) + (0 | i), this
                    }, n.toHSV = function() {
                        var e = this.r * vn,
                            t = this.g * vn,
                            n = this.b * vn,
                            i = {
                                h: 0,
                                s: 0,
                                v: 0
                            },
                            r = Math.max(e, t, n),
                            o = Math.min(e, t, n),
                            a = 0;
                        return i.v = r, i.s = r ? (r - o) / r : 0, i.s ? (a = r - o, i.h = e === r ? (t - n) / a : t === r ? 2 + (n - e) / a : 4 + (e - t) / a, i.h /= 6, i.h < 0 && (i.h += 1)) : i.h = 0, i
                    }, n.set = function(e, t, n, i) {
                        return "object" == typeof e ? null != e._val ? this._val = e._val : (t = e.g || 0, n = e.b || 0, i = "number" == typeof e.a ? e.a : 255, e = e.r || 0, this._val = (i << 24 >>> 0) + (n << 16) + (t << 8) + (0 | e)) : (e = e || 0, t = t || 0, n = n || 0, i = "number" == typeof i ? i : 255, this._val = (i << 24 >>> 0) + (n << 16) + (t << 8) + (0 | e)), this
                    }, n.multiply = function(e) {
                        var t = (255 & this._val) * e.r >> 8,
                            n = (65280 & this._val) * e.g >> 8,
                            i = (16711680 & this._val) * e.b >> 8,
                            r = ((4278190080 & this._val) >>> 8) * e.a;
                        return this._val = 4278190080 & r | 16711680 & i | 65280 & n | 255 & t, this
                    }, n._set_r_unsafe = function(e) {
                        return this._val = (4294967040 & this._val | e) >>> 0, this
                    }, n._set_g_unsafe = function(e) {
                        return this._val = (4294902015 & this._val | e << 8) >>> 0, this
                    }, n._set_b_unsafe = function(e) {
                        return this._val = (4278255615 & this._val | e << 16) >>> 0, this
                    }, n._set_a_unsafe = function(e) {
                        return this._val = (16777215 & this._val | e << 24) >>> 0, this
                    }, K(t, [{
                        key: "r",
                        get: function() {
                            return 255 & this._val
                        },
                        set: function(e) {
                            e = ~~en(e, 0, 255), this._val = (4294967040 & this._val | e) >>> 0
                        }
                    }, {
                        key: "g",
                        get: function() {
                            return (65280 & this._val) >> 8
                        },
                        set: function(e) {
                            e = ~~en(e, 0, 255), this._val = (4294902015 & this._val | e << 8) >>> 0
                        }
                    }, {
                        key: "b",
                        get: function() {
                            return (16711680 & this._val) >> 16
                        },
                        set: function(e) {
                            e = ~~en(e, 0, 255), this._val = (4278255615 & this._val | e << 16) >>> 0
                        }
                    }, {
                        key: "a",
                        get: function() {
                            return (4278190080 & this._val) >>> 24
                        },
                        set: function(e) {
                            e = ~~en(e, 0, 255), this._val = (16777215 & this._val | e << 24) >>> 0
                        }
                    }, {
                        key: "x",
                        get: function() {
                            return this.r * vn
                        },
                        set: function(e) {
                            this.r = 255 * e
                        }
                    }, {
                        key: "y",
                        get: function() {
                            return this.g * vn
                        },
                        set: function(e) {
                            this.g = 255 * e
                        }
                    }, {
                        key: "z",
                        get: function() {
                            return this.b * vn
                        },
                        set: function(e) {
                            this.b = 255 * e
                        }
                    }, {
                        key: "w",
                        get: function() {
                            return this.a * vn
                        },
                        set: function(e) {
                            this.a = 255 * e
                        }
                    }]), t
                }(it));

            function Sn(e, t, n, i) {
                return new yn(e, t, n, i)
            }
            yn.WHITE = Object.freeze(new yn(255, 255, 255, 255)), yn.GRAY = Object.freeze(new yn(127, 127, 127, 255)), yn.BLACK = Object.freeze(new yn(0, 0, 0, 255)), yn.TRANSPARENT = Object.freeze(new yn(0, 0, 0, 0)), yn.RED = Object.freeze(new yn(255, 0, 0, 255)), yn.GREEN = Object.freeze(new yn(0, 255, 0, 255)), yn.BLUE = Object.freeze(new yn(0, 0, 255, 255)), yn.CYAN = Object.freeze(new yn(0, 255, 255, 255)), yn.MAGENTA = Object.freeze(new yn(255, 0, 255, 255)), yn.YELLOW = Object.freeze(new yn(255, 255, 0, 255)), qt.fastDefine("cc.Color", yn, {
                r: 0,
                g: 0,
                b: 0,
                a: 255
            }), i.Color = yn, i.color = Sn;
            var En = e("Vec3", function(e) {
                function t(t, n, i) {
                    var r;
                    return r = e.call(this) || this, t && "object" == typeof t ? (r.x = t.x, r.y = t.y, r.z = t.z) : (r.x = t || 0, r.y = n || 0, r.z = i || 0), r
                }
                Q(t, e), t.zero = function(e) {
                    return e.x = 0, e.y = 0, e.z = 0, e
                }, t.clone = function(e) {
                    return new t(e.x, e.y, e.z)
                }, t.copy = function(e, t) {
                    return e.x = t.x, e.y = t.y, e.z = t.z, e
                }, t.set = function(e, t, n, i) {
                    return e.x = t, e.y = n, e.z = i, e
                }, t.add = function(e, t, n) {
                    return e.x = t.x + n.x, e.y = t.y + n.y, e.z = t.z + n.z, e
                }, t.subtract = function(e, t, n) {
                    return e.x = t.x - n.x, e.y = t.y - n.y, e.z = t.z - n.z, e
                }, t.multiply = function(e, t, n) {
                    return e.x = t.x * n.x, e.y = t.y * n.y, e.z = t.z * n.z, e
                }, t.divide = function(e, t, n) {
                    return e.x = t.x / n.x, e.y = t.y / n.y, e.z = t.z / n.z, e
                }, t.ceil = function(e, t) {
                    return e.x = Math.ceil(t.x), e.y = Math.ceil(t.y), e.z = Math.ceil(t.z), e
                }, t.floor = function(e, t) {
                    return e.x = Math.floor(t.x), e.y = Math.floor(t.y), e.z = Math.floor(t.z), e
                }, t.min = function(e, t, n) {
                    return e.x = Math.min(t.x, n.x), e.y = Math.min(t.y, n.y), e.z = Math.min(t.z, n.z), e
                }, t.max = function(e, t, n) {
                    return e.x = Math.max(t.x, n.x), e.y = Math.max(t.y, n.y), e.z = Math.max(t.z, n.z), e
                }, t.round = function(e, t) {
                    return e.x = Math.round(t.x), e.y = Math.round(t.y), e.z = Math.round(t.z), e
                }, t.multiplyScalar = function(e, t, n) {
                    return e.x = t.x * n, e.y = t.y * n, e.z = t.z * n, e
                }, t.scaleAndAdd = function(e, t, n, i) {
                    return e.x = t.x + n.x * i, e.y = t.y + n.y * i, e.z = t.z + n.z * i, e
                }, t.distance = function(e, t) {
                    var n = t.x - e.x,
                        i = t.y - e.y,
                        r = t.z - e.z;
                    return Math.sqrt(n * n + i * i + r * r)
                }, t.squaredDistance = function(e, t) {
                    var n = t.x - e.x,
                        i = t.y - e.y,
                        r = t.z - e.z;
                    return n * n + i * i + r * r
                }, t.len = function(e) {
                    var t = e.x,
                        n = e.y,
                        i = e.z;
                    return Math.sqrt(t * t + n * n + i * i)
                }, t.lengthSqr = function(e) {
                    var t = e.x,
                        n = e.y,
                        i = e.z;
                    return t * t + n * n + i * i
                }, t.negate = function(e, t) {
                    return e.x = -t.x, e.y = -t.y, e.z = -t.z, e
                }, t.invert = function(e, t) {
                    return e.x = 1 / t.x, e.y = 1 / t.y, e.z = 1 / t.z, e
                }, t.invertSafe = function(e, t) {
                    var n = t.x,
                        i = t.y,
                        r = t.z;
                    return Math.abs(n) < Qt ? e.x = 0 : e.x = 1 / n, Math.abs(i) < Qt ? e.y = 0 : e.y = 1 / i, Math.abs(r) < Qt ? e.z = 0 : e.z = 1 / r, e
                }, t.normalize = function(e, t) {
                    var n = t.x,
                        i = t.y,
                        r = t.z,
                        o = n * n + i * i + r * r;
                    return o > 0 && (o = 1 / Math.sqrt(o), e.x = n * o, e.y = i * o, e.z = r * o), e
                }, t.dot = function(e, t) {
                    return e.x * t.x + e.y * t.y + e.z * t.z
                }, t.cross = function(e, t, n) {
                    var i = t.x,
                        r = t.y,
                        o = t.z,
                        a = n.x,
                        s = n.y,
                        c = n.z;
                    return e.x = r * c - o * s, e.y = o * a - i * c, e.z = i * s - r * a, e
                }, t.lerp = function(e, t, n, i) {
                    return e.x = t.x + i * (n.x - t.x), e.y = t.y + i * (n.y - t.y), e.z = t.z + i * (n.z - t.z), e
                }, t.random = function(e, t) {
                    t = t || 1;
                    var n = 2 * an() * Math.PI,
                        i = 2 * an() - 1,
                        r = Math.sqrt(1 - i * i);
                    return e.x = r * Math.cos(n) * t, e.y = r * Math.sin(n) * t, e.z = i * t, e
                }, t.transformMat4 = function(e, t, n) {
                    var i = t.x,
                        r = t.y,
                        o = t.z,
                        a = n.m03 * i + n.m07 * r + n.m11 * o + n.m15;
                    return a = a ? Math.abs(1 / a) : 1, e.x = (n.m00 * i + n.m04 * r + n.m08 * o + n.m12) * a, e.y = (n.m01 * i + n.m05 * r + n.m09 * o + n.m13) * a, e.z = (n.m02 * i + n.m06 * r + n.m10 * o + n.m14) * a, e
                }, t.transformMat4Normal = function(e, t, n) {
                    var i = t.x,
                        r = t.y,
                        o = t.z,
                        a = n.m03 * i + n.m07 * r + n.m11 * o;
                    return a = a ? Math.abs(1 / a) : 1, e.x = (n.m00 * i + n.m04 * r + n.m08 * o) * a, e.y = (n.m01 * i + n.m05 * r + n.m09 * o) * a, e.z = (n.m02 * i + n.m06 * r + n.m10 * o) * a, e
                }, t.transformMat3 = function(e, t, n) {
                    var i = t.x,
                        r = t.y,
                        o = t.z;
                    return e.x = i * n.m00 + r * n.m03 + o * n.m06, e.y = i * n.m01 + r * n.m04 + o * n.m07, e.z = i * n.m02 + r * n.m05 + o * n.m08, e
                }, t.transformAffine = function(e, t, n) {
                    var i = t.x,
                        r = t.y,
                        o = t.z;
                    return e.x = n.m00 * i + n.m04 * r + n.m08 * o + n.m12, e.y = n.m01 * i + n.m05 * r + n.m09 * o + n.m13, e.x = n.m02 * i + n.m06 * r + n.m10 * o + n.m14, e
                }, t.transformQuat = function(e, t, n) {
                    var i = n.w * t.x + n.y * t.z - n.z * t.y,
                        r = n.w * t.y + n.z * t.x - n.x * t.z,
                        o = n.w * t.z + n.x * t.y - n.y * t.x,
                        a = -n.x * t.x - n.y * t.y - n.z * t.z;
                    return e.x = i * n.w + a * -n.x + r * -n.z - o * -n.y, e.y = r * n.w + a * -n.y + o * -n.x - i * -n.z, e.z = o * n.w + a * -n.z + i * -n.y - r * -n.x, e
                }, t.transformRTS = function(e, t, n, i, r) {
                    var o = t.x * r.x,
                        a = t.y * r.y,
                        s = t.z * r.z,
                        c = n.w * o + n.y * s - n.z * a,
                        l = n.w * a + n.z * o - n.x * s,
                        u = n.w * s + n.x * a - n.y * o,
                        h = -n.x * o - n.y * a - n.z * s;
                    return e.x = c * n.w + h * -n.x + l * -n.z - u * -n.y + i.x, e.y = l * n.w + h * -n.y + u * -n.x - c * -n.z + i.y, e.z = u * n.w + h * -n.z + c * -n.y - l * -n.x + i.z, e
                }, t.transformInverseRTS = function(e, t, n, i, r) {
                    var o = t.x - i.x,
                        a = t.y - i.y,
                        s = t.z - i.z,
                        c = n.w * o - n.y * s + n.z * a,
                        l = n.w * a - n.z * o + n.x * s,
                        u = n.w * s - n.x * a + n.y * o,
                        h = n.x * o + n.y * a + n.z * s;
                    return e.x = (c * n.w + h * n.x + l * n.z - u * n.y) / r.x, e.y = (l * n.w + h * n.y + u * n.x - c * n.z) / r.y, e.z = (u * n.w + h * n.z + c * n.y - l * n.x) / r.z, e
                }, t.rotateX = function(e, t, n, i) {
                    var r = t.x - n.x,
                        o = t.y - n.y,
                        a = t.z - n.z,
                        s = Math.cos(i),
                        c = Math.sin(i),
                        l = r,
                        u = o * s - a * c,
                        h = o * c + a * s;
                    return e.x = l + n.x, e.y = u + n.y, e.z = h + n.z, e
                }, t.rotateY = function(e, t, n, i) {
                    var r = t.x - n.x,
                        o = t.y - n.y,
                        a = t.z - n.z,
                        s = Math.cos(i),
                        c = Math.sin(i),
                        l = a * c + r * s,
                        u = o,
                        h = a * s - r * c;
                    return e.x = l + n.x, e.y = u + n.y, e.z = h + n.z, e
                }, t.rotateZ = function(e, t, n, i) {
                    var r = t.x - n.x,
                        o = t.y - n.y,
                        a = t.z - n.z,
                        s = Math.cos(i),
                        c = Math.sin(i),
                        l = r * s - o * c,
                        u = r * c + o * s,
                        h = a;
                    return e.x = l + n.x, e.y = u + n.y, e.z = h + n.z, e
                }, t.toArray = function(e, t, n) {
                    return void 0 === n && (n = 0), e[n + 0] = t.x, e[n + 1] = t.y, e[n + 2] = t.z, e
                }, t.fromArray = function(e, t, n) {
                    return void 0 === n && (n = 0), e.x = t[n + 0], e.y = t[n + 1], e.z = t[n + 2], e
                }, t.strictEquals = function(e, t) {
                    return e.x === t.x && e.y === t.y && e.z === t.z
                }, t.equals = function(e, t, n) {
                    void 0 === n && (n = Qt);
                    var i = e.x,
                        r = e.y,
                        o = e.z,
                        a = t.x,
                        s = t.y,
                        c = t.z;
                    return Math.abs(i - a) <= n * Math.max(1, Math.abs(i), Math.abs(a)) && Math.abs(r - s) <= n * Math.max(1, Math.abs(r), Math.abs(s)) && Math.abs(o - c) <= n * Math.max(1, Math.abs(o), Math.abs(c))
                }, t.angle = function(e, n) {
                    t.normalize(Tn, e), t.normalize(An, n);
                    var i = t.dot(Tn, An);
                    return i > 1 ? 0 : i < -1 ? Math.PI : Math.acos(i)
                }, t.projectOnPlane = function(e, n, i) {
                    return t.subtract(e, n, t.project(e, n, i))
                }, t.project = function(e, n, i) {
                    var r = t.lengthSqr(i);
                    return r < 1e-6 ? t.set(e, 0, 0, 0) : t.multiplyScalar(e, i, t.dot(n, i) / r)
                };
                var n = t.prototype;
                return n.clone = function() {
                    return new t(this.x, this.y, this.z)
                }, n.set = function(e, t, n) {
                    return e && "object" == typeof e ? (this.x = e.x, this.y = e.y, this.z = e.z) : (this.x = e || 0, this.y = t || 0, this.z = n || 0), this
                }, n.equals = function(e, t) {
                    return void 0 === t && (t = Qt), Math.abs(this.x - e.x) <= t * Math.max(1, Math.abs(this.x), Math.abs(e.x)) && Math.abs(this.y - e.y) <= t * Math.max(1, Math.abs(this.y), Math.abs(e.y)) && Math.abs(this.z - e.z) <= t * Math.max(1, Math.abs(this.z), Math.abs(e.z))
                }, n.equals3f = function(e, t, n, i) {
                    return void 0 === i && (i = Qt), Math.abs(this.x - e) <= i * Math.max(1, Math.abs(this.x), Math.abs(e)) && Math.abs(this.y - t) <= i * Math.max(1, Math.abs(this.y), Math.abs(t)) && Math.abs(this.z - n) <= i * Math.max(1, Math.abs(this.z), Math.abs(n))
                }, n.strictEquals = function(e) {
                    return this.x === e.x && this.y === e.y && this.z === e.z
                }, n.strictEquals3f = function(e, t, n) {
                    return this.x === e && this.y === t && this.z === n
                }, n.toString = function() {
                    return "(" + this.x.toFixed(2) + ", " + this.y.toFixed(2) + ", " + this.z.toFixed(2) + ")"
                }, n.lerp = function(e, t) {
                    return this.x += t * (e.x - this.x), this.y += t * (e.y - this.y), this.z += t * (e.z - this.z), this
                }, n.add = function(e) {
                    return this.x += e.x, this.y += e.y, this.z += e.z, this
                }, n.add3f = function(e, t, n) {
                    return this.x += e, this.y += t, this.z += n, this
                }, n.subtract = function(e) {
                    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this
                }, n.subtract3f = function(e, t, n) {
                    return this.x -= e, this.y -= t, this.z -= n, this
                }, n.multiplyScalar = function(e) {
                    return "object" == typeof e && console.warn("should use Vec3.multiply for vector * vector operation"), this.x *= e, this.y *= e, this.z *= e, this
                }, n.multiply = function(e) {
                    return "object" != typeof e && console.warn("should use Vec3.scale for vector * scalar operation"), this.x *= e.x, this.y *= e.y, this.z *= e.z, this
                }, n.multiply3f = function(e, t, n) {
                    return this.x *= e, this.y *= t, this.z *= n, this
                }, n.divide = function(e) {
                    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this
                }, n.divide3f = function(e, t, n) {
                    return this.x /= e, this.y /= t, this.z /= n, this
                }, n.negative = function() {
                    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
                }, n.clampf = function(e, t) {
                    return this.x = en(this.x, e.x, t.x), this.y = en(this.y, e.y, t.y), this.z = en(this.z, e.z, t.z), this
                }, n.dot = function(e) {
                    return this.x * e.x + this.y * e.y + this.z * e.z
                }, n.cross = function(e) {
                    var t = this.x,
                        n = this.y,
                        i = this.z,
                        r = e.x,
                        o = e.y,
                        a = e.z;
                    return this.x = n * a - i * o, this.y = i * r - t * a, this.z = t * o - n * r, this
                }, n.length = function() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
                }, n.lengthSqr = function() {
                    return this.x * this.x + this.y * this.y + this.z * this.z
                }, n.normalize = function() {
                    var e = this.x,
                        t = this.y,
                        n = this.z,
                        i = e * e + t * t + n * n;
                    return i > 0 && (i = 1 / Math.sqrt(i), this.x = e * i, this.y = t * i, this.z = n * i), this
                }, n.transformMat4 = function(e) {
                    var t = this.x,
                        n = this.y,
                        i = this.z,
                        r = e.m03 * t + e.m07 * n + e.m11 * i + e.m15;
                    return r = r ? 1 / r : 1, this.x = (e.m00 * t + e.m04 * n + e.m08 * i + e.m12) * r, this.y = (e.m01 * t + e.m05 * n + e.m09 * i + e.m13) * r, this.z = (e.m02 * t + e.m06 * n + e.m10 * i + e.m14) * r, this
                }, t
            }(it));
            En.UNIT_X = Object.freeze(new En(1, 0, 0)), En.UNIT_Y = Object.freeze(new En(0, 1, 0)), En.UNIT_Z = Object.freeze(new En(0, 0, 1)), En.RIGHT = Object.freeze(new En(1, 0, 0)), En.UP = Object.freeze(new En(0, 1, 0)), En.FORWARD = Object.freeze(new En(0, 0, -1)), En.ZERO = Object.freeze(new En(0, 0, 0)), En.ONE = Object.freeze(new En(1, 1, 1)), En.NEG_ONE = Object.freeze(new En(-1, -1, -1));
            var Tn = new En,
                An = new En;

            function xn(e, t, n) {
                return new En(e, t, n)
            }
            qt.fastDefine("cc.Vec3", En, {
                x: 0,
                y: 0,
                z: 0
            }), i.Vec3 = En, i.v3 = xn;
            var Cn = e("Mat3", function(e) {
                function t(t, n, i, r, o, a, s, c, l) {
                    var u;
                    return void 0 === t && (t = 1), void 0 === n && (n = 0), void 0 === i && (i = 0), void 0 === r && (r = 0), void 0 === o && (o = 1), void 0 === a && (a = 0), void 0 === s && (s = 0), void 0 === c && (c = 0), void 0 === l && (l = 1), u = e.call(this) || this, "object" == typeof t ? (u.m00 = t.m00, u.m01 = t.m01, u.m02 = t.m02, u.m03 = t.m03, u.m04 = t.m04, u.m05 = t.m05, u.m06 = t.m06, u.m07 = t.m07, u.m08 = t.m08) : (u.m00 = t, u.m01 = n, u.m02 = i, u.m03 = r, u.m04 = o, u.m05 = a, u.m06 = s, u.m07 = c, u.m08 = l), u
                }
                Q(t, e), t.clone = function(e) {
                    return new t(e.m00, e.m01, e.m02, e.m03, e.m04, e.m05, e.m06, e.m07, e.m08)
                }, t.copy = function(e, t) {
                    return e.m00 = t.m00, e.m01 = t.m01, e.m02 = t.m02, e.m03 = t.m03, e.m04 = t.m04, e.m05 = t.m05, e.m06 = t.m06, e.m07 = t.m07, e.m08 = t.m08, e
                }, t.set = function(e, t, n, i, r, o, a, s, c, l) {
                    return e.m00 = t, e.m01 = n, e.m02 = i, e.m03 = r, e.m04 = o, e.m05 = a, e.m06 = s, e.m07 = c, e.m08 = l, e
                }, t.identity = function(e) {
                    return e.m00 = 1, e.m01 = 0, e.m02 = 0, e.m03 = 0, e.m04 = 1, e.m05 = 0, e.m06 = 0, e.m07 = 0, e.m08 = 1, e
                }, t.transpose = function(e, t) {
                    if (e === t) {
                        var n = t.m01,
                            i = t.m02,
                            r = t.m05;
                        e.m01 = t.m03, e.m02 = t.m06, e.m03 = n, e.m05 = t.m07, e.m06 = i, e.m07 = r
                    } else e.m00 = t.m00, e.m01 = t.m03, e.m02 = t.m06, e.m03 = t.m01, e.m04 = t.m04, e.m05 = t.m07, e.m06 = t.m02, e.m07 = t.m05, e.m08 = t.m08;
                    return e
                }, t.invert = function(e, t) {
                    var n = t.m00,
                        i = t.m01,
                        r = t.m02,
                        o = t.m03,
                        a = t.m04,
                        s = t.m05,
                        c = t.m06,
                        l = t.m07,
                        u = t.m08,
                        h = u * a - s * l,
                        _ = -u * o + s * c,
                        f = l * o - a * c,
                        d = n * h + i * _ + r * f;
                    return 0 === d ? (e.m00 = 0, e.m01 = 0, e.m02 = 0, e.m03 = 0, e.m04 = 0, e.m05 = 0, e.m06 = 0, e.m07 = 0, e.m08 = 0, e) : (d = 1 / d, e.m00 = h * d, e.m01 = (-u * i + r * l) * d, e.m02 = (s * i - r * a) * d, e.m03 = _ * d, e.m04 = (u * n - r * c) * d, e.m05 = (-s * n + r * o) * d, e.m06 = f * d, e.m07 = (-l * n + i * c) * d, e.m08 = (a * n - i * o) * d, e)
                }, t.determinant = function(e) {
                    var t = e.m00,
                        n = e.m01,
                        i = e.m02,
                        r = e.m03,
                        o = e.m04,
                        a = e.m05,
                        s = e.m06,
                        c = e.m07,
                        l = e.m08;
                    return t * (l * o - a * c) + n * (-l * r + a * s) + i * (c * r - o * s)
                }, t.multiply = function(e, t, n) {
                    var i = t.m00,
                        r = t.m01,
                        o = t.m02,
                        a = t.m03,
                        s = t.m04,
                        c = t.m05,
                        l = t.m06,
                        u = t.m07,
                        h = t.m08,
                        _ = n.m00,
                        f = n.m01,
                        d = n.m02,
                        p = n.m03,
                        m = n.m04,
                        g = n.m05,
                        v = n.m06,
                        y = n.m07,
                        S = n.m08;
                    return e.m00 = _ * i + f * a + d * l, e.m01 = _ * r + f * s + d * u, e.m02 = _ * o + f * c + d * h, e.m03 = p * i + m * a + g * l, e.m04 = p * r + m * s + g * u, e.m05 = p * o + m * c + g * h, e.m06 = v * i + y * a + S * l, e.m07 = v * r + y * s + S * u, e.m08 = v * o + y * c + S * h, e
                }, t.multiplyMat4 = function(e, t, n) {
                    var i = t.m00,
                        r = t.m01,
                        o = t.m02,
                        a = t.m03,
                        s = t.m04,
                        c = t.m05,
                        l = t.m06,
                        u = t.m07,
                        h = t.m08,
                        _ = n.m00,
                        f = n.m01,
                        d = n.m02,
                        p = n.m04,
                        m = n.m05,
                        g = n.m06,
                        v = n.m08,
                        y = n.m09,
                        S = n.m10;
                    return e.m00 = _ * i + f * a + d * l, e.m01 = _ * r + f * s + d * u, e.m02 = _ * o + f * c + d * h, e.m03 = p * i + m * a + g * l, e.m04 = p * r + m * s + g * u, e.m05 = p * o + m * c + g * h, e.m06 = v * i + y * a + S * l, e.m07 = v * r + y * s + S * u, e.m08 = v * o + y * c + S * h, e
                }, t.transform = function(e, t, n) {
                    var i = t.m00,
                        r = t.m01,
                        o = t.m02,
                        a = t.m03,
                        s = t.m04,
                        c = t.m05,
                        l = t.m06,
                        u = t.m07,
                        h = t.m08,
                        _ = n.x,
                        f = n.y;
                    return e.m00 = i, e.m01 = r, e.m02 = o, e.m03 = a, e.m04 = s, e.m05 = c, e.m06 = _ * i + f * a + l, e.m07 = _ * r + f * s + u, e.m08 = _ * o + f * c + h, e
                }, t.scale = function(e, t, n) {
                    var i = n.x,
                        r = n.y;
                    return e.m00 = i * t.m00, e.m01 = i * t.m01, e.m02 = i * t.m02, e.m03 = r * t.m03, e.m04 = r * t.m04, e.m05 = r * t.m05, e.m06 = t.m06, e.m07 = t.m07, e.m08 = t.m08, e
                }, t.rotate = function(e, t, n) {
                    var i = t.m00,
                        r = t.m01,
                        o = t.m02,
                        a = t.m03,
                        s = t.m04,
                        c = t.m05,
                        l = t.m06,
                        u = t.m07,
                        h = t.m08,
                        _ = Math.sin(n),
                        f = Math.cos(n);
                    return e.m00 = f * i + _ * a, e.m01 = f * r + _ * s, e.m02 = f * o + _ * c, e.m03 = f * a - _ * i, e.m04 = f * s - _ * r, e.m05 = f * c - _ * o, e.m06 = l, e.m07 = u, e.m08 = h, e
                }, t.fromMat4 = function(e, t) {
                    return e.m00 = t.m00, e.m01 = t.m01, e.m02 = t.m02, e.m03 = t.m04, e.m04 = t.m05, e.m05 = t.m06, e.m06 = t.m08, e.m07 = t.m09, e.m08 = t.m10, e
                }, t.fromViewUp = function(e, n, i) {
                    return En.lengthSqr(n) < Qt * Qt ? (t.identity(e), e) : (i = i || En.UNIT_Y, En.normalize(bn, En.cross(bn, i, n)), En.lengthSqr(bn) < Qt * Qt ? (t.identity(e), e) : (En.cross(Rn, n, bn), t.set(e, bn.x, bn.y, bn.z, Rn.x, Rn.y, Rn.z, n.x, n.y, n.z), e))
                }, t.fromTranslation = function(e, t) {
                    return e.m00 = 1, e.m01 = 0, e.m02 = 0, e.m03 = 0, e.m04 = 1, e.m05 = 0, e.m06 = t.x, e.m07 = t.y, e.m08 = 1, e
                }, t.fromScaling = function(e, t) {
                    return e.m00 = t.x, e.m01 = 0, e.m02 = 0, e.m03 = 0, e.m04 = t.y, e.m05 = 0, e.m06 = 0, e.m07 = 0, e.m08 = 1, e
                }, t.fromRotation = function(e, t) {
                    var n = Math.sin(t),
                        i = Math.cos(t);
                    return e.m00 = i, e.m01 = n, e.m02 = 0, e.m03 = -n, e.m04 = i, e.m05 = 0, e.m06 = 0, e.m07 = 0, e.m08 = 1, e
                }, t.fromQuat = function(e, t) {
                    var n = t.x,
                        i = t.y,
                        r = t.z,
                        o = t.w,
                        a = n + n,
                        s = i + i,
                        c = r + r,
                        l = n * a,
                        u = i * a,
                        h = i * s,
                        _ = r * a,
                        f = r * s,
                        d = r * c,
                        p = o * a,
                        m = o * s,
                        g = o * c;
                    return e.m00 = 1 - h - d, e.m03 = u - g, e.m06 = _ + m, e.m01 = u + g, e.m04 = 1 - l - d, e.m07 = f - p, e.m02 = _ - m, e.m05 = f + p, e.m08 = 1 - l - h, e
                }, t.inverseTransposeMat4 = function(e, t) {
                    var n = t.m00,
                        i = t.m01,
                        r = t.m02,
                        o = t.m03,
                        a = t.m04,
                        s = t.m05,
                        c = t.m06,
                        l = t.m07,
                        u = t.m08,
                        h = t.m09,
                        _ = t.m10,
                        f = t.m11,
                        d = t.m12,
                        p = t.m13,
                        m = t.m14,
                        g = t.m15,
                        v = n * s - i * a,
                        y = n * c - r * a,
                        S = n * l - o * a,
                        E = i * c - r * s,
                        T = i * l - o * s,
                        A = r * l - o * c,
                        x = u * p - h * d,
                        C = u * m - _ * d,
                        b = u * g - f * d,
                        R = h * m - _ * p,
                        w = h * g - f * p,
                        I = _ * g - f * m,
                        P = v * I - y * w + S * R + E * b - T * C + A * x;
                    return P ? (P = 1 / P, e.m00 = (s * I - c * w + l * R) * P, e.m01 = (c * b - a * I - l * C) * P, e.m02 = (a * w - s * b + l * x) * P, e.m03 = (r * w - i * I - o * R) * P, e.m04 = (n * I - r * b + o * C) * P, e.m05 = (i * b - n * w - o * x) * P, e.m06 = (p * A - m * T + g * E) * P, e.m07 = (m * S - d * A - g * y) * P, e.m08 = (d * T - p * S + g * v) * P, e) : null
                }, t.toArray = function(e, t, n) {
                    return void 0 === n && (n = 0), e[n + 0] = t.m00, e[n + 1] = t.m01, e[n + 2] = t.m02, e[n + 3] = t.m03, e[n + 4] = t.m04, e[n + 5] = t.m05, e[n + 6] = t.m06, e[n + 7] = t.m07, e[n + 8] = t.m08, e
                }, t.fromArray = function(e, t, n) {
                    return void 0 === n && (n = 0), e.m00 = t[n + 0], e.m01 = t[n + 1], e.m02 = t[n + 2], e.m03 = t[n + 3], e.m04 = t[n + 4], e.m05 = t[n + 5], e.m06 = t[n + 6], e.m07 = t[n + 7], e.m08 = t[n + 8], e
                }, t.add = function(e, t, n) {
                    return e.m00 = t.m00 + n.m00, e.m01 = t.m01 + n.m01, e.m02 = t.m02 + n.m02, e.m03 = t.m03 + n.m03, e.m04 = t.m04 + n.m04, e.m05 = t.m05 + n.m05, e.m06 = t.m06 + n.m06, e.m07 = t.m07 + n.m07, e.m08 = t.m08 + n.m08, e
                }, t.subtract = function(e, t, n) {
                    return e.m00 = t.m00 - n.m00, e.m01 = t.m01 - n.m01, e.m02 = t.m02 - n.m02, e.m03 = t.m03 - n.m03, e.m04 = t.m04 - n.m04, e.m05 = t.m05 - n.m05, e.m06 = t.m06 - n.m06, e.m07 = t.m07 - n.m07, e.m08 = t.m08 - n.m08, e
                }, t.multiplyScalar = function(e, t, n) {
                    return e.m00 = t.m00 * n, e.m01 = t.m01 * n, e.m02 = t.m02 * n, e.m03 = t.m03 * n, e.m04 = t.m04 * n, e.m05 = t.m05 * n, e.m06 = t.m06 * n, e.m07 = t.m07 * n, e.m08 = t.m08 * n, e
                }, t.multiplyScalarAndAdd = function(e, t, n, i) {
                    return e.m00 = n.m00 * i + t.m00, e.m01 = n.m01 * i + t.m01, e.m02 = n.m02 * i + t.m02, e.m03 = n.m03 * i + t.m03, e.m04 = n.m04 * i + t.m04, e.m05 = n.m05 * i + t.m05, e.m06 = n.m06 * i + t.m06, e.m07 = n.m07 * i + t.m07, e.m08 = n.m08 * i + t.m08, e
                }, t.strictEquals = function(e, t) {
                    return e.m00 === t.m00 && e.m01 === t.m01 && e.m02 === t.m02 && e.m03 === t.m03 && e.m04 === t.m04 && e.m05 === t.m05 && e.m06 === t.m06 && e.m07 === t.m07 && e.m08 === t.m08
                }, t.equals = function(e, t, n) {
                    return void 0 === n && (n = Qt), Math.abs(e.m00 - t.m00) <= n * Math.max(1, Math.abs(e.m00), Math.abs(t.m00)) && Math.abs(e.m01 - t.m01) <= n * Math.max(1, Math.abs(e.m01), Math.abs(t.m01)) && Math.abs(e.m02 - t.m02) <= n * Math.max(1, Math.abs(e.m02), Math.abs(t.m02)) && Math.abs(e.m03 - t.m03) <= n * Math.max(1, Math.abs(e.m03), Math.abs(t.m03)) && Math.abs(e.m04 - t.m04) <= n * Math.max(1, Math.abs(e.m04), Math.abs(t.m04)) && Math.abs(e.m05 - t.m05) <= n * Math.max(1, Math.abs(e.m05), Math.abs(t.m05)) && Math.abs(e.m06 - t.m06) <= n * Math.max(1, Math.abs(e.m06), Math.abs(t.m06)) && Math.abs(e.m07 - t.m07) <= n * Math.max(1, Math.abs(e.m07), Math.abs(t.m07)) && Math.abs(e.m08 - t.m08) <= n * Math.max(1, Math.abs(e.m08), Math.abs(t.m08))
                };
                var n = t.prototype;
                return n.clone = function() {
                    var e = this;
                    return new t(e.m00, e.m01, e.m02, e.m03, e.m04, e.m05, e.m06, e.m07, e.m08)
                }, n.set = function(e, t, n, i, r, o, a, s, c) {
                    return void 0 === e && (e = 1), void 0 === t && (t = 0), void 0 === n && (n = 0), void 0 === i && (i = 0), void 0 === r && (r = 1), void 0 === o && (o = 0), void 0 === a && (a = 0), void 0 === s && (s = 0), void 0 === c && (c = 1), "object" == typeof e ? (this.m00 = e.m00, this.m01 = e.m01, this.m02 = e.m02, this.m03 = e.m03, this.m04 = e.m04, this.m05 = e.m05, this.m06 = e.m06, this.m07 = e.m07, this.m08 = e.m08) : (this.m00 = e, this.m01 = t, this.m02 = n, this.m03 = i, this.m04 = r, this.m05 = o, this.m06 = a, this.m07 = s, this.m08 = c), this
                }, n.equals = function(e, t) {
                    return void 0 === t && (t = Qt), Math.abs(this.m00 - e.m00) <= t * Math.max(1, Math.abs(this.m00), Math.abs(e.m00)) && Math.abs(this.m01 - e.m01) <= t * Math.max(1, Math.abs(this.m01), Math.abs(e.m01)) && Math.abs(this.m02 - e.m02) <= t * Math.max(1, Math.abs(this.m02), Math.abs(e.m02)) && Math.abs(this.m03 - e.m03) <= t * Math.max(1, Math.abs(this.m03), Math.abs(e.m03)) && Math.abs(this.m04 - e.m04) <= t * Math.max(1, Math.abs(this.m04), Math.abs(e.m04)) && Math.abs(this.m05 - e.m05) <= t * Math.max(1, Math.abs(this.m05), Math.abs(e.m05)) && Math.abs(this.m06 - e.m06) <= t * Math.max(1, Math.abs(this.m06), Math.abs(e.m06)) && Math.abs(this.m07 - e.m07) <= t * Math.max(1, Math.abs(this.m07), Math.abs(e.m07)) && Math.abs(this.m08 - e.m08) <= t * Math.max(1, Math.abs(this.m08), Math.abs(e.m08))
                }, n.strictEquals = function(e) {
                    return this.m00 === e.m00 && this.m01 === e.m01 && this.m02 === e.m02 && this.m03 === e.m03 && this.m04 === e.m04 && this.m05 === e.m05 && this.m06 === e.m06 && this.m07 === e.m07 && this.m08 === e.m08
                }, n.toString = function() {
                    var e = this;
                    return "[\n" + e.m00 + ", " + e.m01 + ", " + e.m02 + ",\n" + e.m03 + ",\n" + e.m04 + ", " + e.m05 + ",\n" + e.m06 + ", " + e.m07 + ",\n" + e.m08 + "\n]"
                }, n.identity = function() {
                    return this.m00 = 1, this.m01 = 0, this.m02 = 0, this.m03 = 0, this.m04 = 1, this.m05 = 0, this.m06 = 0, this.m07 = 0, this.m08 = 1, this
                }, n.transpose = function() {
                    var e = this.m01,
                        t = this.m02,
                        n = this.m05;
                    return this.m01 = this.m03, this.m02 = this.m06, this.m03 = e, this.m05 = this.m07, this.m06 = t, this.m07 = n, this
                }, n.invert = function() {
                    var e = this.m00,
                        t = this.m01,
                        n = this.m02,
                        i = this.m03,
                        r = this.m04,
                        o = this.m05,
                        a = this.m06,
                        s = this.m07,
                        c = this.m08,
                        l = c * r - o * s,
                        u = -c * i + o * a,
                        h = s * i - r * a,
                        _ = e * l + t * u + n * h;
                    return 0 === _ ? (this.set(0, 0, 0, 0, 0, 0, 0, 0, 0), this) : (_ = 1 / _, this.m00 = l * _, this.m01 = (-c * t + n * s) * _, this.m02 = (o * t - n * r) * _, this.m03 = u * _, this.m04 = (c * e - n * a) * _, this.m05 = (-o * e + n * i) * _, this.m06 = h * _, this.m07 = (-s * e + t * a) * _, this.m08 = (r * e - t * i) * _, this)
                }, n.determinant = function() {
                    var e = this.m00,
                        t = this.m01,
                        n = this.m02,
                        i = this.m03,
                        r = this.m04,
                        o = this.m05,
                        a = this.m06,
                        s = this.m07,
                        c = this.m08;
                    return e * (c * r - o * s) + t * (-c * i + o * a) + n * (s * i - r * a)
                }, n.add = function(e) {
                    return this.m00 += e.m00, this.m01 += e.m01, this.m02 += e.m02, this.m03 += e.m03, this.m04 += e.m04, this.m05 += e.m05, this.m06 += e.m06, this.m07 += e.m07, this.m08 += e.m08, this
                }, n.subtract = function(e) {
                    return this.m00 -= e.m00, this.m01 -= e.m01, this.m02 -= e.m02, this.m03 -= e.m03, this.m04 -= e.m04, this.m05 -= e.m05, this.m06 -= e.m06, this.m07 -= e.m07, this.m08 -= e.m08, this
                }, n.multiply = function(e) {
                    var t = this.m00,
                        n = this.m01,
                        i = this.m02,
                        r = this.m03,
                        o = this.m04,
                        a = this.m05,
                        s = this.m06,
                        c = this.m07,
                        l = this.m08,
                        u = e.m00,
                        h = e.m01,
                        _ = e.m02,
                        f = e.m03,
                        d = e.m04,
                        p = e.m05,
                        m = e.m06,
                        g = e.m07,
                        v = e.m08;
                    return this.m00 = u * t + h * r + _ * s, this.m01 = u * n + h * o + _ * c, this.m02 = u * i + h * a + _ * l, this.m03 = f * t + d * r + p * s, this.m04 = f * n + d * o + p * c, this.m05 = f * i + d * a + p * l, this.m06 = m * t + g * r + v * s, this.m07 = m * n + g * o + v * c, this.m08 = m * i + g * a + v * l, this
                }, n.multiplyScalar = function(e) {
                    return this.m00 *= e, this.m01 *= e, this.m02 *= e, this.m03 *= e, this.m04 *= e, this.m05 *= e, this.m06 *= e, this.m07 *= e, this.m08 *= e, this
                }, n.scale = function(e) {
                    var t = e.x,
                        n = e.y;
                    return this.m00 = t * this.m00, this.m01 = t * this.m01, this.m02 = t * this.m02, this.m03 = n * this.m03, this.m04 = n * this.m04, this.m05 = n * this.m05, this.m06 = this.m06, this.m07 = this.m07, this.m08 = this.m08, this
                }, n.rotate = function(e) {
                    var t = this.m00,
                        n = this.m01,
                        i = this.m02,
                        r = this.m03,
                        o = this.m04,
                        a = this.m05,
                        s = this.m06,
                        c = this.m07,
                        l = this.m08,
                        u = Math.sin(e),
                        h = Math.cos(e);
                    return this.m00 = h * t + u * r, this.m01 = h * n + u * o, this.m02 = h * i + u * a, this.m03 = h * r - u * t, this.m04 = h * o - u * n, this.m05 = h * a - u * i, this.m06 = s, this.m07 = c, this.m08 = l, this
                }, n.fromQuat = function(e) {
                    var t = e.x,
                        n = e.y,
                        i = e.z,
                        r = e.w,
                        o = t + t,
                        a = n + n,
                        s = i + i,
                        c = t * o,
                        l = n * o,
                        u = n * a,
                        h = i * o,
                        _ = i * a,
                        f = i * s,
                        d = r * o,
                        p = r * a,
                        m = r * s;
                    return this.m00 = 1 - u - f, this.m03 = l - m, this.m06 = h + p, this.m01 = l + m, this.m04 = 1 - c - f, this.m07 = _ - d, this.m02 = h - p, this.m05 = _ + d, this.m08 = 1 - c - u, this
                }, t
            }(it));
            Cn.IDENTITY = Object.freeze(new Cn);
            var bn = new En,
                Rn = new En;
            qt.fastDefine("cc.Mat3", Cn, {
                m00: 1,
                m01: 0,
                m02: 0,
                m03: 0,
                m04: 1,
                m05: 0,
                m06: 0,
                m07: 0,
                m08: 1
            }), i.Mat3 = Cn;
            var wn = e("Quat", function(e) {
                function t(t, n, i, r) {
                    var o;
                    return o = e.call(this) || this, t && "object" == typeof t ? (o.x = t.x, o.y = t.y, o.z = t.z, o.w = t.w) : (o.x = t || 0, o.y = n || 0, o.z = i || 0, o.w = null != r ? r : 1), o
                }
                Q(t, e), t.clone = function(e) {
                    return new t(e.x, e.y, e.z, e.w)
                }, t.copy = function(e, t) {
                    return e.x = t.x, e.y = t.y, e.z = t.z, e.w = t.w, e
                }, t.set = function(e, t, n, i, r) {
                    return e.x = t, e.y = n, e.z = i, e.w = r, e
                }, t.identity = function(e) {
                    return e.x = 0, e.y = 0, e.z = 0, e.w = 1, e
                }, t.rotationTo = function(e, n, i) {
                    var r = En.dot(n, i);
                    return r < -.999999 ? (En.cross(On, En.UNIT_X, n), On.length() < 1e-6 && En.cross(On, En.UNIT_Y, n), En.normalize(On, On), t.fromAxisAngle(e, On, Math.PI), e) : r > .999999 ? (e.x = 0, e.y = 0, e.z = 0, e.w = 1, e) : (En.cross(On, n, i), e.x = On.x, e.y = On.y, e.z = On.z, e.w = 1 + r, t.normalize(e, e))
                }, t.getAxisAngle = function(e, t) {
                    var n = 2 * Math.acos(t.w),
                        i = Math.sin(n / 2);
                    return 0 !== i ? (e.x = t.x / i, e.y = t.y / i, e.z = t.z / i) : (e.x = 1, e.y = 0, e.z = 0), n
                }, t.multiply = function(e, t, n) {
                    var i = t.x * n.w + t.w * n.x + t.y * n.z - t.z * n.y,
                        r = t.y * n.w + t.w * n.y + t.z * n.x - t.x * n.z,
                        o = t.z * n.w + t.w * n.z + t.x * n.y - t.y * n.x,
                        a = t.w * n.w - t.x * n.x - t.y * n.y - t.z * n.z;
                    return e.x = i, e.y = r, e.z = o, e.w = a, e
                }, t.multiplyScalar = function(e, t, n) {
                    return e.x = t.x * n, e.y = t.y * n, e.z = t.z * n, e.w = t.w * n, e
                }, t.scaleAndAdd = function(e, t, n, i) {
                    return e.x = t.x + n.x * i, e.y = t.y + n.y * i, e.z = t.z + n.z * i, e.w = t.w + n.w * i, e
                }, t.rotateX = function(e, t, n) {
                    n *= .5;
                    var i = Math.sin(n),
                        r = Math.cos(n),
                        o = t.x,
                        a = t.y,
                        s = t.z,
                        c = t.w;
                    return e.x = o * r + c * i, e.y = a * r + s * i, e.z = s * r - a * i, e.w = c * r - o * i, e
                }, t.rotateY = function(e, t, n) {
                    n *= .5;
                    var i = Math.sin(n),
                        r = Math.cos(n),
                        o = t.x,
                        a = t.y,
                        s = t.z,
                        c = t.w;
                    return e.x = o * r - s * i, e.y = a * r + c * i, e.z = s * r + o * i, e.w = c * r - a * i, e
                }, t.rotateZ = function(e, t, n) {
                    n *= .5;
                    var i = Math.sin(n),
                        r = Math.cos(n),
                        o = t.x,
                        a = t.y,
                        s = t.z,
                        c = t.w;
                    return e.x = o * r + a * i, e.y = a * r - o * i, e.z = s * r + c * i, e.w = c * r - s * i, e
                }, t.rotateAround = function(e, n, i, r) {
                    return t.invert(In, n), En.transformQuat(On, i, In), t.fromAxisAngle(In, On, r), t.multiply(e, n, In), e
                }, t.rotateAroundLocal = function(e, n, i, r) {
                    return t.fromAxisAngle(In, i, r), t.multiply(e, n, In), e
                }, t.calculateW = function(e, t) {
                    return e.x = t.x, e.y = t.y, e.z = t.z, e.w = Math.sqrt(Math.abs(1 - t.x * t.x - t.y * t.y - t.z * t.z)), e
                }, t.dot = function(e, t) {
                    return e.x * t.x + e.y * t.y + e.z * t.z + e.w * t.w
                }, t.lerp = function(e, t, n, i) {
                    return e.x = t.x + i * (n.x - t.x), e.y = t.y + i * (n.y - t.y), e.z = t.z + i * (n.z - t.z), e.w = t.w + i * (n.w - t.w), e
                }, t.slerp = function(e, t, n, i) {
                    var r = 0,
                        o = 0,
                        a = n.x,
                        s = n.y,
                        c = n.z,
                        l = n.w,
                        u = t.x * n.x + t.y * n.y + t.z * n.z + t.w * n.w;
                    if (u < 0 && (u = -u, a = -a, s = -s, c = -c, l = -l), 1 - u > 1e-6) {
                        var h = Math.acos(u),
                            _ = Math.sin(h);
                        r = Math.sin((1 - i) * h) / _, o = Math.sin(i * h) / _
                    } else r = 1 - i, o = i;
                    return e.x = r * t.x + o * a, e.y = r * t.y + o * s, e.z = r * t.z + o * c, e.w = r * t.w + o * l, e
                }, t.sqlerp = function(e, n, i, r, o, a) {
                    return t.slerp(In, n, o, a), t.slerp(Pn, i, r, a), t.slerp(e, In, Pn, 2 * a * (1 - a)), e
                }, t.invert = function(e, t) {
                    var n = t.x * t.x + t.y * t.y + t.z * t.z + t.w * t.w,
                        i = n ? 1 / n : 0;
                    return e.x = -t.x * i, e.y = -t.y * i, e.z = -t.z * i, e.w = t.w * i, e
                }, t.conjugate = function(e, t) {
                    return e.x = -t.x, e.y = -t.y, e.z = -t.z, e.w = t.w, e
                }, t.len = function(e) {
                    return Math.sqrt(e.x * e.x + e.y * e.y + e.z * e.z + e.w * e.w)
                }, t.lengthSqr = function(e) {
                    return e.x * e.x + e.y * e.y + e.z * e.z + e.w * e.w
                }, t.normalize = function(e, t) {
                    var n = t.x * t.x + t.y * t.y + t.z * t.z + t.w * t.w;
                    return n > 0 && (n = 1 / Math.sqrt(n), e.x = t.x * n, e.y = t.y * n, e.z = t.z * n, e.w = t.w * n), e
                }, t.fromAxes = function(e, n, i, r) {
                    return Cn.set(Dn, n.x, n.y, n.z, i.x, i.y, i.z, r.x, r.y, r.z), t.normalize(e, t.fromMat3(e, Dn))
                }, t.fromViewUp = function(e, n, i) {
                    return Cn.fromViewUp(Dn, n, i), t.normalize(e, t.fromMat3(e, Dn))
                }, t.fromAxisAngle = function(e, t, n) {
                    n *= .5;
                    var i = Math.sin(n);
                    return e.x = i * t.x, e.y = i * t.y, e.z = i * t.z, e.w = Math.cos(n), e
                }, t.fromMat3 = function(e, t) {
                    var n = t.m00,
                        i = t.m03,
                        r = t.m06,
                        o = t.m01,
                        a = t.m04,
                        s = t.m07,
                        c = t.m02,
                        l = t.m05,
                        u = t.m08,
                        h = n + a + u;
                    if (h > 0) {
                        var _ = .5 / Math.sqrt(h + 1);
                        e.w = .25 / _, e.x = (l - s) * _, e.y = (r - c) * _, e.z = (o - i) * _
                    } else if (n > a && n > u) {
                        var f = 2 * Math.sqrt(1 + n - a - u);
                        e.w = (l - s) / f, e.x = .25 * f, e.y = (i + o) / f, e.z = (r + c) / f
                    } else if (a > u) {
                        var d = 2 * Math.sqrt(1 + a - n - u);
                        e.w = (r - c) / d, e.x = (i + o) / d, e.y = .25 * d, e.z = (s + l) / d
                    } else {
                        var p = 2 * Math.sqrt(1 + u - n - a);
                        e.w = (o - i) / p, e.x = (r + c) / p, e.y = (s + l) / p, e.z = .25 * p
                    }
                    return e
                }, t.fromEuler = function(e, t, n, i) {
                    t *= Nn, n *= Nn, i *= Nn;
                    var r = Math.sin(t),
                        o = Math.cos(t),
                        a = Math.sin(n),
                        s = Math.cos(n),
                        c = Math.sin(i),
                        l = Math.cos(i);
                    return e.x = r * s * l + o * a * c, e.y = o * a * l + r * s * c, e.z = o * s * c - r * a * l, e.w = o * s * l - r * a * c, e
                }, t.fromAngleZ = function(e, t) {
                    return t *= Nn, e.x = e.y = 0, e.z = Math.sin(t), e.w = Math.cos(t), e
                }, t.toAxisX = function(e, t) {
                    var n = 2 * t.y,
                        i = 2 * t.z;
                    return e.x = 1 - n * t.y - i * t.z, e.y = n * t.x + i * t.w, e.z = i * t.x + n * t.w, e
                }, t.toAxisY = function(e, t) {
                    var n = 2 * t.x,
                        i = 2 * t.y,
                        r = 2 * t.z;
                    return e.x = i * t.x - r * t.w, e.y = 1 - n * t.x - r * t.z, e.z = r * t.y + n * t.w, e
                }, t.toAxisZ = function(e, t) {
                    var n = 2 * t.x,
                        i = 2 * t.y,
                        r = 2 * t.z;
                    return e.x = r * t.x - i * t.w, e.y = r * t.y - n * t.w, e.z = 1 - n * t.x - i * t.y, e
                }, t.toEuler = function(e, t, n) {
                    var i = t.x,
                        r = t.y,
                        o = t.z,
                        a = t.w,
                        s = 0,
                        c = 0,
                        l = 0,
                        u = i * r + o * a;
                    if (u > .499999) s = 0, c = on(2 * Math.atan2(i, a)), l = 90;
                    else if (u < -.499999) s = 0, c = -on(2 * Math.atan2(i, a)), l = -90;
                    else {
                        var h = i * i,
                            _ = r * r,
                            f = o * o;
                        s = on(Math.atan2(2 * i * a - 2 * r * o, 1 - 2 * h - 2 * f)), c = on(Math.atan2(2 * r * a - 2 * i * o, 1 - 2 * _ - 2 * f)), l = on(Math.asin(2 * u)), n && (s = -180 * Math.sign(s + 1e-6) + s, c = -180 * Math.sign(c + 1e-6) + c, l = 180 * Math.sign(l + 1e-6) - l)
                    }
                    return e.x = s, e.y = c, e.z = l, e
                }, t.toArray = function(e, t, n) {
                    return void 0 === n && (n = 0), e[n + 0] = t.x, e[n + 1] = t.y, e[n + 2] = t.z, e[n + 3] = t.w, e
                }, t.fromArray = function(e, t, n) {
                    return void 0 === n && (n = 0), e.x = t[n + 0], e.y = t[n + 1], e.z = t[n + 2], e.w = t[n + 3], e
                }, t.strictEquals = function(e, t) {
                    return e.x === t.x && e.y === t.y && e.z === t.z && e.w === t.w
                }, t.equals = function(e, t, n) {
                    return void 0 === n && (n = Qt), Math.abs(e.x - t.x) <= n * Math.max(1, Math.abs(e.x), Math.abs(t.x)) && Math.abs(e.y - t.y) <= n * Math.max(1, Math.abs(e.y), Math.abs(t.y)) && Math.abs(e.z - t.z) <= n * Math.max(1, Math.abs(e.z), Math.abs(t.z)) && Math.abs(e.w - t.w) <= n * Math.max(1, Math.abs(e.w), Math.abs(t.w))
                };
                var n = t.prototype;
                return n.clone = function() {
                    return new t(this.x, this.y, this.z, this.w)
                }, n.set = function(e, t, n, i) {
                    return e && "object" == typeof e ? (this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w) : (this.x = e || 0, this.y = t || 0, this.z = n || 0, this.w = null != i ? i : 1), this
                }, n.equals = function(e, t) {
                    return void 0 === t && (t = Qt), Math.abs(this.x - e.x) <= t * Math.max(1, Math.abs(this.x), Math.abs(e.x)) && Math.abs(this.y - e.y) <= t * Math.max(1, Math.abs(this.y), Math.abs(e.y)) && Math.abs(this.z - e.z) <= t * Math.max(1, Math.abs(this.z), Math.abs(e.z)) && Math.abs(this.w - e.w) <= t * Math.max(1, Math.abs(this.w), Math.abs(e.w))
                }, n.strictEquals = function(e) {
                    return e && this.x === e.x && this.y === e.y && this.z === e.z && this.w === e.w
                }, n.getEulerAngles = function(e) {
                    return t.toEuler(e, this)
                }, n.lerp = function(e, t) {
                    return this.x += t * (e.x - this.x), this.y += t * (e.y - this.y), this.z += t * (e.z - this.z), this.w += t * (e.w - this.w), this
                }, n.slerp = function(e, n) {
                    return t.slerp(this, this, e, n)
                }, n.length = function() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
                }, n.lengthSqr = function() {
                    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
                }, t
            }(it));
            wn.IDENTITY = Object.freeze(new wn);
            var In = new wn,
                Pn = new wn,
                On = new En,
                Dn = new Cn,
                Nn = .5 * Math.PI / 180;

            function Mn(e, t, n, i) {
                return void 0 === e && (e = 0), void 0 === t && (t = 0), void 0 === n && (n = 0), void 0 === i && (i = 1), new wn(e, t, n, i)
            }
            qt.fastDefine("cc.Quat", wn, {
                x: 0,
                y: 0,
                z: 0,
                w: 1
            }), i.Quat = wn, i.quat = Mn;
            var Ln = Object.freeze([Object.freeze([1, 0, 0, 1]), Object.freeze([0, 1, -1, 0]), Object.freeze([-1, 0, 0, -1]), Object.freeze([0, -1, 1, 0])]),
                Bn = e("Mat4", function(e) {
                    function t(t, n, i, r, o, a, s, c, l, u, h, _, f, d, p, m) {
                        var g;
                        return void 0 === t && (t = 1), void 0 === n && (n = 0), void 0 === i && (i = 0), void 0 === r && (r = 0), void 0 === o && (o = 0), void 0 === a && (a = 1), void 0 === s && (s = 0), void 0 === c && (c = 0), void 0 === l && (l = 0), void 0 === u && (u = 0), void 0 === h && (h = 1), void 0 === _ && (_ = 0), void 0 === f && (f = 0), void 0 === d && (d = 0), void 0 === p && (p = 0), void 0 === m && (m = 1), (g = e.call(this) || this).m00 = void 0, g.m01 = void 0, g.m02 = void 0, g.m03 = void 0, g.m04 = void 0, g.m05 = void 0, g.m06 = void 0, g.m07 = void 0, g.m08 = void 0, g.m09 = void 0, g.m10 = void 0, g.m11 = void 0, g.m12 = void 0, g.m13 = void 0, g.m14 = void 0, g.m15 = void 0, "object" == typeof t ? (g.m00 = t.m00, g.m01 = t.m01, g.m02 = t.m02, g.m03 = t.m03, g.m04 = t.m04, g.m05 = t.m05, g.m06 = t.m06, g.m07 = t.m07, g.m08 = t.m08, g.m09 = t.m09, g.m10 = t.m10, g.m11 = t.m11, g.m12 = t.m12, g.m13 = t.m13, g.m14 = t.m14, g.m15 = t.m15) : (g.m00 = t, g.m01 = n, g.m02 = i, g.m03 = r, g.m04 = o, g.m05 = a, g.m06 = s, g.m07 = c, g.m08 = l, g.m09 = u, g.m10 = h, g.m11 = _, g.m12 = f, g.m13 = d, g.m14 = p, g.m15 = m), g
                    }
                    Q(t, e), t.clone = function(e) {
                        return new t(e.m00, e.m01, e.m02, e.m03, e.m04, e.m05, e.m06, e.m07, e.m08, e.m09, e.m10, e.m11, e.m12, e.m13, e.m14, e.m15)
                    }, t.copy = function(e, t) {
                        return e.m00 = t.m00, e.m01 = t.m01, e.m02 = t.m02, e.m03 = t.m03, e.m04 = t.m04, e.m05 = t.m05, e.m06 = t.m06, e.m07 = t.m07, e.m08 = t.m08, e.m09 = t.m09, e.m10 = t.m10, e.m11 = t.m11, e.m12 = t.m12, e.m13 = t.m13, e.m14 = t.m14, e.m15 = t.m15, e
                    }, t.set = function(e, t, n, i, r, o, a, s, c, l, u, h, _, f, d, p, m) {
                        return e.m00 = t, e.m01 = n, e.m02 = i, e.m03 = r, e.m04 = o, e.m05 = a, e.m06 = s, e.m07 = c, e.m08 = l, e.m09 = u, e.m10 = h, e.m11 = _, e.m12 = f, e.m13 = d, e.m14 = p, e.m15 = m, e
                    }, t.identity = function(e) {
                        return e.m00 = 1, e.m01 = 0, e.m02 = 0, e.m03 = 0, e.m04 = 0, e.m05 = 1, e.m06 = 0, e.m07 = 0, e.m08 = 0, e.m09 = 0, e.m10 = 1, e.m11 = 0, e.m12 = 0, e.m13 = 0, e.m14 = 0, e.m15 = 1, e
                    }, t.transpose = function(e, t) {
                        if (e === t) {
                            var n = t.m01,
                                i = t.m02,
                                r = t.m03,
                                o = t.m06,
                                a = t.m07,
                                s = t.m11;
                            e.m01 = t.m04, e.m02 = t.m08, e.m03 = t.m12, e.m04 = n, e.m06 = t.m09, e.m07 = t.m13, e.m08 = i, e.m09 = o, e.m11 = t.m14, e.m12 = r, e.m13 = a, e.m14 = s
                        } else e.m00 = t.m00, e.m01 = t.m04, e.m02 = t.m08, e.m03 = t.m12, e.m04 = t.m01, e.m05 = t.m05, e.m06 = t.m09, e.m07 = t.m13, e.m08 = t.m02, e.m09 = t.m06, e.m10 = t.m10, e.m11 = t.m14, e.m12 = t.m03, e.m13 = t.m07, e.m14 = t.m11, e.m15 = t.m15;
                        return e
                    }, t.invert = function(e, t) {
                        var n = t.m00,
                            i = t.m01,
                            r = t.m02,
                            o = t.m03,
                            a = t.m04,
                            s = t.m05,
                            c = t.m06,
                            l = t.m07,
                            u = t.m08,
                            h = t.m09,
                            _ = t.m10,
                            f = t.m11,
                            d = t.m12,
                            p = t.m13,
                            m = t.m14,
                            g = t.m15,
                            v = n * s - i * a,
                            y = n * c - r * a,
                            S = n * l - o * a,
                            E = i * c - r * s,
                            T = i * l - o * s,
                            A = r * l - o * c,
                            x = u * p - h * d,
                            C = u * m - _ * d,
                            b = u * g - f * d,
                            R = h * m - _ * p,
                            w = h * g - f * p,
                            I = _ * g - f * m,
                            P = v * I - y * w + S * R + E * b - T * C + A * x;
                        return 0 === P ? (e.m00 = 0, e.m01 = 0, e.m02 = 0, e.m03 = 0, e.m04 = 0, e.m05 = 0, e.m06 = 0, e.m07 = 0, e.m08 = 0, e.m09 = 0, e.m10 = 0, e.m11 = 0, e.m12 = 0, e.m13 = 0, e.m14 = 0, e.m15 = 0, e) : (P = 1 / P, e.m00 = (s * I - c * w + l * R) * P, e.m01 = (r * w - i * I - o * R) * P, e.m02 = (p * A - m * T + g * E) * P, e.m03 = (_ * T - h * A - f * E) * P, e.m04 = (c * b - a * I - l * C) * P, e.m05 = (n * I - r * b + o * C) * P, e.m06 = (m * S - d * A - g * y) * P, e.m07 = (u * A - _ * S + f * y) * P, e.m08 = (a * w - s * b + l * x) * P, e.m09 = (i * b - n * w - o * x) * P, e.m10 = (d * T - p * S + g * v) * P, e.m11 = (h * S - u * T - f * v) * P, e.m12 = (s * C - a * R - c * x) * P, e.m13 = (n * R - i * C + r * x) * P, e.m14 = (p * y - d * E - m * v) * P, e.m15 = (u * E - h * y + _ * v) * P, e)
                    }, t.determinant = function(e) {
                        var t = e.m00,
                            n = e.m01,
                            i = e.m02,
                            r = e.m03,
                            o = e.m04,
                            a = e.m05,
                            s = e.m06,
                            c = e.m07,
                            l = e.m08,
                            u = e.m09,
                            h = e.m10,
                            _ = e.m11,
                            f = e.m12,
                            d = e.m13,
                            p = e.m14,
                            m = e.m15;
                        return (t * a - n * o) * (h * m - _ * p) - (t * s - i * o) * (u * m - _ * d) + (t * c - r * o) * (u * p - h * d) + (n * s - i * a) * (l * m - _ * f) - (n * c - r * a) * (l * p - h * f) + (i * c - r * s) * (l * d - u * f)
                    }, t.multiply = function(e, t, n) {
                        var i = t.m00,
                            r = t.m01,
                            o = t.m02,
                            a = t.m03,
                            s = t.m04,
                            c = t.m05,
                            l = t.m06,
                            u = t.m07,
                            h = t.m08,
                            _ = t.m09,
                            f = t.m10,
                            d = t.m11,
                            p = t.m12,
                            m = t.m13,
                            g = t.m14,
                            v = t.m15,
                            y = n.m00,
                            S = n.m01,
                            E = n.m02,
                            T = n.m03;
                        return e.m00 = y * i + S * s + E * h + T * p, e.m01 = y * r + S * c + E * _ + T * m, e.m02 = y * o + S * l + E * f + T * g, e.m03 = y * a + S * u + E * d + T * v, y = n.m04, S = n.m05, E = n.m06, T = n.m07, e.m04 = y * i + S * s + E * h + T * p, e.m05 = y * r + S * c + E * _ + T * m, e.m06 = y * o + S * l + E * f + T * g, e.m07 = y * a + S * u + E * d + T * v, y = n.m08, S = n.m09, E = n.m10, T = n.m11, e.m08 = y * i + S * s + E * h + T * p, e.m09 = y * r + S * c + E * _ + T * m, e.m10 = y * o + S * l + E * f + T * g, e.m11 = y * a + S * u + E * d + T * v, y = n.m12, S = n.m13, E = n.m14, T = n.m15, e.m12 = y * i + S * s + E * h + T * p, e.m13 = y * r + S * c + E * _ + T * m, e.m14 = y * o + S * l + E * f + T * g, e.m15 = y * a + S * u + E * d + T * v, e
                    }, t.transform = function(e, t, n) {
                        var i = n.x,
                            r = n.y,
                            o = n.z;
                        if (t === e) e.m12 = t.m00 * i + t.m04 * r + t.m08 * o + t.m12, e.m13 = t.m01 * i + t.m05 * r + t.m09 * o + t.m13, e.m14 = t.m02 * i + t.m06 * r + t.m10 * o + t.m14, e.m15 = t.m03 * i + t.m07 * r + t.m11 * o + t.m15;
                        else {
                            var a = t.m00,
                                s = t.m01,
                                c = t.m02,
                                l = t.m03,
                                u = t.m04,
                                h = t.m05,
                                _ = t.m06,
                                f = t.m07,
                                d = t.m08,
                                p = t.m09,
                                m = t.m10,
                                g = t.m11;
                            t.m12, t.m13, t.m14, t.m15, e.m00 = a, e.m01 = s, e.m02 = c, e.m03 = l, e.m04 = u, e.m05 = h, e.m06 = _, e.m07 = f, e.m08 = d, e.m09 = p, e.m10 = m, e.m11 = g, e.m12 = a * i + u * r + d * o + t.m12, e.m13 = s * i + h * r + p * o + t.m13, e.m14 = c * i + _ * r + m * o + t.m14, e.m15 = l * i + f * r + g * o + t.m15
                        }
                        return e
                    }, t.translate = function(e, t, n) {
                        return console.warn("function changed"), t === e ? (e.m12 += n.x, e.m13 += n.y, e.m14 += n.z) : (e.m00 = t.m00, e.m01 = t.m01, e.m02 = t.m02, e.m03 = t.m03, e.m04 = t.m04, e.m05 = t.m05, e.m06 = t.m06, e.m07 = t.m07, e.m08 = t.m08, e.m09 = t.m09, e.m10 = t.m10, e.m11 = t.m11, e.m12 += n.x, e.m13 += n.y, e.m14 += n.z, e.m15 = t.m15), e
                    }, t.scale = function(e, t, n) {
                        var i = n.x,
                            r = n.y,
                            o = n.z;
                        return e.m00 = t.m00 * i, e.m01 = t.m01 * i, e.m02 = t.m02 * i, e.m03 = t.m03 * i, e.m04 = t.m04 * r, e.m05 = t.m05 * r, e.m06 = t.m06 * r, e.m07 = t.m07 * r, e.m08 = t.m08 * o, e.m09 = t.m09 * o, e.m10 = t.m10 * o, e.m11 = t.m11 * o, e.m12 = t.m12, e.m13 = t.m13, e.m14 = t.m14, e.m15 = t.m15, e
                    }, t.rotate = function(e, t, n, i) {
                        var r = i.x,
                            o = i.y,
                            a = i.z,
                            s = Math.sqrt(r * r + o * o + a * a);
                        if (Math.abs(s) < Qt) return null;
                        r *= s = 1 / s, o *= s, a *= s;
                        var c = Math.sin(n),
                            l = Math.cos(n),
                            u = 1 - l,
                            h = t.m00,
                            _ = t.m01,
                            f = t.m02,
                            d = t.m03,
                            p = t.m04,
                            m = t.m05,
                            g = t.m06,
                            v = t.m07,
                            y = t.m08,
                            S = t.m09,
                            E = t.m10,
                            T = t.m11,
                            A = r * r * u + l,
                            x = o * r * u + a * c,
                            C = a * r * u - o * c,
                            b = r * o * u - a * c,
                            R = o * o * u + l,
                            w = a * o * u + r * c,
                            I = r * a * u + o * c,
                            P = o * a * u - r * c,
                            O = a * a * u + l;
                        return e.m00 = h * A + p * x + y * C, e.m01 = _ * A + m * x + S * C, e.m02 = f * A + g * x + E * C, e.m03 = d * A + v * x + T * C, e.m04 = h * b + p * R + y * w, e.m05 = _ * b + m * R + S * w, e.m06 = f * b + g * R + E * w, e.m07 = d * b + v * R + T * w, e.m08 = h * I + p * P + y * O, e.m09 = _ * I + m * P + S * O, e.m10 = f * I + g * P + E * O, e.m11 = d * I + v * P + T * O, t !== e && (e.m12 = t.m12, e.m13 = t.m13, e.m14 = t.m14, e.m15 = t.m15), e
                    }, t.rotateX = function(e, t, n) {
                        var i = Math.sin(n),
                            r = Math.cos(n),
                            o = t.m04,
                            a = t.m05,
                            s = t.m06,
                            c = t.m07,
                            l = t.m08,
                            u = t.m09,
                            h = t.m10,
                            _ = t.m11;
                        return t !== e && (e.m00 = t.m00, e.m01 = t.m01, e.m02 = t.m02, e.m03 = t.m03, e.m12 = t.m12, e.m13 = t.m13, e.m14 = t.m14, e.m15 = t.m15), e.m04 = o * r + l * i, e.m05 = a * r + u * i, e.m06 = s * r + h * i, e.m07 = c * r + _ * i, e.m08 = l * r - o * i, e.m09 = u * r - a * i, e.m10 = h * r - s * i, e.m11 = _ * r - c * i, e
                    }, t.rotateY = function(e, t, n) {
                        var i = Math.sin(n),
                            r = Math.cos(n),
                            o = t.m00,
                            a = t.m01,
                            s = t.m02,
                            c = t.m03,
                            l = t.m08,
                            u = t.m09,
                            h = t.m10,
                            _ = t.m11;
                        return t !== e && (e.m04 = t.m04, e.m05 = t.m05, e.m06 = t.m06, e.m07 = t.m07, e.m12 = t.m12, e.m13 = t.m13, e.m14 = t.m14, e.m15 = t.m15), e.m00 = o * r - l * i, e.m01 = a * r - u * i, e.m02 = s * r - h * i, e.m03 = c * r - _ * i, e.m08 = o * i + l * r, e.m09 = a * i + u * r, e.m10 = s * i + h * r, e.m11 = c * i + _ * r, e
                    }, t.rotateZ = function(e, t, n) {
                        var i = Math.sin(n),
                            r = Math.cos(n),
                            o = t.m00,
                            a = t.m01,
                            s = t.m02,
                            c = t.m03,
                            l = t.m04,
                            u = t.m05,
                            h = t.m06,
                            _ = t.m07;
                        return t !== e && (e.m08 = t.m08, e.m09 = t.m09, e.m10 = t.m10, e.m11 = t.m11, e.m12 = t.m12, e.m13 = t.m13, e.m14 = t.m14, e.m15 = t.m15), e.m00 = o * r + l * i, e.m01 = a * r + u * i, e.m02 = s * r + h * i, e.m03 = c * r + _ * i, e.m04 = l * r - o * i, e.m05 = u * r - a * i, e.m06 = h * r - s * i, e.m07 = _ * r - c * i, e
                    }, t.fromTranslation = function(e, t) {
                        return e.m00 = 1, e.m01 = 0, e.m02 = 0, e.m03 = 0, e.m04 = 0, e.m05 = 1, e.m06 = 0, e.m07 = 0, e.m08 = 0, e.m09 = 0, e.m10 = 1, e.m11 = 0, e.m12 = t.x, e.m13 = t.y, e.m14 = t.z, e.m15 = 1, e
                    }, t.fromScaling = function(e, t) {
                        return e.m00 = t.x, e.m01 = 0, e.m02 = 0, e.m03 = 0, e.m04 = 0, e.m05 = t.y, e.m06 = 0, e.m07 = 0, e.m08 = 0, e.m09 = 0, e.m10 = t.z, e.m11 = 0, e.m12 = 0, e.m13 = 0, e.m14 = 0, e.m15 = 1, e
                    }, t.fromRotation = function(e, t, n) {
                        var i = n.x,
                            r = n.y,
                            o = n.z,
                            a = Math.sqrt(i * i + r * r + o * o);
                        if (Math.abs(a) < Qt) return null;
                        i *= a = 1 / a, r *= a, o *= a;
                        var s = Math.sin(t),
                            c = Math.cos(t),
                            l = 1 - c;
                        return e.m00 = i * i * l + c, e.m01 = r * i * l + o * s, e.m02 = o * i * l - r * s, e.m03 = 0, e.m04 = i * r * l - o * s, e.m05 = r * r * l + c, e.m06 = o * r * l + i * s, e.m07 = 0, e.m08 = i * o * l + r * s, e.m09 = r * o * l - i * s, e.m10 = o * o * l + c, e.m11 = 0, e.m12 = 0, e.m13 = 0, e.m14 = 0, e.m15 = 1, e
                    }, t.fromXRotation = function(e, t) {
                        var n = Math.sin(t),
                            i = Math.cos(t);
                        return e.m00 = 1, e.m01 = 0, e.m02 = 0, e.m03 = 0, e.m04 = 0, e.m05 = i, e.m06 = n, e.m07 = 0, e.m08 = 0, e.m09 = -n, e.m10 = i, e.m11 = 0, e.m12 = 0, e.m13 = 0, e.m14 = 0, e.m15 = 1, e
                    }, t.fromYRotation = function(e, t) {
                        var n = Math.sin(t),
                            i = Math.cos(t);
                        return e.m00 = i, e.m01 = 0, e.m02 = -n, e.m03 = 0, e.m04 = 0, e.m05 = 1, e.m06 = 0, e.m07 = 0, e.m08 = n, e.m09 = 0, e.m10 = i, e.m11 = 0, e.m12 = 0, e.m13 = 0, e.m14 = 0, e.m15 = 1, e
                    }, t.fromZRotation = function(e, t) {
                        var n = Math.sin(t),
                            i = Math.cos(t);
                        return e.m00 = i, e.m01 = n, e.m02 = 0, e.m03 = 0, e.m04 = -n, e.m05 = i, e.m06 = 0, e.m07 = 0, e.m08 = 0, e.m09 = 0, e.m10 = 1, e.m11 = 0, e.m12 = 0, e.m13 = 0, e.m14 = 0, e.m15 = 1, e
                    }, t.fromRT = function(e, t, n) {
                        var i = t.x,
                            r = t.y,
                            o = t.z,
                            a = t.w,
                            s = i + i,
                            c = r + r,
                            l = o + o,
                            u = i * s,
                            h = i * c,
                            _ = i * l,
                            f = r * c,
                            d = r * l,
                            p = o * l,
                            m = a * s,
                            g = a * c,
                            v = a * l;
                        return e.m00 = 1 - (f + p), e.m01 = h + v, e.m02 = _ - g, e.m03 = 0, e.m04 = h - v, e.m05 = 1 - (u + p), e.m06 = d + m, e.m07 = 0, e.m08 = _ + g, e.m09 = d - m, e.m10 = 1 - (u + f), e.m11 = 0, e.m12 = n.x, e.m13 = n.y, e.m14 = n.z, e.m15 = 1, e
                    }, t.getTranslation = function(e, t) {
                        return e.x = t.m12, e.y = t.m13, e.z = t.m14, e
                    }, t.getScaling = function(e, t) {
                        var n = zn.m00 = t.m00,
                            i = zn.m01 = t.m01,
                            r = zn.m02 = t.m02,
                            o = zn.m03 = t.m04,
                            a = zn.m04 = t.m05,
                            s = zn.m05 = t.m06,
                            c = zn.m06 = t.m08,
                            l = zn.m07 = t.m09,
                            u = zn.m08 = t.m10;
                        return e.x = Math.sqrt(n * n + i * i + r * r), e.y = Math.sqrt(o * o + a * a + s * s), e.z = Math.sqrt(c * c + l * l + u * u), Cn.determinant(zn) < 0 && (e.x *= -1), e
                    }, t.getRotation = function(e, t) {
                        var n = t.m00 + t.m05 + t.m10,
                            i = 0;
                        return n > 0 ? (i = 2 * Math.sqrt(n + 1), e.w = .25 * i, e.x = (t.m06 - t.m09) / i, e.y = (t.m08 - t.m02) / i, e.z = (t.m01 - t.m04) / i) : t.m00 > t.m05 && t.m00 > t.m10 ? (i = 2 * Math.sqrt(1 + t.m00 - t.m05 - t.m10), e.w = (t.m06 - t.m09) / i, e.x = .25 * i, e.y = (t.m01 + t.m04) / i, e.z = (t.m08 + t.m02) / i) : t.m05 > t.m10 ? (i = 2 * Math.sqrt(1 + t.m05 - t.m00 - t.m10), e.w = (t.m08 - t.m02) / i, e.x = (t.m01 + t.m04) / i, e.y = .25 * i, e.z = (t.m06 + t.m09) / i) : (i = 2 * Math.sqrt(1 + t.m10 - t.m00 - t.m05), e.w = (t.m01 - t.m04) / i, e.x = (t.m08 + t.m02) / i, e.y = (t.m06 + t.m09) / i, e.z = .25 * i), e
                    }, t.toRTS = function(e, t, n, i) {
                        i.x = En.set(Fn, e.m00, e.m01, e.m02).length(), zn.m00 = e.m00 / i.x, zn.m01 = e.m01 / i.x, zn.m02 = e.m02 / i.x, i.y = En.set(Fn, e.m04, e.m05, e.m06).length(), zn.m03 = e.m04 / i.y, zn.m04 = e.m05 / i.y, zn.m05 = e.m06 / i.y, i.z = En.set(Fn, e.m08, e.m09, e.m10).length(), zn.m06 = e.m08 / i.z, zn.m07 = e.m09 / i.z, zn.m08 = e.m10 / i.z, Cn.determinant(zn) < 0 && (i.x *= -1, zn.m00 *= -1, zn.m01 *= -1, zn.m02 *= -1), wn.fromMat3(t, zn), En.set(n, e.m12, e.m13, e.m14)
                    }, t.fromRTS = function(e, t, n, i) {
                        var r = t.x,
                            o = t.y,
                            a = t.z,
                            s = t.w,
                            c = r + r,
                            l = o + o,
                            u = a + a,
                            h = r * c,
                            _ = r * l,
                            f = r * u,
                            d = o * l,
                            p = o * u,
                            m = a * u,
                            g = s * c,
                            v = s * l,
                            y = s * u,
                            S = i.x,
                            E = i.y,
                            T = i.z;
                        return e.m00 = (1 - (d + m)) * S, e.m01 = (_ + y) * S, e.m02 = (f - v) * S, e.m03 = 0, e.m04 = (_ - y) * E, e.m05 = (1 - (h + m)) * E, e.m06 = (p + g) * E, e.m07 = 0, e.m08 = (f + v) * T, e.m09 = (p - g) * T, e.m10 = (1 - (h + d)) * T, e.m11 = 0, e.m12 = n.x, e.m13 = n.y, e.m14 = n.z, e.m15 = 1, e
                    }, t.fromRTSOrigin = function(e, t, n, i, r) {
                        var o = t.x,
                            a = t.y,
                            s = t.z,
                            c = t.w,
                            l = o + o,
                            u = a + a,
                            h = s + s,
                            _ = o * l,
                            f = o * u,
                            d = o * h,
                            p = a * u,
                            m = a * h,
                            g = s * h,
                            v = c * l,
                            y = c * u,
                            S = c * h,
                            E = i.x,
                            T = i.y,
                            A = i.z,
                            x = r.x,
                            C = r.y,
                            b = r.z;
                        return e.m00 = (1 - (p + g)) * E, e.m01 = (f + S) * E, e.m02 = (d - y) * E, e.m03 = 0, e.m04 = (f - S) * T, e.m05 = (1 - (_ + g)) * T, e.m06 = (m + v) * T, e.m07 = 0, e.m08 = (d + y) * A, e.m09 = (m - v) * A, e.m10 = (1 - (_ + p)) * A, e.m11 = 0, e.m12 = n.x + x - (e.m00 * x + e.m04 * C + e.m08 * b), e.m13 = n.y + C - (e.m01 * x + e.m05 * C + e.m09 * b), e.m14 = n.z + b - (e.m02 * x + e.m06 * C + e.m10 * b), e.m15 = 1, e
                    }, t.fromQuat = function(e, t) {
                        var n = t.x,
                            i = t.y,
                            r = t.z,
                            o = t.w,
                            a = n + n,
                            s = i + i,
                            c = r + r,
                            l = n * a,
                            u = i * a,
                            h = i * s,
                            _ = r * a,
                            f = r * s,
                            d = r * c,
                            p = o * a,
                            m = o * s,
                            g = o * c;
                        return e.m00 = 1 - h - d, e.m01 = u + g, e.m02 = _ - m, e.m03 = 0, e.m04 = u - g, e.m05 = 1 - l - d, e.m06 = f + p, e.m07 = 0, e.m08 = _ + m, e.m09 = f - p, e.m10 = 1 - l - h, e.m11 = 0, e.m12 = 0, e.m13 = 0, e.m14 = 0, e.m15 = 1, e
                    }, t.frustum = function(e, t, n, i, r, o, a) {
                        var s = 1 / (n - t),
                            c = 1 / (r - i),
                            l = 1 / (o - a);
                        return e.m00 = 2 * o * s, e.m01 = 0, e.m02 = 0, e.m03 = 0, e.m04 = 0, e.m05 = 2 * o * c, e.m06 = 0, e.m07 = 0, e.m08 = (n + t) * s, e.m09 = (r + i) * c, e.m10 = (a + o) * l, e.m11 = -1, e.m12 = 0, e.m13 = 0, e.m14 = a * o * 2 * l, e.m15 = 0, e
                    }, t.perspective = function(e, t, n, i, r, o, a, s, c) {
                        void 0 === o && (o = !0), void 0 === a && (a = -1), void 0 === s && (s = 1), void 0 === c && (c = 0);
                        var l = 1 / Math.tan(t / 2),
                            u = 1 / (i - r),
                            h = o ? l / n : l,
                            _ = (o ? l : l * n) * s,
                            f = Ln[c];
                        return e.m00 = h * f[0], e.m01 = h * f[1], e.m02 = 0, e.m03 = 0, e.m04 = _ * f[2], e.m05 = _ * f[3], e.m06 = 0, e.m07 = 0, e.m08 = 0, e.m09 = 0, e.m10 = (r - a * i) * u, e.m11 = -1, e.m12 = 0, e.m13 = 0, e.m14 = r * i * u * (1 - a), e.m15 = 0, e
                    }, t.ortho = function(e, t, n, i, r, o, a, s, c, l) {
                        void 0 === s && (s = -1), void 0 === c && (c = 1), void 0 === l && (l = 0);
                        var u = 1 / (t - n),
                            h = 1 / (i - r) * c,
                            _ = 1 / (o - a),
                            f = -2 * u,
                            d = -2 * h,
                            p = (t + n) * u,
                            m = (r + i) * h,
                            g = Ln[l];
                        return e.m00 = f * g[0], e.m01 = f * g[1], e.m02 = 0, e.m03 = 0, e.m04 = d * g[2], e.m05 = d * g[3], e.m06 = 0, e.m07 = 0, e.m08 = 0, e.m09 = 0, e.m10 = _ * (1 - s), e.m11 = 0, e.m12 = p * g[0] + m * g[2], e.m13 = p * g[1] + m * g[3], e.m14 = (o - s * a) * _, e.m15 = 1, e
                    }, t.lookAt = function(e, t, n, i) {
                        var r = t.x,
                            o = t.y,
                            a = t.z,
                            s = i.x,
                            c = i.y,
                            l = i.z,
                            u = r - n.x,
                            h = o - n.y,
                            _ = a - n.z,
                            f = 1 / Math.sqrt(u * u + h * h + _ * _),
                            d = c * (_ *= f) - l * (h *= f),
                            p = l * (u *= f) - s * _,
                            m = s * h - c * u,
                            g = h * (m *= f = 1 / Math.sqrt(d * d + p * p + m * m)) - _ * (p *= f),
                            v = _ * (d *= f) - u * m,
                            y = u * p - h * d;
                        return e.m00 = d, e.m01 = g, e.m02 = u, e.m03 = 0, e.m04 = p, e.m05 = v, e.m06 = h, e.m07 = 0, e.m08 = m, e.m09 = y, e.m10 = _, e.m11 = 0, e.m12 = -(d * r + p * o + m * a), e.m13 = -(g * r + v * o + y * a), e.m14 = -(u * r + h * o + _ * a), e.m15 = 1, e
                    }, t.inverseTranspose = function(e, t) {
                        var n = t.m00,
                            i = t.m01,
                            r = t.m02,
                            o = t.m03,
                            a = t.m04,
                            s = t.m05,
                            c = t.m06,
                            l = t.m07,
                            u = t.m08,
                            h = t.m09,
                            _ = t.m10,
                            f = t.m11,
                            d = t.m12,
                            p = t.m13,
                            m = t.m14,
                            g = t.m15,
                            v = n * s - i * a,
                            y = n * c - r * a,
                            S = n * l - o * a,
                            E = i * c - r * s,
                            T = i * l - o * s,
                            A = r * l - o * c,
                            x = u * p - h * d,
                            C = u * m - _ * d,
                            b = u * g - f * d,
                            R = h * m - _ * p,
                            w = h * g - f * p,
                            I = _ * g - f * m,
                            P = v * I - y * w + S * R + E * b - T * C + A * x;
                        return P ? (P = 1 / P, e.m00 = (s * I - c * w + l * R) * P, e.m01 = (c * b - a * I - l * C) * P, e.m02 = (a * w - s * b + l * x) * P, e.m03 = 0, e.m04 = (r * w - i * I - o * R) * P, e.m05 = (n * I - r * b + o * C) * P, e.m06 = (i * b - n * w - o * x) * P, e.m07 = 0, e.m08 = (p * A - m * T + g * E) * P, e.m09 = (m * S - d * A - g * y) * P, e.m10 = (d * T - p * S + g * v) * P, e.m11 = 0, e.m12 = 0, e.m13 = 0, e.m14 = 0, e.m15 = 1, e) : null
                    }, t.toArray = function(e, t, n) {
                        return void 0 === n && (n = 0), e[n + 0] = t.m00, e[n + 1] = t.m01, e[n + 2] = t.m02, e[n + 3] = t.m03, e[n + 4] = t.m04, e[n + 5] = t.m05, e[n + 6] = t.m06, e[n + 7] = t.m07, e[n + 8] = t.m08, e[n + 9] = t.m09, e[n + 10] = t.m10, e[n + 11] = t.m11, e[n + 12] = t.m12, e[n + 13] = t.m13, e[n + 14] = t.m14, e[n + 15] = t.m15, e
                    }, t.fromArray = function(e, t, n) {
                        return void 0 === n && (n = 0), e.m00 = t[n + 0], e.m01 = t[n + 1], e.m02 = t[n + 2], e.m03 = t[n + 3], e.m04 = t[n + 4], e.m05 = t[n + 5], e.m06 = t[n + 6], e.m07 = t[n + 7], e.m08 = t[n + 8], e.m09 = t[n + 9], e.m10 = t[n + 10], e.m11 = t[n + 11], e.m12 = t[n + 12], e.m13 = t[n + 13], e.m14 = t[n + 14], e.m15 = t[n + 15], e
                    }, t.add = function(e, t, n) {
                        return e.m00 = t.m00 + n.m00, e.m01 = t.m01 + n.m01, e.m02 = t.m02 + n.m02, e.m03 = t.m03 + n.m03, e.m04 = t.m04 + n.m04, e.m05 = t.m05 + n.m05, e.m06 = t.m06 + n.m06, e.m07 = t.m07 + n.m07, e.m08 = t.m08 + n.m08, e.m09 = t.m09 + n.m09, e.m10 = t.m10 + n.m10, e.m11 = t.m11 + n.m11, e.m12 = t.m12 + n.m12, e.m13 = t.m13 + n.m13, e.m14 = t.m14 + n.m14, e.m15 = t.m15 + n.m15, e
                    }, t.subtract = function(e, t, n) {
                        return e.m00 = t.m00 - n.m00, e.m01 = t.m01 - n.m01, e.m02 = t.m02 - n.m02, e.m03 = t.m03 - n.m03, e.m04 = t.m04 - n.m04, e.m05 = t.m05 - n.m05, e.m06 = t.m06 - n.m06, e.m07 = t.m07 - n.m07, e.m08 = t.m08 - n.m08, e.m09 = t.m09 - n.m09, e.m10 = t.m10 - n.m10, e.m11 = t.m11 - n.m11, e.m12 = t.m12 - n.m12, e.m13 = t.m13 - n.m13, e.m14 = t.m14 - n.m14, e.m15 = t.m15 - n.m15, e
                    }, t.multiplyScalar = function(e, t, n) {
                        return e.m00 = t.m00 * n, e.m01 = t.m01 * n, e.m02 = t.m02 * n, e.m03 = t.m03 * n, e.m04 = t.m04 * n, e.m05 = t.m05 * n, e.m06 = t.m06 * n, e.m07 = t.m07 * n, e.m08 = t.m08 * n, e.m09 = t.m09 * n, e.m10 = t.m10 * n, e.m11 = t.m11 * n, e.m12 = t.m12 * n, e.m13 = t.m13 * n, e.m14 = t.m14 * n, e.m15 = t.m15 * n, e
                    }, t.multiplyScalarAndAdd = function(e, t, n, i) {
                        return e.m00 = t.m00 + n.m00 * i, e.m01 = t.m01 + n.m01 * i, e.m02 = t.m02 + n.m02 * i, e.m03 = t.m03 + n.m03 * i, e.m04 = t.m04 + n.m04 * i, e.m05 = t.m05 + n.m05 * i, e.m06 = t.m06 + n.m06 * i, e.m07 = t.m07 + n.m07 * i, e.m08 = t.m08 + n.m08 * i, e.m09 = t.m09 + n.m09 * i, e.m10 = t.m10 + n.m10 * i, e.m11 = t.m11 + n.m11 * i, e.m12 = t.m12 + n.m12 * i, e.m13 = t.m13 + n.m13 * i, e.m14 = t.m14 + n.m14 * i, e.m15 = t.m15 + n.m15 * i, e
                    }, t.strictEquals = function(e, t) {
                        return e.m00 === t.m00 && e.m01 === t.m01 && e.m02 === t.m02 && e.m03 === t.m03 && e.m04 === t.m04 && e.m05 === t.m05 && e.m06 === t.m06 && e.m07 === t.m07 && e.m08 === t.m08 && e.m09 === t.m09 && e.m10 === t.m10 && e.m11 === t.m11 && e.m12 === t.m12 && e.m13 === t.m13 && e.m14 === t.m14 && e.m15 === t.m15
                    }, t.equals = function(e, t, n) {
                        return void 0 === n && (n = Qt), Math.abs(e.m00 - t.m00) <= n * Math.max(1, Math.abs(e.m00), Math.abs(t.m00)) && Math.abs(e.m01 - t.m01) <= n * Math.max(1, Math.abs(e.m01), Math.abs(t.m01)) && Math.abs(e.m02 - t.m02) <= n * Math.max(1, Math.abs(e.m02), Math.abs(t.m02)) && Math.abs(e.m03 - t.m03) <= n * Math.max(1, Math.abs(e.m03), Math.abs(t.m03)) && Math.abs(e.m04 - t.m04) <= n * Math.max(1, Math.abs(e.m04), Math.abs(t.m04)) && Math.abs(e.m05 - t.m05) <= n * Math.max(1, Math.abs(e.m05), Math.abs(t.m05)) && Math.abs(e.m06 - t.m06) <= n * Math.max(1, Math.abs(e.m06), Math.abs(t.m06)) && Math.abs(e.m07 - t.m07) <= n * Math.max(1, Math.abs(e.m07), Math.abs(t.m07)) && Math.abs(e.m08 - t.m08) <= n * Math.max(1, Math.abs(e.m08), Math.abs(t.m08)) && Math.abs(e.m09 - t.m09) <= n * Math.max(1, Math.abs(e.m09), Math.abs(t.m09)) && Math.abs(e.m10 - t.m10) <= n * Math.max(1, Math.abs(e.m10), Math.abs(t.m10)) && Math.abs(e.m11 - t.m11) <= n * Math.max(1, Math.abs(e.m11), Math.abs(t.m11)) && Math.abs(e.m12 - t.m12) <= n * Math.max(1, Math.abs(e.m12), Math.abs(t.m12)) && Math.abs(e.m13 - t.m13) <= n * Math.max(1, Math.abs(e.m13), Math.abs(t.m13)) && Math.abs(e.m14 - t.m14) <= n * Math.max(1, Math.abs(e.m14), Math.abs(t.m14)) && Math.abs(e.m15 - t.m15) <= n * Math.max(1, Math.abs(e.m15), Math.abs(t.m15))
                    };
                    var n = t.prototype;
                    return n.clone = function() {
                        return new t(this.m00, this.m01, this.m02, this.m03, this.m04, this.m05, this.m06, this.m07, this.m08, this.m09, this.m10, this.m11, this.m12, this.m13, this.m14, this.m15)
                    }, n.set = function(e, t, n, i, r, o, a, s, c, l, u, h, _, f, d, p) {
                        return void 0 === e && (e = 1), void 0 === t && (t = 0), void 0 === n && (n = 0), void 0 === i && (i = 0), void 0 === r && (r = 0), void 0 === o && (o = 1), void 0 === a && (a = 0), void 0 === s && (s = 0), void 0 === c && (c = 0), void 0 === l && (l = 0), void 0 === u && (u = 1), void 0 === h && (h = 0), void 0 === _ && (_ = 0), void 0 === f && (f = 0), void 0 === d && (d = 0), void 0 === p && (p = 1), "object" == typeof e ? (this.m01 = e.m01, this.m02 = e.m02, this.m03 = e.m03, this.m04 = e.m04, this.m05 = e.m05, this.m06 = e.m06, this.m07 = e.m07, this.m08 = e.m08, this.m09 = e.m09, this.m10 = e.m10, this.m11 = e.m11, this.m12 = e.m12, this.m13 = e.m13, this.m14 = e.m14, this.m15 = e.m15, this.m00 = e.m00) : (this.m01 = t, this.m02 = n, this.m03 = i, this.m04 = r, this.m05 = o, this.m06 = a, this.m07 = s, this.m08 = c, this.m09 = l, this.m10 = u, this.m11 = h, this.m12 = _, this.m13 = f, this.m14 = d, this.m15 = p, this.m00 = e), this
                    }, n.equals = function(e, t) {
                        return void 0 === t && (t = Qt), Math.abs(this.m00 - e.m00) <= t * Math.max(1, Math.abs(this.m00), Math.abs(e.m00)) && Math.abs(this.m01 - e.m01) <= t * Math.max(1, Math.abs(this.m01), Math.abs(e.m01)) && Math.abs(this.m02 - e.m02) <= t * Math.max(1, Math.abs(this.m02), Math.abs(e.m02)) && Math.abs(this.m03 - e.m03) <= t * Math.max(1, Math.abs(this.m03), Math.abs(e.m03)) && Math.abs(this.m04 - e.m04) <= t * Math.max(1, Math.abs(this.m04), Math.abs(e.m04)) && Math.abs(this.m05 - e.m05) <= t * Math.max(1, Math.abs(this.m05), Math.abs(e.m05)) && Math.abs(this.m06 - e.m06) <= t * Math.max(1, Math.abs(this.m06), Math.abs(e.m06)) && Math.abs(this.m07 - e.m07) <= t * Math.max(1, Math.abs(this.m07), Math.abs(e.m07)) && Math.abs(this.m08 - e.m08) <= t * Math.max(1, Math.abs(this.m08), Math.abs(e.m08)) && Math.abs(this.m09 - e.m09) <= t * Math.max(1, Math.abs(this.m09), Math.abs(e.m09)) && Math.abs(this.m10 - e.m10) <= t * Math.max(1, Math.abs(this.m10), Math.abs(e.m10)) && Math.abs(this.m11 - e.m11) <= t * Math.max(1, Math.abs(this.m11), Math.abs(e.m11)) && Math.abs(this.m12 - e.m12) <= t * Math.max(1, Math.abs(this.m12), Math.abs(e.m12)) && Math.abs(this.m13 - e.m13) <= t * Math.max(1, Math.abs(this.m13), Math.abs(e.m13)) && Math.abs(this.m14 - e.m14) <= t * Math.max(1, Math.abs(this.m14), Math.abs(e.m14)) && Math.abs(this.m15 - e.m15) <= t * Math.max(1, Math.abs(this.m15), Math.abs(e.m15))
                    }, n.strictEquals = function(e) {
                        return this.m00 === e.m00 && this.m01 === e.m01 && this.m02 === e.m02 && this.m03 === e.m03 && this.m04 === e.m04 && this.m05 === e.m05 && this.m06 === e.m06 && this.m07 === e.m07 && this.m08 === e.m08 && this.m09 === e.m09 && this.m10 === e.m10 && this.m11 === e.m11 && this.m12 === e.m12 && this.m13 === e.m13 && this.m14 === e.m14 && this.m15 === e.m15
                    }, n.toString = function() {
                        return "[\n" + this.m00 + ", " + this.m01 + ", " + this.m02 + ", " + this.m03 + ",\n" + this.m04 + ", " + this.m05 + ", " + this.m06 + ", " + this.m07 + ",\n" + this.m08 + ", " + this.m09 + ", " + this.m10 + ", " + this.m11 + ",\n" + this.m12 + ", " + this.m13 + ", " + this.m14 + ", " + this.m15 + "\n]"
                    }, n.identity = function() {
                        return this.m00 = 1, this.m01 = 0, this.m02 = 0, this.m03 = 0, this.m04 = 0, this.m05 = 1, this.m06 = 0, this.m07 = 0, this.m08 = 0, this.m09 = 0, this.m10 = 1, this.m11 = 0, this.m12 = 0, this.m13 = 0, this.m14 = 0, this.m15 = 1, this
                    }, n.zero = function() {
                        return this.m00 = 0, this.m01 = 0, this.m02 = 0, this.m03 = 0, this.m04 = 0, this.m05 = 0, this.m06 = 0, this.m07 = 0, this.m08 = 0, this.m09 = 0, this.m10 = 0, this.m11 = 0, this.m12 = 0, this.m13 = 0, this.m14 = 0, this.m15 = 0, this
                    }, n.transpose = function() {
                        var e = this.m01,
                            t = this.m02,
                            n = this.m03,
                            i = this.m06,
                            r = this.m07,
                            o = this.m11;
                        return this.m01 = this.m04, this.m02 = this.m08, this.m03 = this.m12, this.m04 = e, this.m06 = this.m09, this.m07 = this.m13, this.m08 = t, this.m09 = i, this.m11 = this.m14, this.m12 = n, this.m13 = r, this.m14 = o, this
                    }, n.invert = function() {
                        var e = this.m00,
                            t = this.m01,
                            n = this.m02,
                            i = this.m03,
                            r = this.m04,
                            o = this.m05,
                            a = this.m06,
                            s = this.m07,
                            c = this.m08,
                            l = this.m09,
                            u = this.m10,
                            h = this.m11,
                            _ = this.m12,
                            f = this.m13,
                            d = this.m14,
                            p = this.m15,
                            m = e * o - t * r,
                            g = e * a - n * r,
                            v = e * s - i * r,
                            y = t * a - n * o,
                            S = t * s - i * o,
                            E = n * s - i * a,
                            T = c * f - l * _,
                            A = c * d - u * _,
                            x = c * p - h * _,
                            C = l * d - u * f,
                            b = l * p - h * f,
                            R = u * p - h * d,
                            w = m * R - g * b + v * C + y * x - S * A + E * T;
                        return 0 === w ? (this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0), this) : (w = 1 / w, this.m00 = (o * R - a * b + s * C) * w, this.m01 = (n * b - t * R - i * C) * w, this.m02 = (f * E - d * S + p * y) * w, this.m03 = (u * S - l * E - h * y) * w, this.m04 = (a * x - r * R - s * A) * w, this.m05 = (e * R - n * x + i * A) * w, this.m06 = (d * v - _ * E - p * g) * w, this.m07 = (c * E - u * v + h * g) * w, this.m08 = (r * b - o * x + s * T) * w, this.m09 = (t * x - e * b - i * T) * w, this.m10 = (_ * S - f * v + p * m) * w, this.m11 = (l * v - c * S - h * m) * w, this.m12 = (o * A - r * C - a * T) * w, this.m13 = (e * C - t * A + n * T) * w, this.m14 = (f * g - _ * y - d * m) * w, this.m15 = (c * y - l * g + u * m) * w, this)
                    }, n.determinant = function() {
                        var e = this.m00,
                            t = this.m01,
                            n = this.m02,
                            i = this.m03,
                            r = this.m04,
                            o = this.m05,
                            a = this.m06,
                            s = this.m07,
                            c = this.m08,
                            l = this.m09,
                            u = this.m10,
                            h = this.m11,
                            _ = this.m12,
                            f = this.m13,
                            d = this.m14,
                            p = this.m15;
                        return (e * o - t * r) * (u * p - h * d) - (e * a - n * r) * (l * p - h * f) + (e * s - i * r) * (l * d - u * f) + (t * a - n * o) * (c * p - h * _) - (t * s - i * o) * (c * d - u * _) + (n * s - i * a) * (c * f - l * _)
                    }, n.add = function(e) {
                        return this.m00 += e.m00, this.m01 += e.m01, this.m02 += e.m02, this.m03 += e.m03, this.m04 += e.m04, this.m05 += e.m05, this.m06 += e.m06, this.m07 += e.m07, this.m08 += e.m08, this.m09 += e.m09, this.m10 += e.m10, this.m11 += e.m11, this.m12 += e.m12, this.m13 += e.m13, this.m14 += e.m14, this.m15 += e.m15, this
                    }, n.subtract = function(e) {
                        return this.m00 -= e.m00, this.m01 -= e.m01, this.m02 -= e.m02, this.m03 -= e.m03, this.m04 -= e.m04, this.m05 -= e.m05, this.m06 -= e.m06, this.m07 -= e.m07, this.m08 -= e.m08, this.m09 -= e.m09, this.m10 -= e.m10, this.m11 -= e.m11, this.m12 -= e.m12, this.m13 -= e.m13, this.m14 -= e.m14, this.m15 -= e.m15, this
                    }, n.multiply = function(e) {
                        var t = this.m00,
                            n = this.m01,
                            i = this.m02,
                            r = this.m03,
                            o = this.m04,
                            a = this.m05,
                            s = this.m06,
                            c = this.m07,
                            l = this.m08,
                            u = this.m09,
                            h = this.m10,
                            _ = this.m11,
                            f = this.m12,
                            d = this.m13,
                            p = this.m14,
                            m = this.m15,
                            g = e.m00,
                            v = e.m01,
                            y = e.m02,
                            S = e.m03;
                        return this.m00 = g * t + v * o + y * l + S * f, this.m01 = g * n + v * a + y * u + S * d, this.m02 = g * i + v * s + y * h + S * p, this.m03 = g * r + v * c + y * _ + S * m, g = e.m04, v = e.m05, y = e.m06, S = e.m07, this.m04 = g * t + v * o + y * l + S * f, this.m05 = g * n + v * a + y * u + S * d, this.m06 = g * i + v * s + y * h + S * p, this.m07 = g * r + v * c + y * _ + S * m, g = e.m08, v = e.m09, y = e.m10, S = e.m11, this.m08 = g * t + v * o + y * l + S * f, this.m09 = g * n + v * a + y * u + S * d, this.m10 = g * i + v * s + y * h + S * p, this.m11 = g * r + v * c + y * _ + S * m, g = e.m12, v = e.m13, y = e.m14, S = e.m15, this.m12 = g * t + v * o + y * l + S * f, this.m13 = g * n + v * a + y * u + S * d, this.m14 = g * i + v * s + y * h + S * p, this.m15 = g * r + v * c + y * _ + S * m, this
                    }, n.multiplyScalar = function(e) {
                        return this.m00 *= e, this.m01 *= e, this.m02 *= e, this.m03 *= e, this.m04 *= e, this.m05 *= e, this.m06 *= e, this.m07 *= e, this.m08 *= e, this.m09 *= e, this.m10 *= e, this.m11 *= e, this.m12 *= e, this.m13 *= e, this.m14 *= e, this.m15 *= e, this
                    }, n.translate = function(e) {
                        return console.warn("function changed"), this.m12 += e.x, this.m13 += e.y, this.m14 += e.z, this
                    }, n.scale = function(e) {
                        var t = e.x,
                            n = e.y,
                            i = e.z;
                        return this.m00 *= t, this.m01 *= t, this.m02 *= t, this.m03 *= t, this.m04 *= n, this.m05 *= n, this.m06 *= n, this.m07 *= n, this.m08 *= i, this.m09 *= i, this.m10 *= i, this.m11 *= i, this
                    }, n.rotate = function(e, t) {
                        var n = t.x,
                            i = t.y,
                            r = t.z,
                            o = Math.sqrt(n * n + i * i + r * r);
                        if (Math.abs(o) < Qt) return null;
                        n *= o = 1 / o, i *= o, r *= o;
                        var a = Math.sin(e),
                            s = Math.cos(e),
                            c = 1 - s,
                            l = this.m00,
                            u = this.m01,
                            h = this.m02,
                            _ = this.m03,
                            f = this.m04,
                            d = this.m05,
                            p = this.m06,
                            m = this.m07,
                            g = this.m08,
                            v = this.m09,
                            y = this.m10,
                            S = this.m11,
                            E = n * n * c + s,
                            T = i * n * c + r * a,
                            A = r * n * c - i * a,
                            x = n * i * c - r * a,
                            C = i * i * c + s,
                            b = r * i * c + n * a,
                            R = n * r * c + i * a,
                            w = i * r * c - n * a,
                            I = r * r * c + s;
                        return this.m00 = l * E + f * T + g * A, this.m01 = u * E + d * T + v * A, this.m02 = h * E + p * T + y * A, this.m03 = _ * E + m * T + S * A, this.m04 = l * x + f * C + g * b, this.m05 = u * x + d * C + v * b, this.m06 = h * x + p * C + y * b, this.m07 = _ * x + m * C + S * b, this.m08 = l * R + f * w + g * I, this.m09 = u * R + d * w + v * I, this.m10 = h * R + p * w + y * I, this.m11 = _ * R + m * w + S * I, this
                    }, n.getTranslation = function(e) {
                        return e.x = this.m12, e.y = this.m13, e.z = this.m14, e
                    }, n.getScale = function(e) {
                        var t = zn.m00 = this.m00,
                            n = zn.m01 = this.m01,
                            i = zn.m02 = this.m02,
                            r = zn.m03 = this.m04,
                            o = zn.m04 = this.m05,
                            a = zn.m05 = this.m06,
                            s = zn.m06 = this.m08,
                            c = zn.m07 = this.m09,
                            l = zn.m08 = this.m10;
                        return e.x = Math.sqrt(t * t + n * n + i * i), e.y = Math.sqrt(r * r + o * o + a * a), e.z = Math.sqrt(s * s + c * c + l * l), Cn.determinant(zn) < 0 && (e.x *= -1), e
                    }, n.getRotation = function(e) {
                        var t = this.m00 + this.m05 + this.m10,
                            n = 0;
                        return t > 0 ? (n = 2 * Math.sqrt(t + 1), e.w = .25 * n, e.x = (this.m06 - this.m09) / n, e.y = (this.m08 - this.m02) / n, e.z = (this.m01 - this.m04) / n) : this.m00 > this.m05 && this.m00 > this.m10 ? (n = 2 * Math.sqrt(1 + this.m00 - this.m05 - this.m10), e.w = (this.m06 - this.m09) / n, e.x = .25 * n, e.y = (this.m01 + this.m04) / n, e.z = (this.m08 + this.m02) / n) : this.m05 > this.m10 ? (n = 2 * Math.sqrt(1 + this.m05 - this.m00 - this.m10), e.w = (this.m08 - this.m02) / n, e.x = (this.m01 + this.m04) / n, e.y = .25 * n, e.z = (this.m06 + this.m09) / n) : (n = 2 * Math.sqrt(1 + this.m10 - this.m00 - this.m05), e.w = (this.m01 - this.m04) / n, e.x = (this.m08 + this.m02) / n, e.y = (this.m06 + this.m09) / n, e.z = .25 * n), e
                    }, n.fromRTS = function(e, t, n) {
                        var i = e.x,
                            r = e.y,
                            o = e.z,
                            a = e.w,
                            s = i + i,
                            c = r + r,
                            l = o + o,
                            u = i * s,
                            h = i * c,
                            _ = i * l,
                            f = r * c,
                            d = r * l,
                            p = o * l,
                            m = a * s,
                            g = a * c,
                            v = a * l,
                            y = n.x,
                            S = n.y,
                            E = n.z;
                        return this.m00 = (1 - (f + p)) * y, this.m01 = (h + v) * y, this.m02 = (_ - g) * y, this.m03 = 0, this.m04 = (h - v) * S, this.m05 = (1 - (u + p)) * S, this.m06 = (d + m) * S, this.m07 = 0, this.m08 = (_ + g) * E, this.m09 = (d - m) * E, this.m10 = (1 - (u + f)) * E, this.m11 = 0, this.m12 = t.x, this.m13 = t.y, this.m14 = t.z, this.m15 = 1, this
                    }, n.fromQuat = function(e) {
                        var t = e.x,
                            n = e.y,
                            i = e.z,
                            r = e.w,
                            o = t + t,
                            a = n + n,
                            s = i + i,
                            c = t * o,
                            l = n * o,
                            u = n * a,
                            h = i * o,
                            _ = i * a,
                            f = i * s,
                            d = r * o,
                            p = r * a,
                            m = r * s;
                        return this.m00 = 1 - u - f, this.m01 = l + m, this.m02 = h - p, this.m03 = 0, this.m04 = l - m, this.m05 = 1 - c - f, this.m06 = _ + d, this.m07 = 0, this.m08 = h + p, this.m09 = _ - d, this.m10 = 1 - c - u, this.m11 = 0, this.m12 = 0, this.m13 = 0, this.m14 = 0, this.m15 = 1, this
                    }, t
                }(it));
            Bn.IDENTITY = Object.freeze(new Bn);
            var Fn = new En,
                zn = new Cn;

            function Un(e, t, n, i, r, o, a, s, c, l, u, h, _, f, d, p) {
                return new Bn(e, t, n, i, r, o, a, s, c, l, u, h, _, f, d, p)
            }
            qt.fastDefine("cc.Mat4", Bn, {
                m00: 1,
                m01: 0,
                m02: 0,
                m03: 0,
                m04: 0,
                m05: 1,
                m06: 0,
                m07: 0,
                m08: 0,
                m09: 0,
                m10: 1,
                m11: 0,
                m12: 0,
                m13: 0,
                m14: 0,
                m15: 1
            }), i.Mat4 = Bn, i.mat4 = Un;
            var Gn = e("Vec2", function(e) {
                function t(t, n) {
                    var i;
                    return i = e.call(this) || this, t && "object" == typeof t ? (i.x = t.x, i.y = t.y) : (i.x = t || 0, i.y = n || 0), i
                }
                Q(t, e), t.clone = function(e) {
                    return new t(e.x, e.y)
                }, t.copy = function(e, t) {
                    return e.x = t.x, e.y = t.y, e
                }, t.set = function(e, t, n) {
                    return e.x = t, e.y = n, e
                }, t.add = function(e, t, n) {
                    return e.x = t.x + n.x, e.y = t.y + n.y, e
                }, t.subtract = function(e, t, n) {
                    return e.x = t.x - n.x, e.y = t.y - n.y, e
                }, t.multiply = function(e, t, n) {
                    return e.x = t.x * n.x, e.y = t.y * n.y, e
                }, t.divide = function(e, t, n) {
                    return e.x = t.x / n.x, e.y = t.y / n.y, e
                }, t.ceil = function(e, t) {
                    return e.x = Math.ceil(t.x), e.y = Math.ceil(t.y), e
                }, t.floor = function(e, t) {
                    return e.x = Math.floor(t.x), e.y = Math.floor(t.y), e
                }, t.min = function(e, t, n) {
                    return e.x = Math.min(t.x, n.x), e.y = Math.min(t.y, n.y), e
                }, t.max = function(e, t, n) {
                    return e.x = Math.max(t.x, n.x), e.y = Math.max(t.y, n.y), e
                }, t.round = function(e, t) {
                    return e.x = Math.round(t.x), e.y = Math.round(t.y), e
                }, t.multiplyScalar = function(e, t, n) {
                    return e.x = t.x * n, e.y = t.y * n, e
                }, t.scaleAndAdd = function(e, t, n, i) {
                    return e.x = t.x + n.x * i, e.y = t.y + n.y * i, e
                }, t.distance = function(e, t) {
                    var n = t.x - e.x,
                        i = t.y - e.y;
                    return Math.sqrt(n * n + i * i)
                }, t.squaredDistance = function(e, t) {
                    var n = t.x - e.x,
                        i = t.y - e.y;
                    return n * n + i * i
                }, t.len = function(e) {
                    var t = e.x,
                        n = e.y;
                    return Math.sqrt(t * t + n * n)
                }, t.lengthSqr = function(e) {
                    var t = e.x,
                        n = e.y;
                    return t * t + n * n
                }, t.negate = function(e, t) {
                    return e.x = -t.x, e.y = -t.y, e
                }, t.inverse = function(e, t) {
                    return e.x = 1 / t.x, e.y = 1 / t.y, e
                }, t.inverseSafe = function(e, t) {
                    var n = t.x,
                        i = t.y;
                    return Math.abs(n) < Qt ? e.x = 0 : e.x = 1 / n, Math.abs(i) < Qt ? e.y = 0 : e.y = 1 / i, e
                }, t.normalize = function(e, t) {
                    var n = t.x,
                        i = t.y,
                        r = n * n + i * i;
                    return r > 0 && (r = 1 / Math.sqrt(r), e.x = n * r, e.y = i * r), e
                }, t.dot = function(e, t) {
                    return e.x * t.x + e.y * t.y
                }, t.cross = function(e, t, n) {
                    return e.x = e.y = 0, e.z = t.x * n.y - t.y * n.x, e
                }, t.lerp = function(e, t, n, i) {
                    var r = t.x,
                        o = t.y;
                    return e.x = r + i * (n.x - r), e.y = o + i * (n.y - o), e
                }, t.random = function(e, t) {
                    t = t || 1;
                    var n = 2 * an() * Math.PI;
                    return e.x = Math.cos(n) * t, e.y = Math.sin(n) * t, e
                }, t.transformMat3 = function(e, t, n) {
                    var i = t.x,
                        r = t.y;
                    return e.x = n.m00 * i + n.m03 * r + n.m06, e.y = n.m01 * i + n.m04 * r + n.m07, e
                }, t.transformMat4 = function(e, t, n) {
                    var i = t.x,
                        r = t.y;
                    return e.x = n.m00 * i + n.m04 * r + n.m12, e.y = n.m01 * i + n.m05 * r + n.m13, e
                }, t.str = function(e) {
                    return "Vec2(" + e.x + ", " + e.y + ")"
                }, t.toArray = function(e, t, n) {
                    return void 0 === n && (n = 0), e[n + 0] = t.x, e[n + 1] = t.y, e
                }, t.fromArray = function(e, t, n) {
                    return void 0 === n && (n = 0), e.x = t[n + 0], e.y = t[n + 1], e
                }, t.strictEquals = function(e, t) {
                    return e.x === t.x && e.y === t.y
                }, t.equals = function(e, t, n) {
                    return void 0 === n && (n = Qt), Math.abs(e.x - t.x) <= n * Math.max(1, Math.abs(e.x), Math.abs(t.x)) && Math.abs(e.y - t.y) <= n * Math.max(1, Math.abs(e.y), Math.abs(t.y))
                }, t.angle = function(e, n) {
                    t.normalize(Hn, e), t.normalize(kn, n);
                    var i = t.dot(Hn, kn);
                    return i > 1 ? 0 : i < -1 ? Math.PI : Math.acos(i)
                };
                var n = t.prototype;
                return n.clone = function() {
                    return new t(this.x, this.y)
                }, n.set = function(e, t) {
                    return e && "object" == typeof e ? (this.x = e.x, this.y = e.y) : (this.x = e || 0, this.y = t || 0), this
                }, n.equals = function(e, t) {
                    return void 0 === t && (t = Qt), Math.abs(this.x - e.x) <= t * Math.max(1, Math.abs(this.x), Math.abs(e.x)) && Math.abs(this.y - e.y) <= t * Math.max(1, Math.abs(this.y), Math.abs(e.y))
                }, n.equals2f = function(e, t, n) {
                    return void 0 === n && (n = Qt), Math.abs(this.x - e) <= n * Math.max(1, Math.abs(this.x), Math.abs(e)) && Math.abs(this.y - t) <= n * Math.max(1, Math.abs(this.y), Math.abs(t))
                }, n.strictEquals = function(e) {
                    return e && this.x === e.x && this.y === e.y
                }, n.strictEquals2f = function(e, t) {
                    return this.x === e && this.y === t
                }, n.toString = function() {
                    return "(" + this.x.toFixed(2) + ", " + this.y.toFixed(2) + ")"
                }, n.lerp = function(e, t) {
                    var n = this.x,
                        i = this.y;
                    return this.x = n + t * (e.x - n), this.y = i + t * (e.y - i), this
                }, n.clampf = function(e, t) {
                    return this.x = en(this.x, e.x, t.x), this.y = en(this.y, e.y, t.y), this
                }, n.add = function(e) {
                    return this.x += e.x, this.y += e.y, this
                }, n.add2f = function(e, t) {
                    return this.x += e, this.y += t, this
                }, n.subtract = function(e) {
                    return this.x -= e.x, this.y -= e.y, this
                }, n.subtract2f = function(e, t) {
                    return this.x -= e, this.y -= t, this
                }, n.multiplyScalar = function(e) {
                    return "object" == typeof e && console.warn("should use Vec2.multiply for vector * vector operation"), this.x *= e, this.y *= e, this
                }, n.multiply = function(e) {
                    return "object" != typeof e && console.warn("should use Vec2.scale for vector * scalar operation"), this.x *= e.x, this.y *= e.y, this
                }, n.multiply2f = function(e, t) {
                    return this.x *= e, this.y *= t, this
                }, n.divide = function(e) {
                    return this.x /= e.x, this.y /= e.y, this
                }, n.divide2f = function(e, t) {
                    return this.x /= e, this.y /= t, this
                }, n.negative = function() {
                    return this.x = -this.x, this.y = -this.y, this
                }, n.dot = function(e) {
                    return this.x * e.x + this.y * e.y
                }, n.cross = function(e) {
                    return this.x * e.y - this.y * e.x
                }, n.length = function() {
                    return Math.sqrt(this.x * this.x + this.y * this.y)
                }, n.lengthSqr = function() {
                    return this.x * this.x + this.y * this.y
                }, n.normalize = function() {
                    var e = this.x,
                        t = this.y,
                        n = e * e + t * t;
                    return n > 0 && (n = 1 / Math.sqrt(n), this.x *= n, this.y *= n), this
                }, n.angle = function(e) {
                    var t = this.lengthSqr(),
                        n = e.lengthSqr();
                    if (0 === t || 0 === n) return console.warn("Can't get angle between zero vector"), 0;
                    var i = this.dot(e) / Math.sqrt(t * n);
                    return i = en(i, -1, 1), Math.acos(i)
                }, n.signAngle = function(e) {
                    var t = this.angle(e);
                    return this.cross(e) < 0 ? -t : t
                }, n.rotate = function(e) {
                    var t = this.x,
                        n = this.y,
                        i = Math.sin(e),
                        r = Math.cos(e);
                    return this.x = r * t - i * n, this.y = i * t + r * n, this
                }, n.project = function(e) {
                    var t = this.dot(e) / e.dot(e);
                    return this.x = e.x * t, this.y = e.y * t, this
                }, n.transformMat4 = function(e) {
                    var t = this.x,
                        n = this.y;
                    return this.x = e.m00 * t + e.m04 * n + e.m12, this.y = e.m01 * t + e.m05 * n + e.m13, this
                }, t
            }(it));
            Gn.ZERO = Object.freeze(new Gn(0, 0)), Gn.ONE = Object.freeze(new Gn(1, 1)), Gn.NEG_ONE = Object.freeze(new Gn(-1, -1)), Gn.UNIT_X = Object.freeze(new Gn(1, 0)), Gn.UNIT_Y = Object.freeze(new Gn(0, 1));
            var Hn = new Gn,
                kn = new Gn;

            function Vn(e, t) {
                return new Gn(e, t)
            }
            qt.fastDefine("cc.Vec2", Gn, {
                x: 0,
                y: 0
            }), i.Vec2 = Gn, i.v2 = Vn;
            var Wn = e("Vec4", function(e) {
                function t(t, n, i, r) {
                    var o;
                    return o = e.call(this) || this, t && "object" == typeof t ? (o.x = t.x, o.y = t.y, o.z = t.z, o.w = t.w) : (o.x = t || 0, o.y = n || 0, o.z = i || 0, o.w = r || 0), o
                }
                Q(t, e), t.clone = function(e) {
                    return new t(e.x, e.y, e.z, e.w)
                }, t.copy = function(e, t) {
                    return e.x = t.x, e.y = t.y, e.z = t.z, e.w = t.w, e
                }, t.set = function(e, t, n, i, r) {
                    return e.x = t, e.y = n, e.z = i, e.w = r, e
                }, t.add = function(e, t, n) {
                    return e.x = t.x + n.x, e.y = t.y + n.y, e.z = t.z + n.z, e.w = t.w + n.w, e
                }, t.subtract = function(e, t, n) {
                    return e.x = t.x - n.x, e.y = t.y - n.y, e.z = t.z - n.z, e.w = t.w - n.w, e
                }, t.multiply = function(e, t, n) {
                    return e.x = t.x * n.x, e.y = t.y * n.y, e.z = t.z * n.z, e.w = t.w * n.w, e
                }, t.divide = function(e, t, n) {
                    return e.x = t.x / n.x, e.y = t.y / n.y, e.z = t.z / n.z, e.w = t.w / n.w, e
                }, t.ceil = function(e, t) {
                    return e.x = Math.ceil(t.x), e.y = Math.ceil(t.y), e.z = Math.ceil(t.z), e.w = Math.ceil(t.w), e
                }, t.floor = function(e, t) {
                    return e.x = Math.floor(t.x), e.y = Math.floor(t.y), e.z = Math.floor(t.z), e.w = Math.floor(t.w), e
                }, t.min = function(e, t, n) {
                    return e.x = Math.min(t.x, n.x), e.y = Math.min(t.y, n.y), e.z = Math.min(t.z, n.z), e.w = Math.min(t.w, n.w), e
                }, t.max = function(e, t, n) {
                    return e.x = Math.max(t.x, n.x), e.y = Math.max(t.y, n.y), e.z = Math.max(t.z, n.z), e.w = Math.max(t.w, n.w), e
                }, t.round = function(e, t) {
                    return e.x = Math.round(t.x), e.y = Math.round(t.y), e.z = Math.round(t.z), e.w = Math.round(t.w), e
                }, t.multiplyScalar = function(e, t, n) {
                    return e.x = t.x * n, e.y = t.y * n, e.z = t.z * n, e.w = t.w * n, e
                }, t.scaleAndAdd = function(e, t, n, i) {
                    return e.x = t.x + n.x * i, e.y = t.y + n.y * i, e.z = t.z + n.z * i, e.w = t.w + n.w * i, e
                }, t.distance = function(e, t) {
                    var n = t.x - e.x,
                        i = t.y - e.y,
                        r = t.z - e.z,
                        o = t.w - e.w;
                    return Math.sqrt(n * n + i * i + r * r + o * o)
                }, t.squaredDistance = function(e, t) {
                    var n = t.x - e.x,
                        i = t.y - e.y,
                        r = t.z - e.z,
                        o = t.w - e.w;
                    return n * n + i * i + r * r + o * o
                }, t.len = function(e) {
                    var t = e.x,
                        n = e.y,
                        i = e.z,
                        r = e.w;
                    return Math.sqrt(t * t + n * n + i * i + r * r)
                }, t.lengthSqr = function(e) {
                    var t = e.x,
                        n = e.y,
                        i = e.z,
                        r = e.w;
                    return t * t + n * n + i * i + r * r
                }, t.negate = function(e, t) {
                    return e.x = -t.x, e.y = -t.y, e.z = -t.z, e.w = -t.w, e
                }, t.inverse = function(e, t) {
                    return e.x = 1 / t.x, e.y = 1 / t.y, e.z = 1 / t.z, e.w = 1 / t.w, e
                }, t.inverseSafe = function(e, t) {
                    var n = t.x,
                        i = t.y,
                        r = t.z,
                        o = t.w;
                    return Math.abs(n) < Qt ? e.x = 0 : e.x = 1 / n, Math.abs(i) < Qt ? e.y = 0 : e.y = 1 / i, Math.abs(r) < Qt ? e.z = 0 : e.z = 1 / r, Math.abs(o) < Qt ? e.w = 0 : e.w = 1 / o, e
                }, t.normalize = function(e, t) {
                    var n = t.x,
                        i = t.y,
                        r = t.z,
                        o = t.w,
                        a = n * n + i * i + r * r + o * o;
                    return a > 0 && (a = 1 / Math.sqrt(a), e.x = n * a, e.y = i * a, e.z = r * a, e.w = o * a), e
                }, t.dot = function(e, t) {
                    return e.x * t.x + e.y * t.y + e.z * t.z + e.w * t.w
                }, t.lerp = function(e, t, n, i) {
                    return e.x = t.x + i * (n.x - t.x), e.y = t.y + i * (n.y - t.y), e.z = t.z + i * (n.z - t.z), e.w = t.w + i * (n.w - t.w), e
                }, t.random = function(e, t) {
                    t = t || 1;
                    var n = 2 * an() * Math.PI,
                        i = 2 * an() - 1,
                        r = Math.sqrt(1 - i * i);
                    return e.x = r * Math.cos(n) * t, e.y = r * Math.sin(n) * t, e.z = i * t, e.w = 0, e
                }, t.transformMat4 = function(e, t, n) {
                    var i = t.x,
                        r = t.y,
                        o = t.z,
                        a = t.w;
                    return e.x = n.m00 * i + n.m04 * r + n.m08 * o + n.m12 * a, e.y = n.m01 * i + n.m05 * r + n.m09 * o + n.m13 * a, e.z = n.m02 * i + n.m06 * r + n.m10 * o + n.m14 * a, e.w = n.m03 * i + n.m07 * r + n.m11 * o + n.m15 * a, e
                }, t.transformAffine = function(e, t, n) {
                    var i = t.x,
                        r = t.y,
                        o = t.z,
                        a = t.w;
                    return e.x = n.m00 * i + n.m01 * r + n.m02 * o + n.m03 * a, e.y = n.m04 * i + n.m05 * r + n.m06 * o + n.m07 * a, e.x = n.m08 * i + n.m09 * r + n.m10 * o + n.m11 * a, e.w = t.w, e
                }, t.transformQuat = function(e, t, n) {
                    var i = t.x,
                        r = t.y,
                        o = t.z,
                        a = n.x,
                        s = n.y,
                        c = n.z,
                        l = n.w,
                        u = l * i + s * o - c * r,
                        h = l * r + c * i - a * o,
                        _ = l * o + a * r - s * i,
                        f = -a * i - s * r - c * o;
                    return e.x = u * l + f * -a + h * -c - _ * -s, e.y = h * l + f * -s + _ * -a - u * -c, e.z = _ * l + f * -c + u * -s - h * -a, e.w = t.w, e
                }, t.toArray = function(e, t, n) {
                    return void 0 === n && (n = 0), e[n + 0] = t.x, e[n + 1] = t.y, e[n + 2] = t.z, e[n + 3] = t.w, e
                }, t.fromArray = function(e, t, n) {
                    return void 0 === n && (n = 0), e.x = t[n + 0], e.y = t[n + 1], e.z = t[n + 2], e.w = t[n + 3], e
                }, t.strictEquals = function(e, t) {
                    return e.x === t.x && e.y === t.y && e.z === t.z && e.w === t.w
                }, t.equals = function(e, t, n) {
                    return void 0 === n && (n = Qt), Math.abs(e.x - t.x) <= n * Math.max(1, Math.abs(e.x), Math.abs(t.x)) && Math.abs(e.y - t.y) <= n * Math.max(1, Math.abs(e.y), Math.abs(t.y)) && Math.abs(e.z - t.z) <= n * Math.max(1, Math.abs(e.z), Math.abs(t.z)) && Math.abs(e.w - t.w) <= n * Math.max(1, Math.abs(e.w), Math.abs(t.w))
                };
                var n = t.prototype;
                return n.clone = function() {
                    return new t(this.x, this.y, this.z, this.w)
                }, n.set = function(e, t, n, i) {
                    return e && "object" == typeof e ? (this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w) : (this.x = e || 0, this.y = t || 0, this.z = n || 0, this.w = i || 0), this
                }, n.equals = function(e, t) {
                    return void 0 === t && (t = Qt), Math.abs(this.x - e.x) <= t * Math.max(1, Math.abs(this.x), Math.abs(e.x)) && Math.abs(this.y - e.y) <= t * Math.max(1, Math.abs(this.y), Math.abs(e.y)) && Math.abs(this.z - e.z) <= t * Math.max(1, Math.abs(this.z), Math.abs(e.z)) && Math.abs(this.w - e.w) <= t * Math.max(1, Math.abs(this.w), Math.abs(e.w))
                }, n.equals4f = function(e, t, n, i, r) {
                    return void 0 === r && (r = Qt), Math.abs(this.x - e) <= r * Math.max(1, Math.abs(this.x), Math.abs(e)) && Math.abs(this.y - t) <= r * Math.max(1, Math.abs(this.y), Math.abs(t)) && Math.abs(this.z - n) <= r * Math.max(1, Math.abs(this.z), Math.abs(n)) && Math.abs(this.w - i) <= r * Math.max(1, Math.abs(this.w), Math.abs(i))
                }, n.strictEquals = function(e) {
                    return this.x === e.x && this.y === e.y && this.z === e.z && this.w === e.w
                }, n.strictEquals4f = function(e, t, n, i) {
                    return this.x === e && this.y === t && this.z === n && this.w === i
                }, n.lerp = function(e, t) {
                    var n = this.x,
                        i = this.y,
                        r = this.z,
                        o = this.w;
                    return this.x = n + t * (e.x - n), this.y = i + t * (e.y - i), this.z = r + t * (e.z - r), this.w = o + t * (e.w - o), this
                }, n.toString = function() {
                    return "(" + this.x.toFixed(2) + ", " + this.y.toFixed(2) + ", " + this.z.toFixed(2) + ", " + this.w.toFixed(2) + ")"
                }, n.clampf = function(e, t) {
                    return this.x = en(this.x, e.x, t.x), this.y = en(this.y, e.y, t.y), this.z = en(this.z, e.z, t.z), this.w = en(this.w, e.w, t.w), this
                }, n.add = function(e) {
                    return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this
                }, n.add4f = function(e, t, n, i) {
                    return this.x += e, this.y += t, this.z += n, this.w += i, this
                }, n.subtract = function(e) {
                    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this
                }, n.subtract4f = function(e, t, n, i) {
                    return this.x -= e, this.y -= t, this.z -= n, this.w -= i, this
                }, n.multiplyScalar = function(e) {
                    return "object" == typeof e && console.warn("should use Vec4.multiply for vector * vector operation"), this.x *= e, this.y *= e, this.z *= e, this.w *= e, this
                }, n.multiply = function(e) {
                    return "object" != typeof e && console.warn("should use Vec4.scale for vector * scalar operation"), this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this
                }, n.multiply4f = function(e, t, n, i) {
                    return this.x *= e, this.y *= t, this.z *= n, this.w *= i, this
                }, n.divide = function(e) {
                    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this.w /= e.w, this
                }, n.divide4f = function(e, t, n, i) {
                    return this.x /= e, this.y /= t, this.z /= n, this.w /= i, this
                }, n.negative = function() {
                    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
                }, n.dot = function(e) {
                    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
                }, n.cross = function(e) {
                    var t = this.x,
                        n = this.y,
                        i = this.z,
                        r = e.x,
                        o = e.y,
                        a = e.z;
                    return this.x = n * a - i * o, this.y = i * r - t * a, this.z = t * o - n * r, this
                }, n.length = function() {
                    var e = this.x,
                        t = this.y,
                        n = this.z,
                        i = this.w;
                    return Math.sqrt(e * e + t * t + n * n + i * i)
                }, n.lengthSqr = function() {
                    var e = this.x,
                        t = this.y,
                        n = this.z,
                        i = this.w;
                    return e * e + t * t + n * n + i * i
                }, n.normalize = function() {
                    var e = this.x,
                        t = this.y,
                        n = this.z,
                        i = this.w,
                        r = e * e + t * t + n * n + i * i;
                    return r > 0 && (r = 1 / Math.sqrt(r), this.x = e * r, this.y = t * r, this.z = n * r, this.w = i * r), this
                }, n.transformMat4 = function(e) {
                    var t = this.x,
                        n = this.y,
                        i = this.z,
                        r = this.w;
                    return this.x = e.m00 * t + e.m04 * n + e.m08 * i + e.m12 * r, this.y = e.m01 * t + e.m05 * n + e.m09 * i + e.m13 * r, this.z = e.m02 * t + e.m06 * n + e.m10 * i + e.m14 * r, this.w = e.m03 * t + e.m07 * n + e.m11 * i + e.m15 * r, this
                }, t
            }(it));

            function jn(e, t, n, i) {
                return new Wn(e, t, n, i)
            }
            Wn.ZERO = Object.freeze(new Wn(0, 0, 0, 0)), Wn.ONE = Object.freeze(new Wn(1, 1, 1, 1)), Wn.NEG_ONE = Object.freeze(new Wn(-1, -1, -1, -1)), qt.fastDefine("cc.Vec4", Wn, {
                x: 0,
                y: 0,
                z: 0,
                w: 0
            }), i.Vec4 = Wn, i.v4 = jn, U(Gn, "Vec2", [{
                name: "sub",
                newName: "subtract",
                target: Gn,
                targetName: "Vec2"
            }, {
                name: "mul",
                newName: "multiply",
                target: Gn,
                targetName: "Vec2"
            }, {
                name: "div",
                newName: "divide",
                target: Gn,
                targetName: "Vec2"
            }, {
                name: "dist",
                newName: "distance",
                target: Gn,
                targetName: "Vec2"
            }, {
                name: "sqrDist",
                newName: "squaredDistance",
                target: Gn,
                targetName: "Vec2"
            }, {
                name: "mag",
                newName: "len",
                target: Gn,
                targetName: "Vec2"
            }, {
                name: "sqrMag",
                newName: "lengthSqr",
                target: Gn,
                targetName: "Vec2"
            }, {
                name: "scale",
                newName: "multiplyScalar",
                target: Gn,
                targetName: "Vec2"
            }, {
                name: "exactEquals",
                newName: "strictEquals",
                target: Gn,
                targetName: "Vec2"
            }]), U(Gn.prototype, "Vec2", [{
                name: "mag",
                newName: "length",
                target: Gn.prototype,
                targetName: "Vec2"
            }, {
                name: "magSqr",
                newName: "lengthSqr",
                target: Gn.prototype,
                targetName: "Vec2"
            }, {
                name: "scale",
                newName: "multiplyScalar",
                target: Gn.prototype,
                targetName: "Vec2"
            }, {
                name: "exactEquals",
                newName: "strictEquals",
                target: Gn.prototype,
                targetName: "Vec2"
            }]), U(En, "Vec3", [{
                name: "sub",
                newName: "subtract",
                target: En,
                targetName: "Vec3"
            }, {
                name: "mul",
                newName: "multiply",
                target: En,
                targetName: "Vec3"
            }, {
                name: "div",
                newName: "divide",
                target: En,
                targetName: "Vec3"
            }, {
                name: "dist",
                newName: "distance",
                target: En,
                targetName: "Vec3"
            }, {
                name: "sqrDist",
                newName: "squaredDistance",
                target: En,
                targetName: "Vec3"
            }, {
                name: "mag",
                newName: "len",
                target: En,
                targetName: "Vec3"
            }, {
                name: "sqrMag",
                newName: "lengthSqr",
                target: En,
                targetName: "Vec3"
            }, {
                name: "scale",
                newName: "multiplyScalar",
                target: En,
                targetName: "Vec3"
            }, {
                name: "exactEquals",
                newName: "strictEquals",
                target: En,
                targetName: "Vec3"
            }]), U(En.prototype, "Vec3", [{
                name: "mag",
                newName: "length",
                target: En.prototype,
                targetName: "Vec3"
            }, {
                name: "magSqr",
                newName: "lengthSqr",
                target: En.prototype,
                targetName: "Vec3"
            }, {
                name: "scale",
                newName: "multiplyScalar",
                target: En.prototype,
                targetName: "Vec3"
            }, {
                name: "exactEquals",
                newName: "strictEquals",
                target: En.prototype,
                targetName: "Vec3"
            }]), U(Wn, "Vec4", [{
                name: "sub",
                newName: "subtract",
                target: Wn,
                targetName: "Vec4"
            }, {
                name: "mul",
                newName: "multiply",
                target: Wn,
                targetName: "Vec4"
            }, {
                name: "div",
                newName: "divide",
                target: Wn,
                targetName: "Vec4"
            }, {
                name: "dist",
                newName: "distance",
                target: Wn,
                targetName: "Vec4"
            }, {
                name: "sqrDist",
                newName: "squaredDistance",
                target: Wn,
                targetName: "Vec4"
            }, {
                name: "mag",
                newName: "len",
                target: Wn,
                targetName: "Vec4"
            }, {
                name: "sqrMag",
                newName: "lengthSqr",
                target: Wn,
                targetName: "Vec4"
            }, {
                name: "scale",
                newName: "multiplyScalar",
                target: Wn,
                targetName: "Vec4"
            }, {
                name: "exactEquals",
                newName: "strictEquals",
                target: Wn,
                targetName: "Vec4"
            }]), U(Wn.prototype, "Vec4", [{
                name: "mag",
                newName: "length",
                target: Wn.prototype,
                targetName: "Vec4"
            }, {
                name: "magSqr",
                newName: "lengthSqr",
                target: Wn.prototype,
                targetName: "Vec4"
            }, {
                name: "scale",
                newName: "multiplyScalar",
                target: Wn.prototype,
                targetName: "Vec4"
            }, {
                name: "exactEquals",
                newName: "strictEquals",
                target: Wn.prototype,
                targetName: "Vec4"
            }]), U(wn, "Quat", [{
                name: "mag",
                newName: "len",
                target: wn,
                targetName: "Quat"
            }, {
                name: "mul",
                newName: "multiply",
                target: wn,
                targetName: "Quat"
            }, {
                name: "sqrMag",
                newName: "lengthSqr",
                target: wn,
                targetName: "Quat"
            }, {
                name: "scale",
                newName: "multiplyScalar",
                target: wn,
                targetName: "Quat"
            }, {
                name: "exactEquals",
                newName: "strictEquals",
                target: wn,
                targetName: "Quat"
            }]), U(wn.prototype, "Quat", [{
                name: "scale",
                newName: "multiplyScalar",
                target: wn.prototype,
                targetName: "Quat"
            }, {
                name: "exactEquals",
                newName: "strictEquals",
                target: wn.prototype,
                targetName: "Quat"
            }]), U(yn, "Color", [{
                name: "sub",
                newName: "subtract",
                target: yn,
                targetName: "Color"
            }, {
                name: "mul",
                newName: "multiply",
                target: yn,
                targetName: "Color"
            }, {
                name: "div",
                newName: "divide",
                target: yn,
                targetName: "Color"
            }, {
                name: "exactEquals",
                newName: "strictEquals",
                target: yn,
                targetName: "Color"
            }, {
                name: "fromHex",
                newName: "fromHEX",
                customFunction: function() {
                    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
                    var r = t[1].toString(16);
                    return i.Color.fromHEX(t[0], r)
                }
            }]), U(Cn, "Mat3", [{
                name: "sub",
                newName: "subtract",
                target: Cn,
                targetName: "Mat3"
            }, {
                name: "mul",
                newName: "multiply",
                target: Cn,
                targetName: "Mat3"
            }, {
                name: "exactEquals",
                newName: "strictEquals",
                target: Cn,
                targetName: "Mat3"
            }, {
                name: "transfrom",
                newName: "transform",
                target: Cn,
                targetName: "Mat3"
            }]), U(Cn.prototype, "Mat3", [{
                name: "sub",
                newName: "subtract",
                target: Cn.prototype,
                targetName: "Mat3"
            }, {
                name: "mul",
                newName: "multiply",
                target: Cn.prototype,
                targetName: "Mat3"
            }, {
                name: "mulScalar",
                newName: "multiplyScalar",
                target: Cn.prototype,
                targetName: "Mat3"
            }, {
                name: "exactEquals",
                newName: "strictEquals",
                target: Cn.prototype,
                targetName: "Mat3"
            }]), U(Bn, "Mat4", [{
                name: "sub",
                newName: "subtract",
                target: Bn,
                targetName: "Mat4"
            }, {
                name: "mul",
                newName: "multiply",
                target: Bn,
                targetName: "Mat4"
            }, {
                name: "exactEquals",
                newName: "strictEquals",
                target: Bn,
                targetName: "Mat4"
            }]), U(Bn.prototype, "Mat4", [{
                name: "sub",
                newName: "subtract",
                target: Bn.prototype,
                targetName: "Mat4"
            }, {
                name: "mul",
                newName: "multiply",
                target: Bn.prototype,
                targetName: "Mat4"
            }, {
                name: "mulScalar",
                newName: "multiplyScalar",
                target: Bn.prototype,
                targetName: "Mat4"
            }, {
                name: "exactEquals",
                newName: "strictEquals",
                target: Bn.prototype,
                targetName: "Mat4"
            }]);
            var qn = e("AffineTransform", function() {
                function e(e, t, n, i, r, o) {
                    void 0 === e && (e = 1), void 0 === t && (t = 0), void 0 === n && (n = 0), void 0 === i && (i = 1), void 0 === r && (r = 0), void 0 === o && (o = 0), this.a = e, this.b = t, this.c = n, this.d = i, this.tx = r, this.ty = o
                }
                return e.identity = function() {
                    return new e
                }, e.clone = function(t) {
                    return new e(t.a, t.b, t.c, t.d, t.tx, t.ty)
                }, e.concat = function(e, t, n) {
                    var i = t.a,
                        r = t.b,
                        o = t.c,
                        a = t.d,
                        s = t.tx,
                        c = t.ty;
                    e.a = i * n.a + r * n.c, e.b = i * n.b + r * n.d, e.c = o * n.a + a * n.c, e.d = o * n.b + a * n.d, e.tx = s * n.a + c * n.c + n.tx, e.ty = s * n.b + c * n.d + n.ty
                }, e.invert = function(e, t) {
                    var n = 1 / (t.a * t.d - t.b * t.c);
                    e.a = n * t.d, e.b = -n * t.b, e.c = -n * t.c, e.d = n * t.a, e.tx = n * (t.c * t.ty - t.d * t.tx), e.ty = n * (t.b * t.tx - t.a * t.ty)
                }, e.fromMat4 = function(e, t) {
                    e.a = t.m00, e.b = t.m01, e.c = t.m04, e.d = t.m05, e.tx = t.m12, e.ty = t.m13
                }, e.transformVec2 = function(e, t, n, i) {
                    var r, o;
                    void 0 === i ? (i = n, r = t.x, o = t.y) : (r = t, o = n), e.x = i.a * r + i.c * o + i.tx, e.y = i.b * r + i.d * o + i.ty
                }, e.transformSize = function(e, t, n) {
                    e.width = n.a * t.width + n.c * t.height, e.height = n.b * t.width + n.d * t.height
                }, e.transformRect = function(e, t, n) {
                    var i = t.x + t.width,
                        r = t.y + t.height,
                        o = n.a * t.x + n.c * t.y + n.tx,
                        a = n.b * t.x + n.d * t.y + n.ty,
                        s = n.a * i + n.c * t.y + n.tx,
                        c = n.b * i + n.d * t.y + n.ty,
                        l = n.a * t.x + n.c * r + n.tx,
                        u = n.b * t.x + n.d * r + n.ty,
                        h = n.a * i + n.c * r + n.tx,
                        _ = n.b * i + n.d * r + n.ty,
                        f = Math.min(o, s, l, h),
                        d = Math.max(o, s, l, h),
                        p = Math.min(a, c, u, _),
                        m = Math.max(a, c, u, _);
                    e.x = f, e.y = p, e.width = d - f, e.height = m - p
                }, e.transformObb = function(e, t, n, i, r, o) {
                    var a = o.a * r.x + o.c * r.y + o.tx,
                        s = o.b * r.x + o.d * r.y + o.ty,
                        c = o.a * r.width,
                        l = o.b * r.width,
                        u = o.c * r.height,
                        h = o.d * r.height;
                    t.x = a, t.y = s, n.x = c + a, n.y = l + s, e.x = u + a, e.y = h + s, i.x = c + u + a, i.y = l + h + s
                }, e
            }());
            i.AffineTransform = qn;
            var Xn = e("Size", function(e) {
                function t(t, n) {
                    var i;
                    return i = e.call(this) || this, t && "object" == typeof t ? (i.width = t.width, i.height = t.height) : (i.width = t || 0, i.height = n || 0), i
                }
                Q(t, e), t.lerp = function(e, t, n, i) {
                    return e.width = t.width + (n.width - t.width) * i, e.height = t.height + (n.height - t.height) * i, e
                };
                var n = t.prototype;
                return n.clone = function() {
                    return new t(this.width, this.height)
                }, n.set = function(e, t) {
                    return e && "object" == typeof e ? (this.height = e.height, this.width = e.width) : (this.width = e || 0, this.height = t || 0), this
                }, n.equals = function(e) {
                    return this.width === e.width && this.height === e.height
                }, n.lerp = function(e, t) {
                    return this.width += (e.width - this.width) * t, this.height += (e.height - this.height) * t, this
                }, n.toString = function() {
                    return "(" + this.width.toFixed(2) + ", " + this.height.toFixed(2) + ")"
                }, K(t, [{
                    key: "x",
                    get: function() {
                        return this.width
                    },
                    set: function(e) {
                        this.width = e
                    }
                }, {
                    key: "y",
                    get: function() {
                        return this.height
                    },
                    set: function(e) {
                        this.height = e
                    }
                }]), t
            }(it));

            function Yn(e, t) {
                return void 0 === e && (e = 0), void 0 === t && (t = 0), new Xn(e, t)
            }
            Xn.ZERO = Object.freeze(new Xn(0, 0)), Xn.ONE = Object.freeze(new Xn(1, 1)), qt.fastDefine("cc.Size", Xn, {
                width: 0,
                height: 0
            }), i.size = Yn, i.Size = Xn;
            var Kn = e("Rect", function(e) {
                function t(t, n, i, r) {
                    var o;
                    return o = e.call(this) || this, t && "object" == typeof t ? (o.y = t.y, o.width = t.width, o.height = t.height, o.x = t.x) : (o.x = t || 0, o.y = n || 0, o.width = i || 0, o.height = r || 0), o
                }
                Q(t, e), t.fromMinMax = function(e, t, n) {
                    var i = Math.min(t.x, n.x),
                        r = Math.min(t.y, n.y),
                        o = Math.max(t.x, n.x),
                        a = Math.max(t.y, n.y);
                    return e.x = i, e.y = r, e.width = o - i, e.height = a - r, e
                }, t.lerp = function(e, t, n, i) {
                    var r = t.x,
                        o = t.y,
                        a = t.width,
                        s = t.height;
                    return e.x = r + (n.x - r) * i, e.y = o + (n.y - o) * i, e.width = a + (n.width - a) * i, e.height = s + (n.height - s) * i, e
                }, t.intersection = function(e, t, n) {
                    var i = t.x,
                        r = t.y,
                        o = t.x + t.width,
                        a = t.y + t.height,
                        s = n.x,
                        c = n.y,
                        l = n.x + n.width,
                        u = n.y + n.height;
                    return e.x = Math.max(i, s), e.y = Math.max(r, c), e.width = Math.min(o, l) - e.x, e.height = Math.min(a, u) - e.y, e
                }, t.union = function(e, t, n) {
                    var i = t.x,
                        r = t.y,
                        o = t.width,
                        a = t.height,
                        s = n.x,
                        c = n.y,
                        l = n.width,
                        u = n.height;
                    return e.x = Math.min(i, s), e.y = Math.min(r, c), e.width = Math.max(i + o, s + l) - e.x, e.height = Math.max(r + a, c + u) - e.y, e
                };
                var n = t.prototype;
                return n.clone = function() {
                    return new t(this.x, this.y, this.width, this.height)
                }, n.set = function(e, t, n, i) {
                    return e && "object" == typeof e ? (this.y = e.y, this.width = e.width, this.height = e.height, this.x = e.x) : (this.x = e || 0, this.y = t || 0, this.width = n || 0, this.height = i || 0), this
                }, n.equals = function(e) {
                    return this.x === e.x && this.y === e.y && this.width === e.width && this.height === e.height
                }, n.lerp = function(e, t) {
                    var n = this.x,
                        i = this.y,
                        r = this.width,
                        o = this.height;
                    return this.x = n + (e.x - n) * t, this.y = i + (e.y - i) * t, this.width = r + (e.width - r) * t, this.height = o + (e.height - o) * t, this
                }, n.toString = function() {
                    return "(" + this.x.toFixed(2) + ", " + this.y.toFixed(2) + ", " + this.width.toFixed(2) + ", " + this.height.toFixed(2) + ")"
                }, n.intersects = function(e) {
                    var t = this.x + this.width,
                        n = this.y + this.height,
                        i = e.x + e.width,
                        r = e.y + e.height;
                    return !(t < e.x || i < this.x || n < e.y || r < this.y)
                }, n.contains = function(e) {
                    return this.x <= e.x && this.x + this.width >= e.x && this.y <= e.y && this.y + this.height >= e.y
                }, n.containsRect = function(e) {
                    return this.x <= e.x && this.x + this.width >= e.x + e.width && this.y <= e.y && this.y + this.height >= e.y + e.height
                }, n.transformMat4 = function(e) {
                    var t = this.x,
                        n = this.y,
                        i = t + this.width,
                        r = n + this.height,
                        o = e.m00 * t + e.m04 * n + e.m12,
                        a = e.m01 * t + e.m05 * n + e.m13,
                        s = e.m00 * i + e.m04 * n + e.m12,
                        c = e.m01 * i + e.m05 * n + e.m13,
                        l = e.m00 * t + e.m04 * r + e.m12,
                        u = e.m01 * t + e.m05 * r + e.m13,
                        h = e.m00 * i + e.m04 * r + e.m12,
                        _ = e.m01 * i + e.m05 * r + e.m13,
                        f = Math.min(o, s, l, h),
                        d = Math.max(o, s, l, h),
                        p = Math.min(a, c, u, _),
                        m = Math.max(a, c, u, _);
                    return this.x = f, this.y = p, this.width = d - f, this.height = m - p, this
                }, n.transformMat4ToPoints = function(e, t, n, i, r) {
                    var o = this.x,
                        a = this.y,
                        s = o + this.width,
                        c = a + this.height;
                    t.x = e.m00 * o + e.m04 * a + e.m12, t.y = e.m01 * o + e.m05 * a + e.m13, r.x = e.m00 * s + e.m04 * a + e.m12, r.y = e.m01 * s + e.m05 * a + e.m13, n.x = e.m00 * o + e.m04 * c + e.m12, n.y = e.m01 * o + e.m05 * c + e.m13, i.x = e.m00 * s + e.m04 * c + e.m12, i.y = e.m01 * s + e.m05 * c + e.m13
                }, K(t, [{
                    key: "xMin",
                    get: function() {
                        return this.x
                    },
                    set: function(e) {
                        this.width += this.x - e, this.x = e
                    }
                }, {
                    key: "yMin",
                    get: function() {
                        return this.y
                    },
                    set: function(e) {
                        this.height += this.y - e, this.y = e
                    }
                }, {
                    key: "xMax",
                    get: function() {
                        return this.x + this.width
                    },
                    set: function(e) {
                        this.width = e - this.x
                    }
                }, {
                    key: "yMax",
                    get: function() {
                        return this.y + this.height
                    },
                    set: function(e) {
                        this.height = e - this.y
                    }
                }, {
                    key: "center",
                    get: function() {
                        return new Gn(this.x + .5 * this.width, this.y + .5 * this.height)
                    },
                    set: function(e) {
                        this.x = e.x - .5 * this.width, this.y = e.y - .5 * this.height
                    }
                }, {
                    key: "origin",
                    get: function() {
                        return new Gn(this.x, this.y)
                    },
                    set: function(e) {
                        this.x = e.x, this.y = e.y
                    }
                }, {
                    key: "size",
                    get: function() {
                        return new Xn(this.width, this.height)
                    },
                    set: function(e) {
                        this.width = e.width, this.height = e.height
                    }
                }, {
                    key: "z",
                    get: function() {
                        return this.width
                    },
                    set: function(e) {
                        this.width = e
                    }
                }, {
                    key: "w",
                    get: function() {
                        return this.height
                    },
                    set: function(e) {
                        this.height = e
                    }
                }]), t
            }(it));

            function Zn(e, t, n, i) {
                return void 0 === e && (e = 0), void 0 === t && (t = 0), void 0 === n && (n = 0), void 0 === i && (i = 0), new Kn(e, t, n, i)
            }
            qt.fastDefine("cc.Rect", Kn, {
                x: 0,
                y: 0,
                width: 0,
                height: 0
            }), i.Rect = Kn, i.rect = Zn;
            var Qn = Object.freeze({
                __proto__: null,
                bits: z,
                Vec2: Gn,
                v2: Vn,
                Vec3: En,
                v3: xn,
                Vec4: Wn,
                v4: jn,
                Quat: wn,
                quat: Mn,
                Mat3: Cn,
                Mat4: Bn,
                mat4: Un,
                AffineTransform: qn,
                Size: Xn,
                size: Yn,
                Rect: Kn,
                rect: Zn,
                Color: yn,
                color: Sn,
                EPSILON: Qt,
                equals: Jt,
                approx: $t,
                clamp: en,
                clamp01: tn,
                lerp: nn,
                toRadian: rn,
                toDegree: on,
                random: an,
                randomRange: sn,
                randomRangeInt: cn,
                pseudoRandom: ln,
                pseudoRandomRange: un,
                pseudoRandomRangeInt: hn,
                nextPow2: _n,
                repeat: fn,
                pingPong: dn,
                inverseLerp: pn,
                absMaxComponent: mn,
                absMax: gn
            });
            e("math", Qn);
            var Jn = e("Pool", function() {
                    function e(e, t) {
                        this._ctor = void 0, this._elementsPerBatch = void 0, this._nextAvail = void 0, this._freepool = [], this._ctor = e, this._elementsPerBatch = Math.max(t, 1), this._nextAvail = this._elementsPerBatch - 1;
                        for (var n = 0; n < this._elementsPerBatch; ++n) this._freepool.push(e())
                    }
                    var t = e.prototype;
                    return t.alloc = function() {
                        if (this._nextAvail < 0) {
                            for (var e = this._elementsPerBatch, t = 0; t < e; t++) this._freepool.push(this._ctor());
                            this._nextAvail = e - 1
                        }
                        var n = this._freepool[this._nextAvail--];
                        return this._freepool.length--, n
                    }, t.free = function(e) {
                        this._freepool.push(e), this._nextAvail++
                    }, t.freeArray = function(e) {
                        Array.prototype.push.apply(this._freepool, e), this._nextAvail += e.length
                    }, t.destroy = function(e) {
                        if (e)
                            for (var t = 0; t <= this._nextAvail; t++) e(this._freepool[t]);
                        this._freepool.length = 0, this._nextAvail = -1
                    }, e
                }()),
                $n = e("RecyclePool", function() {
                    function e(e, t) {
                        this._fn = void 0, this._count = 0, this._data = void 0, this._fn = e, this._data = new Array(t);
                        for (var n = 0; n < t; ++n) this._data[n] = e()
                    }
                    var t = e.prototype;
                    return t.reset = function() {
                        this._count = 0
                    }, t.resize = function(e) {
                        if (e > this._data.length)
                            for (var t = this._data.length; t < e; ++t) this._data[t] = this._fn()
                    }, t.add = function() {
                        return this._count >= this._data.length && this.resize(2 * this._data.length), this._data[this._count++]
                    }, t.removeAt = function(e) {
                        if (!(e >= this._count)) {
                            var t = this._count - 1,
                                n = this._data[e];
                            this._data[e] = this._data[t], this._data[t] = n, this._count -= 1
                        }
                    }, K(e, [{
                        key: "length",
                        get: function() {
                            return this._count
                        }
                    }, {
                        key: "data",
                        get: function() {
                            return this._data
                        }
                    }]), e
                }()),
                ei = e("CachedArray", function() {
                    function e(e, t) {
                        this.array = void 0, this.length = 0, this._compareFn = void 0, this.array = new Array(e), this.length = 0, this._compareFn = void 0 !== t ? t : function(e, t) {
                            return e - t
                        }
                    }
                    var t = e.prototype;
                    return t.push = function(e) {
                        this.array[this.length++] = e
                    }, t.pop = function() {
                        return this.array[--this.length]
                    }, t.get = function(e) {
                        return this.array[e]
                    }, t.clear = function() {
                        this.length = 0
                    }, t.destroy = function() {
                        this.length = 0, this.array.length = 0
                    }, t.sort = function() {
                        this.array.length = this.length, this.array.sort(this._compareFn)
                    }, t.concat = function(e) {
                        for (var t = 0; t < e.length; ++t) this.array[this.length++] = e[t]
                    }, t.fastRemove = function(e) {
                        if (!(e >= this.length || e < 0)) {
                            var t = --this.length;
                            this.array[e] = this.array[t]
                        }
                    }, t.indexOf = function(e) {
                        return this.array.indexOf(e)
                    }, e
                }());
            e("memop", Object.freeze({
                __proto__: null,
                Pool: Jn,
                RecyclePool: $n,
                CachedArray: ei
            }));
            var ti = [],
                ni = e("CCObject", function() {
                    function e(e) {
                        void 0 === e && (e = ""), this._objFlags = void 0, this._name = void 0, this._name = e, this._objFlags = 0
                    }
                    e._deferredDestroy = function() {
                        for (var e = ti.length, t = 0; t < e; ++t) {
                            var n = ti[t];
                            1 & n._objFlags || n._destroyImmediate()
                        }
                        e === ti.length ? ti.length = 0 : ti.splice(0, e)
                    };
                    var t = e.prototype;
                    return t.destroy = function() {
                        return 1 & this._objFlags ? (x(5e3), !1) : !(4 & this._objFlags || (this._objFlags |= 4, ti.push(this), 0))
                    }, t._destruct = function() {
                        var e = this.constructor,
                            t = e.__destruct__;
                        t || (t = function(e, t) {
                            var n, r = e instanceof i._BaseNode || e instanceof i.Component,
                                o = r ? "_id" : null,
                                a = {};
                            for (n in e)
                                if (e.hasOwnProperty(n)) {
                                    if (n === o) continue;
                                    switch (typeof e[n]) {
                                        case "string":
                                            a[n] = "";
                                            break;
                                        case "object":
                                        case "function":
                                            a[n] = null
                                    }
                                }
                            if (qt._isCCClass(t))
                                for (var s = i.Class.Attr.getClassAttrs(t), c = t.__props__, l = 0; l < c.length; l++) {
                                    var u = (n = c[l]) + i.Class.Attr.DELIMETER + "default";
                                    if (u in s) {
                                        if (r && "_id" === n) continue;
                                        switch (typeof s[u]) {
                                            case "string":
                                                a[n] = "";
                                                break;
                                            case "object":
                                            case "function":
                                                a[n] = null;
                                                break;
                                            case "undefined":
                                                a[n] = void 0
                                        }
                                    }
                                }
                            var h = "";
                            for (n in a) {
                                var _;
                                _ = qt.IDENTIFIER_RE.test(n) ? "o." + n + "=" : "o[" + qt.escapeForJS(n) + "]=";
                                var f = a[n];
                                "" === f && (f = '""'), h += _ + f + ";\n"
                            }
                            return Function("o", h)
                        }(this, e), ve(e, "__destruct__", t, !0)), t(this)
                    }, t._destroyImmediate = function() {
                        1 & this._objFlags ? b(5e3) : (this._onPreDestroy && this._onPreDestroy(), this._destruct(), this._objFlags |= 1)
                    }, K(e, [{
                        key: "name",
                        get: function() {
                            return this._name
                        },
                        set: function(e) {
                            this._name = e
                        }
                    }, {
                        key: "hideFlags",
                        get: function() {
                            return this._objFlags & e.Flags.AllHideMasks
                        },
                        set: function(t) {
                            var n = t & e.Flags.AllHideMasks;
                            this._objFlags = this._objFlags & ~e.Flags.AllHideMasks | n
                        }
                    }, {
                        key: "isValid",
                        get: function() {
                            return !(1 & this._objFlags)
                        }
                    }]), e
                }()),
                ii = ni.prototype;

            function ri(e, t) {
                return "object" == typeof e ? !(!e || e._objFlags & (t ? 5 : 1)) : void 0 !== e
            }
            ii._deserialize = null, ii._onPreDestroy = null, qt.fastDefine("cc.Object", ni, {
                _name: "",
                _objFlags: 0
            }), ve(ni, "Flags", {
                Destroyed: 1,
                DontSave: 8,
                EditorOnly: 16,
                Dirty: 32,
                DontDestroy: 64,
                PersistentMask: -4192741,
                Destroying: 128,
                Deactivating: 256,
                LockedInEditor: 512,
                HideInHierarchy: 1024,
                AllHideMasks: 1560,
                IsPreloadStarted: 8192,
                IsOnLoadStarted: 32768,
                IsOnLoadCalled: 16384,
                IsOnEnableCalled: 2048,
                IsStartCalled: 65536,
                IsEditorOnEnableCalled: 4096,
                IsPositionLocked: 1 << 21,
                IsRotationLocked: 1 << 17,
                IsScaleLocked: 1 << 18,
                IsAnchorLocked: 1 << 19,
                IsSizeLocked: 1 << 20
            }), i.isValid = ri, i.Object = ni;
            var oi = Ze.fastRemoveAt;

            function ai() {}
            var si = function() {
                    function e() {
                        this.callback = ai, this.target = void 0, this.once = !1
                    }
                    var t = e.prototype;
                    return t.set = function(e, t, n) {
                        this.callback = e || ai, this.target = t, this.once = !!n
                    }, t.reset = function() {
                        this.target = void 0, this.callback = ai, this.once = !1
                    }, t.check = function() {
                        return !(this.target instanceof ni && !ri(this.target, !0))
                    }, e
                }(),
                ci = new Jn((function() {
                    return new si
                }), 32),
                li = function() {
                    function e() {
                        this.callbackInfos = [], this.isInvoking = !1, this.containCanceled = !1
                    }
                    var t = e.prototype;
                    return t.removeByCallback = function(e) {
                        for (var t = 0; t < this.callbackInfos.length; ++t) {
                            var n = this.callbackInfos[t];
                            n && n.callback === e && (n.reset(), ci.free(n), oi(this.callbackInfos, t), --t)
                        }
                    }, t.removeByTarget = function(e) {
                        for (var t = 0; t < this.callbackInfos.length; ++t) {
                            var n = this.callbackInfos[t];
                            n && n.target === e && (n.reset(), ci.free(n), oi(this.callbackInfos, t), --t)
                        }
                    }, t.cancel = function(e) {
                        var t = this.callbackInfos[e];
                        t && (t.reset(), this.isInvoking ? this.callbackInfos[e] = null : oi(this.callbackInfos, e), ci.free(t)), this.containCanceled = !0
                    }, t.cancelAll = function() {
                        for (var e = 0; e < this.callbackInfos.length; e++) {
                            var t = this.callbackInfos[e];
                            t && (t.reset(), ci.free(t), this.callbackInfos[e] = null)
                        }
                        this.containCanceled = !0
                    }, t.purgeCanceled = function() {
                        for (var e = this.callbackInfos.length - 1; e >= 0; --e) this.callbackInfos[e] || oi(this.callbackInfos, e);
                        this.containCanceled = !1
                    }, t.clear = function() {
                        this.cancelAll(), this.callbackInfos.length = 0, this.isInvoking = !1, this.containCanceled = !1
                    }, e
                }(),
                ui = new Jn((function() {
                    return new li
                }), 16),
                hi = function() {
                    function e() {
                        this._callbackTable = Te(!0)
                    }
                    var t = e.prototype;
                    return t.on = function(e, t, n, i) {
                        if (!this.hasEventListener(e, t, n)) {
                            var r = this._callbackTable[e];
                            r || (r = this._callbackTable[e] = ui.alloc());
                            var o = ci.alloc();
                            o.set(t, n, i), r.callbackInfos.push(o)
                        }
                        return t
                    }, t.hasEventListener = function(e, t, n) {
                        var i = this._callbackTable && this._callbackTable[e];
                        if (!i) return !1;
                        var r = i.callbackInfos;
                        if (!t) {
                            if (i.isInvoking) {
                                for (var o = 0; o < r.length; ++o)
                                    if (r[o]) return !0;
                                return !1
                            }
                            return r.length > 0
                        }
                        for (var a = 0; a < r.length; ++a) {
                            var s = r[a];
                            if (s && s.check() && s.callback === t && s.target === n) return !0
                        }
                        return !1
                    }, t.removeAll = function(e) {
                        if ("string" == typeof e) {
                            var t = this._callbackTable && this._callbackTable[e];
                            t && (t.isInvoking ? t.cancelAll() : (t.clear(), ui.free(t), delete this._callbackTable[e]))
                        } else if (e)
                            for (var n in this._callbackTable) {
                                var i = this._callbackTable[n];
                                if (i.isInvoking)
                                    for (var r = i.callbackInfos, o = 0; o < r.length; ++o) {
                                        var a = r[o];
                                        a && a.target === e && i.cancel(o)
                                    } else i.removeByTarget(e)
                            }
                    }, t.off = function(e, t, n) {
                        var i = this._callbackTable && this._callbackTable[e];
                        if (i) {
                            var r = i.callbackInfos;
                            if (t)
                                for (var o = 0; o < r.length; ++o) {
                                    var a = r[o];
                                    if (a && a.callback === t && a.target === n) {
                                        i.cancel(o);
                                        break
                                    }
                                } else this.removeAll(e)
                        }
                    }, t.emit = function(e, t, n, i, r, o) {
                        var a = this._callbackTable && this._callbackTable[e];
                        if (a) {
                            var s = !a.isInvoking;
                            a.isInvoking = !0;
                            for (var c = a.callbackInfos, l = 0, u = c.length; l < u; ++l) {
                                var h = c[l];
                                if (h) {
                                    var _ = h.callback,
                                        f = h.target;
                                    h.once && this.off(e, _, f), h.check() ? f ? _.call(f, t, n, i, r, o) : _(t, n, i, r, o) : this.off(e, _, f)
                                }
                            }
                            s && (a.isInvoking = !1, a.containCanceled && a.purgeCanceled())
                        }
                    }, t.clear = function() {
                        for (var e in this._callbackTable) {
                            var t = this._callbackTable[e];
                            t && (t.clear(), ui.free(t), delete this._callbackTable[e])
                        }
                    }, e
                }();

            function _i(e) {
                for (var t = function(e) {
                        function t() {
                            for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                            return (t = e.call.apply(e, [this].concat(i)) || this)._callbackTable = Te(!0), t
                        }
                        Q(t, e);
                        var n = t.prototype;
                        return n.once = function(e, t, n) {
                            return this.on(e, t, n, !0)
                        }, n.targetOff = function(e) {
                            this.removeAll(e)
                        }, t
                    }(e), n = hi.prototype, i = Object.getOwnPropertyNames(n).concat(Object.getOwnPropertySymbols(n)), r = 0; r < i.length; ++r) {
                    var o = i[r];
                    if (!(o in t.prototype)) {
                        var a = Object.getOwnPropertyDescriptor(n, o);
                        a && Object.defineProperty(t.prototype, o, a)
                    }
                }
                return t
            }
            var fi, di, pi, mi, gi, vi, yi, Si = e("EventTarget", _i((function() {})));
            i.EventTarget = Si,
                function(e) {
                    e.UNKNOWN = "unknown", e.WECHAT = "wechat", e.ANDROID = "androidbrowser", e.IE = "ie", e.EDGE = "edge", e.QQ = "qqbrowser", e.MOBILE_QQ = "mqqbrowser", e.UC = "ucbrowser", e.UCBS = "ucbs", e.BROWSER_360 = "360browser", e.BAIDU_APP = "baiduboxapp", e.BAIDU = "baidubrowser", e.MAXTHON = "maxthon", e.OPERA = "opera", e.OUPENG = "oupeng", e.MIUI = "miuibrowser", e.FIREFOX = "firefox", e.SAFARI = "safari", e.CHROME = "chrome", e.LIEBAO = "liebao", e.QZONE = "qzone", e.SOUGOU = "sogou", e.HUAWEI = "huawei"
                }(fi || (fi = {})),
                function(e) {
                    e.HIDE = "hide", e.SHOW = "show", e.RESIZE = "resize", e.ORIENTATION_CHANGE = "orientation_change"
                }(di || (di = {})),
                function(e) {
                    e.UNKNOWN = "unknown", e.ENGLISH = "en", e.CHINESE = "zh", e.FRENCH = "fr", e.ITALIAN = "it", e.GERMAN = "de", e.SPANISH = "es", e.DUTCH = "du", e.RUSSIAN = "ru", e.KOREAN = "ko", e.JAPANESE = "ja", e.HUNGARIAN = "hu", e.PORTUGUESE = "pt", e.ARABIC = "ar", e.NORWEGIAN = "no", e.POLISH = "pl", e.TURKISH = "tr", e.UKRAINIAN = "uk", e.ROMANIAN = "ro", e.BULGARIAN = "bg"
                }(pi || (pi = {})),
                function(e) {
                    e[e.NONE = 0] = "NONE", e[e.LAN = 1] = "LAN", e[e.WWAN = 2] = "WWAN"
                }(mi || (mi = {})),
                function(e) {
                    e.UNKNOWN = "Unknown", e.IOS = "iOS", e.ANDROID = "Android", e.WINDOWS = "Windows", e.LINUX = "Linux", e.OSX = "OS X"
                }(gi || (gi = {})),
                function(e) {
                    e[e.PORTRAIT = 1] = "PORTRAIT", e[e.PORTRAIT_UPSIDE_DOWN = 2] = "PORTRAIT_UPSIDE_DOWN", e[e.LANDSCAPE_LEFT = 4] = "LANDSCAPE_LEFT", e[e.LANDSCAPE_RIGHT = 8] = "LANDSCAPE_RIGHT", e[e.LANDSCAPE = 12] = "LANDSCAPE"
                }(vi || (vi = {})),
                function(e) {
                    e.UNKNOWN = "UNKNOWN", e.EDITOR_PAGE = "EDITOR_PAGE", e.EDITOR_CORE = "EDITOR_CORE", e.MOBILE_BROWSER = "MOBILE_BROWSER", e.DESKTOP_BROWSER = "DESKTOP_BROWSER", e.WIN32 = "WIN32", e.ANDROID = "ANDROID", e.IOS = "IOS", e.MACOS = "MACOS", e.WECHAT_GAME = "WECHAT_GAME", e.BAIDU_MINI_GAME = "BAIDU_MINI_GAME", e.XIAOMI_QUICK_GAME = "XIAOMI_QUICK_GAME", e.ALIPAY_MINI_GAME = "ALIPAY_MINI_GAME", e.BYTEDANCE_MINI_GAME = "BYTEDANCE_MINI_GAME", e.OPPO_MINI_GAME = "OPPO_MINI_GAME", e.VIVO_MINI_GAME = "VIVO_MINI_GAME", e.HUAWEI_QUICK_GAME = "HUAWEI_QUICK_GAME", e.COCOSPLAY = "COCOSPLAY", e.LINKSURE_MINI_GAME = "LINKSURE_MINI_GAME", e.QTT_MINI_GAME = "QTT_MINI_GAME"
                }(yi || (yi = {}));
            var Ei = new(function() {
                    function e() {
                        var e, t = this;
                        this.networkType = void 0, this.isNative = void 0, this.isBrowser = void 0, this.isMobile = void 0, this.isLittleEndian = void 0, this.platform = void 0, this.language = void 0, this.nativeLanguage = void 0, this.os = void 0, this.osVersion = void 0, this.osMainVersion = void 0, this.browserType = void 0, this.browserVersion = void 0, this.pixelRatio = void 0, this.supportCapability = void 0, this._eventTarget = new Si, this._html = void 0, this._battery = void 0;
                        var n, i = window.navigator,
                            r = i.userAgent.toLowerCase();
                        this._html = document.getElementsByTagName("html")[0], null === (e = i.getBattery) || void 0 === e || e.call(i).then((function(e) {
                            t._battery = e
                        })), this.networkType = mi.LAN, this.isNative = !1, this.isBrowser = !0, this.isMobile = /mobile|android|iphone|ipad/.test(r), this.platform = this.isMobile ? yi.MOBILE_BROWSER : yi.DESKTOP_BROWSER, this.isLittleEndian = (n = new ArrayBuffer(2), new DataView(n).setInt16(0, 256, !0), 256 === new Int16Array(n)[0]);
                        var o = i.language;
                        this.nativeLanguage = o.toLowerCase(), o = (o = o || i.browserLanguage) ? o.split("-")[0] : pi.ENGLISH, this.language = o;
                        var a = !1,
                            s = !1,
                            c = "",
                            l = 0,
                            u = /android\s*(\d+(?:\.\d+)*)/i.exec(r) || /android\s*(\d+(?:\.\d+)*)/i.exec(i.platform);
                        u && (a = !0, c = u[1] || "", l = parseInt(c) || 0), (u = /(iPad|iPhone|iPod).*OS ((\d+_?){2,3})/i.exec(r)) ? (s = !0, c = u[2] || "", l = parseInt(c) || 0) : (/(iPhone|iPad|iPod)/.exec(i.platform) || "MacIntel" === i.platform && i.maxTouchPoints && i.maxTouchPoints > 1) && (s = !0, c = "", l = 0);
                        var h = gi.UNKNOWN; - 1 !== i.appVersion.indexOf("Win") ? h = gi.WINDOWS : s ? h = gi.IOS : -1 !== i.appVersion.indexOf("Mac") ? h = gi.OSX : -1 !== i.appVersion.indexOf("X11") && -1 === i.appVersion.indexOf("Linux") ? h = gi.LINUX : a ? h = gi.ANDROID : -1 === i.appVersion.indexOf("Linux") && -1 === r.indexOf("ubuntu") || (h = gi.LINUX), this.os = h, this.osVersion = c, this.osMainVersion = l, this.browserType = fi.UNKNOWN;
                        var _ = /wechat|weixin|micromessenger/i.exec(r) || /mqqbrowser|micromessenger|qqbrowser|sogou|qzone|liebao|maxthon|ucbs|360 aphone|360browser|baiduboxapp|baidubrowser|maxthon|mxbrowser|miuibrowser/i.exec(r) || /qq|qqbrowser|ucbrowser|ubrowser|edge|HuaweiBrowser/i.exec(r) || /chrome|safari|firefox|trident|opera|opr\/|oupeng/i.exec(r),
                            f = _ ? _[0].toLowerCase() : gi.UNKNOWN;
                        ("safari" === f && a || "qq" === f && /android.*applewebkit/i.test(r)) && (f = fi.ANDROID);
                        var d = {
                            micromessenger: fi.WECHAT,
                            wechat: fi.WECHAT,
                            weixin: fi.WECHAT,
                            trident: fi.IE,
                            edge: fi.EDGE,
                            "360 aphone": fi.BROWSER_360,
                            mxbrowser: fi.MAXTHON,
                            "opr/": fi.OPERA,
                            ubrowser: fi.UC,
                            huaweibrowser: fi.HUAWEI
                        };
                        this.browserType = d[f] || f, this.browserVersion = "";
                        var p = /(mqqbrowser|micromessenger|qqbrowser|sogou|qzone|liebao|maxthon|uc|ucbs|360 aphone|360|baiduboxapp|baidu|maxthon|mxbrowser|miui(?:.hybrid)?)(mobile)?(browser)?\/?([\d.]+)/i.exec(r);
                        p || (p = /(qq|chrome|safari|firefox|trident|opera|opr\/|oupeng)(mobile)?(browser)?\/?([\d.]+)/i.exec(r)), this.browserVersion = p ? p[4] : "", this.pixelRatio = window.devicePixelRatio || 1;
                        var m, g = document.createElement("canvas"),
                            v = !!g.getContext("2d"),
                            y = !1;
                        window.WebGLRenderingContext && (y = !0);
                        try {
                            m = g.toDataURL("image/webp").startsWith("data:image/webp")
                        } catch (e) {
                            m = !1
                        }
                        var S = !1;
                        "undefined" != typeof createImageBitmap && "undefined" != typeof Blob && (g.width = g.height = 2, createImageBitmap(g, {}).then((function(e) {
                            S = !0, null == e || e.close()
                        })).catch((function() {}))), this.supportCapability = {
                            webp: m,
                            gl: y,
                            canvas: v,
                            imageBitmap: S
                        }, this._registerEvent()
                    }
                    var t = e.prototype;
                    return t._registerEvent = function() {
                        var e = this;
                        window.addEventListener("resize", (function() {
                            e._eventTarget.emit(di.RESIZE)
                        })), window.addEventListener("orientationchange", (function() {
                            e._eventTarget.emit(di.ORIENTATION_CHANGE)
                        })), this._registerVisibilityEvent()
                    }, t._registerVisibilityEvent = function() {
                        var e, t = this;
                        e = void 0 !== document.hidden ? "hidden" : void 0 !== document.mozHidden ? "mozHidden" : void 0 !== document.msHidden ? "msHidden" : void 0 !== document.webkitHidden ? "webkitHidden" : "hidden";
                        var n = !1,
                            i = function() {
                                n || (n = !0, t._eventTarget.emit(di.HIDE))
                            },
                            r = function(e, i, r, o, a) {
                                n && (n = !1, t._eventTarget.emit(di.SHOW, e, i, r, o, a))
                            };
                        if (e)
                            for (var o = ["visibilitychange", "mozvisibilitychange", "msvisibilitychange", "webkitvisibilitychange", "qbrowserVisibilityChange"], a = 0; a < o.length; a++) document.addEventListener(o[a], (function(t) {
                                var n = document[e];
                                (n = n || t.hidden) ? i(): r()
                            }));
                        else window.addEventListener("blur", i), window.addEventListener("focus", r);
                        window.navigator.userAgent.indexOf("MicroMessenger") > -1 && (window.onfocus = r), "onpageshow" in window && "onpagehide" in window && (window.addEventListener("pagehide", i), window.addEventListener("pageshow", r), document.addEventListener("pagehide", i), document.addEventListener("pageshow", r))
                    }, t.getViewSize = function() {
                        var e = document.getElementById("GameDiv");
                        return this.isMobile || !e || e === this._html ? new Xn(window.innerWidth, window.innerHeight) : new Xn(e.clientWidth, e.clientHeight)
                    }, t.getOrientation = function() {
                        throw new Error("TODO")
                    }, t.getSafeAreaEdge = function() {
                        throw new Error("TODO")
                    }, t.getBatteryLevel = function() {
                        return this._battery ? this._battery.level : 1
                    }, t.triggerGC = function() {}, t.openURL = function(e) {
                        window.open(e)
                    }, t.now = function() {
                        return Date.now ? Date.now() : +new Date
                    }, t.restartJSVM = function() {}, t.onHide = function(e) {
                        this._eventTarget.on(di.HIDE, e)
                    }, t.onShow = function(e) {
                        this._eventTarget.on(di.SHOW, e)
                    }, t.onViewResize = function(e) {
                        this._eventTarget.on(di.RESIZE, e)
                    }, t.onOrientationChange = function(e) {
                        this._eventTarget.on(di.ORIENTATION_CHANGE, e)
                    }, t.offHide = function(e) {
                        this._eventTarget.off(di.HIDE, e)
                    }, t.offShow = function(e) {
                        this._eventTarget.off(di.SHOW, e)
                    }, t.offViewResize = function(e) {
                        this._eventTarget.off(di.RESIZE, e)
                    }, t.offOrientationChange = function(e) {
                        this._eventTarget.off(di.ORIENTATION_CHANGE, e)
                    }, e
                }()),
                Ti = /(\.[^\.\/\?\\]*)(\?.*)?$/,
                Ai = /((.*)(\/|\\|\\\\))?(.*?\..*$)?/,
                xi = /[^\.\/]+\/\.\.\//;

            function Ci() {
                for (var e = "", t = arguments.length, n = new Array(t), i = 0; i < t; i++) n[i] = arguments[i];
                for (var r = 0, o = n; r < o.length; r++) {
                    var a = o[r];
                    e = (e + ("" === e ? "" : "/") + a).replace(/(\/|\\\\)$/, "")
                }
                return e
            }

            function bi(e) {
                var t = Ti.exec(e);
                return t ? t[1] : ""
            }

            function Ri(e) {
                if (e) {
                    var t = e.lastIndexOf(".");
                    if (-1 !== t) return e.substring(0, t)
                }
                return e
            }

            function wi(e, t) {
                var n = e.indexOf("?");
                n > 0 && (e = e.substring(0, n));
                var i = /(\/|\\)([^\/\\]+)$/g.exec(e.replace(/(\/|\\)$/, ""));
                if (!i) return e;
                var r = i[2];
                return t && e.substring(e.length - t.length).toLowerCase() === t.toLowerCase() ? r.substring(0, r.length - t.length) : r
            }

            function Ii(e) {
                var t = Ai.exec(e);
                return t ? t[2] : ""
            }

            function Pi(e, t) {
                t = t || "";
                var n = e.indexOf("?"),
                    i = "";
                return n > 0 && (i = e.substring(n), e = e.substring(0, n)), (n = e.lastIndexOf(".")) < 0 ? e + t + i : e.substring(0, n) + t + i
            }

            function Oi(e, t, n) {
                if (0 === t.indexOf(".")) return Pi(e, t);
                var i = e.indexOf("?"),
                    r = "",
                    o = n ? bi(e) : "";
                return i > 0 && (r = e.substring(i), e = e.substring(0, i)), i = (i = e.lastIndexOf("/")) <= 0 ? 0 : i + 1, e.substring(0, i) + t + o + r
            }

            function Di(e) {
                var t = e = String(e);
                do {
                    t = e, e = e.replace(xi, "")
                } while (t.length !== e.length);
                return e
            }

            function Ni(e) {
                return e.replace(/[\/\\]$/, "")
            }

            function Mi() {
                return Ei.os === gi.WINDOWS ? "\\" : "/"
            }
            e("path", Object.freeze({
                __proto__: null,
                join: Ci,
                extname: bi,
                mainFileName: Ri,
                basename: wi,
                dirname: Ii,
                changeExtname: Pi,
                changeBasename: Oi,
                _normalize: Di,
                stripSep: Ni,
                getSeperator: Mi
            })), i.log = f, i.warn = d, i.error = p, i.assert = m, i._throw = y, i.logID = T, i.warnID = x, i.errorID = b, i.assertID = I, i.debug = N, i.path = {
                join: Ci,
                extname: bi,
                mainFileName: Ri,
                basename: wi,
                dirname: Ii,
                changeExtname: Pi,
                changeBasename: Oi,
                _normalize: Di,
                stripSep: Ni,
                get sep() {
                    return Mi()
                }
            };
            var Li, Bi, Fi, zi, Ui, Gi, Hi, ki, Vi, Wi, ji, qi, Xi, Yi, Ki, Zi, Qi, Ji, $i, er, tr, nr, ir, rr, or, ar = 0,
                sr = {},
                cr = function() {
                    function e(e, t, n) {
                        this._arrayBuffers = [], this._chunkSize = void 0, this._chunkSize = n * (1 << t)
                    }
                    return e.prototype.allocateNewChunk = function() {
                        return new ArrayBuffer(this._chunkSize)
                    }, e
                }(),
                lr = function() {
                    function e() {}
                    return e.prototype.bind = function() {}, e
                }(),
                ur = function() {
                    function e() {}
                    var t = e.prototype;
                    return t.alloc = function(e, t) {
                        return new ArrayBuffer(t)
                    }, t.free = function() {}, e
                }();
            ! function(e) {
                e[e.UINT32 = 0] = "UINT32", e[e.FLOAT32 = 1] = "FLOAT32", e[e.NEVER = 2] = "NEVER"
            }(or || (or = {}));
            var hr, _r = function() {
                    function e(e, t, n, i) {
                        void 0 === i && (i = 8), this._dataType = void 0, this._elementCount = void 0, this._entryBits = void 0, this._stride = void 0, this._entriesPerChunk = void 0, this._entryMask = void 0, this._chunkMask = void 0, this._poolFlag = void 0, this._arrayBuffers = [], this._freelists = [], this._uint32BufferViews = [], this._float32BufferViews = [], this._hasUint32 = !1, this._hasFloat32 = !1, this._nativePool = void 0, this._elementCount = n.COUNT, this._entryBits = i, this._dataType = t, this._stride = 4 * this._elementCount, this._entriesPerChunk = 1 << i, this._entryMask = this._entriesPerChunk - 1, this._poolFlag = 1 << 30, this._chunkMask = ~(this._entryMask | this._poolFlag), this._nativePool = new cr(e, i, this._stride);
                        var r = or.NEVER,
                            o = !1,
                            a = !1;
                        for (var s in t) {
                            if (o = this._hasFloat32, (a = this._hasUint32) && o) break;
                            r = t[s], o || r !== or.FLOAT32 ? a || r !== or.UINT32 || (this._hasUint32 = !0) : this._hasFloat32 = !0
                        }
                    }
                    var t = e.prototype;
                    return t.alloc = function() {
                        for (var e = 0; e < this._freelists.length; e++) {
                            var t = this._freelists[e];
                            if (t.length) {
                                var n = t[t.length - 1];
                                return t.length--, (e << this._entryBits) + n + this._poolFlag
                            }
                        }
                        for (var i = this._nativePool.allocateNewChunk(), r = [], o = [], a = [], s = this._hasFloat32, c = this._hasUint32, l = 0; l < this._entriesPerChunk; l++) s && r.push(new Float32Array(i, this._stride * l, this._elementCount)), c && o.push(new Uint32Array(i, this._stride * l, this._elementCount)), l && a.push(l);
                        return this._arrayBuffers.push(i), c && this._uint32BufferViews.push(o), s && this._float32BufferViews.push(r), this._freelists.push(a), (e << this._entryBits) + this._poolFlag
                    }, t.get = function(e, t) {
                        var n = (this._chunkMask & e) >> this._entryBits,
                            i = this._entryMask & e;
                        return (this._dataType[t] === or.UINT32 ? this._uint32BufferViews : this._float32BufferViews)[n][i][t]
                    }, t.set = function(e, t, n) {
                        var i = (this._chunkMask & e) >> this._entryBits,
                            r = this._entryMask & e;
                        (this._dataType[t] === or.UINT32 ? this._uint32BufferViews : this._float32BufferViews)[i][r][t] = n
                    }, t.setVec2 = function() {}, t.setVec3 = function() {}, t.getVec3 = function() {}, t.setVec4 = function() {}, t.getVec4 = function() {}, t.setMat4 = function() {}, t.free = function(e) {
                        var t = (this._chunkMask & e) >> this._entryBits,
                            n = this._entryMask & e;
                        (this._hasUint32 ? this._uint32BufferViews : this._float32BufferViews)[t][n].fill(0), this._freelists[t].push(n)
                    }, e
                }(),
                fr = function() {
                    function e(e, t, n) {
                        this._ctor = void 0, this._dtor = void 0, this._indexMask = void 0, this._poolFlag = void 0, this._array = [], this._freelist = [], this._nativePool = void 0, this._ctor = t, n && (this._dtor = n), this._poolFlag = 1 << 29, this._indexMask = ~this._poolFlag, this._nativePool = new lr(e, this._array)
                    }
                    var t = e.prototype;
                    return t.alloc = function() {
                        for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
                        var i = this._freelist,
                            r = -1;
                        if (i.length) r = i[i.length - 1], i.length--, this._array[r] = this._ctor(arguments, this._array[r]);
                        else {
                            r = this._array.length;
                            var o = this._ctor(arguments);
                            if (!o) return 0;
                            this._array.push(o)
                        }
                        return r + this._poolFlag
                    }, t.get = function(e) {
                        var t = this._indexMask & e;
                        return this._array[t]
                    }, t.free = function(e) {
                        var t = this._indexMask & e;
                        this._dtor && (this._array[t] = this._dtor(this._array[t])), this._freelist.push(t)
                    }, e
                }(),
                dr = function() {
                    function e(e) {
                        this._nativeBufferAllocator = void 0, this._buffers = new Map, this._nextBufferIdx = 0, this._poolFlag = void 0, this._bufferIdxMask = void 0, this._freelist = [], this._poolFlag = 1 << 30, this._bufferIdxMask = ~this._poolFlag, this._nativeBufferAllocator = new ur(e)
                    }
                    var t = e.prototype;
                    return t.alloc = function(e) {
                        var t = this._freelist,
                            n = -1;
                        t.length ? (n = t[t.length - 1], t.length--) : n = this._nextBufferIdx++;
                        var i = this._nativeBufferAllocator.alloc(n, e);
                        return this._buffers.set(n, i), n | this._poolFlag
                    }, t.free = function(e) {
                        var t = this._bufferIdxMask & e;
                        this._buffers.get(t) && (this._nativeBufferAllocator.free(t), this._buffers.delete(t), this._freelist.push(t))
                    }, t.getBuffer = function(e) {
                        var t = this._bufferIdxMask & e;
                        return this._buffers.get(t) || null
                    }, e
                }(),
                pr = function(e) {
                    function t(t, n, i, r) {
                        var o;
                        return (o = e.call(this, t) || this)._viewCtor = void 0, o._size = void 0, o._step = void 0, o._viewCtor = n, o._size = i * n.BYTES_PER_ELEMENT, o._step = r || i, o
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.alloc = function() {
                        var e = this._nextBufferIdx++,
                            t = this._nativeBufferAllocator.alloc(e, this._size);
                        return this._buffers.set(e, new this._viewCtor(t)), e | this._poolFlag
                    }, n.getBuffer = function() {
                        return null
                    }, n.assign = function(e, t, n) {
                        var i = this._bufferIdxMask & e,
                            r = this._buffers.get(i);
                        if (r) {
                            var o = t + 1;
                            if (o >= r.length) {
                                for (var a = r.length; o >= a;) a += this._step;
                                a *= this._viewCtor.BYTES_PER_ELEMENT;
                                var s = new this._viewCtor(this._nativeBufferAllocator.alloc(i, a));
                                s.set(r), r = s, this._buffers.set(i, r)
                            }
                            r[o] = n;
                            var c = r[0];
                            r[0] = o > c ? o : c
                        }
                    }, n.erase = function(e, t) {
                        var n = this._bufferIdxMask & e,
                            i = this._buffers.get(n);
                        if (i && !(t >= i[0])) {
                            for (var r = t + 1; r < i[0]; ++r) i[r] = i[r + 1];
                            --i[0]
                        }
                    }, n.push = function(e, t) {
                        var n = this._bufferIdxMask & e,
                            i = this._buffers.get(n);
                        i && this.assign(e, i[0], t)
                    }, n.pop = function(e) {
                        var t = this._bufferIdxMask & e,
                            n = this._buffers.get(t);
                        n && 0 !== n[0] && --n[0]
                    }, n.clear = function(e) {
                        var t = this._bufferIdxMask & e,
                            n = this._buffers.get(t);
                        n && (n[0] = 0)
                    }, n.get = function(e, t) {
                        var n = this._bufferIdxMask & e,
                            i = this._buffers.get(n);
                        return !i || t >= i[0] ? 0 : i[t + 1]
                    }, n.length = function(e) {
                        var t = this._bufferIdxMask & e,
                            n = this._buffers.get(t);
                        return n ? n[0] : 0
                    }, t
                }(dr);

            function mr(e, t, n, i) {
                void 0 === i && (i = !0);
                for (var r = t.length(e), o = 0; o < r; o++) {
                    var a = t.get(e, o);
                    a && n.free(a)
                }
                i ? t.free(e) : t.clear(e)
            }! function(e) {
                e[e.ATTRIBUTE = 0] = "ATTRIBUTE", e[e.DESCRIPTOR_SETS = 1] = "DESCRIPTOR_SETS", e[e.SHADER = 2] = "SHADER", e[e.INPUT_ASSEMBLER = 3] = "INPUT_ASSEMBLER", e[e.PIPELINE_LAYOUT = 4] = "PIPELINE_LAYOUT", e[e.FRAMEBUFFER = 5] = "FRAMEBUFFER", e[e.PASS = 100] = "PASS", e[e.SUB_MODEL = 101] = "SUB_MODEL", e[e.MODEL = 102] = "MODEL", e[e.SCENE = 103] = "SCENE", e[e.CAMERA = 104] = "CAMERA", e[e.NODE = 105] = "NODE", e[e.ROOT = 106] = "ROOT", e[e.AABB = 107] = "AABB", e[e.RENDER_WINDOW = 108] = "RENDER_WINDOW", e[e.FRUSTUM = 109] = "FRUSTUM", e[e.AMBIENT = 110] = "AMBIENT", e[e.FOG = 111] = "FOG", e[e.SKYBOX = 112] = "SKYBOX", e[e.SHADOW = 113] = "SHADOW", e[e.LIGHT = 114] = "LIGHT", e[e.SPHERE = 115] = "SPHERE", e[e.INSTANCED_ATTRIBUTE = 116] = "INSTANCED_ATTRIBUTE", e[e.FLAT_BUFFER = 117] = "FLAT_BUFFER", e[e.SUB_MESH = 118] = "SUB_MESH", e[e.RASTERIZER_STATE = 119] = "RASTERIZER_STATE", e[e.DEPTH_STENCIL_STATE = 120] = "DEPTH_STENCIL_STATE", e[e.BLEND_TARGET = 121] = "BLEND_TARGET", e[e.BLEND_STATE = 122] = "BLEND_STATE", e[e.BATCH_2D = 123] = "BATCH_2D", e[e.PIPELINE_SCENE_DATA = 124] = "PIPELINE_SCENE_DATA", e[e.SUB_MODEL_ARRAY = 200] = "SUB_MODEL_ARRAY", e[e.MODEL_ARRAY = 201] = "MODEL_ARRAY", e[e.ATTRIBUTE_ARRAY = 202] = "ATTRIBUTE_ARRAY", e[e.FLAT_BUFFER_ARRAY = 203] = "FLAT_BUFFER_ARRAY", e[e.INSTANCED_BUFFER_ARRAY = 204] = "INSTANCED_BUFFER_ARRAY", e[e.LIGHT_ARRAY = 205] = "LIGHT_ARRAY", e[e.BLEND_TARGET_ARRAY = 206] = "BLEND_TARGET_ARRAY", e[e.BATCH_ARRAY_2D = 207] = "BATCH_ARRAY_2D", e[e.RAW_BUFFER = 300] = "RAW_BUFFER", e[e.RAW_OBJECT = 400] = "RAW_OBJECT"
            }(hr || (hr = {}));
            var gr, vr = new fr(hr.SHADER, (function(e, t) {
                    return t ? (t.initialize(e[1]), t) : e[0].createShader(e[1])
                }), (function(e) {
                    return e && e.destroy(), e
                })),
                yr = new fr(hr.DESCRIPTOR_SETS, (function(e, t) {
                    return t ? (t.initialize(e[1]), t) : e[0].createDescriptorSet(e[1])
                }), (function(e) {
                    return e && e.destroy(), e
                })),
                Sr = new fr(hr.INPUT_ASSEMBLER, (function(e, t) {
                    return t ? (t.initialize(e[1]), t) : e[0].createInputAssembler(e[1])
                }), (function(e) {
                    return e && e.destroy(), e
                })),
                Er = new fr(hr.PIPELINE_LAYOUT, (function(e, t) {
                    return t ? (t.initialize(e[1]), t) : e[0].createPipelineLayout(e[1])
                }), (function(e) {
                    return e && e.destroy(), e
                })),
                Tr = new fr(hr.FRAMEBUFFER, (function(e, t) {
                    return t ? (t.initialize(e[1]), t) : e[0].createFramebuffer(e[1])
                }), (function(e) {
                    return e && e.destroy(), e
                })),
                Ar = new pr(hr.SUB_MODEL_ARRAY, Uint32Array, 8, 4),
                xr = new pr(hr.MODEL_ARRAY, Uint32Array, 32, 16),
                Cr = new pr(hr.ATTRIBUTE_ARRAY, Uint32Array, 8, 4),
                br = new pr(hr.FLAT_BUFFER_ARRAY, Uint32Array, 8, 4),
                Rr = new pr(hr.LIGHT_ARRAY, Uint32Array, 8, 4),
                wr = new pr(hr.BLEND_TARGET_ARRAY, Uint32Array, 8, 4),
                Ir = new pr(hr.BATCH_ARRAY_2D, Uint32Array, 32, 16),
                Pr = new dr(hr.RAW_BUFFER),
                Or = new fr(hr.RAW_OBJECT, (function(e) {
                    return e[0] || {}
                }), (function() {}));
            ! function(e) {
                e[e.PRIORITY = 0] = "PRIORITY", e[e.STAGE = 1] = "STAGE", e[e.PHASE = 2] = "PHASE", e[e.BATCHING_SCHEME = 3] = "BATCHING_SCHEME", e[e.PRIMITIVE = 4] = "PRIMITIVE", e[e.DYNAMIC_STATES = 5] = "DYNAMIC_STATES", e[e.HASH = 6] = "HASH", e[e.RASTERIZER_STATE = 7] = "RASTERIZER_STATE", e[e.DEPTH_STENCIL_STATE = 8] = "DEPTH_STENCIL_STATE", e[e.BLEND_STATE = 9] = "BLEND_STATE", e[e.DESCRIPTOR_SET = 10] = "DESCRIPTOR_SET", e[e.PIPELINE_LAYOUT = 11] = "PIPELINE_LAYOUT", e[e.COUNT = 12] = "COUNT"
            }(gr || (gr = {}));
            var Dr, Nr = ((Li = {})[gr.PRIORITY] = or.UINT32, Li[gr.STAGE] = or.UINT32, Li[gr.PHASE] = or.UINT32, Li[gr.BATCHING_SCHEME] = or.UINT32, Li[gr.PRIMITIVE] = or.UINT32, Li[gr.DYNAMIC_STATES] = or.UINT32, Li[gr.HASH] = or.UINT32, Li[gr.RASTERIZER_STATE] = or.UINT32, Li[gr.DEPTH_STENCIL_STATE] = or.UINT32, Li[gr.BLEND_STATE] = or.UINT32, Li[gr.DESCRIPTOR_SET] = or.UINT32, Li[gr.PIPELINE_LAYOUT] = or.UINT32, Li[gr.COUNT] = or.NEVER, Li),
                Mr = new _r(hr.PASS, Nr, gr);
            ! function(e) {
                e[e.PRIORITY = 0] = "PRIORITY", e[e.PASS_COUNT = 1] = "PASS_COUNT", e[e.PASS_0 = 2] = "PASS_0", e[e.PASS_1 = 3] = "PASS_1", e[e.PASS_2 = 4] = "PASS_2", e[e.PASS_3 = 5] = "PASS_3", e[e.PASS_4 = 6] = "PASS_4", e[e.PASS_5 = 7] = "PASS_5", e[e.PASS_6 = 8] = "PASS_6", e[e.PASS_7 = 9] = "PASS_7", e[e.SHADER_0 = 10] = "SHADER_0", e[e.SHADER_1 = 11] = "SHADER_1", e[e.SHADER_2 = 12] = "SHADER_2", e[e.SHADER_3 = 13] = "SHADER_3", e[e.SHADER_4 = 14] = "SHADER_4", e[e.SHADER_5 = 15] = "SHADER_5", e[e.SHADER_6 = 16] = "SHADER_6", e[e.SHADER_7 = 17] = "SHADER_7", e[e.PLANAR_SHADER = 18] = "PLANAR_SHADER", e[e.PLANAR_INSTANCE_SHADER = 19] = "PLANAR_INSTANCE_SHADER", e[e.DESCRIPTOR_SET = 20] = "DESCRIPTOR_SET", e[e.INPUT_ASSEMBLER = 21] = "INPUT_ASSEMBLER", e[e.SUB_MESH = 22] = "SUB_MESH", e[e.COUNT = 23] = "COUNT"
            }(Dr || (Dr = {}));
            var Lr, Br = ((Bi = {})[Dr.PRIORITY] = or.UINT32, Bi[Dr.PASS_COUNT] = or.UINT32, Bi[Dr.PASS_0] = or.UINT32, Bi[Dr.PASS_1] = or.UINT32, Bi[Dr.PASS_2] = or.UINT32, Bi[Dr.PASS_3] = or.UINT32, Bi[Dr.PASS_4] = or.UINT32, Bi[Dr.PASS_5] = or.UINT32, Bi[Dr.PASS_6] = or.UINT32, Bi[Dr.PASS_7] = or.UINT32, Bi[Dr.SHADER_0] = or.UINT32, Bi[Dr.SHADER_1] = or.UINT32, Bi[Dr.SHADER_2] = or.UINT32, Bi[Dr.SHADER_3] = or.UINT32, Bi[Dr.SHADER_4] = or.UINT32, Bi[Dr.SHADER_5] = or.UINT32, Bi[Dr.SHADER_6] = or.UINT32, Bi[Dr.SHADER_7] = or.UINT32, Bi[Dr.PLANAR_SHADER] = or.UINT32, Bi[Dr.PLANAR_INSTANCE_SHADER] = or.UINT32, Bi[Dr.DESCRIPTOR_SET] = or.UINT32, Bi[Dr.INPUT_ASSEMBLER] = or.UINT32, Bi[Dr.SUB_MESH] = or.UINT32, Bi[Dr.COUNT] = or.NEVER, Bi),
                Fr = new _r(hr.SUB_MODEL, Br, Dr);
            ! function(e) {
                e[e.ENABLED = 0] = "ENABLED", e[e.VIS_FLAGS = 1] = "VIS_FLAGS", e[e.CAST_SHADOW = 2] = "CAST_SHADOW", e[e.RECEIVE_SHADOW = 3] = "RECEIVE_SHADOW", e[e.WORLD_BOUNDS = 4] = "WORLD_BOUNDS", e[e.NODE = 5] = "NODE", e[e.TRANSFORM = 6] = "TRANSFORM", e[e.SUB_MODEL_ARRAY = 7] = "SUB_MODEL_ARRAY", e[e.INSTANCED_BUFFER = 8] = "INSTANCED_BUFFER", e[e.INSTANCED_ATTR_ARRAY = 9] = "INSTANCED_ATTR_ARRAY", e[e.COUNT = 10] = "COUNT"
            }(Lr || (Lr = {}));
            var zr, Ur = ((Fi = {})[Lr.ENABLED] = or.UINT32, Fi[Lr.VIS_FLAGS] = or.UINT32, Fi[Lr.CAST_SHADOW] = or.UINT32, Fi[Lr.RECEIVE_SHADOW] = or.UINT32, Fi[Lr.WORLD_BOUNDS] = or.UINT32, Fi[Lr.NODE] = or.UINT32, Fi[Lr.TRANSFORM] = or.UINT32, Fi[Lr.SUB_MODEL_ARRAY] = or.UINT32, Fi[Lr.INSTANCED_BUFFER] = or.UINT32, Fi[Lr.INSTANCED_ATTR_ARRAY] = or.UINT32, Fi[Lr.COUNT] = or.NEVER, Fi),
                Gr = new _r(hr.MODEL, Ur, Lr);
            ! function(e) {
                e[e.VIS_FLAGS = 0] = "VIS_FLAGS", e[e.PASS_COUNT = 1] = "PASS_COUNT", e[e.PASS_0 = 2] = "PASS_0", e[e.PASS_1 = 3] = "PASS_1", e[e.PASS_2 = 4] = "PASS_2", e[e.PASS_3 = 5] = "PASS_3", e[e.SHADER_0 = 6] = "SHADER_0", e[e.SHADER_1 = 7] = "SHADER_1", e[e.SHADER_2 = 8] = "SHADER_2", e[e.SHADER_3 = 9] = "SHADER_3", e[e.DESCRIPTOR_SET = 10] = "DESCRIPTOR_SET", e[e.INPUT_ASSEMBLER = 11] = "INPUT_ASSEMBLER", e[e.COUNT = 12] = "COUNT"
            }(zr || (zr = {}));
            var Hr, kr = ((zi = {})[zr.VIS_FLAGS] = or.UINT32, zi[zr.PASS_COUNT] = or.UINT32, zi[zr.PASS_0] = or.UINT32, zi[zr.PASS_1] = or.UINT32, zi[zr.PASS_2] = or.UINT32, zi[zr.PASS_3] = or.UINT32, zi[zr.SHADER_0] = or.UINT32, zi[zr.SHADER_1] = or.UINT32, zi[zr.SHADER_2] = or.UINT32, zi[zr.SHADER_3] = or.UINT32, zi[zr.DESCRIPTOR_SET] = or.UINT32, zi[zr.INPUT_ASSEMBLER] = or.UINT32, zi[zr.COUNT] = or.NEVER, zi),
                Vr = new _r(hr.BATCH_2D, kr, zr);
            ! function(e) {
                e[e.CENTER = 0] = "CENTER", e[e.HALF_EXTENSION = 3] = "HALF_EXTENSION", e[e.COUNT = 6] = "COUNT"
            }(Hr || (Hr = {}));
            var Wr, jr = ((Ui = {})[Hr.CENTER] = or.FLOAT32, Ui[Hr.HALF_EXTENSION] = or.FLOAT32, Ui[Hr.COUNT] = or.NEVER, Ui),
                qr = new _r(hr.AABB, jr, Hr);
            ! function(e) {
                e[e.MAIN_LIGHT = 0] = "MAIN_LIGHT", e[e.MODEL_ARRAY = 1] = "MODEL_ARRAY", e[e.SPHERE_LIGHT_ARRAY = 2] = "SPHERE_LIGHT_ARRAY", e[e.SPOT_LIGHT_ARRAY = 3] = "SPOT_LIGHT_ARRAY", e[e.BATCH_ARRAY_2D = 4] = "BATCH_ARRAY_2D", e[e.COUNT = 5] = "COUNT"
            }(Wr || (Wr = {}));
            var Xr, Yr = ((Gi = {})[Wr.MAIN_LIGHT] = or.UINT32, Gi[Wr.MODEL_ARRAY] = or.UINT32, Gi[Wr.SPHERE_LIGHT_ARRAY] = or.UINT32, Gi[Wr.SPOT_LIGHT_ARRAY] = or.UINT32, Gi[Wr.BATCH_ARRAY_2D] = or.UINT32, Gi[Wr.COUNT] = or.NEVER, Gi),
                Kr = new _r(hr.SCENE, Yr, Wr);
            ! function(e) {
                e[e.WIDTH = 0] = "WIDTH", e[e.HEIGHT = 1] = "HEIGHT", e[e.EXPOSURE = 2] = "EXPOSURE", e[e.CLEAR_FLAGS = 3] = "CLEAR_FLAGS", e[e.CLEAR_DEPTH = 4] = "CLEAR_DEPTH", e[e.CLEAR_STENCIL = 5] = "CLEAR_STENCIL", e[e.VISIBILITY = 6] = "VISIBILITY", e[e.NODE = 7] = "NODE", e[e.SCENE = 8] = "SCENE", e[e.FRUSTUM = 9] = "FRUSTUM", e[e.WINDOW = 10] = "WINDOW", e[e.FORWARD = 11] = "FORWARD", e[e.POSITION = 14] = "POSITION", e[e.VIEW_PORT = 17] = "VIEW_PORT", e[e.CLEAR_COLOR = 21] = "CLEAR_COLOR", e[e.MAT_VIEW = 25] = "MAT_VIEW", e[e.MAT_VIEW_PROJ = 41] = "MAT_VIEW_PROJ", e[e.MAT_VIEW_PROJ_INV = 57] = "MAT_VIEW_PROJ_INV", e[e.MAT_PROJ = 73] = "MAT_PROJ", e[e.MAT_PROJ_INV = 89] = "MAT_PROJ_INV", e[e.MAT_VIEW_PROJ_OFFSCREEN = 105] = "MAT_VIEW_PROJ_OFFSCREEN", e[e.MAT_VIEW_PROJ_INV_OFFSCREEN = 121] = "MAT_VIEW_PROJ_INV_OFFSCREEN", e[e.MAT_PROJ_OFFSCREEN = 137] = "MAT_PROJ_OFFSCREEN", e[e.MAT_PROJ_INV_OFFSCREEN = 153] = "MAT_PROJ_INV_OFFSCREEN", e[e.COUNT = 169] = "COUNT"
            }(Xr || (Xr = {}));
            var Zr, Qr = ((Hi = {})[Xr.WIDTH] = or.UINT32, Hi[Xr.HEIGHT] = or.UINT32, Hi[Xr.EXPOSURE] = or.FLOAT32, Hi[Xr.CLEAR_FLAGS] = or.UINT32, Hi[Xr.CLEAR_DEPTH] = or.FLOAT32, Hi[Xr.CLEAR_STENCIL] = or.UINT32, Hi[Xr.VISIBILITY] = or.UINT32, Hi[Xr.NODE] = or.UINT32, Hi[Xr.SCENE] = or.UINT32, Hi[Xr.FRUSTUM] = or.UINT32, Hi[Xr.WINDOW] = or.UINT32, Hi[Xr.FORWARD] = or.FLOAT32, Hi[Xr.POSITION] = or.FLOAT32, Hi[Xr.VIEW_PORT] = or.FLOAT32, Hi[Xr.CLEAR_COLOR] = or.FLOAT32, Hi[Xr.MAT_VIEW] = or.FLOAT32, Hi[Xr.MAT_VIEW_PROJ] = or.FLOAT32, Hi[Xr.MAT_VIEW_PROJ_INV] = or.FLOAT32, Hi[Xr.MAT_PROJ] = or.FLOAT32, Hi[Xr.MAT_PROJ_INV] = or.FLOAT32, Hi[Xr.MAT_VIEW_PROJ_OFFSCREEN] = or.FLOAT32, Hi[Xr.MAT_VIEW_PROJ_INV_OFFSCREEN] = or.FLOAT32, Hi[Xr.MAT_PROJ_OFFSCREEN] = or.FLOAT32, Hi[Xr.MAT_PROJ_INV_OFFSCREEN] = or.FLOAT32, Hi[Xr.COUNT] = or.NEVER, Hi),
                Jr = new _r(hr.CAMERA, Qr, Xr);
            ! function(e) {
                e[e.FLAGS_CHANGED = 0] = "FLAGS_CHANGED", e[e.LAYER = 1] = "LAYER", e[e.WORLD_SCALE = 2] = "WORLD_SCALE", e[e.WORLD_POSITION = 5] = "WORLD_POSITION", e[e.WORLD_ROTATION = 8] = "WORLD_ROTATION", e[e.WORLD_MATRIX = 12] = "WORLD_MATRIX", e[e.COUNT = 28] = "COUNT"
            }(Zr || (Zr = {}));
            var $r = ((ki = {})[Zr.FLAGS_CHANGED] = or.UINT32, ki[Zr.LAYER] = or.UINT32, ki[Zr.WORLD_SCALE] = or.FLOAT32, ki[Zr.WORLD_POSITION] = or.FLOAT32, ki[Zr.WORLD_ROTATION] = or.FLOAT32, ki[Zr.WORLD_MATRIX] = or.FLOAT32, ki[Zr.COUNT] = or.NEVER, ki);
            delete Zr[Zr.COUNT], Zr[Zr.COUNT = Zr.LAYER + 1] = "COUNT";
            var eo, to = new _r(hr.NODE, $r, Zr);
            ! function(e) {
                e[e.CUMULATIVE_TIME = 0] = "CUMULATIVE_TIME", e[e.FRAME_TIME = 1] = "FRAME_TIME", e[e.COUNT = 2] = "COUNT"
            }(eo || (eo = {}));
            var no, io = ((Vi = {})[eo.CUMULATIVE_TIME] = or.FLOAT32, Vi[eo.FRAME_TIME] = or.FLOAT32, Vi[eo.COUNT] = or.NEVER, Vi),
                ro = new _r(hr.ROOT, io, eo, 1);
            ! function(e) {
                e[e.HAS_ON_SCREEN_ATTACHMENTS = 0] = "HAS_ON_SCREEN_ATTACHMENTS", e[e.HAS_OFF_SCREEN_ATTACHMENTS = 1] = "HAS_OFF_SCREEN_ATTACHMENTS", e[e.FRAMEBUFFER = 2] = "FRAMEBUFFER", e[e.COUNT = 3] = "COUNT"
            }(no || (no = {}));
            var oo, ao = ((Wi = {})[no.HAS_ON_SCREEN_ATTACHMENTS] = or.UINT32, Wi[no.HAS_OFF_SCREEN_ATTACHMENTS] = or.UINT32, Wi[no.FRAMEBUFFER] = or.UINT32, Wi[no.COUNT] = or.NEVER, Wi),
                so = new _r(hr.RENDER_WINDOW, ao, no, 2);
            ! function(e) {
                e[e.VERTICES = 0] = "VERTICES", e[e.PLANES = 24] = "PLANES", e[e.COUNT = 48] = "COUNT"
            }(oo || (oo = {}));
            var co, lo = ((ji = {})[oo.VERTICES] = or.FLOAT32, ji[oo.PLANES] = or.FLOAT32, ji[oo.COUNT] = or.NEVER, ji),
                uo = new _r(hr.FRUSTUM, lo, oo);
            ! function(e) {
                e[e.ENABLE = 0] = "ENABLE", e[e.ILLUM = 1] = "ILLUM", e[e.SKY_COLOR = 2] = "SKY_COLOR", e[e.GROUND_ALBEDO = 6] = "GROUND_ALBEDO", e[e.COUNT = 10] = "COUNT"
            }(co || (co = {}));
            var ho = ((qi = {})[co.ENABLE] = or.UINT32, qi[co.ILLUM] = or.FLOAT32, qi[co.SKY_COLOR] = or.FLOAT32, qi[co.GROUND_ALBEDO] = or.FLOAT32, qi[co.COUNT] = or.NEVER, qi);
            delete co[co.COUNT], co[co.COUNT = co.ILLUM + 1] = "COUNT";
            var _o, fo = new _r(hr.AMBIENT, ho, co, 1);
            ! function(e) {
                e[e.ENABLE = 0] = "ENABLE", e[e.IS_RGBE = 1] = "IS_RGBE", e[e.USE_IBL = 2] = "USE_IBL", e[e.MODEL = 3] = "MODEL", e[e.COUNT = 4] = "COUNT"
            }(_o || (_o = {}));
            var po, mo = ((Xi = {})[_o.ENABLE] = or.UINT32, Xi[_o.IS_RGBE] = or.UINT32, Xi[_o.USE_IBL] = or.UINT32, Xi[_o.MODEL] = or.UINT32, Xi[_o.COUNT] = or.NEVER, Xi),
                go = new _r(hr.SKYBOX, mo, _o, 1);
            ! function(e) {
                e[e.ENABLE = 0] = "ENABLE", e[e.TYPE = 1] = "TYPE", e[e.DENSITY = 2] = "DENSITY", e[e.START = 3] = "START", e[e.END = 4] = "END", e[e.ATTEN = 5] = "ATTEN", e[e.TOP = 6] = "TOP", e[e.RANGE = 7] = "RANGE", e[e.COLOR = 8] = "COLOR", e[e.COUNT = 12] = "COUNT"
            }(po || (po = {}));
            var vo = ((Yi = {})[po.ENABLE] = or.UINT32, Yi[po.TYPE] = or.UINT32, Yi[po.DENSITY] = or.FLOAT32, Yi[po.START] = or.FLOAT32, Yi[po.END] = or.FLOAT32, Yi[po.ATTEN] = or.FLOAT32, Yi[po.TOP] = or.FLOAT32, Yi[po.RANGE] = or.FLOAT32, Yi[po.COLOR] = or.FLOAT32, Yi[po.COUNT] = or.NEVER, Yi);
            delete po[po.COUNT], po[po.COUNT = po.RANGE + 1] = "COUNT";
            var yo, So = new _r(hr.FOG, vo, po);
            ! function(e) {
                e[e.ENABLE = 0] = "ENABLE", e[e.DIRTY = 1] = "DIRTY", e[e.TYPE = 2] = "TYPE", e[e.DISTANCE = 3] = "DISTANCE", e[e.INSTANCE_PASS = 4] = "INSTANCE_PASS", e[e.PLANAR_PASS = 5] = "PLANAR_PASS", e[e.NEAR = 6] = "NEAR", e[e.FAR = 7] = "FAR", e[e.ASPECT = 8] = "ASPECT", e[e.PCF_TYPE = 9] = "PCF_TYPE", e[e.SHADOW_MAP_DIRTY = 10] = "SHADOW_MAP_DIRTY", e[e.BIAS = 11] = "BIAS", e[e.PACKING = 12] = "PACKING", e[e.LINEAR = 13] = "LINEAR", e[e.SELF_SHADOW = 14] = "SELF_SHADOW", e[e.NORMAL_BIAS = 15] = "NORMAL_BIAS", e[e.ORTHO_SIZE = 16] = "ORTHO_SIZE", e[e.AUTO_ADAPT = 17] = "AUTO_ADAPT", e[e.COLOR = 18] = "COLOR", e[e.SIZE = 22] = "SIZE", e[e.NORMAL = 24] = "NORMAL", e[e.MAT_LIGHT = 27] = "MAT_LIGHT", e[e.COUNT = 43] = "COUNT"
            }(yo || (yo = {}));
            var Eo = ((Ki = {})[yo.ENABLE] = or.UINT32, Ki[yo.DIRTY] = or.UINT32, Ki[yo.TYPE] = or.UINT32, Ki[yo.DISTANCE] = or.FLOAT32, Ki[yo.INSTANCE_PASS] = or.UINT32, Ki[yo.PLANAR_PASS] = or.UINT32, Ki[yo.NEAR] = or.FLOAT32, Ki[yo.FAR] = or.FLOAT32, Ki[yo.ASPECT] = or.FLOAT32, Ki[yo.PCF_TYPE] = or.UINT32, Ki[yo.SHADOW_MAP_DIRTY] = or.UINT32, Ki[yo.BIAS] = or.FLOAT32, Ki[yo.PACKING] = or.UINT32, Ki[yo.LINEAR] = or.UINT32, Ki[yo.SELF_SHADOW] = or.UINT32, Ki[yo.NORMAL_BIAS] = or.FLOAT32, Ki[yo.ORTHO_SIZE] = or.FLOAT32, Ki[yo.AUTO_ADAPT] = or.UINT32, Ki[yo.COLOR] = or.FLOAT32, Ki[yo.SIZE] = or.FLOAT32, Ki[yo.NORMAL] = or.FLOAT32, Ki[yo.MAT_LIGHT] = or.FLOAT32, Ki[yo.COUNT] = or.NEVER, Ki);
            delete yo[yo.COUNT], yo[yo.COUNT = yo.AUTO_ADAPT + 1] = "COUNT";
            var To, Ao = new _r(hr.SHADOW, Eo, yo, 1);
            ! function(e) {
                e[e.SHADOW = 0] = "SHADOW", e[e.SKYBOX = 1] = "SKYBOX", e[e.AMBIENT = 2] = "AMBIENT", e[e.FOG = 3] = "FOG", e[e.IS_HDR = 4] = "IS_HDR", e[e.SHADING_SCALE = 5] = "SHADING_SCALE", e[e.FP_SCALE = 6] = "FP_SCALE", e[e.DEFERRED_LIGHT_PASS = 7] = "DEFERRED_LIGHT_PASS", e[e.DEFERRED_LIGHT_PASS_SHADER = 8] = "DEFERRED_LIGHT_PASS_SHADER", e[e.DEFERRED_POST_PASS = 9] = "DEFERRED_POST_PASS", e[e.DEFERRED_POST_PASS_SHADER = 10] = "DEFERRED_POST_PASS_SHADER", e[e.COUNT = 11] = "COUNT"
            }(To || (To = {}));
            var xo, Co = ((Zi = {})[To.SHADOW] = or.UINT32, Zi[To.SKYBOX] = or.UINT32, Zi[To.AMBIENT] = or.UINT32, Zi[To.FOG] = or.UINT32, Zi[To.IS_HDR] = or.UINT32, Zi[To.SHADING_SCALE] = or.UINT32, Zi[To.FP_SCALE] = or.UINT32, Zi[To.DEFERRED_LIGHT_PASS] = or.UINT32, Zi[To.DEFERRED_LIGHT_PASS_SHADER] = or.UINT32, Zi[To.DEFERRED_POST_PASS] = or.UINT32, Zi[To.DEFERRED_POST_PASS_SHADER] = or.UINT32, Zi[To.COUNT] = or.NEVER, Zi),
                bo = new _r(hr.PIPELINE_SCENE_DATA, Co, To, 1);
            ! function(e) {
                e[e.USE_COLOR_TEMPERATURE = 0] = "USE_COLOR_TEMPERATURE", e[e.ILLUMINANCE = 1] = "ILLUMINANCE", e[e.NODE = 2] = "NODE", e[e.RANGE = 3] = "RANGE", e[e.TYPE = 4] = "TYPE", e[e.AABB = 5] = "AABB", e[e.FRUSTUM = 6] = "FRUSTUM", e[e.SIZE = 7] = "SIZE", e[e.SPOT_ANGLE = 8] = "SPOT_ANGLE", e[e.ASPECT = 9] = "ASPECT", e[e.DIRECTION = 10] = "DIRECTION", e[e.COLOR = 13] = "COLOR", e[e.COLOR_TEMPERATURE_RGB = 16] = "COLOR_TEMPERATURE_RGB", e[e.POSITION = 19] = "POSITION", e[e.COUNT = 22] = "COUNT"
            }(xo || (xo = {}));
            var Ro, wo = ((Qi = {})[xo.USE_COLOR_TEMPERATURE] = or.UINT32, Qi[xo.ILLUMINANCE] = or.FLOAT32, Qi[xo.NODE] = or.UINT32, Qi[xo.RANGE] = or.FLOAT32, Qi[xo.TYPE] = or.UINT32, Qi[xo.AABB] = or.UINT32, Qi[xo.FRUSTUM] = or.UINT32, Qi[xo.SIZE] = or.FLOAT32, Qi[xo.SPOT_ANGLE] = or.FLOAT32, Qi[xo.ASPECT] = or.FLOAT32, Qi[xo.DIRECTION] = or.FLOAT32, Qi[xo.COLOR] = or.FLOAT32, Qi[xo.COLOR_TEMPERATURE_RGB] = or.FLOAT32, Qi[xo.POSITION] = or.FLOAT32, Qi[xo.COUNT] = or.NEVER, Qi),
                Io = new _r(hr.LIGHT, wo, xo, 3);
            ! function(e) {
                e[e.RADIUS = 0] = "RADIUS", e[e.CENTER = 1] = "CENTER", e[e.COUNT = 4] = "COUNT"
            }(Ro || (Ro = {}));
            var Po = ((Ji = {})[Ro.RADIUS] = or.FLOAT32, Ji[Ro.CENTER] = or.FLOAT32, Ji[Ro.COUNT] = or.NEVER, Ji);
            delete Ro[Ro.COUNT], Ro[Ro.COUNT = Ro.RADIUS + 1] = "COUNT";
            var Oo, Do = new _r(hr.SPHERE, Po, Ro, 3);
            ! function(e) {
                e[e.STRIDE = 0] = "STRIDE", e[e.AMOUNT = 1] = "AMOUNT", e[e.BUFFER = 2] = "BUFFER", e[e.COUNT = 3] = "COUNT"
            }(Oo || (Oo = {}));
            var No, Mo = (($i = {})[Oo.STRIDE] = or.UINT32, $i[Oo.AMOUNT] = or.UINT32, $i[Oo.BUFFER] = or.UINT32, $i[Oo.COUNT] = or.NEVER, $i),
                Lo = new _r(hr.FLAT_BUFFER, Mo, Oo, 3);
            ! function(e) {
                e[e.FLAT_BUFFER_ARRAY = 0] = "FLAT_BUFFER_ARRAY", e[e.COUNT = 1] = "COUNT"
            }(No || (No = {}));
            var Bo, Fo = ((er = {})[No.FLAT_BUFFER_ARRAY] = or.UINT32, er[No.COUNT] = or.NEVER, er),
                zo = new _r(hr.SUB_MESH, Fo, No, 3);
            ! function(e) {
                e[e.IS_DISCARD = 0] = "IS_DISCARD", e[e.POLYGO_MODEL = 1] = "POLYGO_MODEL", e[e.SHADE_MODEL = 2] = "SHADE_MODEL", e[e.CULL_MODE = 3] = "CULL_MODE", e[e.IS_FRONT_FACE_CCW = 4] = "IS_FRONT_FACE_CCW", e[e.DEPTH_BIAS_ENABLED = 5] = "DEPTH_BIAS_ENABLED", e[e.DEPTH_BIAS = 6] = "DEPTH_BIAS", e[e.DEPTH_BIAS_CLAMP = 7] = "DEPTH_BIAS_CLAMP", e[e.DEPTH_BIAS_SLOP = 8] = "DEPTH_BIAS_SLOP", e[e.IS_DEPTH_CLIP = 9] = "IS_DEPTH_CLIP", e[e.IS_MULTI_SAMPLE = 10] = "IS_MULTI_SAMPLE", e[e.LINE_WIDTH = 11] = "LINE_WIDTH", e[e.COUNT = 12] = "COUNT"
            }(Bo || (Bo = {}));
            var Uo, Go = ((tr = {})[Bo.IS_DISCARD] = or.UINT32, tr[Bo.POLYGO_MODEL] = or.UINT32, tr[Bo.SHADE_MODEL] = or.UINT32, tr[Bo.CULL_MODE] = or.UINT32, tr[Bo.IS_FRONT_FACE_CCW] = or.UINT32, tr[Bo.DEPTH_BIAS_ENABLED] = or.UINT32, tr[Bo.DEPTH_BIAS] = or.FLOAT32, tr[Bo.DEPTH_BIAS_CLAMP] = or.FLOAT32, tr[Bo.DEPTH_BIAS_SLOP] = or.FLOAT32, tr[Bo.IS_DEPTH_CLIP] = or.UINT32, tr[Bo.IS_MULTI_SAMPLE] = or.UINT32, tr[Bo.LINE_WIDTH] = or.FLOAT32, tr[Bo.COUNT] = or.NEVER, tr),
                Ho = new _r(hr.RASTERIZER_STATE, Go, Bo, 9);
            ! function(e) {
                e[e.DEPTH_TEST = 0] = "DEPTH_TEST", e[e.DEPTH_WRITE = 1] = "DEPTH_WRITE", e[e.DEPTH_FUNC = 2] = "DEPTH_FUNC", e[e.STENCIL_TEST_FRONT = 3] = "STENCIL_TEST_FRONT", e[e.STENCIL_FUNC_FRONT = 4] = "STENCIL_FUNC_FRONT", e[e.STENCIL_READ_MASK_FRONT = 5] = "STENCIL_READ_MASK_FRONT", e[e.STENCIL_WRITE_MASK_FRONT = 6] = "STENCIL_WRITE_MASK_FRONT", e[e.STENCIL_FAIL_OP_FRONT = 7] = "STENCIL_FAIL_OP_FRONT", e[e.STENCIL_Z_FAIL_OP_FRONT = 8] = "STENCIL_Z_FAIL_OP_FRONT", e[e.STENCIL_PASS_OP_FRONT = 9] = "STENCIL_PASS_OP_FRONT", e[e.STENCIL_REF_FRONT = 10] = "STENCIL_REF_FRONT", e[e.STENCIL_TEST_BACK = 11] = "STENCIL_TEST_BACK", e[e.STENCIL_FUNC_BACK = 12] = "STENCIL_FUNC_BACK", e[e.STENCIL_READ_MADK_BACK = 13] = "STENCIL_READ_MADK_BACK", e[e.STENCIL_WRITE_MASK_BACK = 14] = "STENCIL_WRITE_MASK_BACK", e[e.STENCIL_FAIL_OP_BACK = 15] = "STENCIL_FAIL_OP_BACK", e[e.STENCIL_Z_FAIL_OP_BACK = 16] = "STENCIL_Z_FAIL_OP_BACK", e[e.STENCIL_PASS_OP_BACK = 17] = "STENCIL_PASS_OP_BACK", e[e.STENCIL_REF_BACK = 18] = "STENCIL_REF_BACK", e[e.COUNT = 19] = "COUNT"
            }(Uo || (Uo = {}));
            var ko, Vo = ((nr = {})[Uo.DEPTH_TEST] = or.UINT32, nr[Uo.DEPTH_WRITE] = or.UINT32, nr[Uo.DEPTH_FUNC] = or.UINT32, nr[Uo.STENCIL_TEST_FRONT] = or.UINT32, nr[Uo.STENCIL_FUNC_FRONT] = or.UINT32, nr[Uo.STENCIL_READ_MASK_FRONT] = or.UINT32, nr[Uo.STENCIL_WRITE_MASK_FRONT] = or.UINT32, nr[Uo.STENCIL_FAIL_OP_FRONT] = or.UINT32, nr[Uo.STENCIL_Z_FAIL_OP_FRONT] = or.UINT32, nr[Uo.STENCIL_PASS_OP_FRONT] = or.UINT32, nr[Uo.STENCIL_REF_FRONT] = or.UINT32, nr[Uo.STENCIL_TEST_BACK] = or.UINT32, nr[Uo.STENCIL_FUNC_BACK] = or.UINT32, nr[Uo.STENCIL_READ_MADK_BACK] = or.UINT32, nr[Uo.STENCIL_WRITE_MASK_BACK] = or.UINT32, nr[Uo.STENCIL_FAIL_OP_BACK] = or.UINT32, nr[Uo.STENCIL_Z_FAIL_OP_BACK] = or.UINT32, nr[Uo.STENCIL_PASS_OP_BACK] = or.UINT32, nr[Uo.STENCIL_REF_BACK] = or.UINT32, nr[Uo.COUNT] = or.NEVER, nr),
                Wo = new _r(hr.DEPTH_STENCIL_STATE, Vo, Uo, 9);
            ! function(e) {
                e[e.BLEND = 0] = "BLEND", e[e.BLEND_SRC = 1] = "BLEND_SRC", e[e.BLEND_DST = 2] = "BLEND_DST", e[e.BLEND_EQ = 3] = "BLEND_EQ", e[e.BLEND_SRC_ALPHA = 4] = "BLEND_SRC_ALPHA", e[e.BLEND_DST_ALPHA = 5] = "BLEND_DST_ALPHA", e[e.BLEND_ALPHA_EQ = 6] = "BLEND_ALPHA_EQ", e[e.BLEND_COLOR_MASK = 7] = "BLEND_COLOR_MASK", e[e.COUNT = 8] = "COUNT"
            }(ko || (ko = {})), (ir = {})[ko.BLEND] = or.UINT32, ir[ko.BLEND_SRC] = or.UINT32, ir[ko.BLEND_DST] = or.UINT32, ir[ko.BLEND_EQ] = or.UINT32, ir[ko.BLEND_SRC_ALPHA] = or.UINT32, ir[ko.BLEND_DST_ALPHA] = or.UINT32, ir[ko.BLEND_ALPHA_EQ] = or.UINT32, ir[ko.BLEND_COLOR_MASK] = or.UINT32, ir[ko.COUNT] = or.NEVER;
            var jo, qo = new _r(hr.BLEND_TARGET, Vo, ko, 9);
            ! function(e) {
                e[e.IS_A2C = 0] = "IS_A2C", e[e.IS_INDEPEND = 1] = "IS_INDEPEND", e[e.BLEND_COLOR = 2] = "BLEND_COLOR", e[e.BLEND_TARGET = 6] = "BLEND_TARGET", e[e.COUNT = 7] = "COUNT"
            }(jo || (jo = {}));
            var Xo = ((rr = {})[jo.IS_A2C] = or.UINT32, rr[jo.IS_INDEPEND] = or.UINT32, rr[jo.BLEND_COLOR] = or.FLOAT32, rr[jo.BLEND_TARGET] = or.UINT32, rr[jo.COUNT] = or.NEVER, rr),
                Yo = new _r(hr.BLEND_STATE, Xo, jo, 9),
                Ko = function() {
                    function e() {
                        this._skyColor = new yn(51, 128, 204, 1), this._groundAlbedo = new yn(51, 51, 51, 255), this._albedoArray = Float32Array.from([.2, .2, .2, 1]), this._colorArray = Float32Array.from([.2, .5, .8, 1]), this._handle = 0, this._handle = fo.alloc()
                    }
                    var t = e.prototype;
                    return t.initialize = function(e) {
                        this._skyColor.set(e.skyColor), this._groundAlbedo.set(e.groundAlbedo), yn.toArray(this._colorArray, this._skyColor), En.toArray(this._albedoArray, this._groundAlbedo), fo.setVec4(this._handle, co.SKY_COLOR, this._skyColor), fo.setVec4(this._handle, co.GROUND_ALBEDO, this._groundAlbedo), fo.set(this._handle, co.ILLUM, e.skyIllum)
                    }, t.destroy = function() {
                        this._handle && (fo.free(this._handle), this._handle = 0)
                    }, K(e, [{
                        key: "colorArray",
                        get: function() {
                            return this._colorArray
                        }
                    }, {
                        key: "albedoArray",
                        get: function() {
                            return this._albedoArray
                        }
                    }, {
                        key: "enabled",
                        get: function() {
                            return fo.get(this._handle, co.ENABLE)
                        },
                        set: function(e) {
                            fo.set(this._handle, co.ENABLE, e ? 1 : 0)
                        }
                    }, {
                        key: "skyColor",
                        get: function() {
                            return this._skyColor
                        },
                        set: function(e) {
                            this._skyColor.set(e), yn.toArray(this._colorArray, this._skyColor), fo.setVec4(this._handle, co.SKY_COLOR, this._skyColor)
                        }
                    }, {
                        key: "skyIllum",
                        get: function() {
                            return fo.get(this._handle, co.ILLUM)
                        },
                        set: function(e) {
                            fo.set(this._handle, co.ILLUM, e)
                        }
                    }, {
                        key: "groundAlbedo",
                        get: function() {
                            return this._groundAlbedo
                        },
                        set: function(e) {
                            this._groundAlbedo.set(e), En.toArray(this._albedoArray, this._groundAlbedo), fo.setVec4(this._handle, co.GROUND_ALBEDO, this._groundAlbedo)
                        }
                    }, {
                        key: "handle",
                        get: function() {
                            return this._handle
                        }
                    }]), e
                }();
            Ko.SUN_ILLUM = 65e3, Ko.SKY_ILLUM = 2e4, i.Ambient = Ko;
            var Zo = new En,
                Qo = new En,
                Jo = new En,
                $o = new En,
                ea = new En,
                ta = new En,
                na = new Array(3),
                ia = new Array(3);

            function ra(e, t) {
                return En.dot(t.n, e) - t.d
            }

            function oa(e, t, n) {
                return En.copy(e, t), En.subtract(ea, n.center, n.halfExtents), En.add(ta, n.center, n.halfExtents), e.x = e.x < ea.x ? ea.x : e.x, e.y = e.y < ea.y ? ea.y : e.y, e.z = e.z < ea.z ? ea.z : e.z, e.x = e.x > ta.x ? ta.x : e.x, e.y = e.y > ta.y ? ta.y : e.y, e.z = e.z > ta.z ? ta.z : e.z, e
            }

            function aa(e, t, n) {
                En.set(Zo, n.orientation.m00, n.orientation.m01, n.orientation.m02), En.set(Qo, n.orientation.m03, n.orientation.m04, n.orientation.m05), En.set(Jo, n.orientation.m06, n.orientation.m07, n.orientation.m08), na[0] = Zo, na[1] = Qo, na[2] = Jo, ia[0] = n.halfExtents.x, ia[1] = n.halfExtents.y, ia[2] = n.halfExtents.z, En.subtract($o, t, n.center), En.set(e, n.center.x, n.center.y, n.center.z);
                for (var i = 0; i < 3; i++) {
                    var r = En.dot($o, na[i]);
                    r > ia[i] && (r = ia[i]), r < -ia[i] && (r = -ia[i]), e.x += r * na[i].x, e.y += r * na[i].y, e.z += r * na[i].z
                }
                return e
            }
            var sa = Object.freeze({
                    __proto__: null,
                    point_plane: ra,
                    pt_point_plane: function(e, t, n) {
                        var i = ra(t, n);
                        return En.subtract(e, t, En.multiplyScalar(e, n.n, i))
                    },
                    pt_point_aabb: oa,
                    pt_point_obb: aa,
                    pt_point_line: function(e, t, n, i) {
                        En.subtract(Zo, n, i);
                        var r = Zo,
                            o = En.lengthSqr(r);
                        if (0 == o) En.copy(e, n);
                        else {
                            En.subtract(Zo, t, n);
                            var a = En.dot(Zo, r) / o;
                            a < 0 ? En.copy(e, n) : a > 1 ? En.copy(e, i) : En.scaleAndAdd(e, n, r, a)
                        }
                    }
                }),
                ca = {
                    SHAPE_RAY: 1,
                    SHAPE_LINE: 2,
                    SHAPE_SPHERE: 4,
                    SHAPE_AABB: 8,
                    SHAPE_OBB: 16,
                    SHAPE_PLANE: 32,
                    SHAPE_TRIANGLE: 64,
                    SHAPE_FRUSTUM: 128,
                    SHAPE_FRUSTUM_ACCURATE: 256,
                    SHAPE_CAPSULE: 512
                },
                la = function() {
                    function e(e, t, n, i, r, o) {
                        void 0 === e && (e = 0), void 0 === t && (t = 0), void 0 === n && (n = 0), void 0 === i && (i = 0), void 0 === r && (r = 0), void 0 === o && (o = -1), this.s = void 0, this.e = void 0, this._type = void 0, this._type = ca.SHAPE_LINE, this.s = new En(e, t, n), this.e = new En(i, r, o)
                    }
                    return e.create = function(t, n, i, r, o, a) {
                        return new e(t, n, i, r, o, a)
                    }, e.clone = function(t) {
                        return new e(t.s.x, t.s.y, t.s.z, t.e.x, t.e.y, t.e.z)
                    }, e.copy = function(e, t) {
                        return En.copy(e.s, t.s), En.copy(e.e, t.e), e
                    }, e.fromPoints = function(e, t, n) {
                        return En.copy(e.s, t), En.copy(e.e, n), e
                    }, e.set = function(e, t, n, i, r, o, a) {
                        return e.s.x = t, e.s.y = n, e.s.z = i, e.e.x = r, e.e.y = o, e.e.z = a, e
                    }, e.len = function(e) {
                        return En.distance(e.s, e.e)
                    }, e.prototype.length = function() {
                        return En.distance(this.s, this.e)
                    }, K(e, [{
                        key: "type",
                        get: function() {
                            return this._type
                        }
                    }]), e
                }(),
                ua = function() {
                    function e(e, t, n, i, r, o) {
                        void 0 === e && (e = 0), void 0 === t && (t = 0), void 0 === n && (n = 0), void 0 === i && (i = 0), void 0 === r && (r = 0), void 0 === o && (o = -1), this.o = void 0, this.d = void 0, this._type = void 0, this._type = ca.SHAPE_RAY, this.o = new En(e, t, n), this.d = new En(i, r, o)
                    }
                    return e.create = function(t, n, i, r, o, a) {
                        return void 0 === t && (t = 0), void 0 === n && (n = 0), void 0 === i && (i = 0), void 0 === r && (r = 0), void 0 === o && (o = 0), void 0 === a && (a = 1), new e(t, n, i, r, o, a)
                    }, e.clone = function(t) {
                        return new e(t.o.x, t.o.y, t.o.z, t.d.x, t.d.y, t.d.z)
                    }, e.copy = function(e, t) {
                        return En.copy(e.o, t.o), En.copy(e.d, t.d), e
                    }, e.fromPoints = function(e, t, n) {
                        return En.copy(e.o, t), En.normalize(e.d, En.subtract(e.d, n, t)), e
                    }, e.set = function(e, t, n, i, r, o, a) {
                        return e.o.x = t, e.o.y = n, e.o.z = i, e.d.x = r, e.d.y = o, e.d.z = a, e
                    }, e.prototype.computeHit = function(e, t) {
                        En.normalize(e, this.d), En.scaleAndAdd(e, this.o, e, t)
                    }, K(e, [{
                        key: "type",
                        get: function() {
                            return this._type
                        }
                    }]), e
                }(),
                ha = new En,
                _a = new En,
                fa = new En,
                da = new En;

            function pa(e) {
                return Math.max(Math.max(e.x, e.y), e.z)
            }
            var ma, ga, va, ya, Sa, Ea, Ta, Aa, xa, Ca, ba, Ra, wa, Ia, Pa, Oa, Da, Na, Ma, La, Ba, Fa, za, Ua, Ga, Ha, ka, Va, Wa, ja, qa, Xa, Ya, Ka, Za, Qa, Ja, $a, es = function() {
                    function e(e, t, n, i) {
                        void 0 === e && (e = 0), void 0 === t && (t = 0), void 0 === n && (n = 0), void 0 === i && (i = 1), this._center = new En(0, 0, 0), this._poolHandle = 0, this._type = void 0, this._type = ca.SHAPE_SPHERE, this._center = new En(e, t, n), this._poolHandle = Do.alloc(), Do.setVec3(this._poolHandle, Ro.CENTER, this._center), Do.set(this._poolHandle, Ro.RADIUS, i)
                    }
                    e.create = function(t, n, i, r) {
                        return new e(t, n, i, r)
                    }, e.clone = function(t) {
                        return new e(t.center.x, t.center.y, t.center.z, t.radius)
                    }, e.copy = function(e, t) {
                        return En.copy(e.center, t.center), e.radius = t.radius, e
                    }, e.fromPoints = function(e, t, n) {
                        return En.multiplyScalar(e.center, En.add(ha, t, n), .5), e.radius = .5 * En.subtract(ha, n, t).length(), e
                    }, e.set = function(e, t, n, i, r) {
                        return e.center.x = t, e.center.y = n, e.center.z = i, e.radius = r, e
                    }, e.mergePoint = function(e, t, n) {
                        if (t.radius < 0) return e.center.set(n), e.radius = 0, e;
                        En.subtract(_a, n, t.center);
                        var i = _a.length();
                        if (i > t.radius) {
                            var r = .5 * (i - t.radius);
                            e.radius += r, En.multiplyScalar(_a, _a, r / i), En.add(e.center, e.center, _a)
                        }
                        return e
                    }, e.mergeAABB = function(t, n, i) {
                        return i.getBoundary(fa, da), e.mergePoint(t, n, fa), e.mergePoint(t, n, da), t
                    };
                    var t = e.prototype;
                    return t.destroy = function() {
                        this._poolHandle && (Do.free(this._poolHandle), this._poolHandle = 0)
                    }, t.clone = function() {
                        return e.clone(this)
                    }, t.copy = function(t) {
                        return e.copy(this, t)
                    }, t.getBoundary = function(e, t) {
                        En.set(e, this.center.x - this.radius, this.center.y - this.radius, this.center.z - this.radius), En.set(t, this.center.x + this.radius, this.center.y + this.radius, this.center.z + this.radius)
                    }, t.transform = function(e, t, n, i, r) {
                        En.transformMat4(r.center, this.center, e), r.radius = this.radius * pa(i)
                    }, t.translateAndRotate = function(e, t, n) {
                        En.transformMat4(n.center, this.center, e)
                    }, t.setScale = function(e, t) {
                        t.radius = this.radius * pa(e)
                    }, K(e, [{
                        key: "center",
                        get: function() {
                            return this._center
                        },
                        set: function(e) {
                            this._center = e, Do.setVec3(this._poolHandle, Ro.CENTER, this._center)
                        }
                    }, {
                        key: "radius",
                        get: function() {
                            return Do.get(this._poolHandle, Ro.RADIUS)
                        },
                        set: function(e) {
                            Do.set(this._poolHandle, Ro.RADIUS, e)
                        }
                    }, {
                        key: "handle",
                        get: function() {
                            return this._poolHandle
                        }
                    }, {
                        key: "type",
                        get: function() {
                            return this._type
                        }
                    }]), e
                }(),
                ts = function() {
                    function e(e, t, n, i, r, o, a, s, c) {
                        void 0 === e && (e = 0), void 0 === t && (t = 0), void 0 === n && (n = 0), void 0 === i && (i = 1), void 0 === r && (r = 0), void 0 === o && (o = 0), void 0 === a && (a = 0), void 0 === s && (s = 1), void 0 === c && (c = 0), this.a = void 0, this.b = void 0, this.c = void 0, this._type = void 0, this._type = ca.SHAPE_TRIANGLE, this.a = new En(e, t, n), this.b = new En(i, r, o), this.c = new En(a, s, c)
                    }
                    return e.create = function(t, n, i, r, o, a, s, c, l) {
                        return void 0 === t && (t = 1), void 0 === n && (n = 0), void 0 === i && (i = 0), void 0 === r && (r = 0), void 0 === o && (o = 0), void 0 === a && (a = 0), void 0 === s && (s = 0), void 0 === c && (c = 0), void 0 === l && (l = 1), new e(t, n, i, r, o, a, s, c, l)
                    }, e.clone = function(t) {
                        return new e(t.a.x, t.a.y, t.a.z, t.b.x, t.b.y, t.b.z, t.c.x, t.c.y, t.c.z)
                    }, e.copy = function(e, t) {
                        return En.copy(e.a, t.a), En.copy(e.b, t.b), En.copy(e.c, t.c), e
                    }, e.fromPoints = function(e, t, n, i) {
                        return En.copy(e.a, t), En.copy(e.b, n), En.copy(e.c, i), e
                    }, e.set = function(e, t, n, i, r, o, a, s, c, l) {
                        return e.a.x = t, e.a.y = n, e.a.z = i, e.b.x = r, e.b.y = o, e.b.z = a, e.c.x = s, e.c.y = c, e.c.z = l, e
                    }, K(e, [{
                        key: "type",
                        get: function() {
                            return this._type
                        }
                    }]), e
                }(),
                ns = function(e, t, n) {
                    for (var i = 0; i < t.length; ++i) e.length <= i && e.push(new n), e[i].copy(t[i]);
                    e.length = t.length
                };
            ! function(e) {
                e[e.UNKNOWN = 0] = "UNKNOWN", e[e.BUFFER = 1] = "BUFFER", e[e.TEXTURE = 2] = "TEXTURE", e[e.RENDER_PASS = 3] = "RENDER_PASS", e[e.FRAMEBUFFER = 4] = "FRAMEBUFFER", e[e.SAMPLER = 5] = "SAMPLER", e[e.SHADER = 6] = "SHADER", e[e.DESCRIPTOR_SET_LAYOUT = 7] = "DESCRIPTOR_SET_LAYOUT", e[e.PIPELINE_LAYOUT = 8] = "PIPELINE_LAYOUT", e[e.PIPELINE_STATE = 9] = "PIPELINE_STATE", e[e.DESCRIPTOR_SET = 10] = "DESCRIPTOR_SET", e[e.INPUT_ASSEMBLER = 11] = "INPUT_ASSEMBLER", e[e.COMMAND_BUFFER = 12] = "COMMAND_BUFFER", e[e.QUEUE = 13] = "QUEUE", e[e.GLOBAL_BARRIER = 14] = "GLOBAL_BARRIER", e[e.TEXTURE_BARRIER = 15] = "TEXTURE_BARRIER", e[e.BUFFER_BARRIER = 16] = "BUFFER_BARRIER"
            }(ma || (ma = {})),
            function(e) {
                e[e.UNREADY = 0] = "UNREADY", e[e.FAILED = 1] = "FAILED", e[e.SUCCESS = 2] = "SUCCESS"
            }(ga || (ga = {})),
            function(e) {
                e[e.UNKNOWN = 0] = "UNKNOWN", e[e.GLES2 = 1] = "GLES2", e[e.GLES3 = 2] = "GLES3", e[e.METAL = 3] = "METAL", e[e.VULKAN = 4] = "VULKAN", e[e.WEBGL = 5] = "WEBGL", e[e.WEBGL2 = 6] = "WEBGL2", e[e.WEBGPU = 7] = "WEBGPU"
            }(va || (va = {})),
            function(e) {
                e[e.IDENTITY = 0] = "IDENTITY", e[e.ROTATE_90 = 1] = "ROTATE_90", e[e.ROTATE_180 = 2] = "ROTATE_180", e[e.ROTATE_270 = 3] = "ROTATE_270"
            }(ya || (ya = {})),
            function(e) {
                e[e.COLOR_FLOAT = 0] = "COLOR_FLOAT", e[e.COLOR_HALF_FLOAT = 1] = "COLOR_HALF_FLOAT", e[e.TEXTURE_FLOAT = 2] = "TEXTURE_FLOAT", e[e.TEXTURE_HALF_FLOAT = 3] = "TEXTURE_HALF_FLOAT", e[e.TEXTURE_FLOAT_LINEAR = 4] = "TEXTURE_FLOAT_LINEAR", e[e.TEXTURE_HALF_FLOAT_LINEAR = 5] = "TEXTURE_HALF_FLOAT_LINEAR", e[e.FORMAT_R11G11B10F = 6] = "FORMAT_R11G11B10F", e[e.FORMAT_D16 = 7] = "FORMAT_D16", e[e.FORMAT_D16S8 = 8] = "FORMAT_D16S8", e[e.FORMAT_D24 = 9] = "FORMAT_D24", e[e.FORMAT_D24S8 = 10] = "FORMAT_D24S8", e[e.FORMAT_D32F = 11] = "FORMAT_D32F", e[e.FORMAT_D32FS8 = 12] = "FORMAT_D32FS8", e[e.FORMAT_ETC1 = 13] = "FORMAT_ETC1", e[e.FORMAT_ETC2 = 14] = "FORMAT_ETC2", e[e.FORMAT_DXT = 15] = "FORMAT_DXT", e[e.FORMAT_PVRTC = 16] = "FORMAT_PVRTC", e[e.FORMAT_ASTC = 17] = "FORMAT_ASTC", e[e.FORMAT_RGB8 = 18] = "FORMAT_RGB8", e[e.MSAA = 19] = "MSAA", e[e.ELEMENT_INDEX_UINT = 20] = "ELEMENT_INDEX_UINT", e[e.INSTANCED_ARRAYS = 21] = "INSTANCED_ARRAYS", e[e.MULTIPLE_RENDER_TARGETS = 22] = "MULTIPLE_RENDER_TARGETS", e[e.BLEND_MINMAX = 23] = "BLEND_MINMAX", e[e.DEPTH_BOUNDS = 24] = "DEPTH_BOUNDS", e[e.LINE_WIDTH = 25] = "LINE_WIDTH", e[e.STENCIL_WRITE_MASK = 26] = "STENCIL_WRITE_MASK", e[e.STENCIL_COMPARE_MASK = 27] = "STENCIL_COMPARE_MASK", e[e.MULTITHREADED_SUBMISSION = 28] = "MULTITHREADED_SUBMISSION", e[e.COMPUTE_SHADER = 29] = "COMPUTE_SHADER", e[e.COUNT = 30] = "COUNT"
            }(Sa || (Sa = {})),
            function(e) {
                e[e.UNKNOWN = 0] = "UNKNOWN", e[e.A8 = 1] = "A8", e[e.L8 = 2] = "L8", e[e.LA8 = 3] = "LA8", e[e.R8 = 4] = "R8", e[e.R8SN = 5] = "R8SN", e[e.R8UI = 6] = "R8UI", e[e.R8I = 7] = "R8I", e[e.R16F = 8] = "R16F", e[e.R16UI = 9] = "R16UI", e[e.R16I = 10] = "R16I", e[e.R32F = 11] = "R32F", e[e.R32UI = 12] = "R32UI", e[e.R32I = 13] = "R32I", e[e.RG8 = 14] = "RG8", e[e.RG8SN = 15] = "RG8SN", e[e.RG8UI = 16] = "RG8UI", e[e.RG8I = 17] = "RG8I", e[e.RG16F = 18] = "RG16F", e[e.RG16UI = 19] = "RG16UI", e[e.RG16I = 20] = "RG16I", e[e.RG32F = 21] = "RG32F", e[e.RG32UI = 22] = "RG32UI", e[e.RG32I = 23] = "RG32I", e[e.RGB8 = 24] = "RGB8", e[e.SRGB8 = 25] = "SRGB8", e[e.RGB8SN = 26] = "RGB8SN", e[e.RGB8UI = 27] = "RGB8UI", e[e.RGB8I = 28] = "RGB8I", e[e.RGB16F = 29] = "RGB16F", e[e.RGB16UI = 30] = "RGB16UI", e[e.RGB16I = 31] = "RGB16I", e[e.RGB32F = 32] = "RGB32F", e[e.RGB32UI = 33] = "RGB32UI", e[e.RGB32I = 34] = "RGB32I", e[e.RGBA8 = 35] = "RGBA8", e[e.BGRA8 = 36] = "BGRA8", e[e.SRGB8_A8 = 37] = "SRGB8_A8", e[e.RGBA8SN = 38] = "RGBA8SN", e[e.RGBA8UI = 39] = "RGBA8UI", e[e.RGBA8I = 40] = "RGBA8I", e[e.RGBA16F = 41] = "RGBA16F", e[e.RGBA16UI = 42] = "RGBA16UI", e[e.RGBA16I = 43] = "RGBA16I", e[e.RGBA32F = 44] = "RGBA32F", e[e.RGBA32UI = 45] = "RGBA32UI", e[e.RGBA32I = 46] = "RGBA32I", e[e.R5G6B5 = 47] = "R5G6B5", e[e.R11G11B10F = 48] = "R11G11B10F", e[e.RGB5A1 = 49] = "RGB5A1", e[e.RGBA4 = 50] = "RGBA4", e[e.RGB10A2 = 51] = "RGB10A2", e[e.RGB10A2UI = 52] = "RGB10A2UI", e[e.RGB9E5 = 53] = "RGB9E5", e[e.D16 = 54] = "D16", e[e.D16S8 = 55] = "D16S8", e[e.D24 = 56] = "D24", e[e.D24S8 = 57] = "D24S8", e[e.D32F = 58] = "D32F", e[e.D32F_S8 = 59] = "D32F_S8", e[e.BC1 = 60] = "BC1", e[e.BC1_ALPHA = 61] = "BC1_ALPHA", e[e.BC1_SRGB = 62] = "BC1_SRGB", e[e.BC1_SRGB_ALPHA = 63] = "BC1_SRGB_ALPHA", e[e.BC2 = 64] = "BC2", e[e.BC2_SRGB = 65] = "BC2_SRGB", e[e.BC3 = 66] = "BC3", e[e.BC3_SRGB = 67] = "BC3_SRGB", e[e.BC4 = 68] = "BC4", e[e.BC4_SNORM = 69] = "BC4_SNORM", e[e.BC5 = 70] = "BC5", e[e.BC5_SNORM = 71] = "BC5_SNORM", e[e.BC6H_UF16 = 72] = "BC6H_UF16", e[e.BC6H_SF16 = 73] = "BC6H_SF16", e[e.BC7 = 74] = "BC7", e[e.BC7_SRGB = 75] = "BC7_SRGB", e[e.ETC_RGB8 = 76] = "ETC_RGB8", e[e.ETC2_RGB8 = 77] = "ETC2_RGB8", e[e.ETC2_SRGB8 = 78] = "ETC2_SRGB8", e[e.ETC2_RGB8_A1 = 79] = "ETC2_RGB8_A1", e[e.ETC2_SRGB8_A1 = 80] = "ETC2_SRGB8_A1", e[e.ETC2_RGBA8 = 81] = "ETC2_RGBA8", e[e.ETC2_SRGB8_A8 = 82] = "ETC2_SRGB8_A8", e[e.EAC_R11 = 83] = "EAC_R11", e[e.EAC_R11SN = 84] = "EAC_R11SN", e[e.EAC_RG11 = 85] = "EAC_RG11", e[e.EAC_RG11SN = 86] = "EAC_RG11SN", e[e.PVRTC_RGB2 = 87] = "PVRTC_RGB2", e[e.PVRTC_RGBA2 = 88] = "PVRTC_RGBA2", e[e.PVRTC_RGB4 = 89] = "PVRTC_RGB4", e[e.PVRTC_RGBA4 = 90] = "PVRTC_RGBA4", e[e.PVRTC2_2BPP = 91] = "PVRTC2_2BPP", e[e.PVRTC2_4BPP = 92] = "PVRTC2_4BPP", e[e.ASTC_RGBA_4x4 = 93] = "ASTC_RGBA_4x4", e[e.ASTC_RGBA_5x4 = 94] = "ASTC_RGBA_5x4", e[e.ASTC_RGBA_5x5 = 95] = "ASTC_RGBA_5x5", e[e.ASTC_RGBA_6x5 = 96] = "ASTC_RGBA_6x5", e[e.ASTC_RGBA_6x6 = 97] = "ASTC_RGBA_6x6", e[e.ASTC_RGBA_8x5 = 98] = "ASTC_RGBA_8x5", e[e.ASTC_RGBA_8x6 = 99] = "ASTC_RGBA_8x6", e[e.ASTC_RGBA_8x8 = 100] = "ASTC_RGBA_8x8", e[e.ASTC_RGBA_10x5 = 101] = "ASTC_RGBA_10x5", e[e.ASTC_RGBA_10x6 = 102] = "ASTC_RGBA_10x6", e[e.ASTC_RGBA_10x8 = 103] = "ASTC_RGBA_10x8", e[e.ASTC_RGBA_10x10 = 104] = "ASTC_RGBA_10x10", e[e.ASTC_RGBA_12x10 = 105] = "ASTC_RGBA_12x10", e[e.ASTC_RGBA_12x12 = 106] = "ASTC_RGBA_12x12", e[e.ASTC_SRGBA_4x4 = 107] = "ASTC_SRGBA_4x4", e[e.ASTC_SRGBA_5x4 = 108] = "ASTC_SRGBA_5x4", e[e.ASTC_SRGBA_5x5 = 109] = "ASTC_SRGBA_5x5", e[e.ASTC_SRGBA_6x5 = 110] = "ASTC_SRGBA_6x5", e[e.ASTC_SRGBA_6x6 = 111] = "ASTC_SRGBA_6x6", e[e.ASTC_SRGBA_8x5 = 112] = "ASTC_SRGBA_8x5", e[e.ASTC_SRGBA_8x6 = 113] = "ASTC_SRGBA_8x6", e[e.ASTC_SRGBA_8x8 = 114] = "ASTC_SRGBA_8x8", e[e.ASTC_SRGBA_10x5 = 115] = "ASTC_SRGBA_10x5", e[e.ASTC_SRGBA_10x6 = 116] = "ASTC_SRGBA_10x6", e[e.ASTC_SRGBA_10x8 = 117] = "ASTC_SRGBA_10x8", e[e.ASTC_SRGBA_10x10 = 118] = "ASTC_SRGBA_10x10", e[e.ASTC_SRGBA_12x10 = 119] = "ASTC_SRGBA_12x10", e[e.ASTC_SRGBA_12x12 = 120] = "ASTC_SRGBA_12x12", e[e.COUNT = 121] = "COUNT"
            }(Ea || (Ea = {})),
            function(e) {
                e[e.NONE = 0] = "NONE", e[e.UNORM = 1] = "UNORM", e[e.SNORM = 2] = "SNORM", e[e.UINT = 3] = "UINT", e[e.INT = 4] = "INT", e[e.UFLOAT = 5] = "UFLOAT", e[e.FLOAT = 6] = "FLOAT"
            }(Ta || (Ta = {})),
            function(e) {
                e[e.UNKNOWN = 0] = "UNKNOWN", e[e.BOOL = 1] = "BOOL", e[e.BOOL2 = 2] = "BOOL2", e[e.BOOL3 = 3] = "BOOL3", e[e.BOOL4 = 4] = "BOOL4", e[e.INT = 5] = "INT", e[e.INT2 = 6] = "INT2", e[e.INT3 = 7] = "INT3", e[e.INT4 = 8] = "INT4", e[e.UINT = 9] = "UINT", e[e.UINT2 = 10] = "UINT2", e[e.UINT3 = 11] = "UINT3", e[e.UINT4 = 12] = "UINT4", e[e.FLOAT = 13] = "FLOAT", e[e.FLOAT2 = 14] = "FLOAT2", e[e.FLOAT3 = 15] = "FLOAT3", e[e.FLOAT4 = 16] = "FLOAT4", e[e.MAT2 = 17] = "MAT2", e[e.MAT2X3 = 18] = "MAT2X3", e[e.MAT2X4 = 19] = "MAT2X4", e[e.MAT3X2 = 20] = "MAT3X2", e[e.MAT3 = 21] = "MAT3", e[e.MAT3X4 = 22] = "MAT3X4", e[e.MAT4X2 = 23] = "MAT4X2", e[e.MAT4X3 = 24] = "MAT4X3", e[e.MAT4 = 25] = "MAT4", e[e.SAMPLER1D = 26] = "SAMPLER1D", e[e.SAMPLER1D_ARRAY = 27] = "SAMPLER1D_ARRAY", e[e.SAMPLER2D = 28] = "SAMPLER2D", e[e.SAMPLER2D_ARRAY = 29] = "SAMPLER2D_ARRAY", e[e.SAMPLER3D = 30] = "SAMPLER3D", e[e.SAMPLER_CUBE = 31] = "SAMPLER_CUBE", e[e.SAMPLER = 32] = "SAMPLER", e[e.TEXTURE1D = 33] = "TEXTURE1D", e[e.TEXTURE1D_ARRAY = 34] = "TEXTURE1D_ARRAY", e[e.TEXTURE2D = 35] = "TEXTURE2D", e[e.TEXTURE2D_ARRAY = 36] = "TEXTURE2D_ARRAY", e[e.TEXTURE3D = 37] = "TEXTURE3D", e[e.TEXTURE_CUBE = 38] = "TEXTURE_CUBE", e[e.IMAGE1D = 39] = "IMAGE1D", e[e.IMAGE1D_ARRAY = 40] = "IMAGE1D_ARRAY", e[e.IMAGE2D = 41] = "IMAGE2D", e[e.IMAGE2D_ARRAY = 42] = "IMAGE2D_ARRAY", e[e.IMAGE3D = 43] = "IMAGE3D", e[e.IMAGE_CUBE = 44] = "IMAGE_CUBE", e[e.SUBPASS_INPUT = 45] = "SUBPASS_INPUT", e[e.COUNT = 46] = "COUNT"
            }(Aa || (Aa = {})),
            function(e) {
                e[e.NONE = 0] = "NONE", e[e.TRANSFER_SRC = 1] = "TRANSFER_SRC", e[e.TRANSFER_DST = 2] = "TRANSFER_DST", e[e.INDEX = 4] = "INDEX", e[e.VERTEX = 8] = "VERTEX", e[e.UNIFORM = 16] = "UNIFORM", e[e.STORAGE = 32] = "STORAGE", e[e.INDIRECT = 64] = "INDIRECT"
            }(xa || (xa = {})),
            function(e) {
                e[e.NONE = 0] = "NONE"
            }(Ca || (Ca = {})),
            function(e) {
                e[e.NONE = 0] = "NONE", e[e.READ_ONLY = 1] = "READ_ONLY", e[e.WRITE_ONLY = 2] = "WRITE_ONLY", e[e.READ_WRITE = 3] = "READ_WRITE"
            }(ba || (ba = {})),
            function(e) {
                e[e.NONE = 0] = "NONE", e[e.DEVICE = 1] = "DEVICE", e[e.HOST = 2] = "HOST"
            }(Ra || (Ra = {})),
            function(e) {
                e[e.TEX1D = 0] = "TEX1D", e[e.TEX2D = 1] = "TEX2D", e[e.TEX3D = 2] = "TEX3D", e[e.CUBE = 3] = "CUBE", e[e.TEX1D_ARRAY = 4] = "TEX1D_ARRAY", e[e.TEX2D_ARRAY = 5] = "TEX2D_ARRAY"
            }(wa || (wa = {})),
            function(e) {
                e[e.NONE = 0] = "NONE", e[e.TRANSFER_SRC = 1] = "TRANSFER_SRC", e[e.TRANSFER_DST = 2] = "TRANSFER_DST", e[e.SAMPLED = 4] = "SAMPLED", e[e.STORAGE = 8] = "STORAGE", e[e.COLOR_ATTACHMENT = 16] = "COLOR_ATTACHMENT", e[e.DEPTH_STENCIL_ATTACHMENT = 32] = "DEPTH_STENCIL_ATTACHMENT", e[e.TRANSIENT_ATTACHMENT = 64] = "TRANSIENT_ATTACHMENT", e[e.INPUT_ATTACHMENT = 128] = "INPUT_ATTACHMENT"
            }(Ia || (Ia = {})),
            function(e) {
                e[e.NONE = 0] = "NONE", e[e.GEN_MIPMAP = 1] = "GEN_MIPMAP", e[e.IMMUTABLE = 2] = "IMMUTABLE"
            }(Pa || (Pa = {})),
            function(e) {
                e[e.X1 = 0] = "X1", e[e.X2 = 1] = "X2", e[e.X4 = 2] = "X4", e[e.X8 = 3] = "X8", e[e.X16 = 4] = "X16", e[e.X32 = 5] = "X32", e[e.X64 = 6] = "X64"
            }(Oa || (Oa = {})),
            function(e) {
                e[e.NONE = 0] = "NONE", e[e.POINT = 1] = "POINT", e[e.LINEAR = 2] = "LINEAR", e[e.ANISOTROPIC = 3] = "ANISOTROPIC"
            }(Da || (Da = {})),
            function(e) {
                e[e.WRAP = 0] = "WRAP", e[e.MIRROR = 1] = "MIRROR", e[e.CLAMP = 2] = "CLAMP", e[e.BORDER = 3] = "BORDER"
            }(Na || (Na = {})),
            function(e) {
                e[e.NEVER = 0] = "NEVER", e[e.LESS = 1] = "LESS", e[e.EQUAL = 2] = "EQUAL", e[e.LESS_EQUAL = 3] = "LESS_EQUAL", e[e.GREATER = 4] = "GREATER", e[e.NOT_EQUAL = 5] = "NOT_EQUAL", e[e.GREATER_EQUAL = 6] = "GREATER_EQUAL", e[e.ALWAYS = 7] = "ALWAYS"
            }(Ma || (Ma = {})),
            function(e) {
                e[e.ZERO = 0] = "ZERO", e[e.KEEP = 1] = "KEEP", e[e.REPLACE = 2] = "REPLACE", e[e.INCR = 3] = "INCR", e[e.DECR = 4] = "DECR", e[e.INVERT = 5] = "INVERT", e[e.INCR_WRAP = 6] = "INCR_WRAP", e[e.DECR_WRAP = 7] = "DECR_WRAP"
            }(La || (La = {})),
            function(e) {
                e[e.ZERO = 0] = "ZERO", e[e.ONE = 1] = "ONE", e[e.SRC_ALPHA = 2] = "SRC_ALPHA", e[e.DST_ALPHA = 3] = "DST_ALPHA", e[e.ONE_MINUS_SRC_ALPHA = 4] = "ONE_MINUS_SRC_ALPHA", e[e.ONE_MINUS_DST_ALPHA = 5] = "ONE_MINUS_DST_ALPHA", e[e.SRC_COLOR = 6] = "SRC_COLOR", e[e.DST_COLOR = 7] = "DST_COLOR", e[e.ONE_MINUS_SRC_COLOR = 8] = "ONE_MINUS_SRC_COLOR", e[e.ONE_MINUS_DST_COLOR = 9] = "ONE_MINUS_DST_COLOR", e[e.SRC_ALPHA_SATURATE = 10] = "SRC_ALPHA_SATURATE", e[e.CONSTANT_COLOR = 11] = "CONSTANT_COLOR", e[e.ONE_MINUS_CONSTANT_COLOR = 12] = "ONE_MINUS_CONSTANT_COLOR", e[e.CONSTANT_ALPHA = 13] = "CONSTANT_ALPHA", e[e.ONE_MINUS_CONSTANT_ALPHA = 14] = "ONE_MINUS_CONSTANT_ALPHA"
            }(Ba || (Ba = {})),
            function(e) {
                e[e.ADD = 0] = "ADD", e[e.SUB = 1] = "SUB", e[e.REV_SUB = 2] = "REV_SUB", e[e.MIN = 3] = "MIN", e[e.MAX = 4] = "MAX"
            }(Fa || (Fa = {})),
            function(e) {
                e[e.NONE = 0] = "NONE", e[e.R = 1] = "R", e[e.G = 2] = "G", e[e.B = 4] = "B", e[e.A = 8] = "A", e[e.ALL = 15] = "ALL"
            }(za || (za = {})),
            function(e) {
                e[e.NONE = 0] = "NONE", e[e.VERTEX = 1] = "VERTEX", e[e.CONTROL = 2] = "CONTROL", e[e.EVALUATION = 4] = "EVALUATION", e[e.GEOMETRY = 8] = "GEOMETRY", e[e.FRAGMENT = 16] = "FRAGMENT", e[e.COMPUTE = 32] = "COMPUTE", e[e.ALL = 63] = "ALL"
            }(Ua || (Ua = {})),
            function(e) {
                e[e.LOAD = 0] = "LOAD", e[e.CLEAR = 1] = "CLEAR", e[e.DISCARD = 2] = "DISCARD"
            }(Ga || (Ga = {})),
            function(e) {
                e[e.STORE = 0] = "STORE", e[e.DISCARD = 1] = "DISCARD"
            }(Ha || (Ha = {})),
            function(e) {
                e[e.NONE = 0] = "NONE", e[e.INDIRECT_BUFFER = 1] = "INDIRECT_BUFFER", e[e.INDEX_BUFFER = 2] = "INDEX_BUFFER", e[e.VERTEX_BUFFER = 3] = "VERTEX_BUFFER", e[e.VERTEX_SHADER_READ_UNIFORM_BUFFER = 4] = "VERTEX_SHADER_READ_UNIFORM_BUFFER", e[e.VERTEX_SHADER_READ_TEXTURE = 5] = "VERTEX_SHADER_READ_TEXTURE", e[e.VERTEX_SHADER_READ_OTHER = 6] = "VERTEX_SHADER_READ_OTHER", e[e.FRAGMENT_SHADER_READ_UNIFORM_BUFFER = 7] = "FRAGMENT_SHADER_READ_UNIFORM_BUFFER", e[e.FRAGMENT_SHADER_READ_TEXTURE = 8] = "FRAGMENT_SHADER_READ_TEXTURE", e[e.FRAGMENT_SHADER_READ_COLOR_INPUT_ATTACHMENT = 9] = "FRAGMENT_SHADER_READ_COLOR_INPUT_ATTACHMENT", e[e.FRAGMENT_SHADER_READ_DEPTH_STENCIL_INPUT_ATTACHMENT = 10] = "FRAGMENT_SHADER_READ_DEPTH_STENCIL_INPUT_ATTACHMENT", e[e.FRAGMENT_SHADER_READ_OTHER = 11] = "FRAGMENT_SHADER_READ_OTHER", e[e.COLOR_ATTACHMENT_READ = 12] = "COLOR_ATTACHMENT_READ", e[e.DEPTH_STENCIL_ATTACHMENT_READ = 13] = "DEPTH_STENCIL_ATTACHMENT_READ", e[e.COMPUTE_SHADER_READ_UNIFORM_BUFFER = 14] = "COMPUTE_SHADER_READ_UNIFORM_BUFFER", e[e.COMPUTE_SHADER_READ_TEXTURE = 15] = "COMPUTE_SHADER_READ_TEXTURE", e[e.COMPUTE_SHADER_READ_OTHER = 16] = "COMPUTE_SHADER_READ_OTHER", e[e.TRANSFER_READ = 17] = "TRANSFER_READ", e[e.HOST_READ = 18] = "HOST_READ", e[e.PRESENT = 19] = "PRESENT", e[e.VERTEX_SHADER_WRITE = 20] = "VERTEX_SHADER_WRITE", e[e.FRAGMENT_SHADER_WRITE = 21] = "FRAGMENT_SHADER_WRITE", e[e.COLOR_ATTACHMENT_WRITE = 22] = "COLOR_ATTACHMENT_WRITE", e[e.DEPTH_STENCIL_ATTACHMENT_WRITE = 23] = "DEPTH_STENCIL_ATTACHMENT_WRITE", e[e.COMPUTE_SHADER_WRITE = 24] = "COMPUTE_SHADER_WRITE", e[e.TRANSFER_WRITE = 25] = "TRANSFER_WRITE", e[e.HOST_PREINITIALIZED = 26] = "HOST_PREINITIALIZED", e[e.HOST_WRITE = 27] = "HOST_WRITE"
            }(ka || (ka = {})),
            function(e) {
                e[e.GRAPHICS = 0] = "GRAPHICS", e[e.COMPUTE = 1] = "COMPUTE", e[e.RAY_TRACING = 2] = "RAY_TRACING"
            }(Va || (Va = {})),
            function(e) {
                e[e.POINT_LIST = 0] = "POINT_LIST", e[e.LINE_LIST = 1] = "LINE_LIST", e[e.LINE_STRIP = 2] = "LINE_STRIP", e[e.LINE_LOOP = 3] = "LINE_LOOP", e[e.LINE_LIST_ADJACENCY = 4] = "LINE_LIST_ADJACENCY", e[e.LINE_STRIP_ADJACENCY = 5] = "LINE_STRIP_ADJACENCY", e[e.ISO_LINE_LIST = 6] = "ISO_LINE_LIST", e[e.TRIANGLE_LIST = 7] = "TRIANGLE_LIST", e[e.TRIANGLE_STRIP = 8] = "TRIANGLE_STRIP", e[e.TRIANGLE_FAN = 9] = "TRIANGLE_FAN", e[e.TRIANGLE_LIST_ADJACENCY = 10] = "TRIANGLE_LIST_ADJACENCY", e[e.TRIANGLE_STRIP_ADJACENCY = 11] = "TRIANGLE_STRIP_ADJACENCY", e[e.TRIANGLE_PATCH_ADJACENCY = 12] = "TRIANGLE_PATCH_ADJACENCY", e[e.QUAD_PATCH_LIST = 13] = "QUAD_PATCH_LIST"
            }(Wa || (Wa = {})),
            function(e) {
                e[e.FILL = 0] = "FILL", e[e.POINT = 1] = "POINT", e[e.LINE = 2] = "LINE"
            }(ja || (ja = {})),
            function(e) {
                e[e.GOURAND = 0] = "GOURAND", e[e.FLAT = 1] = "FLAT"
            }(qa || (qa = {})),
            function(e) {
                e[e.NONE = 0] = "NONE", e[e.FRONT = 1] = "FRONT", e[e.BACK = 2] = "BACK"
            }(Xa || (Xa = {})),
            function(e) {
                e[e.NONE = 0] = "NONE", e[e.VIEWPORT = 1] = "VIEWPORT", e[e.SCISSOR = 2] = "SCISSOR", e[e.LINE_WIDTH = 4] = "LINE_WIDTH", e[e.DEPTH_BIAS = 8] = "DEPTH_BIAS", e[e.BLEND_CONSTANTS = 16] = "BLEND_CONSTANTS", e[e.DEPTH_BOUNDS = 32] = "DEPTH_BOUNDS", e[e.STENCIL_WRITE_MASK = 64] = "STENCIL_WRITE_MASK", e[e.STENCIL_COMPARE_MASK = 128] = "STENCIL_COMPARE_MASK"
            }(Ya || (Ya = {})),
            function(e) {
                e[e.FRONT = 0] = "FRONT", e[e.BACK = 1] = "BACK", e[e.ALL = 2] = "ALL"
            }(Ka || (Ka = {})),
            function(e) {
                e[e.UNKNOWN = 0] = "UNKNOWN", e[e.UNIFORM_BUFFER = 1] = "UNIFORM_BUFFER", e[e.DYNAMIC_UNIFORM_BUFFER = 2] = "DYNAMIC_UNIFORM_BUFFER", e[e.STORAGE_BUFFER = 4] = "STORAGE_BUFFER", e[e.DYNAMIC_STORAGE_BUFFER = 8] = "DYNAMIC_STORAGE_BUFFER", e[e.SAMPLER_TEXTURE = 16] = "SAMPLER_TEXTURE", e[e.SAMPLER = 32] = "SAMPLER", e[e.TEXTURE = 64] = "TEXTURE", e[e.STORAGE_IMAGE = 128] = "STORAGE_IMAGE", e[e.INPUT_ATTACHMENT = 256] = "INPUT_ATTACHMENT"
            }(Za || (Za = {})),
            function(e) {
                e[e.GRAPHICS = 0] = "GRAPHICS", e[e.COMPUTE = 1] = "COMPUTE", e[e.TRANSFER = 2] = "TRANSFER"
            }(Qa || (Qa = {})),
            function(e) {
                e[e.PRIMARY = 0] = "PRIMARY", e[e.SECONDARY = 1] = "SECONDARY"
            }(Ja || (Ja = {})),
            function(e) {
                e[e.NONE = 0] = "NONE", e[e.COLOR = 1] = "COLOR", e[e.DEPTH = 2] = "DEPTH", e[e.STENCIL = 4] = "STENCIL", e[e.DEPTH_STENCIL = 6] = "DEPTH_STENCIL", e[e.ALL = 7] = "ALL"
            }($a || ($a = {}));
            var is, rs = function() {
                    function e(e, t, n) {
                        void 0 === e && (e = 0), void 0 === t && (t = 0), void 0 === n && (n = 0), this.x = e, this.y = t, this.z = n
                    }
                    return e.prototype.copy = function(e) {
                        return this.x = e.x, this.y = e.y, this.z = e.z, this
                    }, e
                }(),
                os = function() {
                    function e(e, t, n, i, r, o, a, s, c, l, u, h, _, f, d, p, m, g, v, y, S, E, T) {
                        void 0 === e && (e = 0), void 0 === t && (t = 0), void 0 === n && (n = 0), void 0 === i && (i = 0), void 0 === r && (r = 0), void 0 === o && (o = 0), void 0 === a && (a = 0), void 0 === s && (s = 0), void 0 === c && (c = 0), void 0 === l && (l = 0), void 0 === u && (u = 0), void 0 === h && (h = 0), void 0 === _ && (_ = 0), void 0 === f && (f = 0), void 0 === d && (d = 0), void 0 === p && (p = 1), void 0 === m && (m = 0), void 0 === g && (g = 0), void 0 === v && (v = new rs), void 0 === y && (y = new rs), void 0 === S && (S = -1), void 0 === E && (E = 1), void 0 === T && (T = 1), this.maxVertexAttributes = e, this.maxVertexUniformVectors = t, this.maxFragmentUniformVectors = n, this.maxTextureUnits = i, this.maxImageUnits = r, this.maxVertexTextureUnits = o, this.maxColorRenderTargets = a, this.maxShaderStorageBufferBindings = s, this.maxShaderStorageBlockSize = c, this.maxUniformBufferBindings = l, this.maxUniformBlockSize = u, this.maxTextureSize = h, this.maxCubeMapTextureSize = _, this.depthBits = f, this.stencilBits = d, this.uboOffsetAlignment = p, this.maxComputeSharedMemorySize = m, this.maxComputeWorkGroupInvocations = g, this.maxComputeWorkGroupSize = v, this.maxComputeWorkGroupCount = y, this.clipSpaceMinZ = S, this.screenSpaceSignY = E, this.clipSpaceSignY = T
                    }
                    return e.prototype.copy = function(e) {
                        return this.maxVertexAttributes = e.maxVertexAttributes, this.maxVertexUniformVectors = e.maxVertexUniformVectors, this.maxFragmentUniformVectors = e.maxFragmentUniformVectors, this.maxTextureUnits = e.maxTextureUnits, this.maxImageUnits = e.maxImageUnits, this.maxVertexTextureUnits = e.maxVertexTextureUnits, this.maxColorRenderTargets = e.maxColorRenderTargets, this.maxShaderStorageBufferBindings = e.maxShaderStorageBufferBindings, this.maxShaderStorageBlockSize = e.maxShaderStorageBlockSize, this.maxUniformBufferBindings = e.maxUniformBufferBindings, this.maxUniformBlockSize = e.maxUniformBlockSize, this.maxTextureSize = e.maxTextureSize, this.maxCubeMapTextureSize = e.maxCubeMapTextureSize, this.depthBits = e.depthBits, this.stencilBits = e.stencilBits, this.uboOffsetAlignment = e.uboOffsetAlignment, this.maxComputeSharedMemorySize = e.maxComputeSharedMemorySize, this.maxComputeWorkGroupInvocations = e.maxComputeWorkGroupInvocations, this.maxComputeWorkGroupSize.copy(e.maxComputeWorkGroupSize), this.maxComputeWorkGroupCount.copy(e.maxComputeWorkGroupCount), this.clipSpaceMinZ = e.clipSpaceMinZ, this.screenSpaceSignY = e.screenSpaceSignY, this.clipSpaceSignY = e.clipSpaceSignY, this
                    }, e
                }(),
                as = function() {
                    function e(e, t, n) {
                        void 0 === e && (e = 0), void 0 === t && (t = 0), void 0 === n && (n = 0), this.x = e, this.y = t, this.z = n
                    }
                    return e.prototype.copy = function(e) {
                        return this.x = e.x, this.y = e.y, this.z = e.z, this
                    }, e
                }(),
                ss = function() {
                    function e(e, t, n, i) {
                        void 0 === e && (e = 0), void 0 === t && (t = 0), void 0 === n && (n = 0), void 0 === i && (i = 0), this.x = e, this.y = t, this.width = n, this.height = i
                    }
                    return e.prototype.copy = function(e) {
                        return this.x = e.x, this.y = e.y, this.width = e.width, this.height = e.height, this
                    }, e
                }(),
                cs = function() {
                    function e(e, t, n) {
                        void 0 === e && (e = 0), void 0 === t && (t = 0), void 0 === n && (n = 1), this.width = e, this.height = t, this.depth = n
                    }
                    return e.prototype.copy = function(e) {
                        return this.width = e.width, this.height = e.height, this.depth = e.depth, this
                    }, e
                }(),
                ls = function() {
                    function e(e, t, n) {
                        void 0 === e && (e = 0), void 0 === t && (t = 0), void 0 === n && (n = 1), this.mipLevel = e, this.baseArrayLayer = t, this.layerCount = n
                    }
                    return e.prototype.copy = function(e) {
                        return this.mipLevel = e.mipLevel, this.baseArrayLayer = e.baseArrayLayer, this.layerCount = e.layerCount, this
                    }, e
                }(),
                us = function() {
                    function e(e, t, n, i) {
                        void 0 === e && (e = 0), void 0 === t && (t = 1), void 0 === n && (n = 0), void 0 === i && (i = 1), this.baseMipLevel = e, this.levelCount = t, this.baseArrayLayer = n, this.layerCount = i
                    }
                    return e.prototype.copy = function(e) {
                        return this.baseMipLevel = e.baseMipLevel, this.levelCount = e.levelCount, this.baseArrayLayer = e.baseArrayLayer, this.layerCount = e.layerCount, this
                    }, e
                }(),
                hs = function() {
                    function e(e, t, n, i, r) {
                        void 0 === e && (e = new ls), void 0 === t && (t = new as), void 0 === n && (n = new ls), void 0 === i && (i = new as), void 0 === r && (r = new cs), this.srcSubres = e, this.srcOffset = t, this.dstSubres = n, this.dstOffset = i, this.extent = r
                    }
                    return e.prototype.copy = function(e) {
                        return this.srcSubres.copy(e.srcSubres), this.srcOffset.copy(e.srcOffset), this.dstSubres.copy(e.dstSubres), this.dstOffset.copy(e.dstOffset), this.extent.copy(e.extent), this
                    }, e
                }(),
                _s = function() {
                    function e(e, t, n, i, r, o) {
                        void 0 === e && (e = new ls), void 0 === t && (t = new as), void 0 === n && (n = new cs), void 0 === i && (i = new ls), void 0 === r && (r = new as), void 0 === o && (o = new cs), this.srcSubres = e, this.srcOffset = t, this.srcExtent = n, this.dstSubres = i, this.dstOffset = r, this.dstExtent = o
                    }
                    return e.prototype.copy = function(e) {
                        return this.srcSubres.copy(e.srcSubres), this.srcOffset.copy(e.srcOffset), this.srcExtent.copy(e.srcExtent), this.dstSubres.copy(e.dstSubres), this.dstOffset.copy(e.dstOffset), this.dstExtent.copy(e.dstExtent), this
                    }, e
                }(),
                fs = function() {
                    function e(e, t, n, i, r) {
                        void 0 === e && (e = 0), void 0 === t && (t = 0), void 0 === n && (n = new as), void 0 === i && (i = new cs), void 0 === r && (r = new ls), this.buffStride = e, this.buffTexHeight = t, this.texOffset = n, this.texExtent = i, this.texSubres = r
                    }
                    return e.prototype.copy = function(e) {
                        return this.buffStride = e.buffStride, this.buffTexHeight = e.buffTexHeight, this.texOffset.copy(e.texOffset), this.texExtent.copy(e.texExtent), this.texSubres.copy(e.texSubres), this
                    }, e
                }(),
                ds = function() {
                    function e(e, t, n, i, r, o) {
                        void 0 === e && (e = 0), void 0 === t && (t = 0), void 0 === n && (n = 0), void 0 === i && (i = 0), void 0 === r && (r = 0), void 0 === o && (o = 1), this.left = e, this.top = t, this.width = n, this.height = i, this.minDepth = r, this.maxDepth = o
                    }
                    return e.prototype.copy = function(e) {
                        return this.left = e.left, this.top = e.top, this.width = e.width, this.height = e.height, this.minDepth = e.minDepth, this.maxDepth = e.maxDepth, this
                    }, e
                }(),
                ps = function() {
                    function e(e, t, n, i) {
                        void 0 === e && (e = 0), void 0 === t && (t = 0), void 0 === n && (n = 0), void 0 === i && (i = 0), this.x = e, this.y = t, this.z = n, this.w = i
                    }
                    return e.prototype.copy = function(e) {
                        return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w, this
                    }, e
                }(),
                ms = function() {
                    function e(e, t, n) {
                        void 0 === e && (e = []), void 0 === t && (t = []), void 0 === n && (n = 0), this.bufferOffsets = e, this.samplerOffsets = t, this.flexibleSet = n
                    }
                    return e.prototype.copy = function(e) {
                        return this.bufferOffsets = e.bufferOffsets.slice(), this.samplerOffsets = e.samplerOffsets.slice(), this.flexibleSet = e.flexibleSet, this
                    }, e
                }(),
                gs = function() {
                    function e(e, t, n, i, r) {
                        void 0 === e && (e = xa.NONE), void 0 === t && (t = Ra.NONE), void 0 === n && (n = 0), void 0 === i && (i = 0), void 0 === r && (r = Ca.NONE), this.usage = e, this.memUsage = t, this.size = n, this.stride = i, this.flags = r
                    }
                    return e.prototype.copy = function(e) {
                        return this.usage = e.usage, this.memUsage = e.memUsage, this.size = e.size, this.stride = e.stride, this.flags = e.flags, this
                    }, e
                }(),
                vs = function() {
                    function e(e, t, n) {
                        void 0 === e && (e = null), void 0 === t && (t = 0), void 0 === n && (n = 0), this.buffer = e, this.offset = t, this.range = n
                    }
                    return e.prototype.copy = function(e) {
                        return this.buffer = e.buffer, this.offset = e.offset, this.range = e.range, this
                    }, e
                }(),
                ys = function() {
                    function e(e, t, n, i, r, o, a) {
                        void 0 === e && (e = 0), void 0 === t && (t = 0), void 0 === n && (n = 0), void 0 === i && (i = 0), void 0 === r && (r = 0), void 0 === o && (o = 0), void 0 === a && (a = 0), this.vertexCount = e, this.firstVertex = t, this.indexCount = n, this.firstIndex = i, this.vertexOffset = r, this.instanceCount = o, this.firstInstance = a
                    }
                    return e.prototype.copy = function(e) {
                        return this.vertexCount = e.vertexCount, this.firstVertex = e.firstVertex, this.indexCount = e.indexCount, this.firstIndex = e.firstIndex, this.vertexOffset = e.vertexOffset, this.instanceCount = e.instanceCount, this.firstInstance = e.firstInstance, this
                    }, e
                }(),
                Ss = function() {
                    function e(e, t, n, i, r) {
                        void 0 === e && (e = 0), void 0 === t && (t = 0), void 0 === n && (n = 0), void 0 === i && (i = null), void 0 === r && (r = 0), this.groupCountX = e, this.groupCountY = t, this.groupCountZ = n, this.indirectBuffer = i, this.indirectOffset = r
                    }
                    return e.prototype.copy = function(e) {
                        return this.groupCountX = e.groupCountX, this.groupCountY = e.groupCountY, this.groupCountZ = e.groupCountZ, this.indirectBuffer = e.indirectBuffer, this.indirectOffset = e.indirectOffset, this
                    }, e
                }(),
                Es = function() {
                    function e(e) {
                        void 0 === e && (e = []), this.drawInfos = e
                    }
                    return e.prototype.copy = function(e) {
                        return ns(this.drawInfos, e.drawInfos, ys), this
                    }, e
                }(),
                Ts = function() {
                    function e(e, t, n, i, r, o, a, s, c, l) {
                        void 0 === e && (e = wa.TEX2D), void 0 === t && (t = Ia.NONE), void 0 === n && (n = Ea.UNKNOWN), void 0 === i && (i = 0), void 0 === r && (r = 0), void 0 === o && (o = Pa.NONE), void 0 === a && (a = 1), void 0 === s && (s = 1), void 0 === c && (c = Oa.X1), void 0 === l && (l = 1), this.type = e, this.usage = t, this.format = n, this.width = i, this.height = r, this.flags = o, this.layerCount = a, this.levelCount = s, this.samples = c, this.depth = l
                    }
                    return e.prototype.copy = function(e) {
                        return this.type = e.type, this.usage = e.usage, this.format = e.format, this.width = e.width, this.height = e.height, this.flags = e.flags, this.layerCount = e.layerCount, this.levelCount = e.levelCount, this.samples = e.samples, this.depth = e.depth, this
                    }, e
                }(),
                As = function() {
                    function e(e, t, n, i, r, o, a) {
                        void 0 === e && (e = null), void 0 === t && (t = wa.TEX2D), void 0 === n && (n = Ea.UNKNOWN), void 0 === i && (i = 0), void 0 === r && (r = 1), void 0 === o && (o = 0), void 0 === a && (a = 1), this.texture = e, this.type = t, this.format = n, this.baseLevel = i, this.levelCount = r, this.baseLayer = o, this.layerCount = a
                    }
                    return e.prototype.copy = function(e) {
                        return this.texture = e.texture, this.type = e.type, this.format = e.format, this.baseLevel = e.baseLevel, this.levelCount = e.levelCount, this.baseLayer = e.baseLayer, this.layerCount = e.layerCount, this
                    }, e
                }(),
                xs = function() {
                    function e(e, t, n, i, r, o, a, s, c, l) {
                        void 0 === e && (e = Da.LINEAR), void 0 === t && (t = Da.LINEAR), void 0 === n && (n = Da.NONE), void 0 === i && (i = Na.WRAP), void 0 === r && (r = Na.WRAP), void 0 === o && (o = Na.WRAP), void 0 === a && (a = 0), void 0 === s && (s = Ma.ALWAYS), void 0 === c && (c = new ps), void 0 === l && (l = 0), this.minFilter = e, this.magFilter = t, this.mipFilter = n, this.addressU = i, this.addressV = r, this.addressW = o, this.maxAnisotropy = a, this.cmpFunc = s, this.borderColor = c, this.mipLODBias = l
                    }
                    return e.prototype.copy = function(e) {
                        return this.minFilter = e.minFilter, this.magFilter = e.magFilter, this.mipFilter = e.mipFilter, this.addressU = e.addressU, this.addressV = e.addressV, this.addressW = e.addressW, this.maxAnisotropy = e.maxAnisotropy, this.cmpFunc = e.cmpFunc, this.borderColor.copy(e.borderColor), this.mipLODBias = e.mipLODBias, this
                    }, e
                }(),
                Cs = function() {
                    function e(e, t, n) {
                        void 0 === e && (e = ""), void 0 === t && (t = Aa.UNKNOWN), void 0 === n && (n = 0), this.name = e, this.type = t, this.count = n
                    }
                    return e.prototype.copy = function(e) {
                        return this.name = e.name, this.type = e.type, this.count = e.count, this
                    }, e
                }(),
                bs = function() {
                    function e(e, t, n, i, r) {
                        void 0 === e && (e = 0), void 0 === t && (t = 0), void 0 === n && (n = ""), void 0 === i && (i = []), void 0 === r && (r = 0), this.set = e, this.binding = t, this.name = n, this.members = i, this.count = r
                    }
                    return e.prototype.copy = function(e) {
                        return this.set = e.set, this.binding = e.binding, this.name = e.name, ns(this.members, e.members, Cs), this.count = e.count, this
                    }, e
                }(),
                Rs = function() {
                    function e(e, t, n, i, r) {
                        void 0 === e && (e = 0), void 0 === t && (t = 0), void 0 === n && (n = ""), void 0 === i && (i = Aa.UNKNOWN), void 0 === r && (r = 0), this.set = e, this.binding = t, this.name = n, this.type = i, this.count = r
                    }
                    return e.prototype.copy = function(e) {
                        return this.set = e.set, this.binding = e.binding, this.name = e.name, this.type = e.type, this.count = e.count, this
                    }, e
                }(),
                ws = function() {
                    function e(e, t, n, i) {
                        void 0 === e && (e = 0), void 0 === t && (t = 0), void 0 === n && (n = ""), void 0 === i && (i = 0), this.set = e, this.binding = t, this.name = n, this.count = i
                    }
                    return e.prototype.copy = function(e) {
                        return this.set = e.set, this.binding = e.binding, this.name = e.name, this.count = e.count, this
                    }, e
                }(),
                Is = function() {
                    function e(e, t, n, i, r) {
                        void 0 === e && (e = 0), void 0 === t && (t = 0), void 0 === n && (n = ""), void 0 === i && (i = Aa.UNKNOWN), void 0 === r && (r = 0), this.set = e, this.binding = t, this.name = n, this.type = i, this.count = r
                    }
                    return e.prototype.copy = function(e) {
                        return this.set = e.set, this.binding = e.binding, this.name = e.name, this.type = e.type, this.count = e.count, this
                    }, e
                }(),
                Ps = function() {
                    function e(e, t, n, i, r, o) {
                        void 0 === e && (e = 0), void 0 === t && (t = 0), void 0 === n && (n = ""), void 0 === i && (i = Aa.UNKNOWN), void 0 === r && (r = 0), void 0 === o && (o = ba.READ_WRITE), this.set = e, this.binding = t, this.name = n, this.type = i, this.count = r, this.memoryAccess = o
                    }
                    return e.prototype.copy = function(e) {
                        return this.set = e.set, this.binding = e.binding, this.name = e.name, this.type = e.type, this.count = e.count, this.memoryAccess = e.memoryAccess, this
                    }, e
                }(),
                Os = function() {
                    function e(e, t, n, i, r) {
                        void 0 === e && (e = 0), void 0 === t && (t = 0), void 0 === n && (n = ""), void 0 === i && (i = 0), void 0 === r && (r = ba.READ_WRITE), this.set = e, this.binding = t, this.name = n, this.count = i, this.memoryAccess = r
                    }
                    return e.prototype.copy = function(e) {
                        return this.set = e.set, this.binding = e.binding, this.name = e.name, this.count = e.count, this.memoryAccess = e.memoryAccess, this
                    }, e
                }(),
                Ds = function() {
                    function e(e, t, n, i) {
                        void 0 === e && (e = 0), void 0 === t && (t = 0), void 0 === n && (n = ""), void 0 === i && (i = 0), this.set = e, this.binding = t, this.name = n, this.count = i
                    }
                    return e.prototype.copy = function(e) {
                        return this.set = e.set, this.binding = e.binding, this.name = e.name, this.count = e.count, this
                    }, e
                }(),
                Ns = function() {
                    function e(e, t) {
                        void 0 === e && (e = Ua.NONE), void 0 === t && (t = ""), this.stage = e, this.source = t
                    }
                    return e.prototype.copy = function(e) {
                        return this.stage = e.stage, this.source = e.source, this
                    }, e
                }(),
                Ms = function() {
                    function e(e, t, n, i, r, o) {
                        void 0 === e && (e = ""), void 0 === t && (t = Ea.UNKNOWN), void 0 === n && (n = !1), void 0 === i && (i = 0), void 0 === r && (r = !1), void 0 === o && (o = 0), this.name = e, this.format = t, this.isNormalized = n, this.stream = i, this.isInstanced = r, this.location = o
                    }
                    return e.prototype.copy = function(e) {
                        return this.name = e.name, this.format = e.format, this.isNormalized = e.isNormalized, this.stream = e.stream, this.isInstanced = e.isInstanced, this.location = e.location, this
                    }, e
                }(),
                Ls = function() {
                    function e(e, t, n, i, r, o, a, s, c, l) {
                        void 0 === e && (e = ""), void 0 === t && (t = []), void 0 === n && (n = []), void 0 === i && (i = []), void 0 === r && (r = []), void 0 === o && (o = []), void 0 === a && (a = []), void 0 === s && (s = []), void 0 === c && (c = []), void 0 === l && (l = []), this.name = e, this.stages = t, this.attributes = n, this.blocks = i, this.buffers = r, this.samplerTextures = o, this.samplers = a, this.textures = s, this.images = c, this.subpassInputs = l
                    }
                    return e.prototype.copy = function(e) {
                        return this.name = e.name, ns(this.stages, e.stages, Ns), ns(this.attributes, e.attributes, Ms), ns(this.blocks, e.blocks, bs), ns(this.buffers, e.buffers, Os), ns(this.samplerTextures, e.samplerTextures, Rs), ns(this.samplers, e.samplers, ws), ns(this.textures, e.textures, Is), ns(this.images, e.images, Ps), ns(this.subpassInputs, e.subpassInputs, Ds), this
                    }, e
                }(),
                Bs = function() {
                    function e(e, t, n, i) {
                        void 0 === e && (e = []), void 0 === t && (t = []), void 0 === n && (n = null), void 0 === i && (i = null), this.attributes = e, this.vertexBuffers = t, this.indexBuffer = n, this.indirectBuffer = i
                    }
                    return e.prototype.copy = function(e) {
                        return ns(this.attributes, e.attributes, Ms), this.vertexBuffers = e.vertexBuffers.slice(), this.indexBuffer = e.indexBuffer, this.indirectBuffer = e.indirectBuffer, this
                    }, e
                }(),
                Fs = function() {
                    function e(e, t, n, i, r, o) {
                        void 0 === e && (e = Ea.UNKNOWN), void 0 === t && (t = Oa.X1), void 0 === n && (n = Ga.CLEAR), void 0 === i && (i = Ha.STORE), void 0 === r && (r = []), void 0 === o && (o = [ka.PRESENT]), this.format = e, this.sampleCount = t, this.loadOp = n, this.storeOp = i, this.beginAccesses = r, this.endAccesses = o
                    }
                    return e.prototype.copy = function(e) {
                        return this.format = e.format, this.sampleCount = e.sampleCount, this.loadOp = e.loadOp, this.storeOp = e.storeOp, this.beginAccesses = e.beginAccesses.slice(), this.endAccesses = e.endAccesses.slice(), this
                    }, e
                }(),
                zs = function() {
                    function e(e, t, n, i, r, o, a, s) {
                        void 0 === e && (e = Ea.UNKNOWN), void 0 === t && (t = Oa.X1), void 0 === n && (n = Ga.CLEAR), void 0 === i && (i = Ha.STORE), void 0 === r && (r = Ga.CLEAR), void 0 === o && (o = Ha.STORE), void 0 === a && (a = []), void 0 === s && (s = [ka.DEPTH_STENCIL_ATTACHMENT_WRITE]), this.format = e, this.sampleCount = t, this.depthLoadOp = n, this.depthStoreOp = i, this.stencilLoadOp = r, this.stencilStoreOp = o, this.beginAccesses = a, this.endAccesses = s
                    }
                    return e.prototype.copy = function(e) {
                        return this.format = e.format, this.sampleCount = e.sampleCount, this.depthLoadOp = e.depthLoadOp, this.depthStoreOp = e.depthStoreOp, this.stencilLoadOp = e.stencilLoadOp, this.stencilStoreOp = e.stencilStoreOp, this.beginAccesses = e.beginAccesses.slice(), this.endAccesses = e.endAccesses.slice(), this
                    }, e
                }(),
                Us = function() {
                    function e(e, t, n, i, r) {
                        void 0 === e && (e = []), void 0 === t && (t = []), void 0 === n && (n = []), void 0 === i && (i = []), void 0 === r && (r = -1), this.inputs = e, this.colors = t, this.resolves = n, this.preserves = i, this.depthStencil = r
                    }
                    return e.prototype.copy = function(e) {
                        return this.inputs = e.inputs.slice(), this.colors = e.colors.slice(), this.resolves = e.resolves.slice(), this.preserves = e.preserves.slice(), this.depthStencil = e.depthStencil, this
                    }, e
                }(),
                Gs = function() {
                    function e(e, t, n) {
                        void 0 === e && (e = []), void 0 === t && (t = new zs), void 0 === n && (n = []), this.colorAttachments = e, this.depthStencilAttachment = t, this.subpasses = n
                    }
                    return e.prototype.copy = function(e) {
                        return ns(this.colorAttachments, e.colorAttachments, Fs), this.depthStencilAttachment.copy(e.depthStencilAttachment), ns(this.subpasses, e.subpasses, Us), this
                    }, e
                }(),
                Hs = function() {
                    function e(e, t) {
                        void 0 === e && (e = []), void 0 === t && (t = []), this.prevAccesses = e, this.nextAccesses = t
                    }
                    return e.prototype.copy = function(e) {
                        return this.prevAccesses = e.prevAccesses.slice(), this.nextAccesses = e.nextAccesses.slice(), this
                    }, e
                }(),
                ks = function() {
                    function e(e, t, n, i, r) {
                        void 0 === e && (e = []), void 0 === t && (t = []), void 0 === n && (n = !1), void 0 === i && (i = null), void 0 === r && (r = null), this.prevAccesses = e, this.nextAccesses = t, this.discardContents = n, this.srcQueue = i, this.dstQueue = r
                    }
                    return e.prototype.copy = function(e) {
                        return this.prevAccesses = e.prevAccesses.slice(), this.nextAccesses = e.nextAccesses.slice(), this.discardContents = e.discardContents, this.srcQueue = e.srcQueue, this.dstQueue = e.dstQueue, this
                    }, e
                }(),
                Vs = function() {
                    function e(e, t, n, i, r) {
                        void 0 === e && (e = null), void 0 === t && (t = []), void 0 === n && (n = null), void 0 === i && (i = []), void 0 === r && (r = 0), this.renderPass = e, this.colorTextures = t, this.depthStencilTexture = n, this.colorMipmapLevels = i, this.depthStencilMipmapLevel = r
                    }
                    return e.prototype.copy = function(e) {
                        return this.renderPass = e.renderPass, this.colorTextures = e.colorTextures.slice(), this.depthStencilTexture = e.depthStencilTexture, this.colorMipmapLevels = e.colorMipmapLevels.slice(), this.depthStencilMipmapLevel = e.depthStencilMipmapLevel, this
                    }, e
                }(),
                Ws = function() {
                    function e(e, t, n, i, r) {
                        void 0 === e && (e = -1), void 0 === t && (t = Za.UNKNOWN), void 0 === n && (n = 0), void 0 === i && (i = Ua.NONE), void 0 === r && (r = []), this.binding = e, this.descriptorType = t, this.count = n, this.stageFlags = i, this.immutableSamplers = r
                    }
                    return e.prototype.copy = function(e) {
                        return this.binding = e.binding, this.descriptorType = e.descriptorType, this.count = e.count, this.stageFlags = e.stageFlags, this.immutableSamplers = e.immutableSamplers.slice(), this
                    }, e
                }(),
                js = function() {
                    function e(e) {
                        void 0 === e && (e = []), this.bindings = e
                    }
                    return e.prototype.copy = function(e) {
                        return ns(this.bindings, e.bindings, Ws), this
                    }, e
                }(),
                qs = function() {
                    function e(e) {
                        void 0 === e && (e = null), this.layout = e
                    }
                    return e.prototype.copy = function(e) {
                        return this.layout = e.layout, this
                    }, e
                }(),
                Xs = function() {
                    function e(e) {
                        void 0 === e && (e = []), this.setLayouts = e
                    }
                    return e.prototype.copy = function(e) {
                        return this.setLayouts = e.setLayouts.slice(), this
                    }, e
                }(),
                Ys = function() {
                    function e(e) {
                        void 0 === e && (e = []), this.attributes = e
                    }
                    return e.prototype.copy = function(e) {
                        return ns(this.attributes, e.attributes, Ms), this
                    }, e
                }(),
                Ks = function() {
                    function e(e, t) {
                        void 0 === e && (e = null), void 0 === t && (t = Ja.PRIMARY), this.queue = e, this.type = t
                    }
                    return e.prototype.copy = function(e) {
                        return this.queue = e.queue, this.type = e.type, this
                    }, e
                }(),
                Zs = function() {
                    function e(e) {
                        void 0 === e && (e = Qa.GRAPHICS), this.type = e
                    }
                    return e.prototype.copy = function(e) {
                        return this.type = e.type, this
                    }, e
                }(),
                Qs = function(e, t, n, i, r, o, a, s) {
                    void 0 === e && (e = ""), void 0 === t && (t = 0), void 0 === n && (n = 0), void 0 === i && (i = Ta.NONE), void 0 === r && (r = !1), void 0 === o && (o = !1), void 0 === a && (a = !1), void 0 === s && (s = !1), this.name = e, this.size = t, this.count = n, this.type = i, this.hasAlpha = r, this.hasDepth = o, this.hasStencil = a, this.isCompressed = s
                },
                Js = function() {
                    function e(e, t) {
                        void 0 === e && (e = 0), void 0 === t && (t = 0), this.bufferSize = e, this.textureSize = t
                    }
                    return e.prototype.copy = function(e) {
                        return this.bufferSize = e.bufferSize, this.textureSize = e.textureSize, this
                    }, e
                }(),
                $s = function() {
                    function e(e) {
                        this._gfxType = ma.UNKNOWN, this._gfxType = e
                    }
                    return K(e, [{
                        key: "gfxType",
                        get: function() {
                            return this._gfxType
                        }
                    }]), e
                }(),
                ec = function(e, t, n, i, r, o, a) {
                    void 0 === t && (t = !0), void 0 === n && (n = !0), void 0 === i && (i = 1), void 0 === r && (r = 1), void 0 === o && (o = 1), void 0 === a && (a = new ms), this.canvasElm = e, this.isAntialias = t, this.isPremultipliedAlpha = n, this.devicePixelRatio = i, this.nativeWidth = r, this.nativeHeight = o, this.bindingMappingInfo = a
                };
            ! function(e) {
                e.ATTR_POSITION = "a_position", e.ATTR_NORMAL = "a_normal", e.ATTR_TANGENT = "a_tangent", e.ATTR_BITANGENT = "a_bitangent", e.ATTR_WEIGHTS = "a_weights", e.ATTR_JOINTS = "a_joints", e.ATTR_COLOR = "a_color", e.ATTR_COLOR1 = "a_color1", e.ATTR_COLOR2 = "a_color2", e.ATTR_TEX_COORD = "a_texCoord", e.ATTR_TEX_COORD1 = "a_texCoord1", e.ATTR_TEX_COORD2 = "a_texCoord2", e.ATTR_TEX_COORD3 = "a_texCoord3", e.ATTR_TEX_COORD4 = "a_texCoord4", e.ATTR_TEX_COORD5 = "a_texCoord5", e.ATTR_TEX_COORD6 = "a_texCoord6", e.ATTR_TEX_COORD7 = "a_texCoord7", e.ATTR_TEX_COORD8 = "a_texCoord8", e.ATTR_BATCH_ID = "a_batch_id", e.ATTR_BATCH_UV = "a_batch_uv"
            }(is || (is = {}));
            var tc = Object.freeze([new Qs("UNKNOWN", 0, 0, Ta.NONE, !1, !1, !1, !1), new Qs("A8", 1, 1, Ta.UNORM, !0, !1, !1, !1), new Qs("L8", 1, 1, Ta.UNORM, !1, !1, !1, !1), new Qs("LA8", 1, 2, Ta.UNORM, !0, !1, !1, !1), new Qs("R8", 1, 1, Ta.UNORM, !1, !1, !1, !1), new Qs("R8SN", 1, 1, Ta.SNORM, !1, !1, !1, !1), new Qs("R8UI", 1, 1, Ta.UINT, !1, !1, !1, !1), new Qs("R8I", 1, 1, Ta.INT, !1, !1, !1, !1), new Qs("R16F", 2, 1, Ta.FLOAT, !1, !1, !1, !1), new Qs("R16UI", 2, 1, Ta.UINT, !1, !1, !1, !1), new Qs("R16I", 2, 1, Ta.INT, !1, !1, !1, !1), new Qs("R32F", 4, 1, Ta.FLOAT, !1, !1, !1, !1), new Qs("R32UI", 4, 1, Ta.UINT, !1, !1, !1, !1), new Qs("R32I", 4, 1, Ta.INT, !1, !1, !1, !1), new Qs("RG8", 2, 2, Ta.UNORM, !1, !1, !1, !1), new Qs("RG8SN", 2, 2, Ta.SNORM, !1, !1, !1, !1), new Qs("RG8UI", 2, 2, Ta.UINT, !1, !1, !1, !1), new Qs("RG8I", 2, 2, Ta.INT, !1, !1, !1, !1), new Qs("RG16F", 4, 2, Ta.FLOAT, !1, !1, !1, !1), new Qs("RG16UI", 4, 2, Ta.UINT, !1, !1, !1, !1), new Qs("RG16I", 4, 2, Ta.INT, !1, !1, !1, !1), new Qs("RG32F", 8, 2, Ta.FLOAT, !1, !1, !1, !1), new Qs("RG32UI", 8, 2, Ta.UINT, !1, !1, !1, !1), new Qs("RG32I", 8, 2, Ta.INT, !1, !1, !1, !1), new Qs("RGB8", 3, 3, Ta.UNORM, !1, !1, !1, !1), new Qs("SRGB8", 3, 3, Ta.UNORM, !1, !1, !1, !1), new Qs("RGB8SN", 3, 3, Ta.SNORM, !1, !1, !1, !1), new Qs("RGB8UI", 3, 3, Ta.UINT, !1, !1, !1, !1), new Qs("RGB8I", 3, 3, Ta.INT, !1, !1, !1, !1), new Qs("RGB16F", 6, 3, Ta.FLOAT, !1, !1, !1, !1), new Qs("RGB16UI", 6, 3, Ta.UINT, !1, !1, !1, !1), new Qs("RGB16I", 6, 3, Ta.INT, !1, !1, !1, !1), new Qs("RGB32F", 12, 3, Ta.FLOAT, !1, !1, !1, !1), new Qs("RGB32UI", 12, 3, Ta.UINT, !1, !1, !1, !1), new Qs("RGB32I", 12, 3, Ta.INT, !1, !1, !1, !1), new Qs("RGBA8", 4, 4, Ta.UNORM, !0, !1, !1, !1), new Qs("BGRA8", 4, 4, Ta.UNORM, !0, !1, !1, !1), new Qs("SRGB8_A8", 4, 4, Ta.UNORM, !0, !1, !1, !1), new Qs("RGBA8SN", 4, 4, Ta.SNORM, !0, !1, !1, !1), new Qs("RGBA8UI", 4, 4, Ta.UINT, !0, !1, !1, !1), new Qs("RGBA8I", 4, 4, Ta.INT, !0, !1, !1, !1), new Qs("RGBA16F", 8, 4, Ta.FLOAT, !0, !1, !1, !1), new Qs("RGBA16UI", 8, 4, Ta.UINT, !0, !1, !1, !1), new Qs("RGBA16I", 8, 4, Ta.INT, !0, !1, !1, !1), new Qs("RGBA32F", 16, 4, Ta.FLOAT, !0, !1, !1, !1), new Qs("RGBA32UI", 16, 4, Ta.UINT, !0, !1, !1, !1), new Qs("RGBA32I", 16, 4, Ta.INT, !0, !1, !1, !1), new Qs("R5G6B5", 2, 3, Ta.UNORM, !1, !1, !1, !1), new Qs("R11G11B10F", 4, 3, Ta.FLOAT, !1, !1, !1, !1), new Qs("RGB5A1", 2, 4, Ta.UNORM, !0, !1, !1, !1), new Qs("RGBA4", 2, 4, Ta.UNORM, !0, !1, !1, !1), new Qs("RGB10A2", 2, 4, Ta.UNORM, !0, !1, !1, !1), new Qs("RGB10A2UI", 2, 4, Ta.UINT, !0, !1, !1, !1), new Qs("RGB9E5", 2, 4, Ta.FLOAT, !0, !1, !1, !1), new Qs("D16", 2, 1, Ta.UINT, !1, !0, !1, !1), new Qs("D16S8", 3, 2, Ta.UINT, !1, !0, !0, !1), new Qs("D24", 3, 1, Ta.UINT, !1, !0, !1, !1), new Qs("D24S8", 4, 2, Ta.UINT, !1, !0, !0, !1), new Qs("D32F", 4, 1, Ta.FLOAT, !1, !0, !1, !1), new Qs("D32FS8", 5, 2, Ta.FLOAT, !1, !0, !0, !1), new Qs("BC1", 1, 3, Ta.UNORM, !1, !1, !1, !0), new Qs("BC1_ALPHA", 1, 4, Ta.UNORM, !0, !1, !1, !0), new Qs("BC1_SRGB", 1, 3, Ta.UNORM, !1, !1, !1, !0), new Qs("BC1_SRGB_ALPHA", 1, 4, Ta.UNORM, !0, !1, !1, !0), new Qs("BC2", 1, 4, Ta.UNORM, !0, !1, !1, !0), new Qs("BC2_SRGB", 1, 4, Ta.UNORM, !0, !1, !1, !0), new Qs("BC3", 1, 4, Ta.UNORM, !0, !1, !1, !0), new Qs("BC3_SRGB", 1, 4, Ta.UNORM, !0, !1, !1, !0), new Qs("BC4", 1, 1, Ta.UNORM, !1, !1, !1, !0), new Qs("BC4_SNORM", 1, 1, Ta.SNORM, !1, !1, !1, !0), new Qs("BC5", 1, 2, Ta.UNORM, !1, !1, !1, !0), new Qs("BC5_SNORM", 1, 2, Ta.SNORM, !1, !1, !1, !0), new Qs("BC6H_UF16", 1, 3, Ta.UFLOAT, !1, !1, !1, !0), new Qs("BC6H_SF16", 1, 3, Ta.FLOAT, !1, !1, !1, !0), new Qs("BC7", 1, 4, Ta.UNORM, !0, !1, !1, !0), new Qs("BC7_SRGB", 1, 4, Ta.UNORM, !0, !1, !1, !0), new Qs("ETC_RGB8", 1, 3, Ta.UNORM, !1, !1, !1, !0), new Qs("ETC2_RGB8", 1, 3, Ta.UNORM, !1, !1, !1, !0), new Qs("ETC2_SRGB8", 1, 3, Ta.UNORM, !1, !1, !1, !0), new Qs("ETC2_RGB8_A1", 1, 4, Ta.UNORM, !0, !1, !1, !0), new Qs("ETC2_SRGB8_A1", 1, 4, Ta.UNORM, !0, !1, !1, !0), new Qs("ETC2_RGBA8", 2, 4, Ta.UNORM, !0, !1, !1, !0), new Qs("ETC2_SRGB8_A8", 2, 4, Ta.UNORM, !0, !1, !1, !0), new Qs("EAC_R11", 1, 1, Ta.UNORM, !1, !1, !1, !0), new Qs("EAC_R11SN", 1, 1, Ta.SNORM, !1, !1, !1, !0), new Qs("EAC_RG11", 2, 2, Ta.UNORM, !1, !1, !1, !0), new Qs("EAC_RG11SN", 2, 2, Ta.SNORM, !1, !1, !1, !0), new Qs("PVRTC_RGB2", 2, 3, Ta.UNORM, !1, !1, !1, !0), new Qs("PVRTC_RGBA2", 2, 4, Ta.UNORM, !0, !1, !1, !0), new Qs("PVRTC_RGB4", 2, 3, Ta.UNORM, !1, !1, !1, !0), new Qs("PVRTC_RGBA4", 2, 4, Ta.UNORM, !0, !1, !1, !0), new Qs("PVRTC2_2BPP", 2, 4, Ta.UNORM, !0, !1, !1, !0), new Qs("PVRTC2_4BPP", 2, 4, Ta.UNORM, !0, !1, !1, !0), new Qs("ASTC_RGBA_4x4", 1, 4, Ta.UNORM, !0, !1, !1, !0), new Qs("ASTC_RGBA_5x4", 1, 4, Ta.UNORM, !0, !1, !1, !0), new Qs("ASTC_RGBA_5x5", 1, 4, Ta.UNORM, !0, !1, !1, !0), new Qs("ASTC_RGBA_6x5", 1, 4, Ta.UNORM, !0, !1, !1, !0), new Qs("ASTC_RGBA_6x6", 1, 4, Ta.UNORM, !0, !1, !1, !0), new Qs("ASTC_RGBA_8x5", 1, 4, Ta.UNORM, !0, !1, !1, !0), new Qs("ASTC_RGBA_8x6", 1, 4, Ta.UNORM, !0, !1, !1, !0), new Qs("ASTC_RGBA_8x8", 1, 4, Ta.UNORM, !0, !1, !1, !0), new Qs("ASTC_RGBA_10x5", 1, 4, Ta.UNORM, !0, !1, !1, !0), new Qs("ASTC_RGBA_10x6", 1, 4, Ta.UNORM, !0, !1, !1, !0), new Qs("ASTC_RGBA_10x8", 1, 4, Ta.UNORM, !0, !1, !1, !0), new Qs("ASTC_RGBA_10x10", 1, 4, Ta.UNORM, !0, !1, !1, !0), new Qs("ASTC_RGBA_12x10", 1, 4, Ta.UNORM, !0, !1, !1, !0), new Qs("ASTC_RGBA_12x12", 1, 4, Ta.UNORM, !0, !1, !1, !0), new Qs("ASTC_SRGBA_4x4", 1, 4, Ta.UNORM, !0, !1, !1, !0), new Qs("ASTC_SRGBA_5x4", 1, 4, Ta.UNORM, !0, !1, !1, !0), new Qs("ASTC_SRGBA_5x5", 1, 4, Ta.UNORM, !0, !1, !1, !0), new Qs("ASTC_SRGBA_6x5", 1, 4, Ta.UNORM, !0, !1, !1, !0), new Qs("ASTC_SRGBA_6x6", 1, 4, Ta.UNORM, !0, !1, !1, !0), new Qs("ASTC_SRGBA_8x5", 1, 4, Ta.UNORM, !0, !1, !1, !0), new Qs("ASTC_SRGBA_8x6", 1, 4, Ta.UNORM, !0, !1, !1, !0), new Qs("ASTC_SRGBA_8x8", 1, 4, Ta.UNORM, !0, !1, !1, !0), new Qs("ASTC_SRGBA_10x5", 1, 4, Ta.UNORM, !0, !1, !1, !0), new Qs("ASTC_SRGBA_10x6", 1, 4, Ta.UNORM, !0, !1, !1, !0), new Qs("ASTC_SRGBA_10x8", 1, 4, Ta.UNORM, !0, !1, !1, !0), new Qs("ASTC_SRGBA_10x10", 1, 4, Ta.UNORM, !0, !1, !1, !0), new Qs("ASTC_SRGBA_12x10", 1, 4, Ta.UNORM, !0, !1, !1, !0), new Qs("ASTC_SRGBA_12x12", 1, 4, Ta.UNORM, !0, !1, !1, !0)]),
                nc = Za.UNIFORM_BUFFER | Za.DYNAMIC_UNIFORM_BUFFER | Za.STORAGE_BUFFER | Za.DYNAMIC_STORAGE_BUFFER,
                ic = Za.SAMPLER_TEXTURE | Za.SAMPLER | Za.TEXTURE | Za.STORAGE_IMAGE | Za.INPUT_ATTACHMENT,
                rc = Za.DYNAMIC_STORAGE_BUFFER | Za.DYNAMIC_UNIFORM_BUFFER;

            function oc(e) {
                return e > 0 && 0 == (e & e - 1)
            }

            function ac(e, t, n, i) {
                if (!tc[e].isCompressed) return t * n * i * tc[e].size;
                switch (e) {
                    case Ea.BC1:
                    case Ea.BC1_ALPHA:
                    case Ea.BC1_SRGB:
                    case Ea.BC1_SRGB_ALPHA:
                        return Math.ceil(t / 4) * Math.ceil(n / 4) * 8 * i;
                    case Ea.BC2:
                    case Ea.BC2_SRGB:
                    case Ea.BC3:
                    case Ea.BC3_SRGB:
                    case Ea.BC4:
                    case Ea.BC4_SNORM:
                    case Ea.BC6H_SF16:
                    case Ea.BC6H_UF16:
                    case Ea.BC7:
                    case Ea.BC7_SRGB:
                        return Math.ceil(t / 4) * Math.ceil(n / 4) * 16 * i;
                    case Ea.BC5:
                    case Ea.BC5_SNORM:
                        return Math.ceil(t / 4) * Math.ceil(n / 4) * 32 * i;
                    case Ea.ETC_RGB8:
                    case Ea.ETC2_RGB8:
                    case Ea.ETC2_SRGB8:
                    case Ea.ETC2_RGB8_A1:
                    case Ea.EAC_R11:
                    case Ea.EAC_R11SN:
                        return Math.ceil(t / 4) * Math.ceil(n / 4) * 8 * i;
                    case Ea.ETC2_RGBA8:
                    case Ea.ETC2_SRGB8_A1:
                    case Ea.EAC_RG11:
                    case Ea.EAC_RG11SN:
                        return Math.ceil(t / 4) * Math.ceil(n / 4) * 16 * i;
                    case Ea.PVRTC_RGB2:
                    case Ea.PVRTC_RGBA2:
                    case Ea.PVRTC2_2BPP:
                        return Math.ceil(Math.max(t, 16) * Math.max(n, 8) / 4) * i;
                    case Ea.PVRTC_RGB4:
                    case Ea.PVRTC_RGBA4:
                    case Ea.PVRTC2_4BPP:
                        return Math.ceil(Math.max(t, 8) * Math.max(n, 8) / 2) * i;
                    case Ea.ASTC_RGBA_4x4:
                    case Ea.ASTC_SRGBA_4x4:
                        return Math.ceil(t / 4) * Math.ceil(n / 4) * 16 * i;
                    case Ea.ASTC_RGBA_5x4:
                    case Ea.ASTC_SRGBA_5x4:
                        return Math.ceil(t / 5) * Math.ceil(n / 4) * 16 * i;
                    case Ea.ASTC_RGBA_5x5:
                    case Ea.ASTC_SRGBA_5x5:
                        return Math.ceil(t / 5) * Math.ceil(n / 5) * 16 * i;
                    case Ea.ASTC_RGBA_6x5:
                    case Ea.ASTC_SRGBA_6x5:
                        return Math.ceil(t / 6) * Math.ceil(n / 5) * 16 * i;
                    case Ea.ASTC_RGBA_6x6:
                    case Ea.ASTC_SRGBA_6x6:
                        return Math.ceil(t / 6) * Math.ceil(n / 6) * 16 * i;
                    case Ea.ASTC_RGBA_8x5:
                    case Ea.ASTC_SRGBA_8x5:
                        return Math.ceil(t / 8) * Math.ceil(n / 5) * 16 * i;
                    case Ea.ASTC_RGBA_8x6:
                    case Ea.ASTC_SRGBA_8x6:
                        return Math.ceil(t / 8) * Math.ceil(n / 6) * 16 * i;
                    case Ea.ASTC_RGBA_8x8:
                    case Ea.ASTC_SRGBA_8x8:
                        return Math.ceil(t / 8) * Math.ceil(n / 8) * 16 * i;
                    case Ea.ASTC_RGBA_10x5:
                    case Ea.ASTC_SRGBA_10x5:
                        return Math.ceil(t / 10) * Math.ceil(n / 5) * 16 * i;
                    case Ea.ASTC_RGBA_10x6:
                    case Ea.ASTC_SRGBA_10x6:
                        return Math.ceil(t / 10) * Math.ceil(n / 6) * 16 * i;
                    case Ea.ASTC_RGBA_10x8:
                    case Ea.ASTC_SRGBA_10x8:
                        return Math.ceil(t / 10) * Math.ceil(n / 8) * 16 * i;
                    case Ea.ASTC_RGBA_10x10:
                    case Ea.ASTC_SRGBA_10x10:
                        return Math.ceil(t / 10) * Math.ceil(n / 10) * 16 * i;
                    case Ea.ASTC_RGBA_12x10:
                    case Ea.ASTC_SRGBA_12x10:
                        return Math.ceil(t / 12) * Math.ceil(n / 10) * 16 * i;
                    case Ea.ASTC_RGBA_12x12:
                    case Ea.ASTC_SRGBA_12x12:
                        return Math.ceil(t / 12) * Math.ceil(n / 12) * 16 * i;
                    default:
                        return 0
                }
            }

            function sc(e, t, n, i, r) {
                for (var o = 0, a = 0; a < r; ++a) o += ac(e, t, n, i), t = Math.max(t >> 1, 1), n = Math.max(n >> 1, 1);
                return o
            }
            var cc = [0, 4, 8, 12, 16, 4, 8, 12, 16, 4, 8, 12, 16, 4, 8, 12, 16, 16, 24, 32, 24, 36, 48, 32, 48, 64, 4, 4, 4, 4, 4, 4];

            function lc(e) {
                return cc[e] || 0
            }

            function uc(e) {
                var t = e.size / e.count;
                switch (e.type) {
                    case Ta.UNORM:
                    case Ta.UINT:
                        switch (t) {
                            case 1:
                                return Uint8Array;
                            case 2:
                                return Uint16Array;
                            case 4:
                                return Uint32Array
                        }
                        break;
                    case Ta.SNORM:
                    case Ta.INT:
                        switch (t) {
                            case 1:
                                return Int8Array;
                            case 2:
                                return Int16Array;
                            case 4:
                                return Int32Array
                        }
                        break;
                    case Ta.FLOAT:
                        return Float32Array
                }
                return Float32Array
            }
            var hc = Object.freeze({
                    __proto__: null,
                    get ObjectType() {
                        return ma
                    },
                    get Status() {
                        return ga
                    },
                    get API() {
                        return va
                    },
                    get SurfaceTransform() {
                        return ya
                    },
                    get Feature() {
                        return Sa
                    },
                    get Format() {
                        return Ea
                    },
                    get FormatType() {
                        return Ta
                    },
                    get Type() {
                        return Aa
                    },
                    get BufferUsageBit() {
                        return xa
                    },
                    get BufferFlagBit() {
                        return Ca
                    },
                    get MemoryAccessBit() {
                        return ba
                    },
                    get MemoryUsageBit() {
                        return Ra
                    },
                    get TextureType() {
                        return wa
                    },
                    get TextureUsageBit() {
                        return Ia
                    },
                    get TextureFlagBit() {
                        return Pa
                    },
                    get SampleCount() {
                        return Oa
                    },
                    get Filter() {
                        return Da
                    },
                    get Address() {
                        return Na
                    },
                    get ComparisonFunc() {
                        return Ma
                    },
                    get StencilOp() {
                        return La
                    },
                    get BlendFactor() {
                        return Ba
                    },
                    get BlendOp() {
                        return Fa
                    },
                    get ColorMask() {
                        return za
                    },
                    get ShaderStageFlagBit() {
                        return Ua
                    },
                    get LoadOp() {
                        return Ga
                    },
                    get StoreOp() {
                        return Ha
                    },
                    get AccessType() {
                        return ka
                    },
                    get PipelineBindPoint() {
                        return Va
                    },
                    get PrimitiveMode() {
                        return Wa
                    },
                    get PolygonMode() {
                        return ja
                    },
                    get ShadeModel() {
                        return qa
                    },
                    get CullMode() {
                        return Xa
                    },
                    get DynamicStateFlagBit() {
                        return Ya
                    },
                    get StencilFace() {
                        return Ka
                    },
                    get DescriptorType() {
                        return Za
                    },
                    get QueueType() {
                        return Qa
                    },
                    get CommandBufferType() {
                        return Ja
                    },
                    get ClearFlagBit() {
                        return $a
                    },
                    Size: rs,
                    DeviceCaps: os,
                    Offset: as,
                    Rect: ss,
                    Extent: cs,
                    TextureSubresLayers: ls,
                    TextureSubresRange: us,
                    TextureCopy: hs,
                    TextureBlit: _s,
                    BufferTextureCopy: fs,
                    Viewport: ds,
                    Color: ps,
                    BindingMappingInfo: ms,
                    BufferInfo: gs,
                    BufferViewInfo: vs,
                    DrawInfo: ys,
                    DispatchInfo: Ss,
                    IndirectBuffer: Es,
                    TextureInfo: Ts,
                    TextureViewInfo: As,
                    SamplerInfo: xs,
                    Uniform: Cs,
                    UniformBlock: bs,
                    UniformSamplerTexture: Rs,
                    UniformSampler: ws,
                    UniformTexture: Is,
                    UniformStorageImage: Ps,
                    UniformStorageBuffer: Os,
                    UniformInputAttachment: Ds,
                    ShaderStage: Ns,
                    Attribute: Ms,
                    ShaderInfo: Ls,
                    InputAssemblerInfo: Bs,
                    ColorAttachment: Fs,
                    DepthStencilAttachment: zs,
                    SubpassInfo: Us,
                    RenderPassInfo: Gs,
                    GlobalBarrierInfo: Hs,
                    TextureBarrierInfo: ks,
                    FramebufferInfo: Vs,
                    DescriptorSetLayoutBinding: Ws,
                    DescriptorSetLayoutInfo: js,
                    DescriptorSetInfo: qs,
                    PipelineLayoutInfo: Xs,
                    InputState: Ys,
                    CommandBufferInfo: Ks,
                    QueueInfo: Zs,
                    FormatInfo: Qs,
                    MemoryStatus: Js,
                    Obj: $s,
                    DeviceInfo: ec,
                    get AttributeName() {
                        return is
                    },
                    FormatInfos: tc,
                    DESCRIPTOR_BUFFER_TYPE: nc,
                    DESCRIPTOR_SAMPLER_TYPE: ic,
                    DESCRIPTOR_DYNAMIC_TYPE: rc,
                    DRAW_INFO_SIZE: 28,
                    IsPowerOf2: oc,
                    FormatSize: ac,
                    FormatSurfaceSize: sc,
                    GetTypeSize: lc,
                    getTypedArrayConstructor: uc
                }),
                _c = function(e) {
                    function t(t) {
                        var n;
                        return (n = e.call(this, ma.BUFFER) || this)._device = void 0, n._usage = xa.NONE, n._memUsage = Ra.NONE, n._size = 0, n._stride = 1, n._count = 0, n._flags = Ca.NONE, n._indirectBuffer = null, n._isBufferView = !1, n._device = t, n
                    }
                    return Q(t, e), K(t, [{
                        key: "usage",
                        get: function() {
                            return this._usage
                        }
                    }, {
                        key: "memUsage",
                        get: function() {
                            return this._memUsage
                        }
                    }, {
                        key: "size",
                        get: function() {
                            return this._size
                        }
                    }, {
                        key: "stride",
                        get: function() {
                            return this._stride
                        }
                    }, {
                        key: "count",
                        get: function() {
                            return this._count
                        }
                    }, {
                        key: "flags",
                        get: function() {
                            return this._flags
                        }
                    }]), t
                }($s),
                fc = function(e) {
                    function t(t) {
                        var n;
                        return (n = e.call(this, ma.COMMAND_BUFFER) || this)._device = void 0, n._queue = null, n._type = Ja.PRIMARY, n._numDrawCalls = 0, n._numInstances = 0, n._numTris = 0, n._device = t, n
                    }
                    return Q(t, e), K(t, [{
                        key: "type",
                        get: function() {
                            return this._type
                        }
                    }, {
                        key: "queue",
                        get: function() {
                            return this._queue
                        }
                    }, {
                        key: "numDrawCalls",
                        get: function() {
                            return this._numDrawCalls
                        }
                    }, {
                        key: "numInstances",
                        get: function() {
                            return this._numInstances
                        }
                    }, {
                        key: "numTris",
                        get: function() {
                            return this._numTris
                        }
                    }]), t
                }($s);
            nt(Ea);
            var dc = function() {
                    function e() {
                        this._canvas = null, this._canvas2D = null, this._gfxAPI = va.UNKNOWN, this._transform = ya.IDENTITY, this._deviceName = "", this._renderer = "", this._vendor = "", this._version = "", this._features = new Array(Sa.COUNT), this._queue = null, this._cmdBuff = null, this._devicePixelRatio = 1, this._width = 0, this._height = 0, this._nativeWidth = 0, this._nativeHeight = 0, this._colorFmt = Ea.UNKNOWN, this._depthStencilFmt = Ea.UNKNOWN, this._numDrawCalls = 0, this._numInstances = 0, this._numTris = 0, this._memoryStatus = new Js, this._caps = new os
                    }
                    return e.prototype.hasFeature = function(e) {
                        return this._features[e]
                    }, K(e, [{
                        key: "canvas",
                        get: function() {
                            return this._canvas
                        }
                    }, {
                        key: "canvas2D",
                        get: function() {
                            return this._canvas2D
                        }
                    }, {
                        key: "gfxAPI",
                        get: function() {
                            return this._gfxAPI
                        }
                    }, {
                        key: "queue",
                        get: function() {
                            return this._queue
                        }
                    }, {
                        key: "commandBuffer",
                        get: function() {
                            return this._cmdBuff
                        }
                    }, {
                        key: "devicePixelRatio",
                        get: function() {
                            return this._devicePixelRatio
                        }
                    }, {
                        key: "width",
                        get: function() {
                            return this._width
                        }
                    }, {
                        key: "height",
                        get: function() {
                            return this._height
                        }
                    }, {
                        key: "nativeWidth",
                        get: function() {
                            return this._nativeWidth
                        }
                    }, {
                        key: "nativeHeight",
                        get: function() {
                            return this._nativeHeight
                        }
                    }, {
                        key: "renderer",
                        get: function() {
                            return this._renderer
                        }
                    }, {
                        key: "vendor",
                        get: function() {
                            return this._vendor
                        }
                    }, {
                        key: "colorFormat",
                        get: function() {
                            return this._colorFmt
                        }
                    }, {
                        key: "depthStencilFormat",
                        get: function() {
                            return this._depthStencilFmt
                        }
                    }, {
                        key: "numDrawCalls",
                        get: function() {
                            return this._numDrawCalls
                        }
                    }, {
                        key: "numInstances",
                        get: function() {
                            return this._numInstances
                        }
                    }, {
                        key: "numTris",
                        get: function() {
                            return this._numTris
                        }
                    }, {
                        key: "memoryStatus",
                        get: function() {
                            return this._memoryStatus
                        }
                    }, {
                        key: "capabilities",
                        get: function() {
                            return this._caps
                        }
                    }, {
                        key: "surfaceTransform",
                        get: function() {
                            return this._transform
                        }
                    }]), e
                }(),
                pc = function(e) {
                    function t(t) {
                        var n;
                        return (n = e.call(this, ma.FRAMEBUFFER) || this)._device = void 0, n._renderPass = null, n._colorTextures = [], n._depthStencilTexture = null, n._device = t, n
                    }
                    return Q(t, e), K(t, [{
                        key: "renderPass",
                        get: function() {
                            return this._renderPass
                        }
                    }, {
                        key: "colorTextures",
                        get: function() {
                            return this._colorTextures
                        }
                    }, {
                        key: "depthStencilTexture",
                        get: function() {
                            return this._depthStencilTexture
                        }
                    }]), t
                }($s),
                mc = String.prototype.charCodeAt;

            function gc(e) {
                return this[e]
            }

            function vc(e, t) {
                for (var n = e.length, i = t ^ n, r = 0, o = "string" == typeof e ? mc : gc; n >= 4;) {
                    var a = 255 & o.call(e, r) | (255 & o.call(e, ++r)) << 8 | (255 & o.call(e, ++r)) << 16 | (255 & o.call(e, ++r)) << 24;
                    a = 1540483477 * (65535 & a) + ((1540483477 * (a >>> 16) & 65535) << 16), i = 1540483477 * (65535 & i) + ((1540483477 * (i >>> 16) & 65535) << 16) ^ (a = 1540483477 * (65535 & (a ^= a >>> 24)) + ((1540483477 * (a >>> 16) & 65535) << 16)), n -= 4, ++r
                }
                switch (n) {
                    case 3:
                        i ^= (255 & o.call(e, r + 2)) << 16;
                    case 2:
                        i ^= (255 & o.call(e, r + 1)) << 8;
                    case 1:
                        i = 1540483477 * (65535 & (i ^= 255 & o.call(e, r))) + ((1540483477 * (i >>> 16) & 65535) << 16)
                }
                return i = 1540483477 * (65535 & (i ^= i >>> 13)) + ((1540483477 * (i >>> 16) & 65535) << 16), (i ^= i >>> 15) >>> 0
            }
            var yc = function(e) {
                    function t(t) {
                        var n;
                        return (n = e.call(this, ma.INPUT_ASSEMBLER) || this)._device = void 0, n._attributes = [], n._vertexBuffers = [], n._indexBuffer = null, n._vertexCount = 0, n._firstVertex = 0, n._indexCount = 0, n._firstIndex = 0, n._vertexOffset = 0, n._instanceCount = 0, n._firstInstance = 0, n._attributesHash = 0, n._indirectBuffer = null, n._device = t, n
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.getVertexBuffer = function(e) {
                        return void 0 === e && (e = 0), e < this._vertexBuffers.length ? this._vertexBuffers[e] : null
                    }, n.computeAttributesHash = function() {
                        for (var e = "attrs", t = 0; t < this.attributes.length; ++t) {
                            var n = this.attributes[t];
                            e += "," + n.name + "," + n.format + "," + n.isNormalized + "," + n.stream + "," + n.isInstanced
                        }
                        return vc(e, 666)
                    }, K(t, [{
                        key: "vertexBuffers",
                        get: function() {
                            return this._vertexBuffers
                        }
                    }, {
                        key: "indexBuffer",
                        get: function() {
                            return this._indexBuffer
                        }
                    }, {
                        key: "attributes",
                        get: function() {
                            return this._attributes
                        }
                    }, {
                        key: "attributesHash",
                        get: function() {
                            return this._attributesHash
                        }
                    }, {
                        key: "vertexCount",
                        get: function() {
                            return this._vertexCount
                        },
                        set: function(e) {
                            this._vertexCount = e
                        }
                    }, {
                        key: "firstVertex",
                        get: function() {
                            return this._firstVertex
                        },
                        set: function(e) {
                            this._firstVertex = e
                        }
                    }, {
                        key: "indexCount",
                        get: function() {
                            return this._indexCount
                        },
                        set: function(e) {
                            this._indexCount = e
                        }
                    }, {
                        key: "firstIndex",
                        get: function() {
                            return this._firstIndex
                        },
                        set: function(e) {
                            this._firstIndex = e
                        }
                    }, {
                        key: "vertexOffset",
                        get: function() {
                            return this._vertexOffset
                        },
                        set: function(e) {
                            this._vertexOffset = e
                        }
                    }, {
                        key: "instanceCount",
                        get: function() {
                            return this._instanceCount
                        },
                        set: function(e) {
                            this._instanceCount = e
                        }
                    }, {
                        key: "firstInstance",
                        get: function() {
                            return this._firstInstance
                        },
                        set: function(e) {
                            this._firstInstance = e
                        }
                    }, {
                        key: "indirectBuffer",
                        get: function() {
                            return this._indirectBuffer
                        }
                    }]), t
                }($s),
                Sc = function(e) {
                    function t(t) {
                        var n;
                        return (n = e.call(this, ma.DESCRIPTOR_SET) || this)._device = void 0, n._layout = null, n._buffers = [], n._textures = [], n._samplers = [], n._isDirty = !1, n._device = t, n
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.bindBuffer = function(e, t, n) {
                        void 0 === n && (n = 0);
                        var i = this._layout.bindingIndices[e],
                            r = this._layout.bindings[i];
                        if (r)
                            if (r.descriptorType & nc) {
                                var o = this._layout.descriptorIndices[e];
                                this._buffers[o + n] !== t && (this._buffers[o + n] = t, this._isDirty = !0)
                            } else console.warn("Setting binding is not DescriptorType.UNIFORM_BUFFER.")
                    }, n.bindSampler = function(e, t, n) {
                        void 0 === n && (n = 0);
                        var i = this._layout.bindingIndices[e],
                            r = this._layout.bindings[i];
                        if (r)
                            if (r.descriptorType & ic) {
                                var o = this._layout.descriptorIndices[e];
                                this._samplers[o + n] !== t && (this._samplers[o + n] = t, this._isDirty = !0)
                            } else console.warn("Setting binding is not DescriptorType.SAMPLER.")
                    }, n.bindTexture = function(e, t, n) {
                        void 0 === n && (n = 0);
                        var i = this._layout.bindingIndices[e],
                            r = this._layout.bindings[i];
                        if (r)
                            if (r.descriptorType & ic) {
                                var o = this._layout.descriptorIndices[e];
                                this._textures[o + n] !== t && (this._textures[o + n] = t, this._isDirty = !0)
                            } else console.warn("Setting binding is not DescriptorType.SAMPLER.")
                    }, n.getBuffer = function(e, t) {
                        void 0 === t && (t = 0);
                        var n = this._layout.descriptorIndices[e];
                        return this._buffers[n + t]
                    }, n.getSampler = function(e, t) {
                        void 0 === t && (t = 0);
                        var n = this._layout.descriptorIndices[e];
                        return this._samplers[n + t]
                    }, n.getTexture = function(e, t) {
                        void 0 === t && (t = 0);
                        var n = this._layout.descriptorIndices[e];
                        return this._textures[n + t]
                    }, K(t, [{
                        key: "layout",
                        get: function() {
                            return this._layout
                        }
                    }]), t
                }($s),
                Ec = function(e) {
                    function t(t) {
                        var n;
                        return (n = e.call(this, ma.DESCRIPTOR_SET_LAYOUT) || this)._device = void 0, n._bindings = [], n._bindingIndices = [], n._descriptorIndices = [], n._device = t, n
                    }
                    return Q(t, e), K(t, [{
                        key: "bindings",
                        get: function() {
                            return this._bindings
                        }
                    }, {
                        key: "bindingIndices",
                        get: function() {
                            return this._bindingIndices
                        }
                    }, {
                        key: "descriptorIndices",
                        get: function() {
                            return this._descriptorIndices
                        }
                    }]), t
                }($s),
                Tc = function(e) {
                    function t(t) {
                        var n;
                        return (n = e.call(this, ma.PIPELINE_LAYOUT) || this)._device = void 0, n._setLayouts = [], n._device = t, n
                    }
                    return Q(t, e), K(t, [{
                        key: "setLayouts",
                        get: function() {
                            return this._setLayouts
                        }
                    }]), t
                }($s),
                Ac = function() {
                    function e(e, t, n, i, r, o, a, s, c, l, u, h) {
                        void 0 === e && (e = !1), void 0 === t && (t = ja.FILL), void 0 === n && (n = qa.GOURAND), void 0 === i && (i = Xa.BACK), void 0 === r && (r = !0), void 0 === o && (o = !1), void 0 === a && (a = 0), void 0 === s && (s = 0), void 0 === c && (c = 0), void 0 === l && (l = !0), void 0 === u && (u = !1), void 0 === h && (h = 1), this.isDiscard = e, this.polygonMode = t, this.shadeModel = n, this.cullMode = i, this.isFrontFaceCCW = r, this.depthBiasEnabled = o, this.depthBias = a, this.depthBiasClamp = s, this.depthBiasSlop = c, this.isDepthClip = l, this.isMultisample = u, this.lineWidth = h
                    }
                    var t = e.prototype;
                    return t.reset = function() {
                        this.isDiscard = !1, this.polygonMode = ja.FILL, this.shadeModel = qa.GOURAND, this.cullMode = Xa.BACK, this.isFrontFaceCCW = !0, this.depthBiasEnabled = !1, this.depthBias = 0, this.depthBiasClamp = 0, this.depthBiasSlop = 0, this.isDepthClip = !0, this.isMultisample = !1, this.lineWidth = 1
                    }, t.assign = function(e) {
                        Object.assign(this, e)
                    }, t.destroy = function() {}, K(e, [{
                        key: "handle",
                        get: function() {
                            return 0
                        }
                    }]), e
                }(),
                xc = function() {
                    function e(e, t, n, i, r, o, a, s, c, l, u, h, _, f, d, p, m, g, v) {
                        void 0 === e && (e = !0), void 0 === t && (t = !0), void 0 === n && (n = Ma.LESS), void 0 === i && (i = !1), void 0 === r && (r = Ma.ALWAYS), void 0 === o && (o = 65535), void 0 === a && (a = 65535), void 0 === s && (s = La.KEEP), void 0 === c && (c = La.KEEP), void 0 === l && (l = La.KEEP), void 0 === u && (u = 1), void 0 === h && (h = !1), void 0 === _ && (_ = Ma.ALWAYS), void 0 === f && (f = 65535), void 0 === d && (d = 65535), void 0 === p && (p = La.KEEP), void 0 === m && (m = La.KEEP), void 0 === g && (g = La.KEEP), void 0 === v && (v = 1), this.depthTest = e, this.depthWrite = t, this.depthFunc = n, this.stencilTestFront = i, this.stencilFuncFront = r, this.stencilReadMaskFront = o, this.stencilWriteMaskFront = a, this.stencilFailOpFront = s, this.stencilZFailOpFront = c, this.stencilPassOpFront = l, this.stencilRefFront = u, this.stencilTestBack = h, this.stencilFuncBack = _, this.stencilReadMaskBack = f, this.stencilWriteMaskBack = d, this.stencilFailOpBack = p, this.stencilZFailOpBack = m, this.stencilPassOpBack = g, this.stencilRefBack = v
                    }
                    var t = e.prototype;
                    return t.reset = function() {
                        this.depthTest = !0, this.depthWrite = !0, this.depthFunc = Ma.LESS, this.stencilTestFront = !1, this.stencilFuncFront = Ma.ALWAYS, this.stencilReadMaskFront = 65535, this.stencilWriteMaskFront = 65535, this.stencilFailOpFront = La.KEEP, this.stencilZFailOpFront = La.KEEP, this.stencilPassOpFront = La.KEEP, this.stencilRefFront = 1, this.stencilTestBack = !1, this.stencilFuncBack = Ma.ALWAYS, this.stencilReadMaskBack = 65535, this.stencilWriteMaskBack = 65535, this.stencilFailOpBack = La.KEEP, this.stencilZFailOpBack = La.KEEP, this.stencilPassOpBack = La.KEEP, this.stencilRefBack = 1
                    }, t.assign = function(e) {
                        Object.assign(this, e)
                    }, t.destroy = function() {}, K(e, [{
                        key: "handle",
                        get: function() {
                            return 0
                        }
                    }]), e
                }(),
                Cc = function() {
                    function e(e, t, n, i, r, o, a, s) {
                        void 0 === e && (e = !1), void 0 === t && (t = Ba.ONE), void 0 === n && (n = Ba.ZERO), void 0 === i && (i = Fa.ADD), void 0 === r && (r = Ba.ONE), void 0 === o && (o = Ba.ZERO), void 0 === a && (a = Fa.ADD), void 0 === s && (s = za.ALL), this.blend = e, this.blendSrc = t, this.blendDst = n, this.blendEq = i, this.blendSrcAlpha = r, this.blendDstAlpha = o, this.blendAlphaEq = a, this.blendColorMask = s
                    }
                    var t = e.prototype;
                    return t.reset = function() {
                        this.blend = !1, this.blendSrc = Ba.ONE, this.blendDst = Ba.ZERO, this.blendEq = Fa.ADD, this.blendSrcAlpha = Ba.ONE, this.blendDstAlpha = Ba.ZERO, this.blendAlphaEq = Fa.ADD, this.blendColorMask = za.ALL
                    }, t.assign = function(e) {
                        Object.assign(this, e)
                    }, t.destroy = function() {}, K(e, [{
                        key: "handle",
                        get: function() {
                            return 0
                        }
                    }]), e
                }(),
                bc = function() {
                    function e(e, t, n, i) {
                        void 0 === e && (e = !1), void 0 === t && (t = !1), void 0 === n && (n = new ps), void 0 === i && (i = [new Cc]), this.isA2C = e, this.isIndepend = t, this.blendColor = n, this.targets = i
                    }
                    var t = e.prototype;
                    return t.setTarget = function(e, t) {
                        var n = this.targets[e];
                        n || (n = this.targets[e] = new Cc), Object.assign(n, t)
                    }, t.reset = function() {
                        this.isA2C = !1, this.isIndepend = !1, this.blendColor.x = 0, this.blendColor.y = 0, this.blendColor.z = 0, this.blendColor.w = 0, this.targets.length = 1, this.targets[0].reset()
                    }, t.destroy = function() {}, K(e, [{
                        key: "handle",
                        get: function() {
                            return 0
                        }
                    }]), e
                }(),
                Rc = function(e, t, n, i, r, o, a, s, c, l) {
                    void 0 === e && (e = null), void 0 === t && (t = null), void 0 === n && (n = null), void 0 === i && (i = new Ys), void 0 === r && (r = new Ac), void 0 === o && (o = new xc), void 0 === a && (a = new bc), void 0 === s && (s = Wa.TRIANGLE_LIST), void 0 === c && (c = Ya.NONE), void 0 === l && (l = Va.GRAPHICS), this.shader = e, this.pipelineLayout = t, this.renderPass = n, this.inputState = i, this.rasterizerState = r, this.depthStencilState = o, this.blendState = a, this.primitive = s, this.dynamicStates = c, this.bindPoint = l
                },
                wc = function(e) {
                    function t(t) {
                        var n;
                        return (n = e.call(this, ma.PIPELINE_STATE) || this)._device = void 0, n._shader = null, n._pipelineLayout = null, n._primitive = Wa.TRIANGLE_LIST, n._is = null, n._rs = new Ac, n._dss = new xc, n._bs = new bc, n._dynamicStates = Ya.NONE, n._renderPass = null, n._device = t, n
                    }
                    return Q(t, e), K(t, [{
                        key: "shader",
                        get: function() {
                            return this._shader
                        }
                    }, {
                        key: "pipelineLayout",
                        get: function() {
                            return this._pipelineLayout
                        }
                    }, {
                        key: "primitive",
                        get: function() {
                            return this._primitive
                        }
                    }, {
                        key: "rasterizerState",
                        get: function() {
                            return this._rs
                        }
                    }, {
                        key: "depthStencilState",
                        get: function() {
                            return this._dss
                        }
                    }, {
                        key: "blendState",
                        get: function() {
                            return this._bs
                        }
                    }, {
                        key: "inputState",
                        get: function() {
                            return this._is
                        }
                    }, {
                        key: "dynamicStates",
                        get: function() {
                            return this._dynamicStates
                        }
                    }, {
                        key: "renderPass",
                        get: function() {
                            return this._renderPass
                        }
                    }]), t
                }($s),
                Ic = function(e) {
                    function t(t) {
                        var n;
                        return (n = e.call(this, ma.QUEUE) || this)._device = void 0, n._type = Qa.GRAPHICS, n._isAsync = !1, n._device = t, n
                    }
                    return Q(t, e), t.prototype.isAsync = function() {
                        return this._isAsync
                    }, K(t, [{
                        key: "type",
                        get: function() {
                            return this._type
                        }
                    }]), t
                }($s),
                Pc = function(e) {
                    function t(t) {
                        var n;
                        return (n = e.call(this, ma.RENDER_PASS) || this)._device = void 0, n._colorInfos = [], n._depthStencilInfo = null, n._subpasses = [], n._hash = 0, n._device = t, n
                    }
                    return Q(t, e), t.prototype.computeHash = function() {
                        var e = "";
                        if (this._subpasses.length)
                            for (var t = 0; t < this._subpasses.length; ++t) {
                                var n = this._subpasses[t];
                                if (n.inputs.length) {
                                    e += "ia";
                                    for (var i = 0; i < n.inputs.length; ++i) {
                                        var r = this._colorInfos[n.inputs[i]];
                                        e += "," + r.format + "," + r.sampleCount
                                    }
                                }
                                if (n.colors.length) {
                                    e += "ca";
                                    for (var o = 0; o < n.inputs.length; ++o) {
                                        var a = this._colorInfos[n.inputs[o]];
                                        e += "," + a.format + "," + a.sampleCount
                                    }
                                }
                                if (n.depthStencil >= 0) {
                                    var s = this._colorInfos[n.depthStencil];
                                    e += "ds," + s.format + "," + s.sampleCount
                                }
                            } else {
                                e += "ca";
                                for (var c = 0; c < this._colorInfos.length; ++c) {
                                    var l = this._colorInfos[c];
                                    e += "," + l.format + "," + l.sampleCount
                                }
                                var u = this._depthStencilInfo;
                                u && (e += "ds," + u.format + "," + u.sampleCount)
                            }
                        return vc(e, 666)
                    }, K(t, [{
                        key: "colorAttachments",
                        get: function() {
                            return this._colorInfos
                        }
                    }, {
                        key: "depthStencilAttachment",
                        get: function() {
                            return this._depthStencilInfo
                        }
                    }, {
                        key: "subPasses",
                        get: function() {
                            return this._subpasses
                        }
                    }, {
                        key: "hash",
                        get: function() {
                            return this._hash
                        }
                    }]), t
                }($s),
                Oc = function(e) {
                    function t(t) {
                        var n;
                        return (n = e.call(this, ma.SAMPLER) || this)._device = void 0, n._minFilter = Da.LINEAR, n._magFilter = Da.LINEAR, n._mipFilter = Da.NONE, n._addressU = Na.WRAP, n._addressV = Na.WRAP, n._addressW = Na.WRAP, n._maxAnisotropy = 16, n._cmpFunc = Ma.NEVER, n._borderColor = new ps, n._mipLODBias = 0, n._device = t, n
                    }
                    return Q(t, e), K(t, [{
                        key: "minFilter",
                        get: function() {
                            return this._minFilter
                        }
                    }, {
                        key: "magFilter",
                        get: function() {
                            return this._magFilter
                        }
                    }, {
                        key: "mipFilter",
                        get: function() {
                            return this._mipFilter
                        }
                    }, {
                        key: "addressU",
                        get: function() {
                            return this._addressU
                        }
                    }, {
                        key: "addressV",
                        get: function() {
                            return this._addressV
                        }
                    }, {
                        key: "addressW",
                        get: function() {
                            return this._addressW
                        }
                    }, {
                        key: "maxAnisotropy",
                        get: function() {
                            return this._maxAnisotropy
                        }
                    }, {
                        key: "cmpFunc",
                        get: function() {
                            return this._cmpFunc
                        }
                    }, {
                        key: "borderColor",
                        get: function() {
                            return this._borderColor
                        }
                    }, {
                        key: "mipLODBias",
                        get: function() {
                            return this._mipLODBias
                        }
                    }]), t
                }($s),
                Dc = function(e) {
                    function t(n) {
                        var i;
                        return (i = e.call(this, ma.SHADER) || this)._device = void 0, i._id = void 0, i._name = "", i._stages = [], i._attributes = [], i._blocks = [], i._samplers = [], i._device = n, i._id = t._shaderIdGen++, i
                    }
                    return Q(t, e), K(t, [{
                        key: "id",
                        get: function() {
                            return this._id
                        }
                    }, {
                        key: "name",
                        get: function() {
                            return this._name
                        }
                    }, {
                        key: "attributes",
                        get: function() {
                            return this._attributes
                        }
                    }, {
                        key: "blocks",
                        get: function() {
                            return this._blocks
                        }
                    }, {
                        key: "samplers",
                        get: function() {
                            return this._samplers
                        }
                    }]), t
                }($s);
            Dc._shaderIdGen = 0;
            var Nc = function(e) {
                    function t(t) {
                        var n;
                        return (n = e.call(this, ma.TEXTURE) || this)._device = void 0, n._type = wa.TEX2D, n._usage = Ia.NONE, n._format = Ea.UNKNOWN, n._width = 0, n._height = 0, n._depth = 1, n._layerCount = 1, n._levelCount = 1, n._samples = Oa.X1, n._flags = Pa.NONE, n._isPowerOf2 = !1, n._size = 0, n._device = t, n
                    }
                    return Q(t, e), K(t, [{
                        key: "type",
                        get: function() {
                            return this._type
                        }
                    }, {
                        key: "usage",
                        get: function() {
                            return this._usage
                        }
                    }, {
                        key: "format",
                        get: function() {
                            return this._format
                        }
                    }, {
                        key: "width",
                        get: function() {
                            return this._width
                        }
                    }, {
                        key: "height",
                        get: function() {
                            return this._height
                        }
                    }, {
                        key: "depth",
                        get: function() {
                            return this._depth
                        }
                    }, {
                        key: "layerCount",
                        get: function() {
                            return this._layerCount
                        }
                    }, {
                        key: "levelCount",
                        get: function() {
                            return this._levelCount
                        }
                    }, {
                        key: "samples",
                        get: function() {
                            return this._samples
                        }
                    }, {
                        key: "flags",
                        get: function() {
                            return this._flags
                        }
                    }, {
                        key: "size",
                        get: function() {
                            return this._size
                        }
                    }]), t
                }($s),
                Mc = function(e) {
                    function t(t) {
                        var n;
                        return (n = e.call(this, ma.GLOBAL_BARRIER) || this)._device = void 0, n._info = new Hs, n._device = t, n
                    }
                    return Q(t, e), t.prototype.initialize = function(e) {
                        return this._info.copy(e), !0
                    }, t
                }($s),
                Lc = function(e) {
                    function t(t) {
                        var n;
                        return (n = e.call(this, ma.TEXTURE_BARRIER) || this)._device = void 0, n._info = new ks, n._device = t, n
                    }
                    return Q(t, e), t.prototype.initialize = function(e) {
                        return this._info.copy(e), !0
                    }, t
                }($s),
                Bc = {
                    Device: dc,
                    Buffer: _c,
                    Texture: Nc,
                    Sampler: Oc,
                    Shader: Dc,
                    InputAssembler: yc,
                    RenderPass: Pc,
                    Framebuffer: pc,
                    DescriptorSet: Sc,
                    DescriptorSetLayout: Ec,
                    PipelineLayout: Tc,
                    PipelineState: wc,
                    CommandBuffer: fc,
                    Queue: Ic,
                    GlobalBarrier: Mc,
                    TextureBarrier: Lc,
                    RasterizerState: Ac,
                    BlendState: bc,
                    BlendTarget: Cc,
                    DepthStencilState: xc,
                    PipelineStateInfo: Rc
                };
            Object.assign(Bc, hc), i.gfx = Bc;
            var Fc, zc = {
                Obj: "GFXObject",
                DRAW_INFO_SIZE: "GFX_DRAW_INFO_SIZE",
                DESCRIPTOR_BUFFER_TYPE: "",
                DESCRIPTOR_SAMPLER_TYPE: "",
                DESCRIPTOR_DYNAMIC_TYPE: "",
                getTypedArrayConstructor: ""
            };
            for (var Uc in i.gfx)
                if ("__esModule" !== Uc) {
                    var Gc = zc[Uc];
                    "" === Gc ? Gc = Uc : void 0 === Gc && (Gc = "GFX" + Uc), U(i, "cc", [{
                        name: Gc,
                        newName: Uc,
                        target: i.gfx,
                        targetName: "cc.gfx"
                    }])
                }
            e("gfx", Object.freeze({
                    __proto__: null,
                    DescriptorSet: Sc,
                    Buffer: _c,
                    CommandBuffer: fc,
                    get ObjectType() {
                        return ma
                    },
                    get Status() {
                        return ga
                    },
                    get API() {
                        return va
                    },
                    get SurfaceTransform() {
                        return ya
                    },
                    get Feature() {
                        return Sa
                    },
                    get Format() {
                        return Ea
                    },
                    get FormatType() {
                        return Ta
                    },
                    get Type() {
                        return Aa
                    },
                    get BufferUsageBit() {
                        return xa
                    },
                    get BufferFlagBit() {
                        return Ca
                    },
                    get MemoryAccessBit() {
                        return ba
                    },
                    get MemoryUsageBit() {
                        return Ra
                    },
                    get TextureType() {
                        return wa
                    },
                    get TextureUsageBit() {
                        return Ia
                    },
                    get TextureFlagBit() {
                        return Pa
                    },
                    get SampleCount() {
                        return Oa
                    },
                    get Filter() {
                        return Da
                    },
                    get Address() {
                        return Na
                    },
                    get ComparisonFunc() {
                        return Ma
                    },
                    get StencilOp() {
                        return La
                    },
                    get BlendFactor() {
                        return Ba
                    },
                    get BlendOp() {
                        return Fa
                    },
                    get ColorMask() {
                        return za
                    },
                    get ShaderStageFlagBit() {
                        return Ua
                    },
                    get LoadOp() {
                        return Ga
                    },
                    get StoreOp() {
                        return Ha
                    },
                    get AccessType() {
                        return ka
                    },
                    get PipelineBindPoint() {
                        return Va
                    },
                    get PrimitiveMode() {
                        return Wa
                    },
                    get PolygonMode() {
                        return ja
                    },
                    get ShadeModel() {
                        return qa
                    },
                    get CullMode() {
                        return Xa
                    },
                    get DynamicStateFlagBit() {
                        return Ya
                    },
                    get StencilFace() {
                        return Ka
                    },
                    get DescriptorType() {
                        return Za
                    },
                    get QueueType() {
                        return Qa
                    },
                    get CommandBufferType() {
                        return Ja
                    },
                    get ClearFlagBit() {
                        return $a
                    },
                    Size: rs,
                    DeviceCaps: os,
                    Offset: as,
                    Rect: ss,
                    Extent: cs,
                    TextureSubresLayers: ls,
                    TextureSubresRange: us,
                    TextureCopy: hs,
                    TextureBlit: _s,
                    BufferTextureCopy: fs,
                    Viewport: ds,
                    Color: ps,
                    BindingMappingInfo: ms,
                    BufferInfo: gs,
                    BufferViewInfo: vs,
                    DrawInfo: ys,
                    DispatchInfo: Ss,
                    IndirectBuffer: Es,
                    TextureInfo: Ts,
                    TextureViewInfo: As,
                    SamplerInfo: xs,
                    Uniform: Cs,
                    UniformBlock: bs,
                    UniformSamplerTexture: Rs,
                    UniformSampler: ws,
                    UniformTexture: Is,
                    UniformStorageImage: Ps,
                    UniformStorageBuffer: Os,
                    UniformInputAttachment: Ds,
                    ShaderStage: Ns,
                    Attribute: Ms,
                    ShaderInfo: Ls,
                    InputAssemblerInfo: Bs,
                    ColorAttachment: Fs,
                    DepthStencilAttachment: zs,
                    SubpassInfo: Us,
                    RenderPassInfo: Gs,
                    GlobalBarrierInfo: Hs,
                    TextureBarrierInfo: ks,
                    FramebufferInfo: Vs,
                    DescriptorSetLayoutBinding: Ws,
                    DescriptorSetLayoutInfo: js,
                    DescriptorSetInfo: qs,
                    PipelineLayoutInfo: Xs,
                    InputState: Ys,
                    CommandBufferInfo: Ks,
                    QueueInfo: Zs,
                    FormatInfo: Qs,
                    MemoryStatus: Js,
                    Obj: $s,
                    DeviceInfo: ec,
                    get AttributeName() {
                        return is
                    },
                    FormatInfos: tc,
                    DESCRIPTOR_BUFFER_TYPE: nc,
                    DESCRIPTOR_SAMPLER_TYPE: ic,
                    DESCRIPTOR_DYNAMIC_TYPE: rc,
                    DRAW_INFO_SIZE: 28,
                    IsPowerOf2: oc,
                    FormatSize: ac,
                    FormatSurfaceSize: sc,
                    GetTypeSize: lc,
                    getTypedArrayConstructor: uc,
                    Device: dc,
                    Framebuffer: pc,
                    InputAssembler: yc,
                    DescriptorSetLayout: Ec,
                    PipelineLayout: Tc,
                    RasterizerState: Ac,
                    DepthStencilState: xc,
                    BlendTarget: Cc,
                    BlendState: bc,
                    PipelineStateInfo: Rc,
                    PipelineState: wc,
                    Queue: Ic,
                    RenderPass: Pc,
                    Sampler: Oc,
                    Shader: Dc,
                    Texture: Nc,
                    GlobalBarrier: Mc,
                    TextureBarrier: Lc
                })),
                function(e) {
                    e[e.ALL = 0] = "ALL", e[e.CLOSEST = 1] = "CLOSEST", e[e.ANY = 2] = "ANY"
                }(Fc || (Fc = {}));
            var Hc, kc, Vc, Wc, jc, qc, Xc, Yc, Kc = (Hc = new En(0, 0, 0), function(e, t) {
                    var n = En.dot(e.d, t.n);
                    if (Math.abs(n) < Number.EPSILON) return 0;
                    En.multiplyScalar(Hc, t.n, t.d);
                    var i = En.dot(En.subtract(Hc, Hc, e.o), t.n) / n;
                    return i < 0 ? 0 : i
                }),
                Zc = (kc = new En(0, 0, 0), Vc = new En(0, 0, 0), Wc = new En(0, 0, 0), jc = new En(0, 0, 0), qc = new En(0, 0, 0), function(e, t, n) {
                    En.subtract(kc, t.b, t.a), En.subtract(Vc, t.c, t.a), En.cross(Wc, e.d, Vc);
                    var i = En.dot(kc, Wc);
                    if (i < Number.EPSILON && (!n || i > -Number.EPSILON)) return 0;
                    var r = 1 / i;
                    En.subtract(jc, e.o, t.a);
                    var o = En.dot(jc, Wc) * r;
                    if (o < 0 || o > 1) return 0;
                    En.cross(qc, jc, kc);
                    var a = En.dot(e.d, qc) * r;
                    if (a < 0 || o + a > 1) return 0;
                    var s = En.dot(Vc, qc) * r;
                    return s < 0 ? 0 : s
                }),
                Qc = function() {
                    var e = new En(0, 0, 0);
                    return function(t, n) {
                        var i = n.radius,
                            r = n.center,
                            o = t.o,
                            a = t.d,
                            s = i * i;
                        En.subtract(e, r, o);
                        var c = e.lengthSqr(),
                            l = En.dot(e, a),
                            u = s - (c - l * l);
                        if (u < 0) return 0;
                        var h = Math.sqrt(u),
                            _ = c < s ? l + h : l - h;
                        return _ < 0 ? 0 : _
                    }
                }(),
                Jc = (Xc = new En, Yc = new En, function(e, t) {
                    return En.subtract(Xc, t.center, t.halfExtents), En.add(Yc, t.center, t.halfExtents), $c(e, Xc, Yc)
                });

            function $c(e, t, n) {
                var i = e.o,
                    r = e.d,
                    o = 1 / r.x,
                    a = 1 / r.y,
                    s = 1 / r.z,
                    c = (t.x - i.x) * o,
                    l = (n.x - i.x) * o,
                    u = (t.y - i.y) * a,
                    h = (n.y - i.y) * a,
                    _ = (t.z - i.z) * s,
                    f = (n.z - i.z) * s,
                    d = Math.max(Math.max(Math.min(c, l), Math.min(u, h)), Math.min(_, f)),
                    p = Math.min(Math.min(Math.max(c, l), Math.max(u, h)), Math.max(_, f));
                return p < 0 || d > p ? 0 : d > 0 ? d : p
            }
            var el, tl, nl, il, rl = function() {
                    var e = new En,
                        t = new En,
                        n = new En,
                        i = new En,
                        r = new En,
                        o = new En,
                        a = new En,
                        s = new Array(3),
                        c = new Array(3),
                        l = new Array(3),
                        u = new Array(6);
                    return function(h, _) {
                        s[0] = _.halfExtents.x, s[1] = _.halfExtents.y, s[2] = _.halfExtents.z, e = _.center, t = h.o, n = h.d, En.set(i, _.orientation.m00, _.orientation.m01, _.orientation.m02), En.set(r, _.orientation.m03, _.orientation.m04, _.orientation.m05), En.set(o, _.orientation.m06, _.orientation.m07, _.orientation.m08), En.subtract(a, e, t), c[0] = En.dot(i, n), c[1] = En.dot(r, n), c[2] = En.dot(o, n), l[0] = En.dot(i, a), l[1] = En.dot(r, a), l[2] = En.dot(o, a);
                        for (var f = 0; f < 3; ++f) {
                            if (0 === c[f]) {
                                if (-l[f] - s[f] > 0 || -l[f] + s[f] < 0) return 0;
                                c[f] = 1e-7
                            }
                            u[2 * f + 0] = (l[f] + s[f]) / c[f], u[2 * f + 1] = (l[f] - s[f]) / c[f]
                        }
                        var d = Math.max(Math.max(Math.min(u[0], u[1]), Math.min(u[2], u[3])), Math.min(u[4], u[5])),
                            p = Math.min(Math.min(Math.max(u[0], u[1]), Math.max(u[2], u[3])), Math.max(u[4], u[5]));
                        return p < 0 || d > p ? 0 : d > 0 ? d : p
                    }
                }(),
                ol = function() {
                    var e = new En,
                        t = new En,
                        n = new En,
                        i = new En,
                        r = new En,
                        o = new En,
                        a = new En,
                        s = new es;
                    return function(c, l) {
                        var u = l.radius * l.radius,
                            h = En.normalize(e, c.d),
                            _ = l.ellipseCenter0,
                            f = l.ellipseCenter1,
                            d = En.subtract(t, f, _);
                        if (d.equals(En.ZERO)) return s.radius = l.radius, s.center.set(l.ellipseCenter0), Vl.raySphere(c, s);
                        var p = c.o,
                            m = En.subtract(n, p, _),
                            g = En.cross(i, h, d),
                            v = g.lengthSqr();
                        if (0 === v) {
                            s.radius = l.radius;
                            var y = En.subtract(r, f, p);
                            return m.lengthSqr() < y.lengthSqr() ? s.center.set(l.ellipseCenter0) : s.center.set(l.ellipseCenter1), Vl.raySphere(c, s)
                        }
                        var S = En.cross(r, m, d),
                            E = d.lengthSqr(),
                            T = 2 * En.dot(g, S),
                            A = T * T - 4 * v * (S.lengthSqr() - u * E);
                        if (A < 0) return 0;
                        var x = (-T - Math.sqrt(A)) / (2 * v);
                        if (x < 0) {
                            s.radius = l.radius;
                            var C = En.subtract(o, f, p);
                            return m.lengthSqr() < C.lengthSqr() ? s.center.set(l.ellipseCenter0) : s.center.set(l.ellipseCenter1), Vl.raySphere(c, s)
                        }
                        var b = En.scaleAndAdd(o, c.o, h, x),
                            R = En.subtract(a, b, _),
                            w = En.dot(R, d) / E;
                        return w >= 0 && w <= 1 ? x : w < 0 ? (s.radius = l.radius, s.center.set(l.ellipseCenter0), Vl.raySphere(c, s)) : w > 1 ? (s.radius = l.radius, s.center.set(l.ellipseCenter1), Vl.raySphere(c, s)) : 0
                    }
                }(),
                al = (el = ts.create(), tl = {
                    distance: 1 / 0,
                    doubleSided: !1,
                    mode: Fc.ANY
                }, nl = 0, il = function(e, t, n, i, r, o) {
                    e === Fc.CLOSEST ? (nl > t || 0 === nl) && (nl = t, o && (0 === o.length ? o.push({
                        distance: t,
                        vertexIndex0: n / 3,
                        vertexIndex1: i / 3,
                        vertexIndex2: r / 3
                    }) : (o[0].distance = t, o[0].vertexIndex0 = n / 3, o[0].vertexIndex1 = i / 3, o[0].vertexIndex2 = r / 3))) : (nl = t, o && o.push({
                        distance: t,
                        vertexIndex0: n / 3,
                        vertexIndex1: i / 3,
                        vertexIndex2: r / 3
                    }))
                }, function(e, t, n) {
                    if (nl = 0, 0 === t.geometricInfo.positions.length) return nl;
                    var i = void 0 === n ? tl : n;
                    if ($c(e, t.geometricInfo.boundingBox.min, t.geometricInfo.boundingBox.max)) {
                        var r = t.primitiveMode,
                            o = t.geometricInfo;
                        ! function(e, t, n, i, r) {
                            if (n === Wa.TRIANGLE_LIST)
                                for (var o = t.length, a = 0; a < o; a += 3) {
                                    var s = 3 * t[a],
                                        c = 3 * t[a + 1],
                                        l = 3 * t[a + 2];
                                    En.set(el.a, e[s], e[s + 1], e[s + 2]), En.set(el.b, e[c], e[c + 1], e[c + 2]), En.set(el.c, e[l], e[l + 1], e[l + 2]);
                                    var u = Vl.rayTriangle(i, el, r.doubleSided);
                                    if (!(0 === u || u > r.distance) && (il(r.mode, u, s, c, l, r.result), r.mode === Fc.ANY)) return u
                                } else if (n === Wa.TRIANGLE_STRIP)
                                    for (var h = t.length - 2, _ = 0, f = 0; f < h; f += 1) {
                                        var d = 3 * t[f - _],
                                            p = 3 * t[f + _ + 1],
                                            m = 3 * t[f + 2];
                                        En.set(el.a, e[d], e[d + 1], e[d + 2]), En.set(el.b, e[p], e[p + 1], e[p + 2]), En.set(el.c, e[m], e[m + 1], e[m + 2]), _ = ~_;
                                        var g = Vl.rayTriangle(i, el, r.doubleSided);
                                        if (!(0 === g || g > r.distance) && (il(r.mode, g, d, p, m, r.result), r.mode === Fc.ANY)) return g
                                    } else if (n === Wa.TRIANGLE_FAN) {
                                        var v = t.length - 1,
                                            y = 3 * t[0];
                                        En.set(el.a, e[y], e[y + 1], e[y + 2]);
                                        for (var S = 1; S < v; S += 1) {
                                            var E = 3 * t[S],
                                                T = 3 * t[S + 1];
                                            En.set(el.b, e[E], e[E + 1], e[E + 2]), En.set(el.c, e[T], e[T + 1], e[T + 2]);
                                            var A = Vl.rayTriangle(i, el, r.doubleSided);
                                            if (!(0 === A || A > r.distance) && (il(r.mode, A, y, E, T, r.result), r.mode === Fc.ANY)) return A
                                        }
                                    }
                        }(o.positions, o.indices, r, e, i)
                    }
                    return nl
                }),
                sl = function() {
                    var e = 0,
                        t = {
                            distance: 1 / 0,
                            doubleSided: !1,
                            mode: Fc.ANY
                        };
                    return function(n, i, r) {
                        e = 0;
                        var o = void 0 === r ? t : r,
                            a = i.renderingSubMeshes.length,
                            s = i.struct.minPosition,
                            c = i.struct.maxPosition;
                        if (s && c && !$c(n, s, c)) return e;
                        for (var l = 0; l < a; l++) {
                            var u = i.renderingSubMeshes[l],
                                h = al(n, u, o);
                            if (h)
                                if (o.mode === Fc.CLOSEST)(0 === e || e > h) && (e = h, o.subIndices && (o.subIndices[0] = l));
                                else if (e = h, o.subIndices && o.subIndices.push(l), o.mode === Fc.ANY) return h
                        }
                        return e && o.mode === Fc.CLOSEST && (o.result && (o.result[0].distance = e, o.result.length = 1), o.subIndices && (o.subIndices.length = 1)), e
                    }
                }(),
                cl = function() {
                    var e = 0,
                        t = {
                            distance: 1 / 0,
                            doubleSided: !1,
                            mode: Fc.ANY
                        },
                        n = new ua,
                        i = new Bn;
                    return function(r, o, a) {
                        e = 0;
                        var s = void 0 === a ? t : a,
                            c = o.worldBounds;
                        if (c && !Jc(r, c)) return e;
                        ua.copy(n, r), o.node && (Bn.invert(i, o.node.getWorldMatrix(i)), En.transformMat4(n.o, r.o, i), En.transformMat4Normal(n.d, r.d, i));
                        for (var l = o.subModels, u = 0; u < l.length; u++) {
                            var h = l[u].subMesh,
                                _ = al(n, h, s);
                            if (_)
                                if (s.mode === Fc.CLOSEST)(0 === e || e > _) && (e = _, s.subIndices && (s.subIndices[0] = u));
                                else if (e = _, s.subIndices && s.subIndices.push(u), s.mode === Fc.ANY) return _
                        }
                        return e && s.mode === Fc.CLOSEST && (s.result && (s.result[0].distance = e, s.result.length = 1), s.subIndices && (s.subIndices.length = 1)), e
                    }
                }(),
                ll = function() {
                    var e = new En(0, 0, 0);
                    return function(t, n) {
                        En.subtract(e, t.e, t.s);
                        var i = (n.d - En.dot(t.s, n.n)) / En.dot(e, n.n);
                        return i < 0 || i > 1 ? 0 : i
                    }
                }(),
                ul = function() {
                    var e = new En(0, 0, 0),
                        t = new En(0, 0, 0),
                        n = new En(0, 0, 0),
                        i = new En(0, 0, 0),
                        r = new En(0, 0, 0),
                        o = new En(0, 0, 0);
                    return function(a, s, c) {
                        En.subtract(e, s.b, s.a), En.subtract(t, s.c, s.a), En.subtract(n, a.s, a.e), En.cross(r, e, t);
                        var l = En.dot(n, r);
                        if (l <= 0) return 0;
                        En.subtract(i, a.s, s.a);
                        var u = En.dot(i, r);
                        if (u < 0 || u > l) return 0;
                        En.cross(o, n, i);
                        var h = En.dot(t, o);
                        if (h < 0 || h > l) return 0;
                        var _ = -En.dot(e, o);
                        if (_ < 0 || h + _ > l) return 0;
                        if (c) {
                            var f = 1 / l,
                                d = 1 - (h *= f) - (_ *= f);
                            En.set(c, s.a.x * d + s.b.x * h + s.c.x * _, s.a.y * d + s.b.y * h + s.c.y * _, s.a.z * d + s.b.z * h + s.c.z * _)
                        }
                        return 1
                    }
                }(),
                hl = new ua;

            function _l(e, t) {
                hl.o.set(e.s), En.subtract(hl.d, e.e, e.s), hl.d.normalize();
                var n = Jc(hl, t);
                return n <= e.length() ? n : 0
            }

            function fl(e, t) {
                hl.o.set(e.s), En.subtract(hl.d, e.e, e.s), hl.d.normalize();
                var n = rl(hl, t);
                return n <= e.length() ? n : 0
            }

            function dl(e, t) {
                hl.o.set(e.s), En.subtract(hl.d, e.e, e.s), hl.d.normalize();
                var n = Qc(hl, t);
                return n <= e.length() ? n : 0
            }
            var pl, ml, gl, vl, yl = (pl = new En, ml = new En, gl = new En, vl = new En, function(e, t) {
                return En.subtract(pl, e.center, e.halfExtents), En.add(ml, e.center, e.halfExtents), En.subtract(gl, t.center, t.halfExtents), En.add(vl, t.center, t.halfExtents), pl.x <= vl.x && ml.x >= gl.x && pl.y <= vl.y && ml.y >= gl.y && pl.z <= vl.z && ml.z >= gl.z
            });

            function Sl(e, t, n, i, r, o) {
                En.set(o[0], e.x + n.x * t.x + i.x * t.y + r.x * t.z, e.y + n.y * t.x + i.y * t.y + r.y * t.z, e.z + n.z * t.x + i.z * t.y + r.z * t.z), En.set(o[1], e.x - n.x * t.x + i.x * t.y + r.x * t.z, e.y - n.y * t.x + i.y * t.y + r.y * t.z, e.z - n.z * t.x + i.z * t.y + r.z * t.z), En.set(o[2], e.x + n.x * t.x - i.x * t.y + r.x * t.z, e.y + n.y * t.x - i.y * t.y + r.y * t.z, e.z + n.z * t.x - i.z * t.y + r.z * t.z), En.set(o[3], e.x + n.x * t.x + i.x * t.y - r.x * t.z, e.y + n.y * t.x + i.y * t.y - r.y * t.z, e.z + n.z * t.x + i.z * t.y - r.z * t.z), En.set(o[4], e.x - n.x * t.x - i.x * t.y - r.x * t.z, e.y - n.y * t.x - i.y * t.y - r.y * t.z, e.z - n.z * t.x - i.z * t.y - r.z * t.z), En.set(o[5], e.x + n.x * t.x - i.x * t.y - r.x * t.z, e.y + n.y * t.x - i.y * t.y - r.y * t.z, e.z + n.z * t.x - i.z * t.y - r.z * t.z), En.set(o[6], e.x - n.x * t.x + i.x * t.y - r.x * t.z, e.y - n.y * t.x + i.y * t.y - r.y * t.z, e.z - n.z * t.x + i.z * t.y - r.z * t.z), En.set(o[7], e.x - n.x * t.x - i.x * t.y + r.x * t.z, e.y - n.y * t.x - i.y * t.y + r.y * t.z, e.z - n.z * t.x - i.z * t.y + r.z * t.z)
            }

            function El(e, t) {
                for (var n = En.dot(t, e[0]), i = n, r = 1; r < 8; ++r) {
                    var o = En.dot(t, e[r]);
                    n = o < n ? o : n, i = o > i ? o : i
                }
                return [n, i]
            }
            var Tl, Al, xl, Cl = function() {
                    for (var e = new Array(15), t = 0; t < 15; t++) e[t] = new En(0, 0, 0);
                    for (var n = new Array(8), i = new Array(8), r = 0; r < 8; r++) n[r] = new En(0, 0, 0), i[r] = new En(0, 0, 0);
                    var o = new En,
                        a = new En;
                    return function(t, r) {
                        En.set(e[0], 1, 0, 0), En.set(e[1], 0, 1, 0), En.set(e[2], 0, 0, 1), En.set(e[3], r.orientation.m00, r.orientation.m01, r.orientation.m02), En.set(e[4], r.orientation.m03, r.orientation.m04, r.orientation.m05), En.set(e[5], r.orientation.m06, r.orientation.m07, r.orientation.m08);
                        for (var s = 0; s < 3; ++s) En.cross(e[6 + 3 * s], e[s], e[0]), En.cross(e[7 + 3 * s], e[s], e[1]), En.cross(e[7 + 3 * s], e[s], e[2]);
                        En.subtract(o, t.center, t.halfExtents), En.add(a, t.center, t.halfExtents),
                            function(e, t, n) {
                                En.set(n[0], e.x, t.y, t.z), En.set(n[1], e.x, t.y, e.z), En.set(n[2], e.x, e.y, t.z), En.set(n[3], e.x, e.y, e.z), En.set(n[4], t.x, t.y, t.z), En.set(n[5], t.x, t.y, e.z), En.set(n[6], t.x, e.y, t.z), En.set(n[7], t.x, e.y, e.z)
                            }(o, a, n), Sl(r.center, r.halfExtents, e[3], e[4], e[5], i);
                        for (var c = 0; c < 15; ++c) {
                            var l = El(n, e[c]),
                                u = El(i, e[c]);
                            if (u[0] > l[1] || l[0] > u[1]) return 0
                        }
                        return 1
                    }
                }(),
                bl = function(e, t) {
                    var n = e.halfExtents.x * Math.abs(t.n.x) + e.halfExtents.y * Math.abs(t.n.y) + e.halfExtents.z * Math.abs(t.n.z),
                        i = En.dot(t.n, e.center);
                    return i + n < t.d ? -1 : i - n > t.d ? 0 : 1
                },
                Rl = function(e, t) {
                    for (var n = 0; n < t.planes.length; n++)
                        if (-1 === bl(e, t.planes[n])) return 0;
                    return 1
                },
                wl = function() {
                    for (var e = new Array(8), t = 0, n = 0, i = 0; i < e.length; i++) e[i] = new En(0, 0, 0);
                    return function(i, r) {
                        for (var o = 0, a = !1, s = 0; s < r.planes.length; s++) {
                            if (-1 === (o = bl(i, r.planes[s]))) return 0;
                            1 === o && (a = !0)
                        }
                        if (!a) return 1;
                        for (var c = 0; c < r.vertices.length; c++) En.subtract(e[c], r.vertices[c], i.center);
                        t = 0, n = 0;
                        for (var l = 0; l < r.vertices.length; l++) e[l].x > i.halfExtents.x ? t++ : e[l].x < -i.halfExtents.x && n++;
                        if (t === r.vertices.length || n === r.vertices.length) return 0;
                        t = 0, n = 0;
                        for (var u = 0; u < r.vertices.length; u++) e[u].y > i.halfExtents.y ? t++ : e[u].y < -i.halfExtents.y && n++;
                        if (t === r.vertices.length || n === r.vertices.length) return 0;
                        t = 0, n = 0;
                        for (var h = 0; h < r.vertices.length; h++) e[h].z > i.halfExtents.z ? t++ : e[h].z < -i.halfExtents.z && n++;
                        return t === r.vertices.length || n === r.vertices.length ? 0 : 1
                    }
                }(),
                Il = (Tl = new En(0, 0, 0), Al = new Cn, function(e, t) {
                    return En.subtract(Tl, t, e.center), En.transformMat3(Tl, Tl, Cn.transpose(Al, e.orientation)), n = Tl, i = e.halfExtents, Math.abs(n.x) < i.x && Math.abs(n.y) < i.y && Math.abs(n.z) < i.z;
                    var n, i
                }),
                Pl = (xl = function(e, t, n, i) {
                    return Math.abs(e.x * t + e.y * n + e.z * i)
                }, function(e, t) {
                    var n = e.halfExtents.x * xl(t.n, e.orientation.m00, e.orientation.m01, e.orientation.m02) + e.halfExtents.y * xl(t.n, e.orientation.m03, e.orientation.m04, e.orientation.m05) + e.halfExtents.z * xl(t.n, e.orientation.m06, e.orientation.m07, e.orientation.m08),
                        i = En.dot(t.n, e.center);
                    return i + n < t.d ? -1 : i - n > t.d ? 0 : 1
                }),
                Ol = function(e, t) {
                    for (var n = 0; n < t.planes.length; n++)
                        if (-1 === Pl(e, t.planes[n])) return 0;
                    return 1
                },
                Dl = function() {
                    for (var e = new Array(8), t = 0, n = 0, i = 0, r = 0; r < e.length; r++) e[r] = new En(0, 0, 0);
                    var o = function(e, t, n, i) {
                        return e.x * t + e.y * n + e.z * i
                    };
                    return function(r, a) {
                        for (var s = 0, c = !1, l = 0; l < a.planes.length; l++) {
                            if (-1 === (s = Pl(r, a.planes[l]))) return 0;
                            1 === s && (c = !0)
                        }
                        if (!c) return 1;
                        for (var u = 0; u < a.vertices.length; u++) En.subtract(e[u], a.vertices[u], r.center);
                        n = 0, i = 0;
                        for (var h = 0; h < a.vertices.length; h++)(t = o(e[h], r.orientation.m00, r.orientation.m01, r.orientation.m02)) > r.halfExtents.x ? n++ : t < -r.halfExtents.x && i++;
                        if (n === a.vertices.length || i === a.vertices.length) return 0;
                        n = 0, i = 0;
                        for (var _ = 0; _ < a.vertices.length; _++)(t = o(e[_], r.orientation.m03, r.orientation.m04, r.orientation.m05)) > r.halfExtents.y ? n++ : t < -r.halfExtents.y && i++;
                        if (n === a.vertices.length || i === a.vertices.length) return 0;
                        n = 0, i = 0;
                        for (var f = 0; f < a.vertices.length; f++)(t = o(e[f], r.orientation.m06, r.orientation.m07, r.orientation.m08)) > r.halfExtents.z ? n++ : t < -r.halfExtents.z && i++;
                        return n === a.vertices.length || i === a.vertices.length ? 0 : 1
                    }
                }(),
                Nl = function() {
                    for (var e = new Array(15), t = 0; t < 15; t++) e[t] = new En(0, 0, 0);
                    for (var n = new Array(8), i = new Array(8), r = 0; r < 8; r++) n[r] = new En(0, 0, 0), i[r] = new En(0, 0, 0);
                    return function(t, r) {
                        En.set(e[0], t.orientation.m00, t.orientation.m01, t.orientation.m02), En.set(e[1], t.orientation.m03, t.orientation.m04, t.orientation.m05), En.set(e[2], t.orientation.m06, t.orientation.m07, t.orientation.m08), En.set(e[3], r.orientation.m00, r.orientation.m01, r.orientation.m02), En.set(e[4], r.orientation.m03, r.orientation.m04, r.orientation.m05), En.set(e[5], r.orientation.m06, r.orientation.m07, r.orientation.m08);
                        for (var o = 0; o < 3; ++o) En.cross(e[6 + 3 * o], e[o], e[0]), En.cross(e[7 + 3 * o], e[o], e[1]), En.cross(e[7 + 3 * o], e[o], e[2]);
                        Sl(t.center, t.halfExtents, e[0], e[1], e[2], n), Sl(r.center, r.halfExtents, e[3], e[4], e[5], i);
                        for (var a = 0; a < 15; ++a) {
                            var s = El(n, e[a]),
                                c = El(i, e[a]);
                            if (c[0] > s[1] || s[0] > c[1]) return 0
                        }
                        return 1
                    }
                }(),
                Ml = function() {
                    for (var e = new es, t = new En, n = new En, i = new En, r = new Array(8), o = 0; o < 8; o++) r[o] = new En;
                    for (var a = new Array(8), s = 0; s < 8; s++) a[s] = new En;
                    return function(o, s) {
                        if (0 === En.squaredDistance(s.ellipseCenter0, s.ellipseCenter1)) return e.radius = s.radius, e.center.set(s.ellipseCenter0), Vl.sphereOBB(e, o);
                        t.x = o.orientation.m00, t.y = o.orientation.m01, t.z = o.orientation.m02, n.x = o.orientation.m03, n.y = o.orientation.m04, n.z = o.orientation.m05, i.x = o.orientation.m06, i.y = o.orientation.m07, i.z = o.orientation.m08, Sl(o.center, o.halfExtents, t, n, i, r);
                        var c = a,
                            l = En.copy(c[0], t),
                            u = En.copy(c[1], n),
                            h = En.copy(c[2], i);
                        En.subtract(c[3], s.center, o.center).normalize();
                        var _ = En.subtract(c[4], s.ellipseCenter0, s.ellipseCenter1);
                        _.normalize(), En.cross(c[5], l, _), En.cross(c[6], u, _), En.cross(c[7], h, _);
                        for (var f = 0; f < 8; ++f) {
                            var d = El(r, c[f]),
                                p = En.dot(c[f], s.ellipseCenter0),
                                m = En.dot(c[f], s.ellipseCenter1),
                                g = Math.max(p, m),
                                v = Math.min(p, m) - s.radius,
                                y = g + s.radius;
                            if (v > d[1] || d[0] > y) return 0
                        }
                        return 1
                    }
                }(),
                Ll = function(e, t) {
                    var n = En.dot(t.n, e.center),
                        i = e.radius * t.n.length();
                    return n + i < t.d ? -1 : n - i > t.d ? 0 : 1
                },
                Bl = function(e, t) {
                    for (var n = 0; n < t.planes.length; n++)
                        if (-1 === Ll(e, t.planes[n])) return 0;
                    return 1
                },
                Fl = function() {
                    var e = new En(0, 0, 0),
                        t = [1, -1, 1, -1, 1, -1];
                    return function(n, i) {
                        for (var r = 0; r < 6; r++) {
                            var o = i.planes[r],
                                a = n.radius,
                                s = n.center,
                                c = o.n,
                                l = o.d,
                                u = En.dot(c, s);
                            if (u + a < l) return 0;
                            if (!(u - a > l)) {
                                En.add(e, s, En.multiplyScalar(e, c, a));
                                for (var h = 0; h < 6; h++)
                                    if (h !== r && h !== r + t[r]) {
                                        var _ = i.planes[h];
                                        if (En.dot(_.n, e) < _.d) return 0
                                    }
                            }
                        }
                        return 1
                    }
                }(),
                zl = function(e, t) {
                    var n = e.radius + t.radius;
                    return En.squaredDistance(e.center, t.center) < n * n
                },
                Ul = function() {
                    var e = new En;
                    return function(t, n) {
                        return oa(e, t.center, n), En.squaredDistance(t.center, e) < t.radius * t.radius
                    }
                }(),
                Gl = function() {
                    var e = new En;
                    return function(t, n) {
                        return aa(e, t.center, n), En.squaredDistance(t.center, e) < t.radius * t.radius
                    }
                }(),
                Hl = function() {
                    var e = new En,
                        t = new En;
                    return function(n, i) {
                        var r = n.radius + i.radius,
                            o = r * r,
                            a = En.squaredDistance(i.ellipseCenter0, i.ellipseCenter1);
                        if (0 === a) return En.squaredDistance(n.center, i.center) < o;
                        En.subtract(e, n.center, i.ellipseCenter0), En.subtract(t, i.ellipseCenter1, i.ellipseCenter0);
                        var s = En.dot(e, t) / a;
                        return s < 0 ? En.squaredDistance(n.center, i.ellipseCenter0) < o : s > 1 ? En.squaredDistance(n.center, i.ellipseCenter1) < o : (En.scaleAndAdd(e, i.ellipseCenter0, t, s), En.squaredDistance(n.center, e) < o)
                    }
                }(),
                kl = function() {
                    var e = new En,
                        t = new En,
                        n = new En,
                        i = new En,
                        r = new En,
                        o = new En;
                    return function(a, s) {
                        var c, l, u, h, _ = En.subtract(e, a.ellipseCenter1, a.ellipseCenter0),
                            f = En.subtract(t, s.ellipseCenter1, s.ellipseCenter0),
                            d = En.subtract(n, a.ellipseCenter0, s.ellipseCenter0),
                            p = En.dot(_, _),
                            m = En.dot(_, f),
                            g = En.dot(f, f),
                            v = En.dot(_, d),
                            y = En.dot(f, d),
                            S = p * g - m * m,
                            E = S,
                            T = S;
                        S < Qt ? (l = 0, E = 1, h = y, T = g) : (h = p * y - m * v, (l = m * y - g * v) < 0 ? (l = 0, h = y, T = g) : l > E && (l = E, h = y + m, T = g)), h < 0 ? (h = 0, -v < 0 ? l = 0 : -v > p ? l = E : (l = -v, E = p)) : h > T && (h = T, -v + m < 0 ? l = 0 : -v + m > p ? l = E : (l = -v + m, E = p)), c = Math.abs(l) < Qt ? 0 : l / E, u = Math.abs(h) < Qt ? 0 : h / T;
                        var A = i;
                        A.set(d), A.add(En.multiplyScalar(r, _, c)), A.subtract(En.multiplyScalar(o, f, u));
                        var x = a.radius + s.radius;
                        return A.lengthSqr() < x * x
                    }
                }(),
                Vl = {
                    raySphere: Qc,
                    rayAABB: Jc,
                    rayOBB: rl,
                    rayPlane: Kc,
                    rayTriangle: Zc,
                    rayCapsule: ol,
                    raySubMesh: al,
                    rayMesh: sl,
                    rayModel: cl,
                    lineSphere: dl,
                    lineAABB: _l,
                    lineOBB: fl,
                    linePlane: ll,
                    lineTriangle: ul,
                    sphereWithSphere: zl,
                    sphereAABB: Ul,
                    sphereOBB: Gl,
                    spherePlane: Ll,
                    sphereFrustum: Bl,
                    sphereFrustumAccurate: Fl,
                    sphereCapsule: Hl,
                    aabbWithAABB: yl,
                    aabbWithOBB: Cl,
                    aabbPlane: bl,
                    aabbFrustum: Rl,
                    aabbFrustumAccurate: wl,
                    obbWithOBB: Nl,
                    obbPlane: Pl,
                    obbFrustum: Ol,
                    obbFrustumAccurate: Dl,
                    obbPoint: Il,
                    obbCapsule: Ml,
                    capsuleWithCapsule: kl,
                    resolve: function(e, t, n) {
                        void 0 === n && (n = null);
                        var i = e._type,
                            r = t._type,
                            o = this[i | r];
                        return i < r ? o(e, t, n) : o(t, e, n)
                    }
                };
            Vl[ca.SHAPE_RAY | ca.SHAPE_SPHERE] = Qc, Vl[ca.SHAPE_RAY | ca.SHAPE_AABB] = Jc, Vl[ca.SHAPE_RAY | ca.SHAPE_OBB] = rl, Vl[ca.SHAPE_RAY | ca.SHAPE_PLANE] = Kc, Vl[ca.SHAPE_RAY | ca.SHAPE_TRIANGLE] = Zc, Vl[ca.SHAPE_RAY | ca.SHAPE_CAPSULE] = ol, Vl[ca.SHAPE_LINE | ca.SHAPE_SPHERE] = dl, Vl[ca.SHAPE_LINE | ca.SHAPE_AABB] = _l, Vl[ca.SHAPE_LINE | ca.SHAPE_OBB] = fl, Vl[ca.SHAPE_LINE | ca.SHAPE_PLANE] = ll, Vl[ca.SHAPE_LINE | ca.SHAPE_TRIANGLE] = ul, Vl[ca.SHAPE_SPHERE] = zl, Vl[ca.SHAPE_SPHERE | ca.SHAPE_AABB] = Ul, Vl[ca.SHAPE_SPHERE | ca.SHAPE_OBB] = Gl, Vl[ca.SHAPE_SPHERE | ca.SHAPE_PLANE] = Ll, Vl[ca.SHAPE_SPHERE | ca.SHAPE_FRUSTUM] = Bl, Vl[ca.SHAPE_SPHERE | ca.SHAPE_FRUSTUM_ACCURATE] = Fl, Vl[ca.SHAPE_SPHERE | ca.SHAPE_CAPSULE] = Hl, Vl[ca.SHAPE_AABB] = yl, Vl[ca.SHAPE_AABB | ca.SHAPE_OBB] = Cl, Vl[ca.SHAPE_AABB | ca.SHAPE_PLANE] = bl, Vl[ca.SHAPE_AABB | ca.SHAPE_FRUSTUM] = Rl, Vl[ca.SHAPE_AABB | ca.SHAPE_FRUSTUM_ACCURATE] = wl, Vl[ca.SHAPE_OBB] = Nl, Vl[ca.SHAPE_OBB | ca.SHAPE_PLANE] = Pl, Vl[ca.SHAPE_OBB | ca.SHAPE_FRUSTUM] = Ol, Vl[ca.SHAPE_OBB | ca.SHAPE_FRUSTUM_ACCURATE] = Dl, Vl[ca.SHAPE_OBB | ca.SHAPE_CAPSULE] = Ml, Vl[ca.SHAPE_CAPSULE] = kl, U(la.prototype, "line", [{
                name: "mag",
                newName: "len"
            }, {
                name: "magnitude",
                newName: "len"
            }]), G(Vl, "intersect", [{
                name: "line_quad"
            }]);
            var Wl = new En(0, 0, 0),
                jl = new En(0, 0, 0),
                ql = i.mat4(),
                Xl = i.v4(),
                Yl = function() {
                    function e(e, t, n, i) {
                        void 0 === e && (e = 0), void 0 === t && (t = 1), void 0 === n && (n = 0), void 0 === i && (i = 0), this.n = void 0, this.d = void 0, this._type = void 0, this._type = ca.SHAPE_PLANE, this.n = new En(e, t, n), this.d = i
                    }
                    return e.create = function(t, n, i, r) {
                        return new e(t, n, i, r)
                    }, e.clone = function(t) {
                        return new e(t.n.x, t.n.y, t.n.z, t.d)
                    }, e.copy = function(e, t) {
                        return En.copy(e.n, t.n), e.d = t.d, e
                    }, e.fromPoints = function(e, t, n, i) {
                        return En.subtract(Wl, n, t), En.subtract(jl, i, t), En.normalize(e.n, En.cross(e.n, Wl, jl)), e.d = En.dot(e.n, t), e
                    }, e.set = function(e, t, n, i, r) {
                        return e.n.x = t, e.n.y = n, e.n.z = i, e.d = r, e
                    }, e.fromNormalAndPoint = function(e, t, n) {
                        return En.copy(e.n, t), e.d = En.dot(t, n), e
                    }, e.normalize = function(e, t) {
                        var n = t.n.length();
                        return En.normalize(e.n, t.n), n > 0 && (e.d = t.d / n), e
                    }, e.prototype.transform = function(e) {
                        Bn.invert(ql, e), Bn.transpose(ql, ql), Wn.set(Xl, this.n.x, this.n.y, this.n.z, this.d), Wn.transformMat4(Xl, Xl, ql), En.set(this.n, Xl.x, Xl.y, Xl.z), this.d = Xl.w
                    }, K(e, [{
                        key: "type",
                        get: function() {
                            return this._type
                        }
                    }, {
                        key: "x",
                        get: function() {
                            return this.n.x
                        },
                        set: function(e) {
                            this.n.x = e
                        }
                    }, {
                        key: "y",
                        get: function() {
                            return this.n.y
                        },
                        set: function(e) {
                            this.n.y = e
                        }
                    }, {
                        key: "z",
                        get: function() {
                            return this.n.z
                        },
                        set: function(e) {
                            this.n.z = e
                        }
                    }, {
                        key: "w",
                        get: function() {
                            return this.d
                        },
                        set: function(e) {
                            this.d = e
                        }
                    }]), e
                }(),
                Kl = new En,
                Zl = new En,
                Ql = new En,
                Jl = new En,
                $l = new Cn,
                eu = function(e, t, n) {
                    $l.m00 = Math.abs(n.m00), $l.m01 = Math.abs(n.m01), $l.m02 = Math.abs(n.m02), $l.m03 = Math.abs(n.m04), $l.m04 = Math.abs(n.m05), $l.m05 = Math.abs(n.m06), $l.m06 = Math.abs(n.m08), $l.m07 = Math.abs(n.m09), $l.m08 = Math.abs(n.m10), En.transformMat3(e, t, $l)
                },
                tu = function() {
                    function e(e, t, n, i, r, o) {
                        void 0 === e && (e = 0), void 0 === t && (t = 0), void 0 === n && (n = 0), void 0 === i && (i = 1), void 0 === r && (r = 1), void 0 === o && (o = 1), this.center = void 0, this.halfExtents = void 0, this._type = void 0, this._type = ca.SHAPE_AABB, this.center = new En(e, t, n), this.halfExtents = new En(i, r, o)
                    }
                    e.create = function(t, n, i, r, o, a) {
                        return new e(t, n, i, r, o, a)
                    }, e.clone = function(t) {
                        return new e(t.center.x, t.center.y, t.center.z, t.halfExtents.x, t.halfExtents.y, t.halfExtents.z)
                    }, e.copy = function(e, t) {
                        return En.copy(e.center, t.center), En.copy(e.halfExtents, t.halfExtents), e
                    }, e.fromPoints = function(e, t, n) {
                        return En.add(Kl, n, t), En.subtract(Zl, n, t), En.multiplyScalar(e.center, Kl, .5), En.multiplyScalar(e.halfExtents, Zl, .5), e
                    }, e.set = function(e, t, n, i, r, o, a) {
                        return En.set(e.center, t, n, i), En.set(e.halfExtents, r, o, a), e
                    }, e.merge = function(t, n, i) {
                        return En.subtract(Kl, n.center, n.halfExtents), En.subtract(Zl, i.center, i.halfExtents), En.add(Ql, n.center, n.halfExtents), En.add(Jl, i.center, i.halfExtents), En.max(Jl, Ql, Jl), En.min(Ql, Kl, Zl), e.fromPoints(t, Ql, Jl)
                    }, e.toBoundingSphere = function(e, t) {
                        t.getBoundary(Kl, Zl), e.center.set(Kl), e.radius = 0, En.subtract(Ql, Zl, e.center);
                        var n = Ql.length(),
                            i = .5 * n;
                        return e.radius += i, En.multiplyScalar(Ql, Ql, i / n), En.add(e.center, e.center, Ql), e
                    }, e.transform = function(e, t, n) {
                        return En.transformMat4(e.center, t.center, n), eu(e.halfExtents, t.halfExtents, n), e
                    };
                    var t = e.prototype;
                    return t.getBoundary = function(e, t) {
                        En.subtract(e, this.center, this.halfExtents), En.add(t, this.center, this.halfExtents)
                    }, t.transform = function(e, t, n, i, r) {
                        En.transformMat4(r.center, this.center, e), eu(r.halfExtents, this.halfExtents, e)
                    }, t.clone = function() {
                        return e.clone(this)
                    }, t.copy = function(t) {
                        return e.copy(this, t)
                    }, K(e, [{
                        key: "type",
                        get: function() {
                            return this._type
                        }
                    }]), e
                }(),
                nu = new En,
                iu = new En,
                ru = new Cn,
                ou = function() {
                    function e(e, t, n, i, r, o, a, s, c, l, u, h, _, f, d) {
                        void 0 === e && (e = 0), void 0 === t && (t = 0), void 0 === n && (n = 0), void 0 === i && (i = 1), void 0 === r && (r = 1), void 0 === o && (o = 1), void 0 === a && (a = 1), void 0 === s && (s = 0), void 0 === c && (c = 0), void 0 === l && (l = 0), void 0 === u && (u = 1), void 0 === h && (h = 0), void 0 === _ && (_ = 0), void 0 === f && (f = 0), void 0 === d && (d = 1), this.center = void 0, this.halfExtents = void 0, this.orientation = void 0, this._type = void 0, this._type = ca.SHAPE_OBB, this.center = new En(e, t, n), this.halfExtents = new En(i, r, o), this.orientation = new Cn(a, s, c, l, u, h, _, f, d)
                    }
                    e.create = function(t, n, i, r, o, a, s, c, l, u, h, _, f, d, p) {
                        return new e(t, n, i, r, o, a, s, c, l, u, h, _, f, d, p)
                    }, e.clone = function(t) {
                        return new e(t.center.x, t.center.y, t.center.z, t.halfExtents.x, t.halfExtents.y, t.halfExtents.z, t.orientation.m00, t.orientation.m01, t.orientation.m02, t.orientation.m03, t.orientation.m04, t.orientation.m05, t.orientation.m06, t.orientation.m07, t.orientation.m08)
                    }, e.copy = function(e, t) {
                        return En.copy(e.center, t.center), En.copy(e.halfExtents, t.halfExtents), Cn.copy(e.orientation, t.orientation), e
                    }, e.fromPoints = function(e, t, n) {
                        return En.multiplyScalar(e.center, En.add(nu, t, n), .5), En.multiplyScalar(e.halfExtents, En.subtract(iu, n, t), .5), Cn.identity(e.orientation), e
                    }, e.set = function(e, t, n, i, r, o, a, s, c, l, u, h, _, f, d, p) {
                        return En.set(e.center, t, n, i), En.set(e.halfExtents, r, o, a), Cn.set(e.orientation, s, c, l, u, h, _, f, d, p), e
                    };
                    var t = e.prototype;
                    return t.getBoundary = function(e, t) {
                        ! function(e, t, n) {
                            ru.m00 = Math.abs(n.m00), ru.m01 = Math.abs(n.m01), ru.m02 = Math.abs(n.m02), ru.m03 = Math.abs(n.m03), ru.m04 = Math.abs(n.m04), ru.m05 = Math.abs(n.m05), ru.m06 = Math.abs(n.m06), ru.m07 = Math.abs(n.m07), ru.m08 = Math.abs(n.m08), En.transformMat3(e, t, ru)
                        }(nu, this.halfExtents, this.orientation), En.subtract(e, this.center, nu), En.add(t, this.center, nu)
                    }, t.transform = function(e, t, n, i, r) {
                        En.transformMat4(r.center, this.center, e), Cn.fromQuat(r.orientation, n), En.multiply(r.halfExtents, this.halfExtents, i)
                    }, t.translateAndRotate = function(e, t, n) {
                        En.transformMat4(n.center, this.center, e), Cn.fromQuat(n.orientation, t)
                    }, t.setScale = function(e, t) {
                        En.multiply(t.halfExtents, this.halfExtents, e)
                    }, K(e, [{
                        key: "type",
                        get: function() {
                            return this._type
                        }
                    }]), e
                }(),
                au = function() {
                    function e(e, t, n) {
                        void 0 === e && (e = .5), void 0 === t && (t = .5), void 0 === n && (n = 1), this._type = void 0, this.radius = void 0, this.halfHeight = void 0, this.axis = void 0, this.center = void 0, this.rotation = void 0, this.ellipseCenter0 = void 0, this.ellipseCenter1 = void 0, this._type = ca.SHAPE_CAPSULE, this.radius = e, this.halfHeight = t, this.axis = n, this.center = new En, this.rotation = new wn, this.ellipseCenter0 = new En(0, t, 0), this.ellipseCenter1 = new En(0, -t, 0), this.updateCache()
                    }
                    var t = e.prototype;
                    return t.transform = function(e, t, n, i, r) {
                        var o = i,
                            a = mn(o);
                        r.radius = this.radius * Math.abs(a);
                        var s = (this.halfHeight + this.radius) * Math.abs(o.y) - r.radius;
                        s < 0 && (s = 0), r.halfHeight = s, En.transformMat4(r.center, this.center, e), wn.multiply(r.rotation, this.rotation, n), r.updateCache()
                    }, t.updateCache = function() {
                        this.updateLocalCenter(), En.transformQuat(this.ellipseCenter0, this.ellipseCenter0, this.rotation), En.transformQuat(this.ellipseCenter1, this.ellipseCenter1, this.rotation), this.ellipseCenter0.add(this.center), this.ellipseCenter1.add(this.center)
                    }, t.updateLocalCenter = function() {
                        var e = this.halfHeight;
                        switch (this.axis) {
                            case 0:
                                this.ellipseCenter0.set(e, 0, 0), this.ellipseCenter1.set(-e, 0, 0);
                                break;
                            case 1:
                                this.ellipseCenter0.set(0, e, 0), this.ellipseCenter1.set(0, -e, 0);
                                break;
                            case 2:
                                this.ellipseCenter0.set(0, 0, e), this.ellipseCenter1.set(0, 0, -e)
                        }
                    }, K(e, [{
                        key: "type",
                        get: function() {
                            return this._type
                        }
                    }]), e
                }(),
                su = new Array(8);
            su[0] = new En(1, 1, 1), su[1] = new En(-1, 1, 1), su[2] = new En(-1, -1, 1), su[3] = new En(1, -1, 1), su[4] = new En(1, 1, -1), su[5] = new En(-1, 1, -1), su[6] = new En(-1, -1, -1), su[7] = new En(1, -1, -1);
            var cu, lu, uu, hu = function() {
                function e() {
                    this._type = void 0, this.planes = void 0, this.vertices = void 0, this._type = ca.SHAPE_FRUSTUM, this.planes = new Array(6);
                    for (var e = 0; e < 6; ++e) this.planes[e] = Yl.create(0, 0, 0, 0);
                    this.vertices = new Array(8);
                    for (var t = 0; t < 8; ++t) this.vertices[t] = new En
                }
                e.create = function() {
                    return new e
                }, e.clone = function(t) {
                    return e.copy(new e, t)
                }, e.copy = function(e, t) {
                    e._type = t._type;
                    for (var n = 0; n < 6; ++n) Yl.copy(e.planes[n], t.planes[n]);
                    for (var i = 0; i < 8; ++i) En.copy(e.vertices[i], t.vertices[i]);
                    return e
                };
                var t = e.prototype;
                return t.update = function(e, t) {
                    if (En.set(this.planes[0].n, e.m03 + e.m00, e.m07 + e.m04, e.m11 + e.m08), this.planes[0].d = -(e.m15 + e.m12), En.set(this.planes[1].n, e.m03 - e.m00, e.m07 - e.m04, e.m11 - e.m08), this.planes[1].d = -(e.m15 - e.m12), En.set(this.planes[2].n, e.m03 + e.m01, e.m07 + e.m05, e.m11 + e.m09), this.planes[2].d = -(e.m15 + e.m13), En.set(this.planes[3].n, e.m03 - e.m01, e.m07 - e.m05, e.m11 - e.m09), this.planes[3].d = -(e.m15 - e.m13), En.set(this.planes[4].n, e.m03 + e.m02, e.m07 + e.m06, e.m11 + e.m10), this.planes[4].d = -(e.m15 + e.m14), En.set(this.planes[5].n, e.m03 - e.m02, e.m07 - e.m06, e.m11 - e.m10), this.planes[5].d = -(e.m15 - e.m14), this._type === ca.SHAPE_FRUSTUM_ACCURATE) {
                        for (var n = 0; n < 6; n++) {
                            var i = this.planes[n],
                                r = 1 / i.n.length();
                            En.multiplyScalar(i.n, i.n, r), i.d *= r
                        }
                        for (var o = 0; o < 8; o++) En.transformMat4(this.vertices[o], su[o], t)
                    }
                }, t.transform = function(e) {
                    if (this._type === ca.SHAPE_FRUSTUM_ACCURATE) {
                        for (var t = 0; t < 8; t++) En.transformMat4(this.vertices[t], this.vertices[t], e);
                        Yl.fromPoints(this.planes[0], this.vertices[1], this.vertices[5], this.vertices[6]), Yl.fromPoints(this.planes[1], this.vertices[3], this.vertices[7], this.vertices[4]), Yl.fromPoints(this.planes[2], this.vertices[6], this.vertices[7], this.vertices[3]), Yl.fromPoints(this.planes[3], this.vertices[0], this.vertices[4], this.vertices[5]), Yl.fromPoints(this.planes[4], this.vertices[2], this.vertices[3], this.vertices[0]), Yl.fromPoints(this.planes[0], this.vertices[7], this.vertices[6], this.vertices[5])
                    }
                }, K(e, [{
                    key: "accurate",
                    set: function(e) {
                        this._type = e ? ca.SHAPE_FRUSTUM_ACCURATE : ca.SHAPE_FRUSTUM
                    }
                }, {
                    key: "type",
                    get: function() {
                        return this._type
                    }
                }]), e
            }();

            function _u(e, t) {
                if (t && 0 !== e) {
                    for (var n = t.vertices, i = oo.VERTICES, r = 0; r < 8; ++r) uo.setVec3(e, i, n[r]), i += 3;
                    for (var o = t.planes, a = oo.PLANES, s = 0; s < 6; s++, a += 4) uo.setVec4(e, a, o[s])
                }
            }
            hu.createOrtho = (cu = new En, function(e, t, n, i, r, o) {
                    var a = t / 2,
                        s = n / 2;
                    En.set(cu, a, s, i), En.transformMat4(e.vertices[0], cu, o), En.set(cu, -a, s, i), En.transformMat4(e.vertices[1], cu, o), En.set(cu, -a, -s, i), En.transformMat4(e.vertices[2], cu, o), En.set(cu, a, -s, i), En.transformMat4(e.vertices[3], cu, o), En.set(cu, a, s, r), En.transformMat4(e.vertices[4], cu, o), En.set(cu, -a, s, r), En.transformMat4(e.vertices[5], cu, o), En.set(cu, -a, -s, r), En.transformMat4(e.vertices[6], cu, o), En.set(cu, a, -s, r), En.transformMat4(e.vertices[7], cu, o), Yl.fromPoints(e.planes[0], e.vertices[1], e.vertices[6], e.vertices[5]), Yl.fromPoints(e.planes[1], e.vertices[3], e.vertices[4], e.vertices[7]), Yl.fromPoints(e.planes[2], e.vertices[6], e.vertices[3], e.vertices[7]), Yl.fromPoints(e.planes[3], e.vertices[0], e.vertices[5], e.vertices[4]), Yl.fromPoints(e.planes[4], e.vertices[2], e.vertices[0], e.vertices[3]), Yl.fromPoints(e.planes[0], e.vertices[7], e.vertices[5], e.vertices[6])
                }),
                function(e) {
                    e[e.Default = 0] = "Default", e[e.Normal = 1] = "Normal", e[e.Loop = 2] = "Loop", e[e.ShouldWrap = 4] = "ShouldWrap", e[e.Clamp = 8] = "Clamp", e[e.PingPong = 22] = "PingPong", e[e.Reverse = 36] = "Reverse"
                }(lu || (lu = {})),
                function(e) {
                    e[e.Default = lu.Default] = "Default", e[e.Normal = lu.Normal] = "Normal", e[e.Reverse = lu.Reverse] = "Reverse", e[e.Loop = lu.Loop] = "Loop", e[e.LoopReverse = lu.Loop | lu.Reverse] = "LoopReverse", e[e.PingPong = lu.PingPong] = "PingPong", e[e.PingPongReverse = lu.PingPong | lu.Reverse] = "PingPongReverse"
                }(uu || (uu = {})), nt(uu);
            var fu = function() {
                    function e(e) {
                        this.ratio = 0, this.time = 0, this.direction = 1, this.stopped = !0, this.iterations = 0, this.frameIndex = void 0, e && this.set(e)
                    }
                    return e.prototype.set = function(e) {
                        this.ratio = e.ratio, this.time = e.time, this.direction = e.direction, this.stopped = e.stopped, this.iterations = e.iterations, this.frameIndex = e.frameIndex
                    }, e
                }(),
                du = $e({
                    Default: lu.Default,
                    Normal: lu.Normal,
                    Clamp: lu.Clamp,
                    Loop: lu.Loop,
                    PingPong: lu.PingPong
                }),
                pu = function() {
                    this.time = 0, this.value = 0, this.inTangent = 0, this.outTangent = 0
                };
            qt.fastDefine("cc.Keyframe", pu, {
                time: 0,
                value: 0,
                inTangent: 0,
                outTangent: 0
            });
            var mu = function() {
                    function e() {
                        this.index = void 0, this.time = void 0, this.endTime = void 0, this.coefficient = void 0, this.index = -1, this.time = 0, this.endTime = 0, this.coefficient = new Float32Array(4)
                    }
                    return e.prototype.evaluate = function(e) {
                        return t = e - this.time, n = this.coefficient, t * (t * (t * n[0] + n[1]) + n[2]) + n[3];
                        var t, n
                    }, e
                }(),
                gu = function() {
                    function e(t) {
                        void 0 === t && (t = null), this.keyFrames = void 0, this.preWrapMode = du.Loop, this.postWrapMode = du.Clamp, this.cachedKey = void 0, this.keyFrames = t || [].concat(e.defaultKF), this.cachedKey = new mu
                    }
                    var t = e.prototype;
                    return t.addKey = function(e) {
                        null == this.keyFrames && (this.keyFrames = []), this.keyFrames.push(e)
                    }, t.evaluate_slow = function(e) {
                        var t = e,
                            n = e < 0 ? this.preWrapMode : this.postWrapMode,
                            i = this.keyFrames[0].time,
                            r = this.keyFrames[this.keyFrames.length - 1].time;
                        switch (n) {
                            case du.Loop:
                                t = fn(e - i, r - i) + i;
                                break;
                            case du.PingPong:
                                t = dn(e - i, r - i) + i;
                                break;
                            case du.Default:
                            case du.Normal:
                            case du.Clamp:
                            default:
                                t = en(e, i, r)
                        }
                        var o = 0;
                        if (t > this.keyFrames[0].time)
                            if (t >= this.keyFrames[this.keyFrames.length - 1].time) o = this.keyFrames.length - 2;
                            else
                                for (var a = 0; a < this.keyFrames.length - 1; a++)
                                    if (t >= this.keyFrames[0].time && t <= this.keyFrames[a + 1].time) {
                                        o = a;
                                        break
                                    }
                        var s = this.keyFrames[o],
                            c = this.keyFrames[o + 1],
                            l = pn(s.time, c.time, t),
                            u = c.time - s.time,
                            h = s.outTangent * u,
                            _ = c.inTangent * u,
                            f = l * l,
                            d = f * l,
                            p = d - 2 * f + l,
                            m = d - f,
                            g = -2 * d + 3 * f;
                        return (2 * d - 3 * f + 1) * s.value + p * h + m * _ + g * c.value
                    }, t.evaluate = function(e) {
                        var t = e,
                            n = e < 0 ? this.preWrapMode : this.postWrapMode,
                            i = this.keyFrames[0].time,
                            r = this.keyFrames[this.keyFrames.length - 1].time;
                        switch (n) {
                            case du.Loop:
                                t = fn(e - i, r - i) + i;
                                break;
                            case du.PingPong:
                                t = dn(e - i, r - i) + i;
                                break;
                            case du.Default:
                            case du.Normal:
                            case du.Clamp:
                            default:
                                t = en(e, i, r)
                        }
                        if (t >= this.cachedKey.time && t < this.cachedKey.endTime) return this.cachedKey.evaluate(t);
                        var o = this.findIndex(this.cachedKey, t),
                            a = Math.min(o + 1, this.keyFrames.length - 1);
                        return this.calcOptimizedKey(this.cachedKey, o, a), this.cachedKey.evaluate(t)
                    }, t.calcOptimizedKey = function(e, t, n) {
                        var i = this.keyFrames[t],
                            r = this.keyFrames[n];
                        e.index = t, e.time = i.time, e.endTime = r.time;
                        var o = r.time - i.time,
                            a = r.value - i.value,
                            s = 1 / (o * o),
                            c = i.outTangent * o,
                            l = r.inTangent * o;
                        e.coefficient[0] = (c + l - a - a) * s / o, e.coefficient[1] = (a + a + a - c - c - l) * s, e.coefficient[2] = i.outTangent, e.coefficient[3] = i.value
                    }, t.findIndex = function(e, t) {
                        var n = e.index;
                        if (-1 !== n)
                            if (t > this.keyFrames[n].time)
                                for (var i = 0; i < 3; i++) {
                                    var r = n + i;
                                    if (r + 1 < this.keyFrames.length && this.keyFrames[r + 1].time > t) return r
                                } else
                                    for (var o = 0; o < 3; o++) {
                                        var a = n - o;
                                        if (a >= 0 && this.keyFrames[a - 1].time <= t) return a - 1
                                    }
                        for (var s, c = 0, l = this.keyFrames.length; l - c > 1;) s = Math.floor((c + l) / 2), this.keyFrames[s].time >= t ? l = s : c = s;
                        return c
                    }, e
                }();

            function vu(e, t) {
                console.warn(e + " is deprecated, please use " + t + " instead.")
            }
            gu.defaultKF = [{
                time: 0,
                value: 1,
                inTangent: 0,
                outTangent: 0
            }, {
                time: 1,
                value: 1,
                inTangent: 0,
                outTangent: 0
            }], qt.fastDefine("cc.AnimationCurve", gu, {
                preWrapMode: du.Default,
                postWrapMode: du.Default,
                keyFrames: []
            }), U(Vl, "intersect", [{
                name: "ray_aabb",
                newName: "rayAABB"
            }, {
                name: "ray_plane",
                newName: "rayPlane"
            }, {
                name: "ray_triangle",
                newName: "rayTriangle"
            }, {
                name: "ray_sphere",
                newName: "raySphere"
            }, {
                name: "ray_obb",
                newName: "rayOBB"
            }, {
                name: "ray_capsule",
                newName: "rayCapsule"
            }, {
                name: "ray_subMesh",
                newName: "raySubMesh"
            }, {
                name: "ray_mesh",
                newName: "rayMesh"
            }, {
                name: "ray_model",
                newName: "rayModel"
            }, {
                name: "line_plane",
                newName: "linePlane"
            }, {
                name: "line_triangle",
                newName: "lineTriangle"
            }, {
                name: "line_aabb",
                newName: "lineAABB"
            }, {
                name: "line_obb",
                newName: "lineOBB"
            }, {
                name: "line_sphere",
                newName: "lineSphere"
            }, {
                name: "aabb_aabb",
                newName: "aabbWithAABB"
            }, {
                name: "aabb_obb",
                newName: "aabbWithOBB"
            }, {
                name: "aabb_plane",
                newName: "aabbPlane"
            }, {
                name: "aabb_frustum",
                newName: "aabbFrustum"
            }, {
                name: "aabbFrustum_accurate",
                newName: "aabbFrustumAccurate"
            }, {
                name: "obb_point",
                newName: "obbPoint"
            }, {
                name: "obb_plane",
                newName: "obbPlane"
            }, {
                name: "obb_frustum",
                newName: "obbFrustum"
            }, {
                name: "obbFrustum_accurate",
                newName: "obbFrustumAccurate"
            }, {
                name: "obb_obb",
                newName: "obbWithOBB"
            }, {
                name: "obb_capsule",
                newName: "obbCapsule"
            }, {
                name: "sphere_plane",
                newName: "spherePlane"
            }, {
                name: "sphere_frustum",
                newName: "sphereFrustum"
            }, {
                name: "sphereFrustum_accurate",
                newName: "sphereFrustumAccurate"
            }, {
                name: "sphere_sphere",
                newName: "sphereWithSphere"
            }, {
                name: "sphere_aabb",
                newName: "sphereAABB"
            }, {
                name: "sphere_obb",
                newName: "sphereOBB"
            }, {
                name: "sphere_capsule",
                newName: "sphereCapsule"
            }, {
                name: "capsule_capsule",
                newName: "capsuleWithCapsule"
            }]);
            var yu = function(e) {
                    function t() {
                        var t;
                        return t = e.call(this) || this, vu("line", "Line"), t
                    }
                    return Q(t, e), t
                }(la),
                Su = function(e) {
                    function t() {
                        var t;
                        return t = e.call(this) || this, vu("plane", "Plane"), t
                    }
                    return Q(t, e), t
                }(Yl),
                Eu = function(e) {
                    function t() {
                        var t;
                        return t = e.call(this) || this, vu("ray", "Ray"), t
                    }
                    return Q(t, e), t
                }(ua),
                Tu = function(e) {
                    function t() {
                        var t;
                        return t = e.call(this) || this, vu("triangle", "Triangle"), t
                    }
                    return Q(t, e), t
                }(ts),
                Au = function(e) {
                    function t() {
                        var t;
                        return t = e.call(this) || this, vu("sphere", "Sphere"), t
                    }
                    return Q(t, e), t
                }(es),
                xu = function(e) {
                    function t() {
                        var t;
                        return t = e.call(this) || this, vu("aabb", "AABB"), t
                    }
                    return Q(t, e), t
                }(tu),
                Cu = function(e) {
                    function t() {
                        var t;
                        return t = e.call(this) || this, vu("obb", "OBB"), t
                    }
                    return Q(t, e), t
                }(ou),
                bu = function(e) {
                    function t() {
                        var t;
                        return t = e.call(this) || this, vu("capsule", "Capsule"), t
                    }
                    return Q(t, e), t
                }(au),
                Ru = function(e) {
                    function t() {
                        var t;
                        return t = e.call(this) || this, vu("frustum", "Frustum"), t
                    }
                    return Q(t, e), t
                }(hu),
                wu = Object.freeze({
                    __proto__: null,
                    distance: sa,
                    enums: ca,
                    intersect: Vl,
                    Line: la,
                    Plane: Yl,
                    Ray: ua,
                    Triangle: ts,
                    Sphere: es,
                    AABB: tu,
                    OBB: ou,
                    Capsule: au,
                    Frustum: hu,
                    Keyframe: pu,
                    AnimationCurve: gu,
                    get ERaycastMode() {
                        return Fc
                    },
                    line: yu,
                    plane: Su,
                    ray: Eu,
                    triangle: Tu,
                    sphere: Au,
                    aabb: xu,
                    obb: Cu,
                    capsule: bu,
                    frustum: Ru
                });
            e("geometry", wu);
            var Iu = {
                    NONE: 0,
                    IGNORE_RAYCAST: 1 << 20,
                    GIZMOS: 1 << 21,
                    EDITOR: 1 << 22,
                    UI_3D: 1 << 23,
                    SCENE_GIZMO: 1 << 24,
                    UI_2D: 1 << 25,
                    PROFILER: 1 << 28,
                    DEFAULT: 1 << 30,
                    ALL: 4294967295
                },
                Pu = e("Layers", function() {
                    function e() {}
                    return e.makeMaskInclude = function(e) {
                        for (var t, n = 0, i = te(e); !(t = i()).done;) n |= t.value;
                        return n
                    }, e.makeMaskExclude = function(t) {
                        return ~e.makeMaskInclude(t)
                    }, e.addLayer = function(t, n) {
                        void 0 !== n ? n > 19 || n < 0 ? console.warn("maximum layers reached.") : (e.Enum[t] = 1 << n, e.Enum[n] = t, e.BitMask[t] = 1 << n, e.BitMask[n] = t) : console.warn("bitNum can't be undefined")
                    }, e.deleteLayer = function(t) {
                        t > 19 || t < 0 ? console.warn("do not change buildin layers.") : (delete e.Enum[e.Enum[t]], delete e.Enum[t], delete e.BitMask[e.BitMask[t]], delete e.BitMask[t])
                    }, e
                }());
            Pu.Enum = $e(Iu), Pu.BitMask = Je(Z({}, Iu)), i.Layers = Pu;
            var Ou, Du, Nu = "GbufferFlow",
                Mu = "LightingFlow",
                Lu = "ForwardFlow",
                Bu = "ShadowFlow";
            ! function(e) {
                e[e.DEFAULT = 100] = "DEFAULT", e[e.UI = 200] = "UI"
            }(Ou || (Ou = {})), i.RenderPassStage = Ou,
                function(e) {
                    e[e.MIN = 0] = "MIN", e[e.MAX = 255] = "MAX", e[e.DEFAULT = 128] = "DEFAULT"
                }(Du || (Du = {}));
            var Fu, zu = {
                    bindings: [],
                    layouts: {}
                },
                Uu = {
                    bindings: [],
                    layouts: {}
                };
            ! function(e) {
                e[e.UBO_GLOBAL = 0] = "UBO_GLOBAL", e[e.UBO_CAMERA = 1] = "UBO_CAMERA", e[e.UBO_SHADOW = 2] = "UBO_SHADOW", e[e.SAMPLER_SHADOWMAP = 3] = "SAMPLER_SHADOWMAP", e[e.SAMPLER_ENVIRONMENT = 4] = "SAMPLER_ENVIRONMENT", e[e.SAMPLER_SPOT_LIGHTING_MAP = 5] = "SAMPLER_SPOT_LIGHTING_MAP", e[e.SAMPLER_GBUFFER_ALBEDOMAP = 6] = "SAMPLER_GBUFFER_ALBEDOMAP", e[e.SAMPLER_GBUFFER_POSITIONMAP = 7] = "SAMPLER_GBUFFER_POSITIONMAP", e[e.SAMPLER_GBUFFER_NORMALMAP = 8] = "SAMPLER_GBUFFER_NORMALMAP", e[e.SAMPLER_GBUFFER_EMISSIVEMAP = 9] = "SAMPLER_GBUFFER_EMISSIVEMAP", e[e.SAMPLER_LIGHTING_RESULTMAP = 10] = "SAMPLER_LIGHTING_RESULTMAP", e[e.COUNT = 11] = "COUNT"
            }(Fu || (Fu = {}));
            var Gu, Hu = Fu.SAMPLER_SHADOWMAP,
                ku = Fu.COUNT - Hu;
            ! function(e) {
                e[e.UBO_LOCAL = 0] = "UBO_LOCAL", e[e.UBO_FORWARD_LIGHTS = 1] = "UBO_FORWARD_LIGHTS", e[e.UBO_SKINNING_ANIMATION = 2] = "UBO_SKINNING_ANIMATION", e[e.UBO_SKINNING_TEXTURE = 3] = "UBO_SKINNING_TEXTURE", e[e.UBO_MORPH = 4] = "UBO_MORPH", e[e.SAMPLER_JOINTS = 5] = "SAMPLER_JOINTS", e[e.SAMPLER_MORPH_POSITION = 6] = "SAMPLER_MORPH_POSITION", e[e.SAMPLER_MORPH_NORMAL = 7] = "SAMPLER_MORPH_NORMAL", e[e.SAMPLER_MORPH_TANGENT = 8] = "SAMPLER_MORPH_TANGENT", e[e.SAMPLER_LIGHTMAP = 9] = "SAMPLER_LIGHTMAP", e[e.SAMPLER_SPRITE = 10] = "SAMPLER_SPRITE", e[e.COUNT = 11] = "COUNT"
            }(Gu || (Gu = {}));
            var Vu, Wu = Gu.SAMPLER_JOINTS,
                ju = Gu.COUNT - Wu;
            ! function(e) {
                e[e.GLOBAL = 0] = "GLOBAL", e[e.MATERIAL = 1] = "MATERIAL", e[e.LOCAL = 2] = "LOCAL"
            }(Vu || (Vu = {}));
            var qu = new ms;
            qu.bufferOffsets = [0, Hu + Wu, Hu], qu.samplerOffsets = [-Hu, ku + ju, ku - Wu], qu.flexibleSet = 1;
            var Xu = function() {};
            Xu.SIZE = 4 * (Xu.COUNT = 4 + (Xu.SCREEN_SIZE_OFFSET = 4 + (Xu.NATIVE_SIZE_OFFSET = 4 + (Xu.TIME_OFFSET = 0)))), Xu.NAME = "CCGlobal", Xu.BINDING = Fu.UBO_GLOBAL, Xu.DESCRIPTOR = new Ws(Xu.BINDING, Za.UNIFORM_BUFFER, 1, Ua.ALL), Xu.LAYOUT = new bs(Vu.GLOBAL, Xu.BINDING, Xu.NAME, [new Cs("cc_time", Aa.FLOAT4, 1), new Cs("cc_screenSize", Aa.FLOAT4, 1), new Cs("cc_nativeSize", Aa.FLOAT4, 1)], 1), zu.layouts[Xu.NAME] = Xu.LAYOUT, zu.bindings[Xu.BINDING] = Xu.DESCRIPTOR;
            var Yu = function() {};
            Yu.SIZE = 4 * (Yu.COUNT = 4 + (Yu.GLOBAL_FOG_ADD_OFFSET = 4 + (Yu.GLOBAL_FOG_BASE_OFFSET = 4 + (Yu.GLOBAL_FOG_COLOR_OFFSET = 4 + (Yu.AMBIENT_GROUND_OFFSET = 4 + (Yu.AMBIENT_SKY_OFFSET = 4 + (Yu.MAIN_LIT_COLOR_OFFSET = 4 + (Yu.MAIN_LIT_DIR_OFFSET = 4 + (Yu.EXPOSURE_OFFSET = 4 + (Yu.SCREEN_SCALE_OFFSET = 4 + (Yu.CAMERA_POS_OFFSET = 16 + (Yu.MAT_VIEW_PROJ_INV_OFFSET = 16 + (Yu.MAT_VIEW_PROJ_OFFSET = 16 + (Yu.MAT_PROJ_INV_OFFSET = 16 + (Yu.MAT_PROJ_OFFSET = 16 + (Yu.MAT_VIEW_INV_OFFSET = 16 + (Yu.MAT_VIEW_OFFSET = 0))))))))))))))))), Yu.NAME = "CCCamera", Yu.BINDING = Fu.UBO_CAMERA, Yu.DESCRIPTOR = new Ws(Yu.BINDING, Za.UNIFORM_BUFFER, 1, Ua.ALL), Yu.LAYOUT = new bs(Vu.GLOBAL, Yu.BINDING, Yu.NAME, [new Cs("cc_matView", Aa.MAT4, 1), new Cs("cc_matViewInv", Aa.MAT4, 1), new Cs("cc_matProj", Aa.MAT4, 1), new Cs("cc_matProjInv", Aa.MAT4, 1), new Cs("cc_matViewProj", Aa.MAT4, 1), new Cs("cc_matViewProjInv", Aa.MAT4, 1), new Cs("cc_cameraPos", Aa.FLOAT4, 1), new Cs("cc_screenScale", Aa.FLOAT4, 1), new Cs("cc_exposure", Aa.FLOAT4, 1), new Cs("cc_mainLitDir", Aa.FLOAT4, 1), new Cs("cc_mainLitColor", Aa.FLOAT4, 1), new Cs("cc_ambientSky", Aa.FLOAT4, 1), new Cs("cc_ambientGround", Aa.FLOAT4, 1), new Cs("cc_fogColor", Aa.FLOAT4, 1), new Cs("cc_fogBase", Aa.FLOAT4, 1), new Cs("cc_fogAdd", Aa.FLOAT4, 1)], 1), zu.layouts[Yu.NAME] = Yu.LAYOUT, zu.bindings[Yu.BINDING] = Yu.DESCRIPTOR;
            var Ku = function() {};
            Ku.SIZE = 4 * (Ku.COUNT = 4 + (Ku.SHADOW_COLOR_OFFSET = 4 + (Ku.SHADOW_LIGHT_PACKING_NBIAS_NULL_INFO_OFFSET = 4 + (Ku.SHADOW_WIDTH_HEIGHT_PCF_BIAS_INFO_OFFSET = 4 + (Ku.SHADOW_NEAR_FAR_LINEAR_SELF_INFO_OFFSET = 16 + (Ku.MAT_LIGHT_VIEW_PROJ_OFFSET = 16 + (Ku.MAT_LIGHT_VIEW_OFFSET = 16 + (Ku.MAT_LIGHT_PLANE_PROJ_OFFSET = 0)))))))), Ku.NAME = "CCShadow", Ku.BINDING = Fu.UBO_SHADOW, Ku.DESCRIPTOR = new Ws(Ku.BINDING, Za.UNIFORM_BUFFER, 1, Ua.ALL), Ku.LAYOUT = new bs(Vu.GLOBAL, Ku.BINDING, Ku.NAME, [new Cs("cc_matLightPlaneProj", Aa.MAT4, 1), new Cs("cc_matLightView", Aa.MAT4, 1), new Cs("cc_matLightViewProj", Aa.MAT4, 1), new Cs("cc_shadowNFLSInfo", Aa.FLOAT4, 1), new Cs("cc_shadowWHPBInfo", Aa.FLOAT4, 1), new Cs("cc_shadowLPNNInfo", Aa.FLOAT4, 1), new Cs("cc_shadowColor", Aa.FLOAT4, 1)], 1), zu.layouts[Ku.NAME] = Ku.LAYOUT, zu.bindings[Ku.BINDING] = Ku.DESCRIPTOR;
            var Zu = Fu.SAMPLER_SHADOWMAP,
                Qu = new Ws(Zu, Za.SAMPLER_TEXTURE, 1, Ua.FRAGMENT),
                Ju = new Rs(Vu.GLOBAL, Zu, "cc_shadowMap", Aa.SAMPLER2D, 1);
            zu.layouts.cc_shadowMap = Ju, zu.bindings[Zu] = Qu;
            var $u = Fu.SAMPLER_GBUFFER_ALBEDOMAP,
                eh = new Ws($u, Za.SAMPLER_TEXTURE, 1, Ua.FRAGMENT),
                th = new Rs(Vu.GLOBAL, $u, "cc_gbuffer_albedoMap", Aa.SAMPLER2D, 1);
            zu.layouts.cc_gbuffer_albedoMap = th, zu.bindings[$u] = eh;
            var nh = Fu.SAMPLER_GBUFFER_POSITIONMAP,
                ih = new Ws(nh, Za.SAMPLER_TEXTURE, 1, Ua.FRAGMENT),
                rh = new Rs(Vu.GLOBAL, nh, "cc_gbuffer_positionMap", Aa.SAMPLER2D, 1);
            zu.layouts.cc_gbuffer_positionMap = rh, zu.bindings[nh] = ih;
            var oh = Fu.SAMPLER_GBUFFER_NORMALMAP,
                ah = new Ws(oh, Za.SAMPLER_TEXTURE, 1, Ua.FRAGMENT),
                sh = new Rs(Vu.GLOBAL, oh, "cc_gbuffer_normalMap", Aa.SAMPLER2D, 1);
            zu.layouts.cc_gbuffer_normalMap = sh, zu.bindings[oh] = ah;
            var ch = Fu.SAMPLER_LIGHTING_RESULTMAP,
                lh = new Ws(ch, Za.SAMPLER_TEXTURE, 1, Ua.FRAGMENT),
                uh = new Rs(Vu.GLOBAL, ch, "cc_lighting_resultMap", Aa.SAMPLER2D, 1);
            zu.layouts.cc_lighting_resultMap = uh, zu.bindings[ch] = lh;
            var hh = Fu.SAMPLER_GBUFFER_EMISSIVEMAP,
                _h = new Ws(hh, Za.SAMPLER_TEXTURE, 1, Ua.FRAGMENT),
                fh = new Rs(Vu.GLOBAL, hh, "cc_gbuffer_emissiveMap", Aa.SAMPLER2D, 1);
            zu.layouts.cc_gbuffer_emissiveMap = fh, zu.bindings[hh] = _h;
            var dh = Fu.SAMPLER_ENVIRONMENT,
                ph = new Ws(dh, Za.SAMPLER_TEXTURE, 1, Ua.FRAGMENT),
                mh = new Rs(Vu.GLOBAL, dh, "cc_environment", Aa.SAMPLER_CUBE, 1);
            zu.layouts.cc_environment = mh, zu.bindings[dh] = ph;
            var gh = Fu.SAMPLER_SPOT_LIGHTING_MAP,
                vh = new Ws(gh, Za.SAMPLER_TEXTURE, 1, Ua.FRAGMENT),
                yh = new Rs(Vu.GLOBAL, gh, "cc_spotLightingMap", Aa.SAMPLER2D, 1);
            zu.layouts.cc_spotLightingMap = yh, zu.bindings[gh] = vh;
            var Sh = function() {};
            Sh.SIZE = 4 * (Sh.COUNT = 4 + (Sh.LIGHTINGMAP_UVPARAM = 16 + (Sh.MAT_WORLD_IT_OFFSET = 16 + (Sh.MAT_WORLD_OFFSET = 0)))), Sh.NAME = "CCLocal", Sh.BINDING = Gu.UBO_LOCAL, Sh.DESCRIPTOR = new Ws(Sh.BINDING, Za.UNIFORM_BUFFER, 1, Ua.VERTEX), Sh.LAYOUT = new bs(Vu.LOCAL, Sh.BINDING, Sh.NAME, [new Cs("cc_matWorld", Aa.MAT4, 1), new Cs("cc_matWorldIT", Aa.MAT4, 1), new Cs("cc_lightingMapUVParam", Aa.FLOAT4, 1)], 1), Uu.layouts[Sh.NAME] = Sh.LAYOUT, Uu.bindings[Sh.BINDING] = Sh.DESCRIPTOR;
            var Eh = "a_matWorld0",
                Th = function() {};
            Th.BATCHING_COUNT = 10, Th.MAT_WORLDS_OFFSET = 0, Th.SIZE = 4 * (Th.COUNT = 16 * Th.BATCHING_COUNT), Th.NAME = "CCLocalBatched", Th.BINDING = Gu.UBO_LOCAL, Th.DESCRIPTOR = new Ws(Th.BINDING, Za.UNIFORM_BUFFER, 1, Ua.VERTEX), Th.LAYOUT = new bs(Vu.LOCAL, Th.BINDING, Th.NAME, [new Cs("cc_matWorlds", Aa.MAT4, Th.BATCHING_COUNT)], 1), Uu.layouts[Th.NAME] = Th.LAYOUT, Uu.bindings[Th.BINDING] = Th.DESCRIPTOR;
            var Ah = function() {};
            Ah.LIGHTS_PER_PASS = 1, Ah.SIZE = 4 * (Ah.COUNT = (Ah.LIGHT_DIR_OFFSET = (Ah.LIGHT_SIZE_RANGE_ANGLE_OFFSET = (Ah.LIGHT_COLOR_OFFSET = (Ah.LIGHT_POS_OFFSET = 0) + 4 * Ah.LIGHTS_PER_PASS) + 4 * Ah.LIGHTS_PER_PASS) + 4 * Ah.LIGHTS_PER_PASS) + 4 * Ah.LIGHTS_PER_PASS), Ah.NAME = "CCForwardLight", Ah.BINDING = Gu.UBO_FORWARD_LIGHTS, Ah.DESCRIPTOR = new Ws(Ah.BINDING, Za.DYNAMIC_UNIFORM_BUFFER, 1, Ua.FRAGMENT), Ah.LAYOUT = new bs(Vu.LOCAL, Ah.BINDING, Ah.NAME, [new Cs("cc_lightPos", Aa.FLOAT4, Ah.LIGHTS_PER_PASS), new Cs("cc_lightColor", Aa.FLOAT4, Ah.LIGHTS_PER_PASS), new Cs("cc_lightSizeRangeAngle", Aa.FLOAT4, Ah.LIGHTS_PER_PASS), new Cs("cc_lightDir", Aa.FLOAT4, Ah.LIGHTS_PER_PASS)], 1), Uu.layouts[Ah.NAME] = Ah.LAYOUT, Uu.bindings[Ah.BINDING] = Ah.DESCRIPTOR;
            var xh = function() {};
            xh.LIGHTS_PER_PASS = 10;
            var Ch = function() {};
            Ch.SIZE = 4 * (Ch.COUNT = 4 + (Ch.JOINTS_TEXTURE_INFO_OFFSET = 0)), Ch.NAME = "CCSkinningTexture", Ch.BINDING = Gu.UBO_SKINNING_TEXTURE, Ch.DESCRIPTOR = new Ws(Ch.BINDING, Za.UNIFORM_BUFFER, 1, Ua.VERTEX), Ch.LAYOUT = new bs(Vu.LOCAL, Ch.BINDING, Ch.NAME, [new Cs("cc_jointTextureInfo", Aa.FLOAT4, 1)], 1), Uu.layouts[Ch.NAME] = Ch.LAYOUT, Uu.bindings[Ch.BINDING] = Ch.DESCRIPTOR;
            var bh = function() {};
            bh.SIZE = 4 * (bh.COUNT = 4 + (bh.JOINTS_ANIM_INFO_OFFSET = 0)), bh.NAME = "CCSkinningAnimation", bh.BINDING = Gu.UBO_SKINNING_ANIMATION, bh.DESCRIPTOR = new Ws(bh.BINDING, Za.UNIFORM_BUFFER, 1, Ua.VERTEX), bh.LAYOUT = new bs(Vu.LOCAL, bh.BINDING, bh.NAME, [new Cs("cc_jointAnimInfo", Aa.FLOAT4, 1)], 1), Uu.layouts[bh.NAME] = bh.LAYOUT, Uu.bindings[bh.BINDING] = bh.DESCRIPTOR;
            var Rh = "a_jointAnimInfo",
                wh = function() {};
            wh.SIZE = 4 * (wh.COUNT = 360 + (wh.JOINTS_OFFSET = 0)), wh.NAME = "CCSkinning", wh.BINDING = Gu.UBO_SKINNING_TEXTURE, wh.DESCRIPTOR = new Ws(wh.BINDING, Za.UNIFORM_BUFFER, 1, Ua.VERTEX), wh.LAYOUT = new bs(Vu.LOCAL, wh.BINDING, wh.NAME, [new Cs("cc_joints", Aa.FLOAT4, 90)], 1), Uu.layouts[wh.NAME] = wh.LAYOUT, Uu.bindings[wh.BINDING] = wh.DESCRIPTOR;
            var Ih = function() {};
            Ih.MAX_MORPH_TARGET_COUNT = 60, Ih.OFFSET_OF_WEIGHTS = 0, Ih.OFFSET_OF_VERTICES_COUNT = 4 + (Ih.OFFSET_OF_DISPLACEMENT_TEXTURE_HEIGHT = 4 + (Ih.OFFSET_OF_DISPLACEMENT_TEXTURE_WIDTH = 4 * Ih.MAX_MORPH_TARGET_COUNT)), Ih.COUNT_BASE_4_BYTES = 4 * Math.ceil(Ih.MAX_MORPH_TARGET_COUNT / 4) + 4, Ih.SIZE = 4 * Ih.COUNT_BASE_4_BYTES, Ih.NAME = "CCMorph", Ih.BINDING = Gu.UBO_MORPH, Ih.DESCRIPTOR = new Ws(Ih.BINDING, Za.UNIFORM_BUFFER, 1, Ua.VERTEX), Ih.LAYOUT = new bs(Vu.LOCAL, Ih.BINDING, Ih.NAME, [new Cs("cc_displacementWeights", Aa.FLOAT4, Ih.MAX_MORPH_TARGET_COUNT / 4), new Cs("cc_displacementTextureInfo", Aa.FLOAT4, 1)], 1), Uu.layouts[Ih.NAME] = Ih.LAYOUT, Uu.bindings[Ih.BINDING] = Ih.DESCRIPTOR;
            var Ph = Gu.SAMPLER_JOINTS,
                Oh = new Ws(Ph, Za.SAMPLER_TEXTURE, 1, Ua.VERTEX),
                Dh = new Rs(Vu.LOCAL, Ph, "cc_jointTexture", Aa.SAMPLER2D, 1);
            Uu.layouts.cc_jointTexture = Dh, Uu.bindings[Ph] = Oh;
            var Nh = Gu.SAMPLER_MORPH_POSITION,
                Mh = new Ws(Nh, Za.SAMPLER_TEXTURE, 1, Ua.VERTEX),
                Lh = new Rs(Vu.LOCAL, Nh, "cc_PositionDisplacements", Aa.SAMPLER2D, 1);
            Uu.layouts.cc_PositionDisplacements = Lh, Uu.bindings[Nh] = Mh;
            var Bh = Gu.SAMPLER_MORPH_NORMAL,
                Fh = new Ws(Bh, Za.SAMPLER_TEXTURE, 1, Ua.VERTEX),
                zh = new Rs(Vu.LOCAL, Bh, "cc_NormalDisplacements", Aa.SAMPLER2D, 1);
            Uu.layouts.cc_NormalDisplacements = zh, Uu.bindings[Bh] = Fh;
            var Uh = Gu.SAMPLER_MORPH_TANGENT,
                Gh = new Ws(Uh, Za.SAMPLER_TEXTURE, 1, Ua.VERTEX),
                Hh = new Rs(Vu.LOCAL, Uh, "cc_TangentDisplacements", Aa.SAMPLER2D, 1);
            Uu.layouts.cc_TangentDisplacements = Hh, Uu.bindings[Uh] = Gh;
            var kh = Gu.SAMPLER_LIGHTMAP,
                Vh = new Ws(kh, Za.SAMPLER_TEXTURE, 1, Ua.FRAGMENT),
                Wh = new Rs(Vu.LOCAL, kh, "cc_lightingMap", Aa.SAMPLER2D, 1);
            Uu.layouts.cc_lightingMap = Wh, Uu.bindings[kh] = Vh;
            var jh = Gu.SAMPLER_SPRITE,
                qh = new Ws(jh, Za.SAMPLER_TEXTURE, 1, Ua.FRAGMENT),
                Xh = new Rs(Vu.LOCAL, jh, "cc_spriteTexture", Aa.SAMPLER2D, 1);
            Uu.layouts.cc_spriteTexture = Xh, Uu.bindings[jh] = qh;
            var Yh, Kh, Zh, Qh, Jh, $h = Pu.makeMaskExclude([Pu.BitMask.UI_2D, Pu.BitMask.GIZMOS, Pu.BitMask.EDITOR, Pu.BitMask.SCENE_GIZMO, Pu.BitMask.PROFILER]),
                e_ = Pu.makeMaskExclude([Pu.BitMask.UI_2D, Pu.BitMask.PROFILER]),
                t_ = Pu.Enum.ALL;

            function n_(e) {
                return e.hasFeature(Sa.COLOR_HALF_FLOAT) && e.hasFeature(Sa.TEXTURE_HALF_FLOAT)
            }
            e("pipeline", Object.freeze({
                    __proto__: null,
                    PIPELINE_FLOW_GBUFFER: Nu,
                    PIPELINE_FLOW_LIGHTING: Mu,
                    PIPELINE_FLOW_FORWARD: Lu,
                    PIPELINE_FLOW_SHADOW: Bu,
                    PIPELINE_FLOW_SMAA: "SMAAFlow",
                    PIPELINE_FLOW_TONEMAP: "ToneMapFlow",
                    get RenderPassStage() {
                        return Ou
                    },
                    get RenderPriority() {
                        return Du
                    },
                    globalDescriptorSetLayout: zu,
                    localDescriptorSetLayout: Uu,
                    get PipelineGlobalBindings() {
                        return Fu
                    },
                    get ModelLocalBindings() {
                        return Gu
                    },
                    get SetIndex() {
                        return Vu
                    },
                    bindingMappingInfo: qu,
                    UBOGlobal: Xu,
                    UBOCamera: Yu,
                    UBOShadow: Ku,
                    UNIFORM_SHADOWMAP_BINDING: Zu,
                    UNIFORM_GBUFFER_ALBEDOMAP_BINDING: $u,
                    UNIFORM_GBUFFER_POSITIONMAP_BINDING: nh,
                    UNIFORM_GBUFFER_NORMALMAP_BINDING: oh,
                    UNIFORM_LIGHTING_RESULTMAP_BINDING: ch,
                    UNIFORM_GBUFFER_EMISSIVEMAP_BINDING: hh,
                    UNIFORM_ENVIRONMENT_BINDING: dh,
                    UNIFORM_SPOT_LIGHTING_MAP_TEXTURE_BINDING: gh,
                    UBOLocal: Sh,
                    INST_MAT_WORLD: Eh,
                    UBOLocalBatched: Th,
                    UBOForwardLight: Ah,
                    UBODeferredLight: xh,
                    JOINT_UNIFORM_CAPACITY: 30,
                    UBOSkinningTexture: Ch,
                    UBOSkinningAnimation: bh,
                    INST_JOINT_ANIM_INFO: Rh,
                    UBOSkinning: wh,
                    UBOMorph: Ih,
                    UNIFORM_JOINT_TEXTURE_BINDING: Ph,
                    UNIFORM_POSITION_MORPH_TEXTURE_BINDING: Nh,
                    UNIFORM_NORMAL_MORPH_TEXTURE_BINDING: Bh,
                    UNIFORM_TANGENT_MORPH_TEXTURE_BINDING: Uh,
                    UNIFORM_LIGHTMAP_TEXTURE_BINDING: kh,
                    UNIFORM_SPRITE_TEXTURE_BINDING: jh,
                    CAMERA_DEFAULT_MASK: $h,
                    CAMERA_EDITOR_MASK: e_,
                    MODEL_ALWAYS_MASK: t_,
                    supportsHalfFloatTexture: n_
                })),
                function(e) {
                    e[e.VERTICAL = 0] = "VERTICAL", e[e.HORIZONTAL = 1] = "HORIZONTAL"
                }(Yh || (Yh = {})),
                function(e) {
                    e[e.ORTHO = 0] = "ORTHO", e[e.PERSPECTIVE = 1] = "PERSPECTIVE"
                }(Kh || (Kh = {})),
                function(e) {
                    e[e.F1_8 = 0] = "F1_8", e[e.F2_0 = 1] = "F2_0", e[e.F2_2 = 2] = "F2_2", e[e.F2_5 = 3] = "F2_5", e[e.F2_8 = 4] = "F2_8", e[e.F3_2 = 5] = "F3_2", e[e.F3_5 = 6] = "F3_5", e[e.F4_0 = 7] = "F4_0", e[e.F4_5 = 8] = "F4_5", e[e.F5_0 = 9] = "F5_0", e[e.F5_6 = 10] = "F5_6", e[e.F6_3 = 11] = "F6_3", e[e.F7_1 = 12] = "F7_1", e[e.F8_0 = 13] = "F8_0", e[e.F9_0 = 14] = "F9_0", e[e.F10_0 = 15] = "F10_0", e[e.F11_0 = 16] = "F11_0", e[e.F13_0 = 17] = "F13_0", e[e.F14_0 = 18] = "F14_0", e[e.F16_0 = 19] = "F16_0", e[e.F18_0 = 20] = "F18_0", e[e.F20_0 = 21] = "F20_0", e[e.F22_0 = 22] = "F22_0"
                }(Zh || (Zh = {})),
                function(e) {
                    e[e.ISO100 = 0] = "ISO100", e[e.ISO200 = 1] = "ISO200", e[e.ISO400 = 2] = "ISO400", e[e.ISO800 = 3] = "ISO800"
                }(Qh || (Qh = {})),
                function(e) {
                    e[e.D1 = 0] = "D1", e[e.D2 = 1] = "D2", e[e.D4 = 2] = "D4", e[e.D8 = 3] = "D8", e[e.D15 = 4] = "D15", e[e.D30 = 5] = "D30", e[e.D60 = 6] = "D60", e[e.D125 = 7] = "D125", e[e.D250 = 8] = "D250", e[e.D500 = 9] = "D500", e[e.D1000 = 10] = "D1000", e[e.D2000 = 11] = "D2000", e[e.D4000 = 12] = "D4000"
                }(Jh || (Jh = {}));
            var i_, r_, o_ = [1.8, 2, 2.2, 2.5, 2.8, 3.2, 3.5, 4, 4.5, 5, 5.6, 6.3, 7.1, 8, 9, 10, 11, 13, 14, 16, 18, 20, 22],
                a_ = [1, .5, 1 / 4, 1 / 8, 1 / 15, 1 / 30, 1 / 60, .008, .004, .002, .001, 5e-4, 1 / 4e3],
                s_ = [100, 200, 400, 800],
                c_ = new En,
                l_ = new En,
                u_ = new Bn,
                h_ = $a.STENCIL << 1,
                __ = [],
                f_ = function() {
                    function e(e) {
                        if (this.isWindowSize = !0, this.screenScale = void 0, this._device = void 0, this._scene = null, this._node = null, this._name = null, this._enabled = !1, this._proj = -1, this._aspect = void 0, this._orthoHeight = 10, this._fovAxis = Yh.VERTICAL, this._fov = rn(45), this._nearClip = 1, this._farClip = 1e3, this._clearColor = new ps(.2, .2, .2, 1), this._viewport = new Kn(0, 0, 1, 1), this._curTransform = ya.IDENTITY, this._isProjDirty = !0, this._matView = new Bn, this._matViewInv = null, this._matProj = new Bn, this._matProjInv = new Bn, this._matViewProj = new Bn, this._matViewProjInv = new Bn, this._frustum = new hu, this._forward = new En, this._position = new En, this._priority = 0, this._aperture = Zh.F16_0, this._apertureValue = void 0, this._shutter = Jh.D125, this._shutterValue = 0, this._iso = Qh.ISO100, this._isoValue = 0, this._ec = 0, this._poolHandle = 0, this._frustumHandle = 0, this._window = null, this._device = e, this._apertureValue = o_[this._aperture], this._shutterValue = a_[this._shutter], this._isoValue = s_[this._iso], this._aspect = this.screenScale = 1, !__.length) {
                            var t = e.capabilities.clipSpaceSignY;
                            __[ya.IDENTITY] = new Bn(1, 0, 0, 0, 0, t), __[ya.ROTATE_90] = new Bn(0, 1, 0, 0, -t, 0), __[ya.ROTATE_180] = new Bn(-1, 0, 0, 0, 0, -t), __[ya.ROTATE_270] = new Bn(0, -1, 0, 0, t, 0)
                        }
                    }
                    var t = e.prototype;
                    return t.initialize = function(e) {
                        this._name = e.name, this._node = e.node, this._proj = e.projection, this._priority = e.priority || 0, this._aspect = this.screenScale = 1;
                        var t = this._poolHandle = Jr.alloc();
                        Jr.set(t, Xr.WIDTH, 1), Jr.set(t, Xr.HEIGHT, 1), Jr.set(t, Xr.CLEAR_FLAGS, $a.NONE), Jr.set(t, Xr.CLEAR_DEPTH, 1), Jr.set(t, Xr.NODE, this._node.handle), Jr.set(t, Xr.VISIBILITY, $h), this._scene && Jr.set(t, Xr.SCENE, this._scene.handle), this.updateExposure(), this.changeTargetWindow(e.window), console.log("Created Camera: " + this._name + " " + Jr.get(t, Xr.WIDTH) + "x" + Jr.get(t, Xr.HEIGHT))
                    }, t.destroy = function() {
                        this._window && this._window.detachCamera(this), this._name = null, this._poolHandle && (Jr.free(this._poolHandle), this._poolHandle = 0, this._frustumHandle && (uo.free(this._frustumHandle), this._frustumHandle = 0))
                    }, t.attachToScene = function(e) {
                        this._scene = e, this._enabled = !0, Jr.set(this._poolHandle, Xr.SCENE, e.handle)
                    }, t.detachFromScene = function() {
                        this._scene = null, this._enabled = !1, Jr.set(this._poolHandle, Xr.SCENE, 0)
                    }, t.resize = function(e, t) {
                        var n = this._poolHandle;
                        Jr.set(n, Xr.WIDTH, e), Jr.set(n, Xr.HEIGHT, t), this._aspect = e * this._viewport.width / (t * this._viewport.height), this._isProjDirty = !0
                    }, t.setFixedSize = function(e, t) {
                        var n = this._poolHandle;
                        Jr.set(n, Xr.WIDTH, e), Jr.set(n, Xr.HEIGHT, t), this._aspect = e * this._viewport.width / (t * this._viewport.height), this.isWindowSize = !1
                    }, t.update = function(e) {
                        if (void 0 === e && (e = !1), this._node) {
                            var t = !1;
                            (this._node.hasChangedFlags || e) && (Bn.invert(this._matView, this._node.worldMatrix), Jr.setMat4(this._poolHandle, Xr.MAT_VIEW, this._matView), this._forward.x = -this._matView.m02, this._forward.y = -this._matView.m06, this._forward.z = -this._matView.m10, this._node.getWorldPosition(this._position), Jr.setVec3(this._poolHandle, Xr.POSITION, this._position), Jr.setVec3(this._poolHandle, Xr.FORWARD, this._forward), t = !0);
                            var n = this._device.surfaceTransform;
                            if (this._isProjDirty || this._curTransform !== n) {
                                var i;
                                this._curTransform = n;
                                var r = this._device.capabilities.clipSpaceSignY;
                                if ((null === (i = this.window) || void 0 === i ? void 0 : i.hasOffScreenAttachments) && (n = ya.IDENTITY), this._proj === Kh.PERSPECTIVE) Bn.perspective(this._matProj, this._fov, this._aspect, this._nearClip, this._farClip, this._fovAxis === Yh.VERTICAL, this._device.capabilities.clipSpaceMinZ, r, n);
                                else {
                                    var o = this._orthoHeight * this._aspect,
                                        a = this._orthoHeight;
                                    Bn.ortho(this._matProj, -o, o, -a, a, this._nearClip, this._farClip, this._device.capabilities.clipSpaceMinZ, r, n)
                                }
                                Bn.invert(this._matProjInv, this._matProj), Jr.setMat4(this._poolHandle, Xr.MAT_PROJ, this._matProj), Jr.setMat4(this._poolHandle, Xr.MAT_PROJ_INV, this._matProjInv), t = !0, this._isProjDirty = !1
                            }
                            t && (Bn.multiply(this._matViewProj, this._matProj, this._matView), Bn.invert(this._matViewProjInv, this._matViewProj), this._frustum.update(this._matViewProj, this._matViewProjInv), Jr.setMat4(this._poolHandle, Xr.MAT_VIEW_PROJ, this._matViewProj), Jr.setMat4(this._poolHandle, Xr.MAT_VIEW_PROJ_INV, this._matViewProjInv), _u(this._frustumHandle, this._frustum))
                        }
                    }, t.changeTargetWindow = function(e) {
                        void 0 === e && (e = null), this._window && this._window.detachCamera(this);
                        var t = e || i.director.root.mainWindow;
                        t && (t.attachCamera(this), this.resize(t.width, t.height), this._window = t, Jr.set(this._poolHandle, Xr.WINDOW, t.handle))
                    }, t.detachCamera = function() {
                        this._window && this._window.detachCamera(this)
                    }, t.screenPointToRay = function(e, t, n) {
                        if (!this._node) return null;
                        var i = this._poolHandle,
                            r = Jr.get(i, Xr.WIDTH),
                            o = Jr.get(i, Xr.HEIGHT),
                            a = this._viewport.x * r,
                            s = this._viewport.y * o,
                            c = this._viewport.width * r,
                            l = this._viewport.height * o,
                            u = this._proj === Kh.PERSPECTIVE,
                            h = this._device.capabilities.clipSpaceSignY,
                            _ = Ln[this._curTransform];
                        En.set(c_, (t - a) / c * 2 - 1, (n - s) / l * 2 - 1, u ? 1 : -1);
                        var f = c_.x,
                            d = c_.y;
                        return c_.x = f * _[0] + d * _[2] * h, c_.y = f * _[1] + d * _[3] * h, En.transformMat4(u ? c_ : e.o, c_, this._matViewProjInv), u ? (this._node.getWorldPosition(l_), ua.fromPoints(e, l_, c_)) : En.transformQuat(e.d, En.FORWARD, this._node.worldRotation), e
                    }, t.screenToWorld = function(e, t) {
                        var n = this._poolHandle,
                            i = Jr.get(n, Xr.WIDTH),
                            r = Jr.get(n, Xr.HEIGHT),
                            o = this._viewport.x * i,
                            a = this._viewport.y * r,
                            s = this._viewport.width * i,
                            c = this._viewport.height * r,
                            l = this._device.capabilities.clipSpaceSignY,
                            u = Ln[this._curTransform];
                        if (this._proj === Kh.PERSPECTIVE) {
                            En.set(e, (t.x - o) / s * 2 - 1, (t.y - a) / c * 2 - 1, 1);
                            var h = e.x,
                                _ = e.y;
                            e.x = h * u[0] + _ * u[2] * l, e.y = h * u[1] + _ * u[3] * l, En.transformMat4(e, e, this._matViewProjInv), this._node && this._node.getWorldPosition(c_), En.lerp(e, c_, e, nn(this._nearClip / this._farClip, 1, t.z))
                        } else {
                            En.set(e, (t.x - o) / s * 2 - 1, (t.y - a) / c * 2 - 1, 2 * t.z - 1);
                            var f = e.x,
                                d = e.y;
                            e.x = f * u[0] + d * u[2] * l, e.y = f * u[1] + d * u[3] * l, En.transformMat4(e, e, this._matViewProjInv)
                        }
                        return e
                    }, t.worldToScreen = function(e, t) {
                        var n = this._poolHandle,
                            i = Jr.get(n, Xr.WIDTH),
                            r = Jr.get(n, Xr.HEIGHT),
                            o = this._viewport.x * i,
                            a = this._viewport.y * r,
                            s = this._viewport.width * i,
                            c = this._viewport.height * r,
                            l = this._device.capabilities.clipSpaceSignY,
                            u = Ln[this._curTransform];
                        En.transformMat4(e, t, this._matViewProj);
                        var h = e.x,
                            _ = e.y;
                        return e.x = h * u[0] + _ * u[2] * l, e.y = h * u[1] + _ * u[3] * l, e.x = o + .5 * (e.x + 1) * s, e.y = a + .5 * (e.y + 1) * c, e.z = .5 * e.z + .5, e
                    }, t.worldMatrixToScreen = function(e, t, n, i) {
                        Bn.multiply(e, this._matViewProj, t), Bn.multiply(e, __[this._curTransform], e);
                        var r = n / 2,
                            o = i / 2;
                        return Bn.identity(u_), Bn.transform(u_, u_, En.set(c_, r, o, 0)), Bn.scale(u_, u_, En.set(c_, r, o, 1)), Bn.multiply(e, u_, e), e
                    }, t.updateExposure = function() {
                        var e = Math.log2(this._apertureValue * this._apertureValue / this._shutterValue * 100 / this._isoValue);
                        Jr.set(this._poolHandle, Xr.EXPOSURE, .833333 / Math.pow(2, e))
                    }, K(e, [{
                        key: "node",
                        get: function() {
                            return this._node
                        },
                        set: function(e) {
                            this._node = e
                        }
                    }, {
                        key: "enabled",
                        get: function() {
                            return this._enabled
                        },
                        set: function(e) {
                            this._enabled = e
                        }
                    }, {
                        key: "orthoHeight",
                        get: function() {
                            return this._orthoHeight
                        },
                        set: function(e) {
                            this._orthoHeight = e, this._isProjDirty = !0
                        }
                    }, {
                        key: "projectionType",
                        get: function() {
                            return this._proj
                        },
                        set: function(e) {
                            this._proj = e, this._isProjDirty = !0
                        }
                    }, {
                        key: "fovAxis",
                        get: function() {
                            return this._fovAxis
                        },
                        set: function(e) {
                            this._fovAxis = e, this._isProjDirty = !0
                        }
                    }, {
                        key: "fov",
                        get: function() {
                            return this._fov
                        },
                        set: function(e) {
                            this._fov = e, this._isProjDirty = !0
                        }
                    }, {
                        key: "nearClip",
                        get: function() {
                            return this._nearClip
                        },
                        set: function(e) {
                            this._nearClip = e, this._isProjDirty = !0
                        }
                    }, {
                        key: "farClip",
                        get: function() {
                            return this._farClip
                        },
                        set: function(e) {
                            this._farClip = e, this._isProjDirty = !0
                        }
                    }, {
                        key: "clearColor",
                        get: function() {
                            return this._clearColor
                        },
                        set: function(e) {
                            this._clearColor.x = e.x, this._clearColor.y = e.y, this._clearColor.z = e.z, this._clearColor.w = e.w, Jr.setVec4(this._poolHandle, Xr.CLEAR_COLOR, e)
                        }
                    }, {
                        key: "viewport",
                        get: function() {
                            return this._viewport
                        },
                        set: function(e) {
                            var t = e.x,
                                n = e.width,
                                i = e.height,
                                r = this._device.capabilities.clipSpaceSignY < 0 ? 1 - e.y - i : e.y;
                            switch (this._device.surfaceTransform) {
                                case ya.ROTATE_90:
                                    this._viewport.x = 1 - r - i, this._viewport.y = t, this._viewport.width = i, this._viewport.height = n;
                                    break;
                                case ya.ROTATE_180:
                                    this._viewport.x = 1 - t - n, this._viewport.y = 1 - r - i, this._viewport.width = n, this._viewport.height = i;
                                    break;
                                case ya.ROTATE_270:
                                    this._viewport.x = r, this._viewport.y = 1 - t - n, this._viewport.width = i, this._viewport.height = n;
                                    break;
                                case ya.IDENTITY:
                                    this._viewport.x = t, this._viewport.y = r, this._viewport.width = n, this._viewport.height = i
                            }
                            Jr.setVec4(this._poolHandle, Xr.VIEW_PORT, this._viewport), this.resize(this.width, this.height)
                        }
                    }, {
                        key: "scene",
                        get: function() {
                            return this._scene
                        }
                    }, {
                        key: "name",
                        get: function() {
                            return this._name
                        }
                    }, {
                        key: "width",
                        get: function() {
                            return Jr.get(this._poolHandle, Xr.WIDTH)
                        }
                    }, {
                        key: "height",
                        get: function() {
                            return Jr.get(this._poolHandle, Xr.HEIGHT)
                        }
                    }, {
                        key: "aspect",
                        get: function() {
                            return this._aspect
                        }
                    }, {
                        key: "matView",
                        get: function() {
                            return this._matView
                        },
                        set: function(e) {
                            this._matView = e, Jr.setMat4(this._poolHandle, Xr.MAT_VIEW, this._matView)
                        }
                    }, {
                        key: "matViewInv",
                        get: function() {
                            return this._matViewInv || this._node.worldMatrix
                        },
                        set: function(e) {
                            this._matViewInv = e
                        }
                    }, {
                        key: "matProj",
                        get: function() {
                            return this._matProj
                        },
                        set: function(e) {
                            this._matProj = e, Jr.setMat4(this._poolHandle, Xr.MAT_PROJ, this._matProj)
                        }
                    }, {
                        key: "matProjInv",
                        get: function() {
                            return this._matProjInv
                        },
                        set: function(e) {
                            this._matProjInv = e, Jr.setMat4(this._poolHandle, Xr.MAT_PROJ_INV, this._matProjInv)
                        }
                    }, {
                        key: "matViewProj",
                        get: function() {
                            return this._matViewProj
                        },
                        set: function(e) {
                            this._matViewProj = e, Jr.setMat4(this._poolHandle, Xr.MAT_VIEW_PROJ, this._matViewProj)
                        }
                    }, {
                        key: "matViewProjInv",
                        get: function() {
                            return this._matViewProjInv
                        },
                        set: function(e) {
                            this._matViewProjInv = e, Jr.setMat4(this._poolHandle, Xr.MAT_VIEW_PROJ_INV, this._matViewProjInv)
                        }
                    }, {
                        key: "frustum",
                        get: function() {
                            return this._frustum
                        },
                        set: function(e) {
                            this._frustum = e, _u(this._frustumHandle, e)
                        }
                    }, {
                        key: "window",
                        get: function() {
                            return this._window
                        },
                        set: function(e) {
                            this._window = e, e && Jr.set(this._poolHandle, Xr.WINDOW, e.handle)
                        }
                    }, {
                        key: "forward",
                        get: function() {
                            return this._forward
                        },
                        set: function(e) {
                            this._forward = e, Jr.setVec3(this._poolHandle, Xr.FORWARD, this._forward)
                        }
                    }, {
                        key: "position",
                        get: function() {
                            return this._position
                        },
                        set: function(e) {
                            this._position = e, Jr.setVec3(this._poolHandle, Xr.POSITION, this._position)
                        }
                    }, {
                        key: "visibility",
                        get: function() {
                            return Jr.get(this._poolHandle, Xr.VISIBILITY)
                        },
                        set: function(e) {
                            Jr.set(this._poolHandle, Xr.VISIBILITY, e)
                        }
                    }, {
                        key: "priority",
                        get: function() {
                            return this._priority
                        },
                        set: function(e) {
                            this._priority = e
                        }
                    }, {
                        key: "aperture",
                        get: function() {
                            return this._aperture
                        },
                        set: function(e) {
                            this._aperture = e, this._apertureValue = o_[this._aperture], this.updateExposure()
                        }
                    }, {
                        key: "apertureValue",
                        get: function() {
                            return this._apertureValue
                        }
                    }, {
                        key: "shutter",
                        get: function() {
                            return this._shutter
                        },
                        set: function(e) {
                            this._shutter = e, this._shutterValue = a_[this._shutter], this.updateExposure()
                        }
                    }, {
                        key: "shutterValue",
                        get: function() {
                            return this._shutterValue
                        }
                    }, {
                        key: "iso",
                        get: function() {
                            return this._iso
                        },
                        set: function(e) {
                            this._iso = e, this._isoValue = s_[this._iso], this.updateExposure()
                        }
                    }, {
                        key: "isoValue",
                        get: function() {
                            return this._isoValue
                        }
                    }, {
                        key: "ec",
                        get: function() {
                            return this._ec
                        },
                        set: function(e) {
                            this._ec = e
                        }
                    }, {
                        key: "exposure",
                        get: function() {
                            return Jr.get(this._poolHandle, Xr.EXPOSURE)
                        }
                    }, {
                        key: "clearFlag",
                        get: function() {
                            return Jr.get(this._poolHandle, Xr.CLEAR_FLAGS)
                        },
                        set: function(e) {
                            Jr.set(this._poolHandle, Xr.CLEAR_FLAGS, e)
                        }
                    }, {
                        key: "clearDepth",
                        get: function() {
                            return Jr.get(this._poolHandle, Xr.CLEAR_DEPTH)
                        },
                        set: function(e) {
                            Jr.set(this._poolHandle, Xr.CLEAR_DEPTH, e)
                        }
                    }, {
                        key: "clearStencil",
                        get: function() {
                            return Jr.get(this._poolHandle, Xr.CLEAR_STENCIL)
                        },
                        set: function(e) {
                            Jr.set(this._poolHandle, Xr.CLEAR_STENCIL, e)
                        }
                    }, {
                        key: "handle",
                        get: function() {
                            return this._poolHandle
                        }
                    }]), e
                }();
            ! function(e) {
                e[e.LOCAL = 0] = "LOCAL", e[e.WORLD = 1] = "WORLD"
            }(i_ || (i_ = {})),
            function(e) {
                e[e.NONE = 0] = "NONE", e[e.POSITION = 1] = "POSITION", e[e.ROTATION = 2] = "ROTATION", e[e.SCALE = 4] = "SCALE", e[e.RS = e.ROTATION | e.SCALE] = "RS", e[e.TRS = e.POSITION | e.ROTATION | e.SCALE] = "TRS", e[e.TRS_MASK = ~e.TRS] = "TRS_MASK"
            }(r_ || (r_ = {})), i.internal.TransformBit = r_;
            var d_ = function() {
                    function e(e) {
                        this._root = void 0, this._name = "", this._cameras = [], this._models = [], this._batches = [], this._directionalLights = [], this._sphereLights = [], this._spotLights = [], this._mainLight = null, this._modelId = 0, this._scenePoolHandle = 0, this._modelArrayHandle = 0, this._batchArrayHandle = 0, this._sphereLightsHandle = 0, this._spotLightsHandle = 0, this._root = e, this._createHandles()
                    }
                    e.registerCreateFunc = function(t) {
                        t._createSceneFun = function(t) {
                            return new e(t)
                        }
                    };
                    var t = e.prototype;
                    return t.initialize = function(e) {
                        return this._name = e.name, this._createHandles(), !0
                    }, t.update = function(e) {
                        var t = this._mainLight;
                        t && t.update();
                        for (var n = this._sphereLights, i = 0; i < n.length; i++) n[i].update();
                        for (var r = this._spotLights, o = 0; o < r.length; o++) r[o].update();
                        for (var a = this._models, s = 0; s < a.length; s++) {
                            var c = a[s];
                            c.enabled && (c.updateTransform(e), c.updateUBOs(e))
                        }
                    }, t.destroy = function() {
                        this.removeCameras(), this.removeSphereLights(), this.removeSpotLights(), this.removeModels(), this._modelArrayHandle && (xr.free(this._modelArrayHandle), this._modelArrayHandle = 0), this._scenePoolHandle && (Kr.free(this._scenePoolHandle), this._scenePoolHandle = 0), this._sphereLightsHandle && (Rr.free(this._sphereLightsHandle), this._sphereLightsHandle = 0), this._spotLightsHandle && (Rr.free(this._spotLightsHandle), this._spotLightsHandle = 0), this._batchArrayHandle && (Ir.free(this._batchArrayHandle), this._batchArrayHandle = 0)
                    }, t.addCamera = function(e) {
                        e.attachToScene(this), this._cameras.push(e)
                    }, t.removeCamera = function(e) {
                        for (var t = 0; t < this._cameras.length; ++t)
                            if (this._cameras[t] === e) return this._cameras.splice(t, 1), void e.detachFromScene()
                    }, t.removeCameras = function() {
                        for (var e, t = te(this._cameras); !(e = t()).done;) e.value.detachFromScene();
                        this._cameras.splice(0)
                    }, t.setMainLight = function(e) {
                        this._mainLight = e, Kr.set(this._scenePoolHandle, Wr.MAIN_LIGHT, e.handle)
                    }, t.unsetMainLight = function(e) {
                        if (this._mainLight === e) {
                            var t = this._directionalLights;
                            t.length ? (this._mainLight = t[t.length - 1], this._mainLight.node && (this._mainLight.node.hasChangedFlags |= r_.ROTATION)) : this._mainLight = null
                        }
                    }, t.addDirectionalLight = function(e) {
                        e.attachToScene(this), this._directionalLights.push(e)
                    }, t.removeDirectionalLight = function(e) {
                        for (var t = 0; t < this._directionalLights.length; ++t)
                            if (this._directionalLights[t] === e) return e.detachFromScene(), void this._directionalLights.splice(t, 1)
                    }, t.addSphereLight = function(e) {
                        e.attachToScene(this), this._sphereLights.push(e), Rr.push(this._sphereLightsHandle, e.handle)
                    }, t.removeSphereLight = function(e) {
                        for (var t = 0; t < this._sphereLights.length; ++t)
                            if (this._sphereLights[t] === e) return e.detachFromScene(), this._sphereLights.splice(t, 1), void Rr.erase(this._sphereLightsHandle, t)
                    }, t.addSpotLight = function(e) {
                        e.attachToScene(this), this._spotLights.push(e), Rr.push(this._spotLightsHandle, e.handle)
                    }, t.removeSpotLight = function(e) {
                        for (var t = 0; t < this._spotLights.length; ++t)
                            if (this._spotLights[t] === e) return e.detachFromScene(), this._spotLights.splice(t, 1), void Rr.erase(this._spotLightsHandle, t)
                    }, t.removeSphereLights = function() {
                        for (var e = 0; e < this._sphereLights.length; ++e) this._sphereLights[e].detachFromScene();
                        this._sphereLights.length = 0, Rr.clear(this._sphereLightsHandle)
                    }, t.removeSpotLights = function() {
                        for (var e = 0; e < this._spotLights.length; ++e) this._spotLights[e].detachFromScene();
                        this._spotLights = [], Rr.clear(this._spotLightsHandle)
                    }, t.addModel = function(e) {
                        e.attachToScene(this), this._models.push(e), xr.push(this._modelArrayHandle, e.handle)
                    }, t.removeModel = function(e) {
                        for (var t = 0; t < this._models.length; ++t)
                            if (this._models[t] === e) return e.detachFromScene(), this._models.splice(t, 1), void xr.erase(this._modelArrayHandle, t)
                    }, t.removeModels = function() {
                        for (var e, t = te(this._models); !(e = t()).done;) {
                            var n = e.value;
                            n.detachFromScene(), n.destroy()
                        }
                        this._models.length = 0, xr.clear(this._modelArrayHandle)
                    }, t.addBatch = function(e) {
                        this._batches.push(e), Ir.push(this._batchArrayHandle, e.handle)
                    }, t.removeBatch = function(e) {
                        for (var t = 0; t < this._batches.length; ++t)
                            if (this._batches[t] === e) return this._batches.splice(t, 1), void Ir.erase(this._batchArrayHandle, t)
                    }, t.removeBatches = function() {
                        this._batches.length = 0, Ir.clear(this._batchArrayHandle)
                    }, t.onGlobalPipelineStateChanged = function() {
                        for (var e, t = te(this._models); !(e = t()).done;) e.value.onGlobalPipelineStateChanged()
                    }, t.generateModelId = function() {
                        return this._modelId++
                    }, t._createHandles = function() {
                        this._modelArrayHandle || (this._modelArrayHandle = xr.alloc(), this._scenePoolHandle = Kr.alloc(), Kr.set(this._scenePoolHandle, Wr.MODEL_ARRAY, this._modelArrayHandle), this._spotLightsHandle = Rr.alloc(), Kr.set(this._scenePoolHandle, Wr.SPOT_LIGHT_ARRAY, this._spotLightsHandle), this._sphereLightsHandle = Rr.alloc(), Kr.set(this._scenePoolHandle, Wr.SPHERE_LIGHT_ARRAY, this._sphereLightsHandle)), this._batchArrayHandle || (this._batchArrayHandle = Ir.alloc(), Kr.set(this._scenePoolHandle, Wr.BATCH_ARRAY_2D, this._batchArrayHandle))
                    }, K(e, [{
                        key: "root",
                        get: function() {
                            return this._root
                        }
                    }, {
                        key: "name",
                        get: function() {
                            return this._name
                        }
                    }, {
                        key: "cameras",
                        get: function() {
                            return this._cameras
                        }
                    }, {
                        key: "mainLight",
                        get: function() {
                            return this._mainLight
                        }
                    }, {
                        key: "sphereLights",
                        get: function() {
                            return this._sphereLights
                        }
                    }, {
                        key: "spotLights",
                        get: function() {
                            return this._spotLights
                        }
                    }, {
                        key: "models",
                        get: function() {
                            return this._models
                        }
                    }, {
                        key: "handle",
                        get: function() {
                            return this._scenePoolHandle
                        }
                    }, {
                        key: "batches",
                        get: function() {
                            return this._batches
                        }
                    }]), e
                }(),
                p_ = function() {},
                m_ = function() {
                    return p_
                },
                g_ = v_((function() {}));

            function v_(e) {
                return function(t) {
                    return "function" == typeof t ? e(t) : function(n) {
                        return e(n, t)
                    }
                }
            }

            function y_(e) {
                return function(t) {
                    return function(n) {
                        ! function(e, t, n) {
                            var i = E_(e);
                            if (i) {
                                var r = T_(i, "proto");
                                T_(r, "editor")[t] = n
                            }
                        }(n, e, t)
                    }
                }
            }
            var S_ = "__ccclassCache__";

            function E_(e) {
                return T_(e, S_)
            }

            function T_(e, t) {
                return e[t] || (e[t] = {})
            }
            var A_ = v_((function(e, t) {
                    var n = Qe.getSuper(e);
                    n === Object && (n = null);
                    var i = {
                            name: t,
                            extends: n,
                            ctor: e
                        },
                        r = e[S_];
                    if (r) {
                        var o = r.proto;
                        o && Qe.mixin(i, o), e[S_] = void 0
                    }
                    return qt(i)
                })),
                x_ = y_("requireComponent"),
                C_ = y_("executionOrder"),
                b_ = g_;

            function R_(e, t, n) {
                var i = null;

                function r(e, t, n) {
                    var r = E_(e.constructor);
                    if (r) {
                        var o = T_(r, "proto"),
                            a = T_(o, "properties");
                        ! function(e, t, n, i, r, o) {
                            var a, s = r && (r.get || r.set);
                            i && (a = Bt(i, s));
                            var c = t[n],
                                l = Qe.mixin(c || {}, a || i || {});
                            if (s) r.get && (l.get = r.get), r.set && (l.set = r.set);
                            else if (r) r.initializer && (l.default = function(e) {
                                var t;
                                try {
                                    t = e()
                                } catch (t) {
                                    return e
                                }
                                return "object" != typeof t || null === t ? t : e
                            }(r.initializer));
                            else {
                                var u = o.default || (o.default = function(e) {
                                    var t;
                                    try {
                                        t = new e
                                    } catch (e) {
                                        return {}
                                    }
                                    return t
                                }(e));
                                u.hasOwnProperty(n) && (l.default = u[n])
                            }
                            t[n] = l
                        }(e.constructor, a, t, i, n, r)
                    }
                }
                return void 0 === e ? R_({
                    type: void 0
                }) : void 0 === t ? (i = e, r) : void r(e, t, n)
            }
            var w_ = function(e, t, n) {
                    return R_(P_({}))(e, t, n)
                },
                I_ = function(e, t, n) {
                    return R_({
                        editorOnly: !0
                    })(e, t, n)
                };

            function P_(e) {
                return e.__noImplicit = !0, "serializable" in e || (e.serializable = !0), e
            }
            var O_ = g_,
                D_ = m_,
                N_ = g_,
                M_ = m_,
                L_ = m_,
                B_ = m_,
                F_ = p_,
                z_ = m_,
                U_ = m_,
                G_ = m_,
                H_ = m_,
                k_ = m_,
                V_ = m_,
                W_ = m_,
                j_ = p_,
                q_ = m_,
                X_ = m_,
                Y_ = p_,
                K_ = p_,
                Z_ = ef(bt),
                Q_ = ef(Rt),
                J_ = ef(wt),
                $_ = ef(It);

            function ef(e) {
                return R_({
                    type: e
                })
            }
            var tf = function(e, t, n) {
                    return R_({
                        __noImplicit: !0,
                        override: !0
                    })(e, t, n)
                },
                nf = function() {
                    function e(e) {
                        this._map = null, this._count = 0, e ? (this._map = e, this._count = Object.keys(e).length) : (this._map = Qe.createMap(!0), this._count = 0)
                    }
                    var t = e.prototype;
                    return t.add = function(e, t) {
                        return e in this._map || this._count++, this._map[e] = t
                    }, t.get = function(e) {
                        return this._map[e]
                    }, t.has = function(e) {
                        return e in this._map
                    }, t.remove = function(e) {
                        var t = this._map[e];
                        return e in this._map && (delete this._map[e], this._count--), t
                    }, t.clear = function() {
                        0 !== this._count && (this._map = Qe.createMap(!0), this._count = 0)
                    }, t.forEach = function(e) {
                        for (var t in this._map) e(this._map[t], t)
                    }, t.find = function(e) {
                        for (var t in this._map)
                            if (e(this._map[t], t)) return this._map[t];
                        return null
                    }, t.destroy = function() {
                        this._map = null
                    }, K(e, [{
                        key: "count",
                        get: function() {
                            return this._count
                        }
                    }]), e
                }(),
                rf = function() {
                    function e(t, n) {
                        this.id = e._pipelineId++, this.name = "", this.pipes = [], this.name = t;
                        for (var i = 0, r = n.length; i < r; i++) this.pipes.push(n[i])
                    }
                    var t = e.prototype;
                    return t.insert = function(e, t) {
                        return t > this.pipes.length ? (x(4921), this) : (this.pipes.splice(t, 0, e), this)
                    }, t.append = function(e) {
                        return this.pipes.push(e), this
                    }, t.remove = function(e) {
                        return this.pipes.splice(e, 1), this
                    }, t.sync = function(e) {
                        var t = this.pipes;
                        if (0 === t.length) return null;
                        e.isFinish = !1;
                        for (var n = 0, i = t.length; n < i;) {
                            var r = (0, t[n])(e);
                            if (r) return e.isFinish = !0, r;
                            ++n !== i && (e.input = e.output, e.output = null)
                        }
                        return e.isFinish = !0, e.output
                    }, t.async = function(e) {
                        0 !== this.pipes.length && (e.isFinish = !1, this._flow(0, e))
                    }, t._flow = function(e, t) {
                        var n = this;
                        (0, this.pipes[e])(t, (function(i) {
                            i ? (t.isFinish = !0, t.dispatch("complete", i)) : ++e < n.pipes.length ? (t.input = t.output, t.output = null, n._flow(e, t)) : (t.isFinish = !0, t.dispatch("complete", i, t.output))
                        }))
                    }, e
                }();
            rf._pipelineId = 0;
            var of , af = new nf, sf = new nf, cf = new nf, lf = new nf, uf = new rf("normal load", []), hf = new rf("fetch", []), _f = new rf("transform url", []);
            ! function(e) {
                e.UUID = "uuid", e.PATH = "path", e.DIR = "dir", e.URL = "url", e.SCENE = "scene"
            }( of || ( of = {}));
            var ff, df = {
                default: {
                    priority: 0
                },
                preload: {
                    maxConcurrency: 6,
                    maxRequestsPerFrame: 2,
                    priority: -1
                },
                scene: {
                    maxConcurrency: 20,
                    maxRequestsPerFrame: 20,
                    priority: 1
                },
                bundle: {
                    maxConcurrency: 20,
                    maxRequestsPerFrame: 20,
                    priority: 2
                },
                remote: {
                    maxRetryCount: 4
                }
            };
            ! function(e) {
                e.RESOURCES = "resources", e.MAIN = "main", e.START_SCENE = "start-scene"
            }(ff || (ff = {}));
            var pf = function() {
                function e(t) {
                    this.id = e._taskId++, this.onComplete = null, this.onProgress = null, this.onError = null, this.source = null, this.output = null, this.input = null, this.progress = null, this.options = null, this.isFinish = !0, this.set(t)
                }
                e.create = function(t) {
                    var n;
                    return 0 !== e._deadPool.length ? (n = e._deadPool.pop()).set(t) : n = new e(t), n
                };
                var t = e.prototype;
                return t.set = function(e) {
                    void 0 === e && (e = Object.create(null)), this.onComplete = e.onComplete || null, this.onProgress = e.onProgress || null, this.onError = e.onError || null, this.source = this.input = e.input, this.output = null, this.progress = e.progress, this.options = e.options || Object.create(null)
                }, t.dispatch = function(e, t, n, i, r) {
                    switch (e) {
                        case "complete":
                            this.onComplete && this.onComplete(t, n);
                            break;
                        case "progress":
                            this.onProgress && this.onProgress(t, n, i, r);
                            break;
                        case "error":
                            this.onError && this.onError(t, n, i, r);
                            break;
                        default:
                            var o = "on" + e[0].toUpperCase() + e.substr(1);
                            "function" == typeof this[o] && this[o](t, n, i, r)
                    }
                }, t.recycle = function() {
                    e._deadPool.length !== e.MAX_DEAD_NUM && (this.onComplete = null, this.onProgress = null, this.onError = null, this.source = this.output = this.input = null, this.progress = null, this.options = null, e._deadPool.push(this))
                }, e
            }();
            pf.MAX_DEAD_NUM = 500, pf._taskId = 0, pf._deadPool = [];
            var mf = "0123456789abcdef".split(""),
                gf = ["", "", "", ""],
                vf = gf.concat(gf, "-", gf, "-", gf, "-", gf, "-", gf, gf, gf),
                yf = vf.map((function(e, t) {
                    return "-" === e ? NaN : t
                })).filter(isFinite);

            function Sf(e) {
                var t = e.split("@")[0];
                if (22 !== t.length) return e;
                vf[0] = e[0], vf[1] = e[1];
                for (var n = 2, i = 2; n < 22; n += 2) {
                    var r = lt[e.charCodeAt(n)],
                        o = lt[e.charCodeAt(n + 1)];
                    vf[yf[i++]] = mf[r >> 2], vf[yf[i++]] = mf[(3 & r) << 2 | o >> 4], vf[yf[i++]] = mf[15 & o]
                }
                return e.replace(t, vf.join(""))
            }
            var Ef = /.*[/\\][0-9a-fA-F]{2}[/\\]([0-9a-fA-F-@]{8,}).*/;

            function Tf(e) {
                var t = Ef.exec(e);
                return t ? t[1] : ""
            }

            function Af(e, t) {
                (t = t || Object.create(null)).__isNative__ = t.isNative, t.ext = t.nativeExt;
                var n = lf.find((function(t) {
                    return !!t.getAssetInfo(e)
                }));
                return n && (t.bundle = n.name), bf(e, t)
            }

            function xf(e) {
                return e && (e instanceof i.SceneAsset || e instanceof i.Scene)
            }

            function Cf(e) {
                return e && (46 === e.charCodeAt(0) && 47 === e.charCodeAt(1) ? e = e.slice(2) : 47 === e.charCodeAt(0) && (e = e.slice(1))), e
            }

            function bf(e, t) {
                var n = pf.create({
                        input: e,
                        options: t
                    }),
                    i = [];
                try {
                    for (var r, o = te(_f.sync(n)); !(r = o()).done;) {
                        var a = r.value,
                            s = a.url;
                        a.recycle(), i.push(s)
                    }
                } catch (e) {
                    for (var c, l = te(n.output); !(c = l()).done;) c.value.recycle();
                    p(e.message, e.stack)
                }
                return n.recycle(), i.length > 1 ? i : i[0]
            }
            var Rf, wf, If, Pf, Of = Object.freeze({
                    __proto__: null,
                    getUuidFromURL: Tf,
                    getUrlWithUuid: Af,
                    isScene: xf,
                    normalize: Cf,
                    transform: bf,
                    decodeUuid: Sf
                }),
                Df = e("Event", function() {
                    function e(e, t) {
                        this.type = void 0, this.bubbles = void 0, this.target = null, this.currentTarget = null, this.eventPhase = 0, this.propagationStopped = !1, this.propagationImmediateStopped = !1, this.type = e, this.bubbles = !!t
                    }
                    var t = e.prototype;
                    return t.unuse = function() {
                        this.type = e.NO_TYPE, this.target = null, this.currentTarget = null, this.eventPhase = e.NONE, this.propagationStopped = !1, this.propagationImmediateStopped = !1
                    }, t.reuse = function(e, t) {
                        this.type = e, this.bubbles = t || !1
                    }, t.isStopped = function() {
                        return this.propagationStopped || this.propagationImmediateStopped
                    }, t.getCurrentTarget = function() {
                        return this.currentTarget
                    }, t.getType = function() {
                        return this.type
                    }, e
                }());
            Df.NO_TYPE = "no_type", Df.TOUCH = "touch", Df.MOUSE = "mouse", Df.KEYBOARD = "keyboard", Df.ACCELERATION = "acceleration", Df.NONE = 0, Df.CAPTURING_PHASE = 1, Df.AT_TARGET = 2, Df.BUBBLING_PHASE = 3, i.Event = Df;
            var Nf = e("Asset", A_("cc.Asset")((Pf = function(e) {
                function t() {
                    for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                    return (t = e.call.apply(e, [this].concat(i)) || this).loaded = !0, ne(t, "_native", If, $(t)), t._nativeUrl = "", t.__onLoadedInvoked__ = !1, t.__nativeDepend__ = null, t.__depends__ = null, t._file = null, t._ref = 0, Object.defineProperty($(t), "_uuid", {
                        value: "",
                        writable: !0
                    }), t
                }
                Q(t, e), t.deserialize = function(e) {
                    return i.deserialize(e)
                };
                var n = t.prototype;
                return n.toString = function() {
                    return this.nativeUrl
                }, n.serialize = function() {}, n._setRawAsset = function(e, t) {
                    void 0 === t && (t = !0), this._native = !1 !== t ? e || "" : "/" + e
                }, n.addRef = function() {
                    return this._ref++, this
                }, n.decRef = function(e) {
                    return void 0 === e && (e = !0), this._ref > 0 && this._ref--, e && i.assetManager._releaseManager.tryRelease(this), this
                }, n.onLoaded = function() {}, n.initDefault = function(e) {
                    e && (this._uuid = e), this.isDefault = !0
                }, n.validate = function() {
                    return !0
                }, K(t, [{
                    key: "nativeUrl",
                    get: function() {
                        if (!this._nativeUrl) {
                            if (!this._native) return "";
                            var e = this._native;
                            if (47 === e.charCodeAt(0)) return e.slice(1);
                            46 === e.charCodeAt(0) ? this._nativeUrl = Af(this._uuid, {
                                nativeExt: e,
                                isNative: !0
                            }) : this._nativeUrl = Af(this._uuid, {
                                __nativeName__: e,
                                nativeExt: bi(e),
                                isNative: !0
                            })
                        }
                        return this._nativeUrl
                    }
                }, {
                    key: "_nativeAsset",
                    get: function() {
                        return this._file
                    },
                    set: function(e) {
                        this._file = e
                    }
                }, {
                    key: "_nativeDep",
                    get: function() {
                        if (this._native) return {
                            __isNative__: !0,
                            uuid: this._uuid,
                            ext: this._native
                        }
                    }
                }, {
                    key: "refCount",
                    get: function() {
                        return this._ref
                    }
                }]), t
            }(_i(ni)), If = ie((wf = Pf).prototype, "_native", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return ""
                }
            }), ie(wf.prototype, "_nativeAsset", [R_], Object.getOwnPropertyDescriptor(wf.prototype, "_nativeAsset"), wf.prototype), Rf = wf)) || Rf);
            Nf.prototype.createNode = null, i.Asset = Nf;
            var Mf, Lf, Bf, Ff, zf, Uf, Gf, Hf = 1024;

            function kf(e) {
                return i.sys.capabilities.imageBitmap && e instanceof ImageBitmap
            }! function(e) {
                e[e.RGB565 = Ea.R5G6B5] = "RGB565", e[e.RGB5A1 = Ea.RGB5A1] = "RGB5A1", e[e.RGBA4444 = Ea.RGBA4] = "RGBA4444", e[e.RGB888 = Ea.RGB8] = "RGB888", e[e.RGB32F = Ea.RGB32F] = "RGB32F", e[e.RGBA8888 = Ea.RGBA8] = "RGBA8888", e[e.RGBA32F = Ea.RGBA32F] = "RGBA32F", e[e.A8 = Ea.A8] = "A8", e[e.I8 = Ea.L8] = "I8", e[e.AI8 = Ea.LA8] = "AI8", e[e.RGB_PVRTC_2BPPV1 = Ea.PVRTC_RGB2] = "RGB_PVRTC_2BPPV1", e[e.RGBA_PVRTC_2BPPV1 = Ea.PVRTC_RGBA2] = "RGBA_PVRTC_2BPPV1", e[e.RGB_A_PVRTC_2BPPV1 = Hf++] = "RGB_A_PVRTC_2BPPV1", e[e.RGB_PVRTC_4BPPV1 = Ea.PVRTC_RGB4] = "RGB_PVRTC_4BPPV1", e[e.RGBA_PVRTC_4BPPV1 = Ea.PVRTC_RGBA4] = "RGBA_PVRTC_4BPPV1", e[e.RGB_A_PVRTC_4BPPV1 = Hf++] = "RGB_A_PVRTC_4BPPV1", e[e.RGB_ETC1 = Ea.ETC_RGB8] = "RGB_ETC1", e[e.RGBA_ETC1 = Hf++] = "RGBA_ETC1", e[e.RGB_ETC2 = Ea.ETC2_RGB8] = "RGB_ETC2", e[e.RGBA_ETC2 = Ea.ETC2_RGBA8] = "RGBA_ETC2", e[e.RGBA_ASTC_4x4 = Ea.ASTC_RGBA_4x4] = "RGBA_ASTC_4x4", e[e.RGBA_ASTC_5x4 = Ea.ASTC_RGBA_5x4] = "RGBA_ASTC_5x4", e[e.RGBA_ASTC_5x5 = Ea.ASTC_RGBA_5x5] = "RGBA_ASTC_5x5", e[e.RGBA_ASTC_6x5 = Ea.ASTC_RGBA_6x5] = "RGBA_ASTC_6x5", e[e.RGBA_ASTC_6x6 = Ea.ASTC_RGBA_6x6] = "RGBA_ASTC_6x6", e[e.RGBA_ASTC_8x5 = Ea.ASTC_RGBA_8x5] = "RGBA_ASTC_8x5", e[e.RGBA_ASTC_8x6 = Ea.ASTC_RGBA_8x6] = "RGBA_ASTC_8x6", e[e.RGBA_ASTC_8x8 = Ea.ASTC_RGBA_8x8] = "RGBA_ASTC_8x8", e[e.RGBA_ASTC_10x5 = Ea.ASTC_RGBA_10x5] = "RGBA_ASTC_10x5", e[e.RGBA_ASTC_10x6 = Ea.ASTC_RGBA_10x6] = "RGBA_ASTC_10x6", e[e.RGBA_ASTC_10x8 = Ea.ASTC_RGBA_10x8] = "RGBA_ASTC_10x8", e[e.RGBA_ASTC_10x10 = Ea.ASTC_RGBA_10x10] = "RGBA_ASTC_10x10", e[e.RGBA_ASTC_12x10 = Ea.ASTC_RGBA_12x10] = "RGBA_ASTC_12x10", e[e.RGBA_ASTC_12x12 = Ea.ASTC_RGBA_12x12] = "RGBA_ASTC_12x12"
            }(Mf || (Mf = {})),
            function(e) {
                e[e.REPEAT = Na.WRAP] = "REPEAT", e[e.CLAMP_TO_EDGE = Na.CLAMP] = "CLAMP_TO_EDGE", e[e.MIRRORED_REPEAT = Na.MIRROR] = "MIRRORED_REPEAT", e[e.CLAMP_TO_BORDER = Na.BORDER] = "CLAMP_TO_BORDER"
            }(Lf || (Lf = {})),
            function(e) {
                e[e.NONE = Da.NONE] = "NONE", e[e.LINEAR = Da.LINEAR] = "LINEAR", e[e.NEAREST = Da.POINT] = "NEAREST"
            }(Bf || (Bf = {}));
            var Vf, Wf = e("ImageAsset", A_("cc.ImageAsset")((Gf = Uf = function(e) {
                function t(t) {
                    var n;
                    return (n = e.call(this) || this)._nativeData = void 0, n._tex = void 0, n._exportedExts = void 0, n._format = Mf.RGBA8888, n._width = 0, n._height = 0, n.loaded = !1, n._nativeData = {
                        _data: null,
                        width: 0,
                        height: 0,
                        format: 0,
                        _compressed: !1
                    }, void 0 !== t && n.reset(t), n
                }
                Q(t, e);
                var n = t.prototype;
                return n.reset = function(e) {
                    var t = this;
                    kf(e) ? (this._nativeData = e, this._onDataComplete()) : e instanceof HTMLElement ? (this._nativeData = e, e.complete || e instanceof HTMLCanvasElement ? this._onDataComplete() : (this.loaded = !1, e.addEventListener("load", (function() {
                        t._onDataComplete()
                    })), e.addEventListener("error", (function(e) {
                        x(3119, e.message)
                    })))) : (this._nativeData = e, this._format = e.format, this._onDataComplete())
                }, n.destroy = function() {
                    return this.data && this.data instanceof HTMLImageElement ? (this.data.src = "", this._setRawAsset("")) : kf(this.data) && this.data.close && this.data.close(), e.prototype.destroy.call(this)
                }, n._serialize = function() {}, n._deserialize = function(e) {
                    var n = "";
                    "string" == typeof e ? n = e : (this._width = e.w, this._height = e.h, n = e.fmt);
                    for (var r, o = i.director.root ? i.director.root.device : null, a = n.split("_"), s = "", c = Number.MAX_VALUE, l = this._format, u = "", h = i.macro.SUPPORT_TEXTURE_FORMATS, _ = te(a); !(r = _()).done;) {
                        var f = r.value.split("@"),
                            d = parseInt(f[0], void 0),
                            p = t.extnames[d] || f[0],
                            m = h.indexOf(p);
                        if (-1 !== m && m < c) {
                            var g = f[1] ? parseInt(f[1]) : this._format;
                            if (!(".astc" !== p || o && o.hasFeature(Sa.FORMAT_ASTC))) continue;
                            if (!(".pvr" !== p || o && o.hasFeature(Sa.FORMAT_PVRTC))) continue;
                            if (!(g !== Mf.RGB_ETC1 && g !== Mf.RGBA_ETC1 || o && o.hasFeature(Sa.FORMAT_ETC1))) continue;
                            if (!(g !== Mf.RGB_ETC2 && g !== Mf.RGBA_ETC2 || o && o.hasFeature(Sa.FORMAT_ETC2))) continue;
                            if (".webp" === p && !i.sys.capabilities.webp) continue;
                            c = m, u = p, l = g
                        } else s || (s = p)
                    }
                    u ? (this._setRawAsset(u), this._format = l) : s ? (this._setRawAsset(s), x(3120, s, s)) : x(3121)
                }, n._onDataComplete = function() {
                    this.loaded = !0, this.emit("load")
                }, n.initDefault = function(n) {
                    if (e.prototype.initDefault.call(this, n), t._sharedPlaceHolderCanvas) this.reset(t._sharedPlaceHolderCanvas);
                    else {
                        var i = document.createElement("canvas"),
                            r = i.getContext("2d"),
                            o = i.width = i.height = 2;
                        r.fillStyle = "#ff00ff", r.fillRect(0, 0, o, o), this.reset(i), t._sharedPlaceHolderCanvas = i
                    }
                }, n.validate = function() {
                    return !!this.data
                }, K(t, [{
                    key: "_nativeAsset",
                    get: function() {
                        return this._nativeData
                    },
                    set: function(e) {
                        e instanceof HTMLElement || kf(e) || (e.format = e.format || this._format), this.reset(e)
                    }
                }, {
                    key: "data",
                    get: function() {
                        return this._nativeData && ((e = this._nativeData) instanceof HTMLImageElement || e instanceof HTMLCanvasElement || kf(e)) ? this._nativeData : this._nativeData && this._nativeData._data;
                        var e
                    }
                }, {
                    key: "width",
                    get: function() {
                        return this._nativeData.width || this._width
                    }
                }, {
                    key: "height",
                    get: function() {
                        return this._nativeData.height || this._height
                    }
                }, {
                    key: "format",
                    get: function() {
                        return this._format
                    }
                }, {
                    key: "isCompressed",
                    get: function() {
                        return this._format >= Mf.RGB_ETC1 && this._format <= Mf.RGBA_ASTC_12x12 || this._format >= Mf.RGB_A_PVRTC_2BPPV1 && this._format <= Mf.RGBA_ETC1
                    }
                }, {
                    key: "url",
                    get: function() {
                        return this.nativeUrl
                    }
                }, {
                    key: "_texture",
                    get: function() {
                        if (!this._tex) {
                            var e = new i.Texture2D;
                            e.name = this.nativeUrl, e.image = this, this._tex = e
                        }
                        return this._tex
                    },
                    set: function(e) {
                        this._tex = e
                    }
                }]), t
            }(Nf), Uf.extnames = [".png", ".jpg", ".jpeg", ".bmp", ".webp", ".pvr", ".pkm", ".astc"], Uf._sharedPlaceHolderCanvas = null, ie((zf = Gf).prototype, "_nativeAsset", [tf], Object.getOwnPropertyDescriptor(zf.prototype, "_nativeAsset"), zf.prototype), Ff = zf)) || Ff);
            i.ImageAsset = Wf,
                function(e) {
                    e[e.minFilter = 0] = "minFilter", e[e.magFilter = 1] = "magFilter", e[e.mipFilter = 2] = "mipFilter", e[e.addressU = 3] = "addressU", e[e.addressV = 4] = "addressV", e[e.addressW = 5] = "addressW", e[e.maxAnisotropy = 6] = "maxAnisotropy", e[e.cmpFunc = 7] = "cmpFunc", e[e.mipLODBias = 8] = "mipLODBias", e[e.total = 9] = "total"
                }(Vf || (Vf = {}));
            var jf = [Da.LINEAR, Da.LINEAR, Da.NONE, Na.WRAP, Na.WRAP, Na.WRAP, 0, Ma.NEVER, 0],
                qf = Kf(jf),
                Xf = new ps,
                Yf = new xs;

            function Kf(e) {
                for (var t = 0, n = 0, i = 0; i < jf.length; i++) switch (t = e[i] || jf[i], i) {
                    case Vf.minFilter:
                        n |= t;
                        break;
                    case Vf.magFilter:
                        n |= t << 2;
                        break;
                    case Vf.mipFilter:
                        n |= t << 4;
                        break;
                    case Vf.addressU:
                        n |= t << 6;
                        break;
                    case Vf.addressV:
                        n |= t << 8;
                        break;
                    case Vf.addressW:
                        n |= t << 10;
                        break;
                    case Vf.maxAnisotropy:
                        n |= t << 12;
                        break;
                    case Vf.cmpFunc:
                        n |= t << 16;
                        break;
                    case Vf.mipLODBias:
                        n |= t << 28
                }
                return n
            }
            var Zf, Qf, Jf, $f, ed, td, nd, id, rd, od, ad, sd, cd = new(function() {
                function e() {
                    this._cache = {}
                }
                return e.prototype.getSampler = function(e, t) {
                    return t || (t = qf), this._cache[t] || (Yf.minFilter = 3 & t, Yf.magFilter = t >> 2 & 3, Yf.mipFilter = t >> 4 & 3, Yf.addressU = t >> 6 & 3, Yf.addressV = t >> 8 & 3, Yf.addressW = t >> 10 & 3, Yf.maxAnisotropy = t >> 12 & 15, Yf.cmpFunc = t >> 16 & 15, Yf.mipLODBias = t >> 28 & 15, Yf.borderColor = Xf, this._cache[t] = e.createSampler(Yf))
                }, e
            }());
            i.samplerLib = cd;
            var ld = new ue("Tex"),
                ud = A_("cc.TextureBase")((sd = ad = function(e) {
                    function t() {
                        var t;
                        return ne(t = e.call(this) || this, "_format", Jf, $(t)), ne(t, "_minFilter", $f, $(t)), ne(t, "_magFilter", ed, $(t)), ne(t, "_mipFilter", td, $(t)), ne(t, "_wrapS", nd, $(t)), ne(t, "_wrapT", id, $(t)), ne(t, "_wrapR", rd, $(t)), ne(t, "_anisotropy", od, $(t)), t._width = 1, t._height = 1, t._id = void 0, t._samplerInfo = [], t._samplerHash = 0, t._gfxSampler = null, t._gfxDevice = null, t._textureHash = 0, t._id = ld.getNewId(), t.loaded = !1, t._gfxDevice = t._getGFXDevice(), t._textureHash = vc(t._id, 666), t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.getId = function() {
                        return this._id
                    }, n.getPixelFormat = function() {
                        return this._format
                    }, n.getAnisotropy = function() {
                        return this._anisotropy
                    }, n.setWrapMode = function(e, t, n) {
                        this._wrapS = e, this._samplerInfo[Vf.addressU] = e, this._wrapT = t, this._samplerInfo[Vf.addressV] = t, void 0 !== n && (this._wrapR = n, this._samplerInfo[Vf.addressW] = n), this._samplerHash = Kf(this._samplerInfo), this._gfxDevice && (this._gfxSampler = cd.getSampler(this._gfxDevice, this._samplerHash))
                    }, n.setFilters = function(e, t) {
                        this._minFilter = e, this._samplerInfo[Vf.minFilter] = e, this._magFilter = t, this._samplerInfo[Vf.magFilter] = t, this._samplerHash = Kf(this._samplerInfo), this._gfxDevice && (this._gfxSampler = cd.getSampler(this._gfxDevice, this._samplerHash))
                    }, n.setMipFilter = function(e) {
                        this._mipFilter = e, this._samplerInfo[Vf.mipFilter] = e, this._samplerHash = Kf(this._samplerInfo), this._gfxDevice && (this._gfxSampler = cd.getSampler(this._gfxDevice, this._samplerHash))
                    }, n.setAnisotropy = function(e) {
                        this._anisotropy = e, this._samplerInfo[Vf.maxAnisotropy] = e, this._samplerHash = Kf(this._samplerInfo), this._gfxDevice && (this._gfxSampler = cd.getSampler(this._gfxDevice, this._samplerHash))
                    }, n.destroy = function() {
                        var t = e.prototype.destroy.call(this);
                        return t && i.director.root && i.director.root.batcher2D && i.director.root.batcher2D._releaseDescriptorSetCache(this._textureHash), t
                    }, n.getHash = function() {
                        return this._textureHash
                    }, n.getGFXTexture = function() {
                        return null
                    }, n.getSamplerHash = function() {
                        return this._samplerHash
                    }, n.getGFXSampler = function() {
                        return this._gfxSampler || (this._gfxDevice ? this._gfxSampler = cd.getSampler(this._gfxDevice, this._samplerHash) : b(9302)), this._gfxSampler
                    }, n._serialize = function() {
                        return ""
                    }, n._deserialize = function(e) {
                        var t = e.split(",");
                        t.unshift(""), t.length >= 5 && (this.setFilters(parseInt(t[1]), parseInt(t[2])), this.setWrapMode(parseInt(t[3]), parseInt(t[4]))), t.length >= 7 && (this.setMipFilter(parseInt(t[5])), this.setAnisotropy(parseInt(t[6])))
                    }, n._getGFXDevice = function() {
                        return i.director.root ? i.director.root.device : null
                    }, n._getGFXFormat = function() {
                        return this._getGFXPixelFormat(this._format)
                    }, n._setGFXFormat = function(e) {
                        this._format = void 0 === e ? Mf.RGBA8888 : e
                    }, n._getGFXPixelFormat = function(e) {
                        return e === Mf.RGBA_ETC1 ? e = Mf.RGB_ETC1 : e === Mf.RGB_A_PVRTC_4BPPV1 ? e = Mf.RGB_PVRTC_4BPPV1 : e === Mf.RGB_A_PVRTC_2BPPV1 && (e = Mf.RGB_PVRTC_2BPPV1), e
                    }, K(t, [{
                        key: "isCompressed",
                        get: function() {
                            return this._format >= Mf.RGB_ETC1 && this._format <= Mf.RGBA_ASTC_12x12 || this._format >= Mf.RGB_A_PVRTC_2BPPV1 && this._format <= Mf.RGBA_ETC1
                        }
                    }, {
                        key: "width",
                        get: function() {
                            return this._width
                        }
                    }, {
                        key: "height",
                        get: function() {
                            return this._height
                        }
                    }]), t
                }(Nf), ad.PixelFormat = Mf, ad.WrapMode = Lf, ad.Filter = Bf, Jf = ie((Qf = sd).prototype, "_format", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return Mf.RGBA8888
                    }
                }), $f = ie(Qf.prototype, "_minFilter", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return Bf.LINEAR
                    }
                }), ed = ie(Qf.prototype, "_magFilter", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return Bf.LINEAR
                    }
                }), td = ie(Qf.prototype, "_mipFilter", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return Bf.NONE
                    }
                }), nd = ie(Qf.prototype, "_wrapS", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return Lf.REPEAT
                    }
                }), id = ie(Qf.prototype, "_wrapT", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return Lf.REPEAT
                    }
                }), rd = ie(Qf.prototype, "_wrapR", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return Lf.REPEAT
                    }
                }), od = ie(Qf.prototype, "_anisotropy", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 0
                    }
                }), Zf = Qf)) || Zf;
            i.TextureBase = ud;
            var hd = [Gn, En, Wn, wn, yn, Xn, Kn, Bn];

            function _d(e, t) {
                e.x = t[1], e.y = t[2], e.z = t[3], e.w = t[4]
            }
            var fd = [function(e, t) {
                    e.x = t[1], e.y = t[2]
                }, function(e, t) {
                    e.x = t[1], e.y = t[2], e.z = t[3]
                }, _d, _d, function(e, t) {
                    e._val = t[1]
                }, function(e, t) {
                    e.width = t[1], e.height = t[2]
                }, function(e, t) {
                    e.x = t[1], e.y = t[2], e.width = t[3], e.height = t[4]
                }, function(e, t) {
                    Bn.fromArray(e, t, 1)
                }],
                dd = e("Details", function() {
                    function e() {
                        this.uuidObjList = null, this.uuidPropList = null, this.uuidList = null, this.uuidTypeList = []
                    }
                    var t = e.prototype;
                    return t.init = function(e) {
                        this.uuidObjList = e[8], this.uuidPropList = e[9], this.uuidList = e[10]
                    }, t.reset = function() {
                        this.uuidList = null, this.uuidObjList = null, this.uuidPropList = null
                    }, t.push = function(e, t, n, i) {
                        this.uuidObjList.push(e), this.uuidPropList.push(t), this.uuidList.push(n), this.uuidTypeList.push(i || "")
                    }, e
                }());

            function pd(e, t) {
                for (var n = e[4][t[0]], i = n[0], r = new(0, i[0]), o = i[1], a = i[2], s = n[n.length - 1], c = 1; c < s; ++c) r[o[n[c]]] = t[c];
                for (; c < t.length; ++c) {
                    var l = o[n[c]],
                        u = i[n[c] + a];
                    (0, Ed[u])(e, r, l, t[c])
                }
                return r
            }

            function md(e, t, n) {
                var i = new t;
                return i._deserialize ? i._deserialize(n, e[0]) : b(5303, Ae(t)), i
            }

            function gd(e, t, n, i) {
                i >= 0 ? t[n] = e[5][i] : e[7][3 * ~i] = t
            }

            function vd(e) {
                return function(t, n, i, r) {
                    n[i] = r;
                    for (var o = 0; o < r.length; ++o) e(t, r, o, r[o])
                }
            }

            function yd(e, t, n, i) {
                t[n] = null, e[8][i] = t
            }

            function Sd(e, t, n, i) {
                t[n] = pd(e, i)
            }
            dd.pool = new Ke((function(e) {
                e.reset()
            }), 5), dd.pool.get = function() {
                return this._get() || new dd
            };
            var Ed = new Array(13);

            function Td(e, t) {
                return e || bd.reportMissingClass(t), Object
            }

            function Ad(e, t, n, i, r, o) {
                var a = e(t);
                if (!a) {
                    if (r) return void(n[i] = function(t, n, i) {
                        return function() {
                            var r = e(i) || Td(o, i);
                            return t[n] = r, new r
                        }
                    }(n, i, t));
                    a = Td(o, t)
                }
                n[i] = a
            }

            function xd(e, t, n) {
                for (var i = n || qe, r = e[3], o = 0; o < r.length; ++o) {
                    var a = r[o];
                    "string" != typeof a ? Ad(i, a[0], a, 0, t, n) : Ad(i, a, r, o, t, n)
                }
            }

            function Cd(e) {
                var t = e[4];
                if (t)
                    for (var n = e[3], i = 0; i < t.length; ++i) {
                        var r = t[i];
                        r[0] = n[r[0]]
                    }
            }

            function bd(e, t, n) {
                "string" == typeof e && (e = JSON.parse(e));
                var r, o = !t;
                (t = t || dd.pool.get()).init(e), n = n || {};
                var a = e[0],
                    s = !1;
                if ("object" == typeof a && (s = a.preprocessed, a = a.version), a < 1) throw new Error(P(5304, a));
                n._version = a, n.result = t, e[0] = n, s || (xd(e, !1, n.classFinder), Cd(e)), i.game._isCloning = !0;
                var c = e[5],
                    l = function(e) {
                        var t = e[5],
                            n = e[6],
                            i = 0 === n ? 0 : n.length,
                            r = t[t.length - 1],
                            o = t.length - i;
                        "number" != typeof r ? r = 0 : (r < 0 && (r = ~r), --o);
                        for (var a = 0; a < o; ++a) t[a] = pd(e, t[a]);
                        for (var s = e[3], c = 0; c < i; ++c, ++a) {
                            var l = n[c],
                                u = t[a];
                            if (l >= 0) {
                                var h = s[l];
                                t[a] = md(e, h, u)
                            } else(0, Ed[l = ~l])(e, t, a, u)
                        }
                        return r
                    }(e);
                return i.game._isCloning = !1, e[7] && function(e, t, n) {
                        for (var i = e.length - 1, r = 0, o = 3 * e[i]; r < o; r += 3) {
                            var a = e[r],
                                s = t[e[r + 2]],
                                c = e[r + 1];
                            c >= 0 ? a[n[c]] = s : a[~c] = s
                        }
                        for (; r < i; r += 3) {
                            var l = t[e[r]],
                                u = t[e[r + 2]],
                                h = e[r + 1];
                            h >= 0 ? l[n[h]] = u : l[~h] = u
                        }
                    }(e[7], c, e[2]),
                    function(e) {
                        for (var t = e[5], n = e[2], i = e[1], r = e[8], o = e[9], a = e[10], s = 0; s < r.length; ++s) {
                            var c = r[s];
                            "number" == typeof c && (r[s] = t[c]);
                            var l = o[s];
                            "number" == typeof l && (l = l >= 0 ? n[l] : ~l, o[s] = l);
                            var u = a[s];
                            "number" == typeof u && (a[s] = i[u])
                        }
                    }(e), r = c[l], o && dd.pool.put(t), r
            }
            Ed[0] = function(e, t, n, i) {
                t[n] = i
            }, Ed[1] = gd, Ed[2] = vd(gd), Ed[3] = vd(yd), Ed[4] = Sd, Ed[5] = function(e, t, n, i) {
                fd[i[0]](t[n], i)
            }, Ed[6] = yd, Ed[7] = function(e, t, n, i) {
                t[n].set(i)
            }, Ed[8] = function(e, t, n, i) {
                var r = new hd[i[0]];
                fd[i[0]](r, i), t[n] = r
            }, Ed[9] = vd(Sd), Ed[10] = function(e, t, n, i) {
                var r = e[3][i[0]];
                t[n] = md(e, r, i[1])
            }, Ed[11] = function(e, t, n, i) {
                var r = i[0];
                t[n] = r;
                for (var o = 1; o < i.length; o += 3) {
                    var a = i[o],
                        s = i[o + 1],
                        c = i[o + 2];
                    (0, Ed[s])(e, r, a, c)
                }
            }, Ed[12] = function(e, t, n, i) {
                var r = i[0];
                t[n] = r;
                for (var o = 0; o < r.length; ++o) {
                    var a = r[o],
                        s = i[o + 1];
                    0 !== s && (0, Ed[s])(e, r, o, a)
                }
            }, bd.Details = dd, bd.reportMissingClass = function(e) {
                x(5302, e)
            };
            var Rd, wd, Id, Pd = function(e) {
                this.preprocessed = !0, this.version = e
            };

            function Od(e, t, n) {
                return [1, 0, 0, [e], 0, n ? [t, -1] : [t],
                    [0], 0, [],
                    [],
                    []
                ]
            }
            i.deserialize = bd;
            var Dd = e("Script", A_("cc.Script")(Rd = function(e) {
                function t() {
                    return e.apply(this, arguments) || this
                }
                return Q(t, e), t
            }(Nf)) || Rd);
            i._Script = Dd;
            var Nd = e("JavaScript", A_("cc.JavaScript")(wd = function(e) {
                function t() {
                    return e.apply(this, arguments) || this
                }
                return Q(t, e), t
            }(Dd)) || wd);
            i._JavaScript = Nd;
            var Md, Ld, Bd, Fd, zd, Ud, Gd, Hd, kd, Vd, Wd, jd = e("TypeScript", A_("cc.TypeScript")(Id = function(e) {
                function t() {
                    return e.apply(this, arguments) || this
                }
                return Q(t, e), t
            }(Dd)) || Id);
            i._TypeScript = jd;
            var qd, Xd, Yd, Kd, Zd = new ue("Comp"),
                Qd = ni.Flags.IsOnLoadCalled,
                Jd = e("Component", (Md = A_("cc.Component"), Ld = U_(), Bd = ef(Dd), Fd = G_(), Md((Wd = Vd = function(e) {
                    function t() {
                        for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                        return ne(t = e.call.apply(e, [this].concat(i)) || this, "node", Gd, $(t)), ne(t, "_enabled", Hd, $(t)), ne(t, "__prefab", kd, $(t)), t._sceneGetter = null, t._id = Zd.getNewId(), t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n._getRenderScene = function() {
                        return this._sceneGetter ? this._sceneGetter() : this.node.scene._renderScene
                    }, n.addComponent = function(e) {
                        return this.node.addComponent(e)
                    }, n.getComponent = function(e) {
                        return this.node.getComponent(e)
                    }, n.getComponents = function(e) {
                        return this.node.getComponents(e)
                    }, n.getComponentInChildren = function(e) {
                        return this.node.getComponentInChildren(e)
                    }, n.getComponentsInChildren = function(e) {
                        return this.node.getComponentsInChildren(e)
                    }, n.destroy = function() {
                        return !!e.prototype.destroy.call(this) && (this._enabled && this.node.activeInHierarchy && i.director._compScheduler.disableComp(this), !0)
                    }, n._onPreDestroy = function() {
                        this.unscheduleAllCallbacks(), i.director._nodeActivator.destroyComp(this), this.node._removeComponent(this)
                    }, n._instantiate = function(e) {
                        return e || (e = i.instantiate._clone(this, this)), e && (e.node = null), e
                    }, n.schedule = function(e, t, n, r) {
                        void 0 === t && (t = 0), void 0 === n && (n = i.macro.REPEAT_FOREVER), void 0 === r && (r = 0), I(e, 1619), I((t = t || 0) >= 0, 1620), n = Number.isNaN(n) ? i.macro.REPEAT_FOREVER : n, r = r || 0;
                        var o = i.director.getScheduler(),
                            a = o.isTargetPaused(this);
                        o.schedule(e, this, t, n, r, a)
                    }, n.scheduleOnce = function(e, t) {
                        void 0 === t && (t = 0), this.schedule(e, 0, 0, t)
                    }, n.unschedule = function(e) {
                        e && i.director.getScheduler().unschedule(e, this)
                    }, n.unscheduleAllCallbacks = function() {
                        i.director.getScheduler().unscheduleAllForTarget(this)
                    }, K(t, [{
                        key: "name",
                        get: function() {
                            if (this._name) return this._name;
                            var e = Ae(this),
                                t = e.lastIndexOf(".");
                            return t >= 0 && (e = e.slice(t + 1)), this.node.name + "<" + e + ">"
                        },
                        set: function(e) {
                            this._name = e
                        }
                    }, {
                        key: "uuid",
                        get: function() {
                            return this._id
                        }
                    }, {
                        key: "__scriptAsset",
                        get: function() {
                            return null
                        }
                    }, {
                        key: "enabled",
                        get: function() {
                            return this._enabled
                        },
                        set: function(e) {
                            if (this._enabled !== e && (this._enabled = e, this.node.activeInHierarchy)) {
                                var t = i.director._compScheduler;
                                e ? t.enableComp(this) : t.disableComp(this)
                            }
                        }
                    }, {
                        key: "enabledInHierarchy",
                        get: function() {
                            return this._enabled && this.node && this.node.activeInHierarchy
                        }
                    }, {
                        key: "_isOnLoadCalled",
                        get: function() {
                            return this._objFlags & Qd
                        }
                    }]), t
                }(ni), Vd.system = null, ie((Ud = Wd).prototype, "__scriptAsset", [Ld, Bd, Fd, K_], Object.getOwnPropertyDescriptor(Ud.prototype, "__scriptAsset"), Ud.prototype), Gd = ie(Ud.prototype, "node", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return null
                    }
                }), Hd = ie(Ud.prototype, "_enabled", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return !0
                    }
                }), kd = ie(Ud.prototype, "__prefab", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return null
                    }
                }), zd = Ud)) || zd)),
                $d = Jd.prototype;
            $d.update = null, $d.lateUpdate = null, $d.__preload = null, $d.onLoad = null, $d.start = null, $d.onEnable = null, $d.onDisable = null, $d.onDestroy = null, $d.onFocusInEditor = null, $d.onLostFocusInEditor = null, $d.resetInEditor = null, $d._getLocalBounds = null, $d.onRestore = null, Jd._requireComponent = null, Jd._executionOrder = 0, ve(Jd, "_registerEditorProps", (function(e, t) {
                var n = t.requireComponent;
                n && (e._requireComponent = n);
                var i = t.executionOrder;
                i && "number" == typeof i && (e._executionOrder = i)
            })), i.Component = Jd;
            var ep = e("MissingScript", A_("cc.MissingScript")(qd = M_()((Kd = function(e) {
                function t() {
                    var t;
                    return ne(t = e.call(this) || this, "_$erialized", Yd, $(t)), t
                }
                return Q(t, e), t.safeFindClass = function(e) {
                    var t = qe(e);
                    if (t) return t;
                    i.deserialize.reportMissingClass(e)
                }, t.prototype.onLoad = function() {
                    x(4600, this.node.name)
                }, t
            }(Jd), Yd = ie((Xd = Kd).prototype, "_$erialized", [w_, I_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return null
                }
            }), qd = Xd)) || qd) || qd);

            function tp(e, t) {
                var n;
                n = ep.safeFindClass;
                var i, r = dd.pool.get();
                try {
                    i = bd(e, r, {
                        classFinder: n,
                        customEnv: t
                    })
                } catch (e) {
                    throw p(e), dd.pool.put(r), e
                }
                i._uuid = t.__uuid__ || "";
                for (var o = r.uuidList, a = r.uuidObjList, s = r.uuidPropList, c = r.uuidTypeList || [], l = [], u = 0; u < o.length; u++) {
                    var h = o[u];
                    l[u] = {
                        uuid: Sf(h),
                        owner: a[u],
                        prop: s[u],
                        type: Qe._getClassById(c[u])
                    }
                }
                return i.__depends__ = l, i._native && (i.__nativeDepend__ = !0), dd.pool.put(r), i
            }
            i._MissingScript = ep;
            var np, ip = new(function() {
                    function e() {
                        this._depends = new nf
                    }
                    var t = e.prototype;
                    return t.init = function() {
                        this._depends.clear()
                    }, t.getNativeDep = function(e) {
                        var t = this._depends.get(e);
                        return t && t.nativeDep ? Z({}, t.nativeDep) : null
                    }, t.getDeps = function(e) {
                        return this._depends.has(e) ? this._depends.get(e).deps : []
                    }, t.getDepsRecursively = function(e) {
                        var t = Object.create(null),
                            n = [];
                        return this._descend(e, t, n), n
                    }, t.remove = function(e) {
                        this._depends.remove(e)
                    }, t.parse = function(e, t) {
                        var n, i, r = null;
                        if (Array.isArray(t) || t.__type__) {
                            if (this._depends.has(e)) return this._depends.get(e);
                            if (!Array.isArray(t) || "number" == typeof(i = (n = t[5])[n.length - 1]) && i < 0) try {
                                var o = tp(t, {
                                    __uuid__: e
                                });
                                (r = this._parseDepsFromAsset(o)).nativeDep && (r.nativeDep.uuid = e), cf.add(e + "@import", o)
                            } catch (t) {
                                sf.remove(e + "@import"), r = {
                                    deps: []
                                }
                            } else r = {
                                deps: this._parseDepsFromJson(t)
                            }
                        } else {
                            if (this._depends.has(e) && (r = this._depends.get(e)).parsedFromExistAsset) return r;
                            r = this._parseDepsFromAsset(t)
                        }
                        return this._depends.add(e, r), r
                    }, t._parseDepsFromAsset = function(e) {
                        for (var t = {
                                deps: [],
                                parsedFromExistAsset: !0
                            }, n = e.__depends__, i = 0, r = n.length; i < r; i++) t.deps.push(n[i].uuid);
                        return e.__nativeDepend__ && (t.nativeDep = e._nativeDep), t
                    }, t._parseDepsFromJson = function(e) {
                        var t = null;
                        return (t = function(e) {
                            var t = e[1];
                            return e[10].map((function(e) {
                                return t[e]
                            }))
                        }(e)).forEach((function(e, n) {
                            return t[n] = Sf(e)
                        })), t
                    }, t._descend = function(e, t, n) {
                        for (var i = this.getDeps(e), r = 0; r < i.length; r++) {
                            var o = i[r];
                            t[o] || (t[o] = !0, n.push(o), this._descend(o, t, n))
                        }
                    }, e
                }()),
                rp = [new fs];

            function op(e) {
                return e && 0 == (e & e - 1)
            }
            var ap, sp, cp, lp, up, hp, _p = A_("cc.SimpleTexture")(np = function(e) {
                function t() {
                    for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                    return (t = e.call.apply(e, [this].concat(i)) || this)._gfxTexture = null, t._mipmapLevel = 1, t._textureWidth = 0, t._textureHeight = 0, t
                }
                Q(t, e);
                var n = t.prototype;
                return n.getGFXTexture = function() {
                    return this._gfxTexture
                }, n.destroy = function() {
                    return this._tryDestroyTexture(), e.prototype.destroy.call(this)
                }, n.updateImage = function() {
                    this.updateMipmaps(0)
                }, n.updateMipmaps = function() {}, n.uploadData = function(e, t, n) {
                    if (void 0 === t && (t = 0), void 0 === n && (n = 0), this._gfxTexture && !(this._mipmapLevel <= t)) {
                        var i = this._getGFXDevice();
                        if (i) {
                            var r = rp[0];
                            r.texExtent.width = this._textureWidth >> t, r.texExtent.height = this._textureHeight >> t, r.texSubres.mipLevel = t, r.texSubres.baseArrayLayer = n, ArrayBuffer.isView(e) ? i.copyBuffersToTexture([e], this._gfxTexture, rp) : i.copyTexImagesToTexture([e], this._gfxTexture, rp)
                        }
                    }
                }, n._assignImage = function(e, t, n) {
                    var r = this,
                        o = function() {
                            var i = e.data;
                            if (i && (r.uploadData(i, t, n), r._checkTextureLoaded(), rt.CLEANUP_IMAGE_CACHE)) {
                                var o = ip.getDeps(r._uuid),
                                    a = o.indexOf(e._uuid); - 1 !== a && (ae(o, a), e.decRef())
                            }
                        };
                    if (e.loaded) o();
                    else {
                        if (e.once("load", (function() {
                                o()
                            })), !this.isCompressed) {
                            var a = i.builtinResMgr.get("black-texture").image;
                            this.uploadData(a.data, t, n)
                        }
                        i.assetManager.postLoadNative(e)
                    }
                }, n._checkTextureLoaded = function() {
                    this._textureReady()
                }, n._textureReady = function() {
                    this.loaded = !0, this.emit("load")
                }, n._setMipmapLevel = function(e) {
                    this._mipmapLevel = e < 1 ? 1 : e
                }, n._getGfxTextureCreateInfo = function() {
                    return null
                }, n._tryReset = function() {
                    if (this._tryDestroyTexture(), 0 !== this._mipmapLevel) {
                        var e = this._getGFXDevice();
                        e && this._createTexture(e)
                    }
                }, n._createTexture = function(e) {
                    if (0 !== this._width && 0 !== this._height) {
                        var t = Pa.NONE;
                        this._mipFilter !== Bf.NONE && function(e, t, n) {
                            return !(e.gfxAPI === va.WEBGL) || op(t) && op(n)
                        }(e, this._width, this._height) && (this._mipmapLevel = function(e, t) {
                            for (var n = Math.max(e, t), i = 0; n;) n >>= 1, i++;
                            return i
                        }(this._width, this._height), t = Pa.GEN_MIPMAP);
                        var n = this._getGfxTextureCreateInfo({
                            usage: Ia.SAMPLED | Ia.TRANSFER_DST,
                            format: this._getGFXFormat(),
                            levelCount: this._mipmapLevel,
                            flags: t | Pa.IMMUTABLE
                        });
                        if (n) {
                            var i = e.createTexture(n);
                            this._textureWidth = n.width, this._textureHeight = n.height, this._gfxTexture = i
                        }
                    }
                }, n._tryDestroyTexture = function() {
                    this._gfxTexture && (this._gfxTexture.destroy(), this._gfxTexture = null)
                }, K(t, [{
                    key: "mipmapLevel",
                    get: function() {
                        return this._mipmapLevel
                    }
                }]), t
            }(ud)) || np;
            i.SimpleTexture = _p;
            var fp, dp, pp, mp, gp, vp, yp = e("Texture2D", (ap = A_("cc.Texture2D"), sp = ef([Wf]), ap((hp = function(e) {
                function t() {
                    for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                    return ne(t = e.call.apply(e, [this].concat(i)) || this, "_mipmaps", up, $(t)), t
                }
                Q(t, e);
                var n = t.prototype;
                return n.initialize = function() {
                    this.mipmaps = this._mipmaps
                }, n.onLoaded = function() {
                    this.initialize()
                }, n.reset = function(e) {
                    this._width = e.width, this._height = e.height, this._setGFXFormat(e.format), this._setMipmapLevel(e.mipmapLevel || 1), this._tryReset()
                }, n.create = function(e, t, n, i) {
                    void 0 === n && (n = Mf.RGBA8888), void 0 === i && (i = 1), this.reset({
                        width: e,
                        height: t,
                        format: n,
                        mipmapLevel: i
                    })
                }, n.toString = function() {
                    return 0 !== this._mipmaps.length ? this._mipmaps[0].url : ""
                }, n.updateMipmaps = function(e, t) {
                    if (void 0 === e && (e = 0), !(e >= this._mipmaps.length))
                        for (var n = Math.min(void 0 === t ? this._mipmaps.length : t, this._mipmaps.length - e), i = 0; i < n; ++i) {
                            var r = e + i;
                            this._assignImage(this._mipmaps[r], r)
                        }
                }, n.getHtmlElementObj = function() {
                    return this._mipmaps[0] && this._mipmaps[0].data instanceof HTMLElement ? this._mipmaps[0].data : null
                }, n.destroy = function() {
                    return this._mipmaps = [], e.prototype.destroy.call(this)
                }, n.description = function() {
                    return "<cc.Texture2D | Name = " + (this._mipmaps[0] ? this._mipmaps[0].url : "") + " | Dimension = " + this.width + " x " + this.height + ">"
                }, n.releaseTexture = function() {
                    this.destroy()
                }, n._serialize = function() {
                    return null
                }, n._deserialize = function(t, n) {
                    var i = t;
                    e.prototype._deserialize.call(this, i.base, n), this._mipmaps = new Array(i.mipmaps.length);
                    for (var r = 0; r < i.mipmaps.length; ++r)
                        if (this._mipmaps[r] = new Wf, i.mipmaps[r]) {
                            var o = i.mipmaps[r];
                            n.result.push(this._mipmaps, "" + r, o, Qe._getClassId(Wf)), this._mipmaps[r]._texture = this
                        }
                }, n._getGfxTextureCreateInfo = function(e) {
                    var t = new Ts(wa.TEX2D);
                    return t.width = this._width, t.height = this._height, Object.assign(t, e)
                }, n._checkTextureLoaded = function() {
                    for (var t = !0, n = 0; n < this._mipmaps.length; ++n)
                        if (!this._mipmaps[n].loaded) {
                            t = !1;
                            break
                        }
                    t && e.prototype._textureReady.call(this)
                }, n.initDefault = function(t) {
                    e.prototype.initDefault.call(this, t);
                    var n = new Wf;
                    n.initDefault(), this.image = n
                }, n.validate = function() {
                    return this.mipmaps && 0 !== this.mipmaps.length
                }, K(t, [{
                    key: "mipmaps",
                    get: function() {
                        return this._mipmaps
                    },
                    set: function(e) {
                        var t = this;
                        if (this._mipmaps = e, this._setMipmapLevel(this._mipmaps.length), this._mipmaps.length > 0) {
                            var n = this._mipmaps[0];
                            this.reset({
                                width: n.width,
                                height: n.height,
                                format: n.format,
                                mipmapLevel: this._mipmaps.length
                            }), this._mipmaps.forEach((function(e, n) {
                                t._assignImage(e, n)
                            }))
                        } else this.reset({
                            width: 0,
                            height: 0,
                            mipmapLevel: this._mipmaps.length
                        })
                    }
                }, {
                    key: "image",
                    get: function() {
                        return 0 === this._mipmaps.length ? null : this._mipmaps[0]
                    },
                    set: function(e) {
                        this.mipmaps = e ? [e] : []
                    }
                }]), t
            }(_p), up = ie((lp = hp).prototype, "_mipmaps", [sp], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return []
                }
            }), cp = lp)) || cp));
            i.Texture2D = yp,
                function(e) {
                    e[e.right = 0] = "right", e[e.left = 1] = "left", e[e.top = 2] = "top", e[e.bottom = 3] = "bottom", e[e.front = 4] = "front", e[e.back = 5] = "back"
                }(vp || (vp = {}));
            var Sp = e("TextureCube", A_("cc.TextureCube")((gp = mp = function(e) {
                function t() {
                    for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                    return ne(t = e.call.apply(e, [this].concat(i)) || this, "_mipmaps", pp, $(t)), t
                }
                Q(t, e), t.fromTexture2DArray = function(e, n) {
                    for (var i = [], r = e.length / 6, o = 0; o < r; o++) {
                        var a = 6 * o;
                        i.push({
                            front: e[a + vp.front].image,
                            back: e[a + vp.back].image,
                            left: e[a + vp.left].image,
                            right: e[a + vp.right].image,
                            top: e[a + vp.top].image,
                            bottom: e[a + vp.bottom].image
                        })
                    }
                    return (n = n || new t).mipmaps = i, n
                };
                var n = t.prototype;
                return n.onLoaded = function() {
                    this.mipmaps = this._mipmaps, this.loaded = !0, this.emit("load")
                }, n.reset = function(e) {
                    this._width = e.width, this._height = e.height, this._setGFXFormat(e.format), this._setMipmapLevel(e.mipmapLevel || 1), this._tryReset()
                }, n.updateMipmaps = function(e, t) {
                    var n = this;
                    if (void 0 === e && (e = 0), !(e >= this._mipmaps.length))
                        for (var i = Math.min(void 0 === t ? this._mipmaps.length : t, this._mipmaps.length - e), r = function(t) {
                                var i = e + t;
                                Ep(n._mipmaps[i], (function(e, t) {
                                    n._assignImage(e, i, t)
                                }))
                            }, o = 0; o < i; ++o) r(o)
                }, n.destroy = function() {
                    return this._mipmaps = [], e.prototype.destroy.call(this)
                }, n.releaseTexture = function() {
                    this.mipmaps = []
                }, n._serialize = function() {
                    return null
                }, n._deserialize = function(t, n) {
                    var i = t;
                    e.prototype._deserialize.call(this, i.base, n), this._mipmaps = new Array(i.mipmaps.length);
                    for (var r = 0; r < i.mipmaps.length; ++r) {
                        this._mipmaps[r] = {
                            front: new Wf,
                            back: new Wf,
                            left: new Wf,
                            right: new Wf,
                            top: new Wf,
                            bottom: new Wf
                        };
                        var o = i.mipmaps[r],
                            a = Qe._getClassId(Wf);
                        n.result.push(this._mipmaps[r], "front", o.front, a), n.result.push(this._mipmaps[r], "back", o.back, a), n.result.push(this._mipmaps[r], "left", o.left, a), n.result.push(this._mipmaps[r], "right", o.right, a), n.result.push(this._mipmaps[r], "top", o.top, a), n.result.push(this._mipmaps[r], "bottom", o.bottom, a)
                    }
                }, n._getGfxTextureCreateInfo = function(e) {
                    var t = new Ts(wa.CUBE);
                    return t.width = this._width, t.height = this._height, t.layerCount = 6, Object.assign(t, e), t
                }, n.initDefault = function(t) {
                    e.prototype.initDefault.call(this, t);
                    var n = new Wf;
                    n.initDefault(), this.mipmaps = [{
                        front: n,
                        back: n,
                        top: n,
                        bottom: n,
                        left: n,
                        right: n
                    }]
                }, n.validate = function() {
                    return 0 !== this._mipmaps.length && !this._mipmaps.find((function(e) {
                        return !(e.top && e.bottom && e.front && e.back && e.left && e.right)
                    }))
                }, K(t, [{
                    key: "mipmaps",
                    get: function() {
                        return this._mipmaps
                    },
                    set: function(e) {
                        var t = this;
                        if (this._mipmaps = e, this._setMipmapLevel(this._mipmaps.length), this._mipmaps.length > 0) {
                            var n = this._mipmaps[0].front;
                            this.reset({
                                width: n.width,
                                height: n.height,
                                format: n.format,
                                mipmapLevel: this._mipmaps.length
                            }), this._mipmaps.forEach((function(e, n) {
                                Ep(e, (function(e, i) {
                                    t._assignImage(e, n, i)
                                }))
                            }))
                        } else this.reset({
                            width: 0,
                            height: 0,
                            mipmapLevel: this._mipmaps.length
                        })
                    }
                }, {
                    key: "image",
                    get: function() {
                        return 0 === this._mipmaps.length ? null : this._mipmaps[0]
                    },
                    set: function(e) {
                        this.mipmaps = e ? [e] : []
                    }
                }]), t
            }(_p), mp.FaceIndex = vp, pp = ie((dp = gp).prototype, "_mipmaps", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return []
                }
            }), fp = dp)) || fp);

            function Ep(e, t) {
                t(e.front, vp.front), t(e.back, vp.back), t(e.left, vp.left), t(e.right, vp.right), t(e.top, vp.top), t(e.bottom, vp.bottom)
            }
            i.TextureCube = Sp;
            var Tp, Ap, xp, Cp = e("effects", [{
                    name: "billboard",
                    techniques: [{
                        name: "add",
                        passes: [{
                            rasterizerState: {
                                cullMode: 0
                            },
                            blendState: {
                                targets: [{
                                    blend: !0,
                                    blendSrc: 2,
                                    blendDst: 1,
                                    blendSrcAlpha: 2,
                                    blendDstAlpha: 1
                                }]
                            },
                            program: "billboard|vert:vs_main|tinted-fs:add",
                            depthStencilState: {
                                depthTest: !0,
                                depthWrite: !1
                            },
                            properties: {
                                mainTexture: {
                                    value: "grey",
                                    type: 28
                                },
                                mainTiling_Offset: {
                                    value: [1, 1, 0, 0],
                                    type: 16
                                },
                                tintColor: {
                                    value: [.5, .5, .5, .5],
                                    type: 16
                                }
                            }
                        }]
                    }],
                    shaders: [{
                        name: "billboard|vert:vs_main|tinted-fs:add",
                        hash: 456146524,
                        builtins: {
                            statistics: {
                                CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS: 50,
                                CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS: 38
                            },
                            globals: {
                                blocks: [{
                                    name: "CCGlobal",
                                    defines: []
                                }, {
                                    name: "CCCamera",
                                    defines: []
                                }],
                                samplerTextures: []
                            },
                            locals: {
                                blocks: [{
                                    name: "CCLocal",
                                    defines: []
                                }],
                                samplerTextures: []
                            }
                        },
                        defines: [{
                            name: "CC_USE_HDR",
                            type: "boolean"
                        }],
                        blocks: [{
                            name: "Constants",
                            defines: [],
                            binding: 0,
                            stageFlags: 1,
                            members: [{
                                name: "mainTiling_Offset",
                                type: 16,
                                count: 1
                            }, {
                                name: "frameTile_velLenScale",
                                type: 16,
                                count: 1
                            }, {
                                name: "scale",
                                type: 16,
                                count: 1
                            }]
                        }, {
                            name: "builtin",
                            defines: [],
                            binding: 1,
                            stageFlags: 1,
                            members: [{
                                name: "cc_size_rotation",
                                type: 16,
                                count: 1
                            }]
                        }, {
                            name: "FragConstants",
                            defines: [],
                            binding: 2,
                            stageFlags: 16,
                            members: [{
                                name: "tintColor",
                                type: 16,
                                count: 1
                            }]
                        }],
                        samplerTextures: [{
                            name: "mainTexture",
                            type: 28,
                            count: 1,
                            defines: [],
                            stageFlags: 16,
                            binding: 3
                        }],
                        attributes: [{
                            name: "a_position",
                            type: 15,
                            count: 1,
                            defines: [],
                            stageFlags: 1,
                            format: 32,
                            location: 0
                        }, {
                            name: "a_texCoord",
                            type: 14,
                            count: 1,
                            defines: [],
                            stageFlags: 1,
                            format: 21,
                            location: 1
                        }, {
                            name: "a_color",
                            type: 16,
                            count: 1,
                            defines: [],
                            stageFlags: 1,
                            format: 44,
                            location: 2
                        }]
                    }]
                }, {
                    name: "clear-stencil",
                    techniques: [{
                        passes: [{
                            blendState: {
                                targets: [{
                                    blend: !0
                                }]
                            },
                            rasterizerState: {
                                cullMode: 0
                            },
                            program: "clear-stencil|sprite-vs:vert|sprite-fs:frag",
                            depthStencilState: {
                                depthTest: !1,
                                depthWrite: !1
                            }
                        }]
                    }],
                    shaders: [{
                        name: "clear-stencil|sprite-vs:vert|sprite-fs:frag",
                        hash: 1062464958,
                        builtins: {
                            statistics: {
                                CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS: 0,
                                CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS: 0
                            },
                            globals: {
                                blocks: [],
                                samplerTextures: []
                            },
                            locals: {
                                blocks: [],
                                samplerTextures: []
                            }
                        },
                        defines: [],
                        blocks: [],
                        samplerTextures: [],
                        attributes: [{
                            name: "a_position",
                            type: 15,
                            count: 1,
                            defines: [],
                            stageFlags: 1,
                            format: 32,
                            location: 0
                        }]
                    }]
                }, {
                    name: "graphics",
                    techniques: [{
                        passes: [{
                            blendState: {
                                targets: [{
                                    blend: !0,
                                    blendSrc: 1,
                                    blendDst: 4,
                                    blendSrcAlpha: 1,
                                    blendDstAlpha: 4
                                }]
                            },
                            rasterizerState: {
                                cullMode: 0
                            },
                            program: "graphics|vs:vert|fs:frag",
                            depthStencilState: {
                                depthTest: !1,
                                depthWrite: !1
                            }
                        }]
                    }],
                    shaders: [{
                        name: "graphics|vs:vert|fs:frag",
                        hash: 3946667351,
                        builtins: {
                            statistics: {
                                CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS: 46,
                                CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS: 0
                            },
                            globals: {
                                blocks: [{
                                    name: "CCGlobal",
                                    defines: []
                                }, {
                                    name: "CCCamera",
                                    defines: []
                                }],
                                samplerTextures: []
                            },
                            locals: {
                                blocks: [{
                                    name: "CCLocal",
                                    defines: []
                                }],
                                samplerTextures: []
                            }
                        },
                        defines: [],
                        blocks: [],
                        samplerTextures: [],
                        attributes: [{
                            name: "a_position",
                            type: 15,
                            count: 1,
                            defines: [],
                            stageFlags: 1,
                            format: 32,
                            location: 0
                        }, {
                            name: "a_color",
                            type: 16,
                            count: 1,
                            defines: [],
                            stageFlags: 1,
                            format: 44,
                            location: 1
                        }, {
                            name: "a_dist",
                            type: 13,
                            count: 1,
                            defines: [],
                            stageFlags: 1,
                            format: 11,
                            location: 2
                        }]
                    }]
                }, {
                    name: "particle-gpu",
                    techniques: [{
                        name: "add",
                        passes: [{
                            rasterizerState: {
                                cullMode: 0
                            },
                            blendState: {
                                targets: [{
                                    blend: !0,
                                    blendSrc: 2,
                                    blendDst: 1,
                                    blendSrcAlpha: 2,
                                    blendDstAlpha: 1
                                }]
                            },
                            program: "particle-gpu|particle-vs-gpu:gpvs_main|tinted-fs:add",
                            depthStencilState: {
                                depthTest: !0,
                                depthWrite: !1
                            },
                            properties: {
                                mainTexture: {
                                    value: "grey",
                                    type: 28
                                },
                                mainTiling_Offset: {
                                    value: [1, 1, 0, 0],
                                    type: 16
                                },
                                tintColor: {
                                    value: [.5, .5, .5, .5],
                                    type: 16
                                }
                            }
                        }]
                    }],
                    shaders: [{
                        name: "particle-gpu|particle-vs-gpu:gpvs_main|tinted-fs:add",
                        hash: 932177378,
                        builtins: {
                            statistics: {
                                CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS: 60,
                                CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS: 38
                            },
                            globals: {
                                blocks: [{
                                    name: "CCGlobal",
                                    defines: []
                                }, {
                                    name: "CCCamera",
                                    defines: []
                                }],
                                samplerTextures: []
                            },
                            locals: {
                                blocks: [{
                                    name: "CCLocal",
                                    defines: []
                                }],
                                samplerTextures: []
                            }
                        },
                        defines: [{
                            name: "CC_RENDER_MODE",
                            type: "number",
                            range: [0, 4]
                        }, {
                            name: "COLOR_OVER_TIME_MODULE_ENABLE",
                            type: "boolean"
                        }, {
                            name: "ROTATION_OVER_TIME_MODULE_ENABLE",
                            type: "boolean"
                        }, {
                            name: "SIZE_OVER_TIME_MODULE_ENABLE",
                            type: "boolean"
                        }, {
                            name: "FORCE_OVER_TIME_MODULE_ENABLE",
                            type: "boolean"
                        }, {
                            name: "VELOCITY_OVER_TIME_MODULE_ENABLE",
                            type: "boolean"
                        }, {
                            name: "TEXTURE_ANIMATION_MODULE_ENABLE",
                            type: "boolean"
                        }, {
                            name: "CC_USE_WORLD_SPACE",
                            type: "boolean"
                        }, {
                            name: "CC_USE_HDR",
                            type: "boolean"
                        }],
                        blocks: [{
                            name: "Constants",
                            defines: [],
                            binding: 0,
                            stageFlags: 1,
                            members: [{
                                name: "mainTiling_Offset",
                                type: 16,
                                count: 1
                            }, {
                                name: "frameTile_velLenScale",
                                type: 16,
                                count: 1
                            }, {
                                name: "scale",
                                type: 16,
                                count: 1
                            }]
                        }, {
                            name: "SampleConstants",
                            defines: [],
                            binding: 1,
                            stageFlags: 1,
                            members: [{
                                name: "u_sampleInfo",
                                type: 16,
                                count: 1
                            }]
                        }, {
                            name: "TickConstants",
                            defines: [],
                            binding: 2,
                            stageFlags: 1,
                            members: [{
                                name: "u_worldRot",
                                type: 16,
                                count: 1
                            }, {
                                name: "u_timeDelta",
                                type: 16,
                                count: 1
                            }]
                        }, {
                            name: "ColorConstant",
                            defines: ["COLOR_OVER_TIME_MODULE_ENABLE"],
                            binding: 3,
                            stageFlags: 1,
                            members: [{
                                name: "u_color_mode",
                                type: 5,
                                count: 1
                            }]
                        }, {
                            name: "RotationConstant",
                            defines: ["ROTATION_OVER_TIME_MODULE_ENABLE"],
                            binding: 4,
                            stageFlags: 1,
                            members: [{
                                name: "u_rotation_mode",
                                type: 5,
                                count: 1
                            }]
                        }, {
                            name: "SizeConstant",
                            defines: ["SIZE_OVER_TIME_MODULE_ENABLE"],
                            binding: 5,
                            stageFlags: 1,
                            members: [{
                                name: "u_size_mode",
                                type: 5,
                                count: 1
                            }]
                        }, {
                            name: "ForceConstant",
                            defines: ["FORCE_OVER_TIME_MODULE_ENABLE"],
                            binding: 6,
                            stageFlags: 1,
                            members: [{
                                name: "u_force_mode",
                                type: 5,
                                count: 1
                            }, {
                                name: "u_force_space",
                                type: 5,
                                count: 1
                            }]
                        }, {
                            name: "VelocityConstant",
                            defines: ["VELOCITY_OVER_TIME_MODULE_ENABLE"],
                            binding: 7,
                            stageFlags: 1,
                            members: [{
                                name: "u_velocity_mode",
                                type: 5,
                                count: 1
                            }, {
                                name: "u_velocity_space",
                                type: 5,
                                count: 1
                            }]
                        }, {
                            name: "AnimationConstant",
                            defines: ["TEXTURE_ANIMATION_MODULE_ENABLE"],
                            binding: 8,
                            stageFlags: 1,
                            members: [{
                                name: "u_anim_info",
                                type: 16,
                                count: 1
                            }]
                        }, {
                            name: "FragConstants",
                            defines: [],
                            binding: 9,
                            stageFlags: 16,
                            members: [{
                                name: "tintColor",
                                type: 16,
                                count: 1
                            }]
                        }],
                        samplerTextures: [{
                            name: "color_over_time_tex0",
                            type: 28,
                            count: 1,
                            defines: ["COLOR_OVER_TIME_MODULE_ENABLE"],
                            stageFlags: 1,
                            binding: 10
                        }, {
                            name: "rotation_over_time_tex0",
                            type: 28,
                            count: 1,
                            defines: ["ROTATION_OVER_TIME_MODULE_ENABLE"],
                            stageFlags: 1,
                            binding: 11
                        }, {
                            name: "size_over_time_tex0",
                            type: 28,
                            count: 1,
                            defines: ["SIZE_OVER_TIME_MODULE_ENABLE"],
                            stageFlags: 1,
                            binding: 12
                        }, {
                            name: "force_over_time_tex0",
                            type: 28,
                            count: 1,
                            defines: ["FORCE_OVER_TIME_MODULE_ENABLE"],
                            stageFlags: 1,
                            binding: 13
                        }, {
                            name: "velocity_over_time_tex0",
                            type: 28,
                            count: 1,
                            defines: ["VELOCITY_OVER_TIME_MODULE_ENABLE"],
                            stageFlags: 1,
                            binding: 14
                        }, {
                            name: "texture_animation_tex0",
                            type: 28,
                            count: 1,
                            defines: ["TEXTURE_ANIMATION_MODULE_ENABLE"],
                            stageFlags: 1,
                            binding: 15
                        }, {
                            name: "mainTexture",
                            type: 28,
                            count: 1,
                            defines: [],
                            stageFlags: 16,
                            binding: 16
                        }],
                        attributes: [{
                            name: "a_position_starttime",
                            type: 16,
                            count: 1,
                            defines: [],
                            stageFlags: 1,
                            format: 44,
                            location: 0
                        }, {
                            name: "a_size_uv",
                            type: 16,
                            count: 1,
                            defines: [],
                            stageFlags: 1,
                            format: 44,
                            location: 1
                        }, {
                            name: "a_rotation_uv",
                            type: 16,
                            count: 1,
                            defines: [],
                            stageFlags: 1,
                            format: 44,
                            location: 2
                        }, {
                            name: "a_color",
                            type: 16,
                            count: 1,
                            defines: [],
                            stageFlags: 1,
                            format: 44,
                            location: 3
                        }, {
                            name: "a_dir_life",
                            type: 16,
                            count: 1,
                            defines: [],
                            stageFlags: 1,
                            format: 44,
                            location: 4
                        }, {
                            name: "a_rndSeed",
                            type: 13,
                            count: 1,
                            defines: [],
                            stageFlags: 1,
                            format: 11,
                            location: 5
                        }, {
                            name: "a_texCoord",
                            type: 15,
                            count: 1,
                            defines: ["CC_RENDER_MODE"],
                            stageFlags: 1,
                            format: 32,
                            location: 6
                        }, {
                            name: "a_texCoord3",
                            type: 15,
                            count: 1,
                            defines: ["CC_RENDER_MODE"],
                            stageFlags: 1,
                            format: 32,
                            location: 7
                        }, {
                            name: "a_normal",
                            type: 15,
                            count: 1,
                            defines: ["CC_RENDER_MODE"],
                            stageFlags: 1,
                            format: 32,
                            location: 8
                        }, {
                            name: "a_color1",
                            type: 16,
                            count: 1,
                            defines: ["CC_RENDER_MODE"],
                            stageFlags: 1,
                            format: 44,
                            location: 9
                        }]
                    }]
                }, {
                    name: "particle-trail",
                    techniques: [{
                        name: "add",
                        passes: [{
                            rasterizerState: {
                                cullMode: 0
                            },
                            blendState: {
                                targets: [{
                                    blend: !0,
                                    blendSrc: 2,
                                    blendDst: 1,
                                    blendSrcAlpha: 2,
                                    blendDstAlpha: 1
                                }]
                            },
                            program: "particle-trail|particle-trail:vs_main|tinted-fs:add",
                            depthStencilState: {
                                depthTest: !0,
                                depthWrite: !1
                            },
                            properties: {
                                mainTexture: {
                                    value: "grey",
                                    type: 28
                                },
                                mainTiling_Offset: {
                                    value: [1, 1, 0, 0],
                                    type: 16
                                },
                                frameTile_velLenScale: {
                                    value: [1, 1, 0, 0],
                                    type: 16
                                },
                                tintColor: {
                                    value: [.5, .5, .5, .5],
                                    type: 16
                                }
                            }
                        }]
                    }],
                    shaders: [{
                        name: "particle-trail|particle-trail:vs_main|tinted-fs:add",
                        hash: 293909391,
                        builtins: {
                            statistics: {
                                CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS: 49,
                                CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS: 38
                            },
                            globals: {
                                blocks: [{
                                    name: "CCGlobal",
                                    defines: []
                                }, {
                                    name: "CCCamera",
                                    defines: []
                                }],
                                samplerTextures: []
                            },
                            locals: {
                                blocks: [{
                                    name: "CCLocal",
                                    defines: []
                                }],
                                samplerTextures: []
                            }
                        },
                        defines: [{
                            name: "CC_RENDER_MODE",
                            type: "number",
                            range: [0, 4]
                        }, {
                            name: "CC_DRAW_WIRE_FRAME",
                            type: "boolean"
                        }, {
                            name: "CC_USE_WORLD_SPACE",
                            type: "boolean"
                        }, {
                            name: "CC_USE_HDR",
                            type: "boolean"
                        }],
                        blocks: [{
                            name: "Constants",
                            defines: [],
                            binding: 0,
                            stageFlags: 1,
                            members: [{
                                name: "mainTiling_Offset",
                                type: 16,
                                count: 1
                            }, {
                                name: "frameTile_velLenScale",
                                type: 16,
                                count: 1
                            }, {
                                name: "scale",
                                type: 16,
                                count: 1
                            }]
                        }, {
                            name: "FragConstants",
                            defines: [],
                            binding: 1,
                            stageFlags: 16,
                            members: [{
                                name: "tintColor",
                                type: 16,
                                count: 1
                            }]
                        }],
                        samplerTextures: [{
                            name: "mainTexture",
                            type: 28,
                            count: 1,
                            defines: [],
                            stageFlags: 16,
                            binding: 2
                        }],
                        attributes: [{
                            name: "a_position",
                            type: 15,
                            count: 1,
                            defines: [],
                            stageFlags: 1,
                            format: 32,
                            location: 0
                        }, {
                            name: "a_texCoord",
                            type: 16,
                            count: 1,
                            defines: [],
                            stageFlags: 1,
                            format: 44,
                            location: 1
                        }, {
                            name: "a_texCoord1",
                            type: 15,
                            count: 1,
                            defines: [],
                            stageFlags: 1,
                            format: 32,
                            location: 2
                        }, {
                            name: "a_texCoord2",
                            type: 15,
                            count: 1,
                            defines: [],
                            stageFlags: 1,
                            format: 32,
                            location: 3
                        }, {
                            name: "a_color",
                            type: 16,
                            count: 1,
                            defines: [],
                            stageFlags: 1,
                            format: 44,
                            location: 4
                        }]
                    }]
                }, {
                    name: "particle",
                    techniques: [{
                        name: "add",
                        passes: [{
                            rasterizerState: {
                                cullMode: 0
                            },
                            blendState: {
                                targets: [{
                                    blend: !0,
                                    blendSrc: 2,
                                    blendDst: 1,
                                    blendSrcAlpha: 2,
                                    blendDstAlpha: 1
                                }]
                            },
                            program: "particle|particle-vs-legacy:lpvs_main|tinted-fs:add",
                            depthStencilState: {
                                depthTest: !0,
                                depthWrite: !1
                            },
                            properties: {
                                mainTexture: {
                                    value: "grey",
                                    type: 28
                                },
                                mainTiling_Offset: {
                                    value: [1, 1, 0, 0],
                                    type: 16
                                },
                                tintColor: {
                                    value: [.5, .5, .5, .5],
                                    type: 16
                                }
                            }
                        }]
                    }],
                    shaders: [{
                        name: "particle|particle-vs-legacy:lpvs_main|tinted-fs:add",
                        hash: 3802928649,
                        builtins: {
                            statistics: {
                                CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS: 49,
                                CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS: 38
                            },
                            globals: {
                                blocks: [{
                                    name: "CCGlobal",
                                    defines: []
                                }, {
                                    name: "CCCamera",
                                    defines: []
                                }],
                                samplerTextures: []
                            },
                            locals: {
                                blocks: [{
                                    name: "CCLocal",
                                    defines: []
                                }],
                                samplerTextures: []
                            }
                        },
                        defines: [{
                            name: "CC_RENDER_MODE",
                            type: "number",
                            range: [0, 4]
                        }, {
                            name: "CC_USE_WORLD_SPACE",
                            type: "boolean"
                        }, {
                            name: "CC_USE_HDR",
                            type: "boolean"
                        }],
                        blocks: [{
                            name: "Constants",
                            defines: [],
                            binding: 0,
                            stageFlags: 1,
                            members: [{
                                name: "mainTiling_Offset",
                                type: 16,
                                count: 1
                            }, {
                                name: "frameTile_velLenScale",
                                type: 16,
                                count: 1
                            }, {
                                name: "scale",
                                type: 16,
                                count: 1
                            }]
                        }, {
                            name: "FragConstants",
                            defines: [],
                            binding: 1,
                            stageFlags: 16,
                            members: [{
                                name: "tintColor",
                                type: 16,
                                count: 1
                            }]
                        }],
                        samplerTextures: [{
                            name: "mainTexture",
                            type: 28,
                            count: 1,
                            defines: [],
                            stageFlags: 16,
                            binding: 2
                        }],
                        attributes: [{
                            name: "a_position",
                            type: 15,
                            count: 1,
                            defines: [],
                            stageFlags: 1,
                            format: 32,
                            location: 0
                        }, {
                            name: "a_texCoord",
                            type: 15,
                            count: 1,
                            defines: [],
                            stageFlags: 1,
                            format: 32,
                            location: 1
                        }, {
                            name: "a_texCoord1",
                            type: 15,
                            count: 1,
                            defines: [],
                            stageFlags: 1,
                            format: 32,
                            location: 2
                        }, {
                            name: "a_texCoord2",
                            type: 15,
                            count: 1,
                            defines: [],
                            stageFlags: 1,
                            format: 32,
                            location: 3
                        }, {
                            name: "a_color",
                            type: 16,
                            count: 1,
                            defines: [],
                            stageFlags: 1,
                            format: 44,
                            location: 4
                        }, {
                            name: "a_color1",
                            type: 15,
                            count: 1,
                            defines: ["CC_RENDER_MODE"],
                            stageFlags: 1,
                            format: 32,
                            location: 8
                        }, {
                            name: "a_texCoord3",
                            type: 15,
                            count: 1,
                            defines: ["CC_RENDER_MODE"],
                            stageFlags: 1,
                            format: 32,
                            location: 6
                        }, {
                            name: "a_normal",
                            type: 15,
                            count: 1,
                            defines: ["CC_RENDER_MODE"],
                            stageFlags: 1,
                            format: 32,
                            location: 7
                        }]
                    }]
                }, {
                    name: "spine",
                    techniques: [{
                        passes: [{
                            blendState: {
                                targets: [{
                                    blend: !0,
                                    blendSrc: 2,
                                    blendDst: 4,
                                    blendDstAlpha: 4
                                }]
                            },
                            rasterizerState: {
                                cullMode: 0
                            },
                            program: "spine|sprite-vs:vert|sprite-fs:frag",
                            depthStencilState: {
                                depthTest: !1,
                                depthWrite: !1
                            },
                            properties: {
                                alphaThreshold: {
                                    value: [.5],
                                    type: 13
                                }
                            }
                        }]
                    }],
                    shaders: [{
                        name: "spine|sprite-vs:vert|sprite-fs:frag",
                        hash: 2041444135,
                        builtins: {
                            statistics: {
                                CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS: 46,
                                CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS: 1
                            },
                            globals: {
                                blocks: [{
                                    name: "CCGlobal",
                                    defines: []
                                }, {
                                    name: "CCCamera",
                                    defines: []
                                }],
                                samplerTextures: []
                            },
                            locals: {
                                blocks: [{
                                    name: "CCLocal",
                                    defines: ["USE_LOCAL"]
                                }],
                                samplerTextures: [{
                                    name: "cc_spriteTexture",
                                    defines: []
                                }]
                            }
                        },
                        defines: [{
                            name: "USE_LOCAL",
                            type: "boolean"
                        }, {
                            name: "TWO_COLORED",
                            type: "boolean"
                        }, {
                            name: "USE_ALPHA_TEST",
                            type: "boolean"
                        }],
                        blocks: [{
                            name: "ALPHA_TEST_DATA",
                            defines: ["USE_ALPHA_TEST"],
                            binding: 0,
                            stageFlags: 16,
                            members: [{
                                name: "alphaThreshold",
                                type: 13,
                                count: 1
                            }]
                        }],
                        samplerTextures: [],
                        attributes: [{
                            name: "a_position",
                            type: 15,
                            count: 1,
                            defines: [],
                            stageFlags: 1,
                            format: 32,
                            location: 0
                        }, {
                            name: "a_texCoord",
                            type: 14,
                            count: 1,
                            defines: [],
                            stageFlags: 1,
                            format: 21,
                            location: 1
                        }, {
                            name: "a_color",
                            type: 16,
                            count: 1,
                            defines: [],
                            stageFlags: 1,
                            format: 44,
                            location: 2
                        }, {
                            name: "a_color2",
                            type: 16,
                            count: 1,
                            defines: ["TWO_COLORED"],
                            stageFlags: 1,
                            format: 44,
                            location: 3
                        }]
                    }]
                }, {
                    name: "sprite",
                    techniques: [{
                        passes: [{
                            blendState: {
                                targets: [{
                                    blend: !0,
                                    blendSrc: 2,
                                    blendDst: 4,
                                    blendDstAlpha: 4
                                }]
                            },
                            rasterizerState: {
                                cullMode: 0
                            },
                            program: "sprite|sprite-vs:vert|sprite-fs:frag",
                            depthStencilState: {
                                depthTest: !1,
                                depthWrite: !1
                            },
                            properties: {
                                alphaThreshold: {
                                    value: [.5],
                                    type: 13
                                }
                            }
                        }]
                    }],
                    shaders: [{
                        name: "sprite|sprite-vs:vert|sprite-fs:frag",
                        hash: 1142786345,
                        builtins: {
                            statistics: {
                                CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS: 46,
                                CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS: 1
                            },
                            globals: {
                                blocks: [{
                                    name: "CCGlobal",
                                    defines: []
                                }, {
                                    name: "CCCamera",
                                    defines: []
                                }],
                                samplerTextures: []
                            },
                            locals: {
                                blocks: [{
                                    name: "CCLocal",
                                    defines: ["USE_LOCAL"]
                                }],
                                samplerTextures: [{
                                    name: "cc_spriteTexture",
                                    defines: ["USE_TEXTURE"]
                                }]
                            }
                        },
                        defines: [{
                            name: "USE_LOCAL",
                            type: "boolean"
                        }, {
                            name: "SAMPLE_FROM_RT",
                            type: "boolean"
                        }, {
                            name: "USE_PIXEL_ALIGNMENT",
                            type: "boolean"
                        }, {
                            name: "CC_USE_EMBEDDED_ALPHA",
                            type: "boolean"
                        }, {
                            name: "USE_ALPHA_TEST",
                            type: "boolean"
                        }, {
                            name: "USE_TEXTURE",
                            type: "boolean"
                        }, {
                            name: "IS_GRAY",
                            type: "boolean"
                        }],
                        blocks: [{
                            name: "ALPHA_TEST_DATA",
                            defines: ["USE_ALPHA_TEST"],
                            binding: 0,
                            stageFlags: 16,
                            members: [{
                                name: "alphaThreshold",
                                type: 13,
                                count: 1
                            }]
                        }],
                        samplerTextures: [],
                        attributes: [{
                            name: "a_position",
                            type: 15,
                            count: 1,
                            defines: [],
                            stageFlags: 1,
                            format: 32,
                            location: 0
                        }, {
                            name: "a_texCoord",
                            type: 14,
                            count: 1,
                            defines: [],
                            stageFlags: 1,
                            format: 21,
                            location: 1
                        }, {
                            name: "a_color",
                            type: 16,
                            count: 1,
                            defines: [],
                            stageFlags: 1,
                            format: 44,
                            location: 2
                        }]
                    }]
                }, {
                    name: "standard",
                    techniques: [{
                        name: "opaque",
                        passes: [{
                            program: "standard|standard-vs|standard-fs",
                            properties: {
                                tilingOffset: {
                                    value: [1, 1, 0, 0],
                                    type: 16
                                },
                                mainColor: {
                                    value: [1, 1, 1, 1],
                                    type: 16,
                                    handleInfo: ["albedo", 0, 16]
                                },
                                albedoScale: {
                                    value: [1, 1, 1],
                                    type: 15,
                                    handleInfo: ["albedoScaleAndCutoff", 0, 15]
                                },
                                alphaThreshold: {
                                    value: [.5],
                                    type: 13,
                                    handleInfo: ["albedoScaleAndCutoff", 3, 13]
                                },
                                occlusion: {
                                    value: [1],
                                    type: 13,
                                    handleInfo: ["pbrParams", 0, 13]
                                },
                                roughness: {
                                    value: [.8],
                                    type: 13,
                                    handleInfo: ["pbrParams", 1, 13]
                                },
                                metallic: {
                                    value: [.6],
                                    type: 13,
                                    handleInfo: ["pbrParams", 2, 13]
                                },
                                normalStrenth: {
                                    value: [1],
                                    type: 13,
                                    handleInfo: ["pbrParams", 3, 13]
                                },
                                emissive: {
                                    value: [0, 0, 0, 1],
                                    type: 16
                                },
                                emissiveScale: {
                                    value: [1, 1, 1],
                                    type: 15,
                                    handleInfo: ["emissiveScaleParam", 0, 15]
                                },
                                mainTexture: {
                                    value: "grey",
                                    type: 28,
                                    handleInfo: ["albedoMap", 0, 28]
                                },
                                normalMap: {
                                    value: "normal",
                                    type: 28
                                },
                                pbrMap: {
                                    value: "grey",
                                    type: 28
                                },
                                metallicRoughnessMap: {
                                    value: "grey",
                                    type: 28
                                },
                                occlusionMap: {
                                    value: "white",
                                    type: 28
                                },
                                emissiveMap: {
                                    value: "grey",
                                    type: 28
                                },
                                albedo: {
                                    type: 16,
                                    value: [1, 1, 1, 1]
                                },
                                albedoScaleAndCutoff: {
                                    type: 16,
                                    value: [1, 1, 1, .5]
                                },
                                pbrParams: {
                                    type: 16,
                                    value: [1, .8, .6, 1]
                                },
                                emissiveScaleParam: {
                                    type: 16,
                                    value: [1, 1, 1, 0]
                                },
                                albedoMap: {
                                    type: 28,
                                    value: "grey"
                                }
                            }
                        }, {
                            phase: "deferred",
                            propertyIndex: 0,
                            blendState: {
                                targets: [{
                                    blend: !1
                                }, {
                                    blend: !1
                                }, {
                                    blend: !1
                                }, {
                                    blend: !1
                                }]
                            },
                            program: "standard|standard-vs|standard-fs",
                            properties: {
                                tilingOffset: {
                                    value: [1, 1, 0, 0],
                                    type: 16
                                },
                                mainColor: {
                                    value: [1, 1, 1, 1],
                                    type: 16,
                                    handleInfo: ["albedo", 0, 16]
                                },
                                albedoScale: {
                                    value: [1, 1, 1],
                                    type: 15,
                                    handleInfo: ["albedoScaleAndCutoff", 0, 15]
                                },
                                alphaThreshold: {
                                    value: [.5],
                                    type: 13,
                                    handleInfo: ["albedoScaleAndCutoff", 3, 13]
                                },
                                occlusion: {
                                    value: [1],
                                    type: 13,
                                    handleInfo: ["pbrParams", 0, 13]
                                },
                                roughness: {
                                    value: [.8],
                                    type: 13,
                                    handleInfo: ["pbrParams", 1, 13]
                                },
                                metallic: {
                                    value: [.6],
                                    type: 13,
                                    handleInfo: ["pbrParams", 2, 13]
                                },
                                normalStrenth: {
                                    value: [1],
                                    type: 13,
                                    handleInfo: ["pbrParams", 3, 13]
                                },
                                emissive: {
                                    value: [0, 0, 0, 1],
                                    type: 16
                                },
                                emissiveScale: {
                                    value: [1, 1, 1],
                                    type: 15,
                                    handleInfo: ["emissiveScaleParam", 0, 15]
                                },
                                mainTexture: {
                                    value: "grey",
                                    type: 28,
                                    handleInfo: ["albedoMap", 0, 28]
                                },
                                normalMap: {
                                    value: "normal",
                                    type: 28
                                },
                                pbrMap: {
                                    value: "grey",
                                    type: 28
                                },
                                metallicRoughnessMap: {
                                    value: "grey",
                                    type: 28
                                },
                                occlusionMap: {
                                    value: "white",
                                    type: 28
                                },
                                emissiveMap: {
                                    value: "grey",
                                    type: 28
                                },
                                albedo: {
                                    type: 16,
                                    value: [1, 1, 1, 1]
                                },
                                albedoScaleAndCutoff: {
                                    type: 16,
                                    value: [1, 1, 1, .5]
                                },
                                pbrParams: {
                                    type: 16,
                                    value: [1, .8, .6, 1]
                                },
                                emissiveScaleParam: {
                                    type: 16,
                                    value: [1, 1, 1, 0]
                                },
                                albedoMap: {
                                    type: 28,
                                    value: "grey"
                                }
                            }
                        }, {
                            phase: "forward-add",
                            propertyIndex: 0,
                            embeddedMacros: {
                                CC_FORWARD_ADD: !0
                            },
                            blendState: {
                                targets: [{
                                    blend: !0,
                                    blendSrc: 1,
                                    blendDst: 1,
                                    blendSrcAlpha: 0,
                                    blendDstAlpha: 1
                                }]
                            },
                            program: "standard|standard-vs|standard-fs",
                            depthStencilState: {
                                depthFunc: 2,
                                depthTest: !0,
                                depthWrite: !1
                            },
                            properties: {
                                tilingOffset: {
                                    value: [1, 1, 0, 0],
                                    type: 16
                                },
                                mainColor: {
                                    value: [1, 1, 1, 1],
                                    type: 16,
                                    handleInfo: ["albedo", 0, 16]
                                },
                                albedoScale: {
                                    value: [1, 1, 1],
                                    type: 15,
                                    handleInfo: ["albedoScaleAndCutoff", 0, 15]
                                },
                                alphaThreshold: {
                                    value: [.5],
                                    type: 13,
                                    handleInfo: ["albedoScaleAndCutoff", 3, 13]
                                },
                                occlusion: {
                                    value: [1],
                                    type: 13,
                                    handleInfo: ["pbrParams", 0, 13]
                                },
                                roughness: {
                                    value: [.8],
                                    type: 13,
                                    handleInfo: ["pbrParams", 1, 13]
                                },
                                metallic: {
                                    value: [.6],
                                    type: 13,
                                    handleInfo: ["pbrParams", 2, 13]
                                },
                                normalStrenth: {
                                    value: [1],
                                    type: 13,
                                    handleInfo: ["pbrParams", 3, 13]
                                },
                                emissive: {
                                    value: [0, 0, 0, 1],
                                    type: 16
                                },
                                emissiveScale: {
                                    value: [1, 1, 1],
                                    type: 15,
                                    handleInfo: ["emissiveScaleParam", 0, 15]
                                },
                                mainTexture: {
                                    value: "grey",
                                    type: 28,
                                    handleInfo: ["albedoMap", 0, 28]
                                },
                                normalMap: {
                                    value: "normal",
                                    type: 28
                                },
                                pbrMap: {
                                    value: "grey",
                                    type: 28
                                },
                                metallicRoughnessMap: {
                                    value: "grey",
                                    type: 28
                                },
                                occlusionMap: {
                                    value: "white",
                                    type: 28
                                },
                                emissiveMap: {
                                    value: "grey",
                                    type: 28
                                },
                                albedo: {
                                    type: 16,
                                    value: [1, 1, 1, 1]
                                },
                                albedoScaleAndCutoff: {
                                    type: 16,
                                    value: [1, 1, 1, .5]
                                },
                                pbrParams: {
                                    type: 16,
                                    value: [1, .8, .6, 1]
                                },
                                emissiveScaleParam: {
                                    type: 16,
                                    value: [1, 1, 1, 0]
                                },
                                albedoMap: {
                                    type: 28,
                                    value: "grey"
                                }
                            }
                        }, {
                            phase: "shadow-caster",
                            propertyIndex: 0,
                            rasterizerState: {
                                cullMode: 1
                            },
                            program: "standard|shadow-caster-vs:vert|shadow-caster-fs:frag",
                            properties: {
                                tilingOffset: {
                                    value: [1, 1, 0, 0],
                                    type: 16
                                },
                                mainColor: {
                                    value: [1, 1, 1, 1],
                                    type: 16,
                                    handleInfo: ["albedo", 0, 16]
                                },
                                albedoScale: {
                                    value: [1, 1, 1],
                                    type: 15,
                                    handleInfo: ["albedoScaleAndCutoff", 0, 15]
                                },
                                alphaThreshold: {
                                    value: [.5],
                                    type: 13,
                                    handleInfo: ["albedoScaleAndCutoff", 3, 13]
                                },
                                occlusion: {
                                    value: [1],
                                    type: 13,
                                    handleInfo: ["pbrParams", 0, 13]
                                },
                                roughness: {
                                    value: [.8],
                                    type: 13,
                                    handleInfo: ["pbrParams", 1, 13]
                                },
                                metallic: {
                                    value: [.6],
                                    type: 13,
                                    handleInfo: ["pbrParams", 2, 13]
                                },
                                normalStrenth: {
                                    value: [1],
                                    type: 13,
                                    handleInfo: ["pbrParams", 3, 13]
                                },
                                emissive: {
                                    value: [0, 0, 0, 1],
                                    type: 16
                                },
                                emissiveScale: {
                                    value: [1, 1, 1],
                                    type: 15,
                                    handleInfo: ["emissiveScaleParam", 0, 15]
                                },
                                mainTexture: {
                                    value: "grey",
                                    type: 28,
                                    handleInfo: ["albedoMap", 0, 28]
                                },
                                albedo: {
                                    type: 16,
                                    value: [1, 1, 1, 1]
                                },
                                albedoScaleAndCutoff: {
                                    type: 16,
                                    value: [1, 1, 1, .5]
                                },
                                pbrParams: {
                                    type: 16,
                                    value: [1, .8, .6, 1]
                                },
                                emissiveScaleParam: {
                                    type: 16,
                                    value: [1, 1, 1, 0]
                                },
                                albedoMap: {
                                    type: 28,
                                    value: "grey"
                                }
                            }
                        }]
                    }],
                    shaders: [{
                        name: "standard|standard-vs|standard-fs",
                        hash: 632993342,
                        builtins: {
                            statistics: {
                                CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS: 216,
                                CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS: 59
                            },
                            globals: {
                                blocks: [{
                                    name: "CCGlobal",
                                    defines: []
                                }, {
                                    name: "CCCamera",
                                    defines: []
                                }, {
                                    name: "CCShadow",
                                    defines: []
                                }],
                                samplerTextures: [{
                                    name: "cc_shadowMap",
                                    defines: ["CC_RECEIVE_SHADOW"]
                                }, {
                                    name: "cc_spotLightingMap",
                                    defines: ["CC_RECEIVE_SHADOW"]
                                }, {
                                    name: "cc_environment",
                                    defines: ["CC_USE_IBL"]
                                }]
                            },
                            locals: {
                                blocks: [{
                                    name: "CCMorph",
                                    defines: ["CC_USE_MORPH"]
                                }, {
                                    name: "CCSkinningTexture",
                                    defines: ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
                                }, {
                                    name: "CCSkinningAnimation",
                                    defines: ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
                                }, {
                                    name: "CCSkinning",
                                    defines: ["CC_USE_SKINNING", "!CC_USE_BAKED_ANIMATION"]
                                }, {
                                    name: "CCLocalBatched",
                                    defines: ["!USE_INSTANCING", "USE_BATCHING"]
                                }, {
                                    name: "CCLocal",
                                    defines: ["!USE_INSTANCING", "!USE_BATCHING"]
                                }, {
                                    name: "CCForwardLight",
                                    defines: ["CC_FORWARD_ADD"]
                                }],
                                samplerTextures: [{
                                    name: "cc_PositionDisplacements",
                                    defines: ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_POSITION"]
                                }, {
                                    name: "cc_NormalDisplacements",
                                    defines: ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_NORMAL"]
                                }, {
                                    name: "cc_TangentDisplacements",
                                    defines: ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_TANGENT"]
                                }, {
                                    name: "cc_jointTexture",
                                    defines: ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
                                }, {
                                    name: "cc_lightingMap",
                                    defines: ["USE_LIGHTMAP", "!USE_BATCHING", "!CC_FORWARD_ADD"]
                                }]
                            }
                        },
                        defines: [{
                            name: "CC_USE_MORPH",
                            type: "boolean"
                        }, {
                            name: "CC_MORPH_TARGET_COUNT",
                            type: "number",
                            range: [2, 8]
                        }, {
                            name: "CC_MORPH_PRECOMPUTED",
                            type: "boolean"
                        }, {
                            name: "CC_MORPH_TARGET_HAS_POSITION",
                            type: "boolean"
                        }, {
                            name: "CC_MORPH_TARGET_HAS_NORMAL",
                            type: "boolean"
                        }, {
                            name: "CC_MORPH_TARGET_HAS_TANGENT",
                            type: "boolean"
                        }, {
                            name: "CC_USE_SKINNING",
                            type: "boolean"
                        }, {
                            name: "CC_USE_BAKED_ANIMATION",
                            type: "boolean"
                        }, {
                            name: "USE_INSTANCING",
                            type: "boolean"
                        }, {
                            name: "USE_BATCHING",
                            type: "boolean"
                        }, {
                            name: "USE_LIGHTMAP",
                            type: "boolean"
                        }, {
                            name: "CC_USE_FOG",
                            type: "number",
                            range: [0, 4]
                        }, {
                            name: "CC_FORWARD_ADD",
                            type: "boolean"
                        }, {
                            name: "CC_RECEIVE_SHADOW",
                            type: "boolean"
                        }, {
                            name: "USE_VERTEX_COLOR",
                            type: "boolean"
                        }, {
                            name: "USE_NORMAL_MAP",
                            type: "boolean"
                        }, {
                            name: "HAS_SECOND_UV",
                            type: "boolean"
                        }, {
                            name: "SAMPLE_FROM_RT",
                            type: "boolean"
                        }, {
                            name: "CC_USE_IBL",
                            type: "number",
                            range: [0, 2]
                        }, {
                            name: "CC_USE_HDR",
                            type: "boolean"
                        }, {
                            name: "USE_ALBEDO_MAP",
                            type: "boolean"
                        }, {
                            name: "ALBEDO_UV",
                            type: "string",
                            options: ["v_uv", "v_uv1"]
                        }, {
                            name: "NORMAL_UV",
                            type: "string",
                            options: ["v_uv", "v_uv1"]
                        }, {
                            name: "PBR_UV",
                            type: "string",
                            options: ["v_uv", "v_uv1"]
                        }, {
                            name: "USE_PBR_MAP",
                            type: "boolean"
                        }, {
                            name: "USE_METALLIC_ROUGHNESS_MAP",
                            type: "boolean"
                        }, {
                            name: "USE_OCCLUSION_MAP",
                            type: "boolean"
                        }, {
                            name: "USE_EMISSIVE_MAP",
                            type: "boolean"
                        }, {
                            name: "EMISSIVE_UV",
                            type: "string",
                            options: ["v_uv", "v_uv1"]
                        }, {
                            name: "USE_ALPHA_TEST",
                            type: "boolean"
                        }, {
                            name: "ALPHA_TEST_CHANNEL",
                            type: "string",
                            options: ["a", "r"]
                        }, {
                            name: "CC_PIPELINE_TYPE",
                            type: "number",
                            range: [0, 1]
                        }],
                        blocks: [{
                            name: "Constants",
                            defines: [],
                            binding: 0,
                            stageFlags: 17,
                            members: [{
                                name: "tilingOffset",
                                type: 16,
                                count: 1
                            }, {
                                name: "albedo",
                                type: 16,
                                count: 1
                            }, {
                                name: "albedoScaleAndCutoff",
                                type: 16,
                                count: 1
                            }, {
                                name: "pbrParams",
                                type: 16,
                                count: 1
                            }, {
                                name: "emissive",
                                type: 16,
                                count: 1
                            }, {
                                name: "emissiveScaleParam",
                                type: 16,
                                count: 1
                            }]
                        }],
                        samplerTextures: [{
                            name: "albedoMap",
                            type: 28,
                            count: 1,
                            defines: ["USE_ALBEDO_MAP"],
                            stageFlags: 16,
                            binding: 1
                        }, {
                            name: "normalMap",
                            type: 28,
                            count: 1,
                            defines: ["USE_NORMAL_MAP"],
                            stageFlags: 16,
                            binding: 2
                        }, {
                            name: "pbrMap",
                            type: 28,
                            count: 1,
                            defines: ["USE_PBR_MAP"],
                            stageFlags: 16,
                            binding: 3
                        }, {
                            name: "metallicRoughnessMap",
                            type: 28,
                            count: 1,
                            defines: ["USE_METALLIC_ROUGHNESS_MAP"],
                            stageFlags: 16,
                            binding: 4
                        }, {
                            name: "occlusionMap",
                            type: 28,
                            count: 1,
                            defines: ["USE_OCCLUSION_MAP"],
                            stageFlags: 16,
                            binding: 5
                        }, {
                            name: "emissiveMap",
                            type: 28,
                            count: 1,
                            defines: ["USE_EMISSIVE_MAP"],
                            stageFlags: 16,
                            binding: 6
                        }],
                        attributes: [{
                            name: "a_position",
                            type: 15,
                            count: 1,
                            defines: [],
                            stageFlags: 1,
                            format: 32,
                            location: 0
                        }, {
                            name: "a_normal",
                            type: 15,
                            count: 1,
                            defines: [],
                            stageFlags: 1,
                            format: 32,
                            location: 1
                        }, {
                            name: "a_texCoord",
                            type: 14,
                            count: 1,
                            defines: [],
                            stageFlags: 1,
                            format: 21,
                            location: 2
                        }, {
                            name: "a_tangent",
                            type: 16,
                            count: 1,
                            defines: [],
                            stageFlags: 1,
                            format: 44,
                            location: 3
                        }, {
                            name: "a_vertexId",
                            type: 13,
                            count: 1,
                            defines: ["CC_USE_MORPH"],
                            stageFlags: 1,
                            format: 11,
                            location: 6
                        }, {
                            name: "a_joints",
                            type: "u32vec4",
                            count: 1,
                            defines: ["CC_USE_SKINNING"],
                            stageFlags: 1,
                            location: 4
                        }, {
                            name: "a_weights",
                            type: 16,
                            count: 1,
                            defines: ["CC_USE_SKINNING"],
                            stageFlags: 1,
                            format: 44,
                            location: 5
                        }, {
                            name: "a_jointAnimInfo",
                            type: 16,
                            count: 1,
                            defines: ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION", "USE_INSTANCING"],
                            stageFlags: 1,
                            format: 44,
                            isInstanced: !0,
                            location: 7
                        }, {
                            name: "a_matWorld0",
                            type: 16,
                            count: 1,
                            defines: ["USE_INSTANCING"],
                            stageFlags: 1,
                            format: 44,
                            isInstanced: !0,
                            location: 8
                        }, {
                            name: "a_matWorld1",
                            type: 16,
                            count: 1,
                            defines: ["USE_INSTANCING"],
                            stageFlags: 1,
                            format: 44,
                            isInstanced: !0,
                            location: 9
                        }, {
                            name: "a_matWorld2",
                            type: 16,
                            count: 1,
                            defines: ["USE_INSTANCING"],
                            stageFlags: 1,
                            format: 44,
                            isInstanced: !0,
                            location: 10
                        }, {
                            name: "a_lightingMapUVParam",
                            type: 16,
                            count: 1,
                            defines: ["USE_INSTANCING", "USE_LIGHTMAP"],
                            stageFlags: 1,
                            format: 44,
                            isInstanced: !0,
                            location: 11
                        }, {
                            name: "a_dyn_batch_id",
                            type: 13,
                            count: 1,
                            defines: ["!USE_INSTANCING", "USE_BATCHING"],
                            stageFlags: 1,
                            format: 11,
                            location: 12
                        }, {
                            name: "a_color",
                            type: 16,
                            count: 1,
                            defines: ["USE_VERTEX_COLOR"],
                            stageFlags: 1,
                            format: 44,
                            location: 13
                        }, {
                            name: "a_texCoord1",
                            type: 14,
                            count: 1,
                            defines: [],
                            stageFlags: 1,
                            format: 21,
                            location: 14
                        }]
                    }, {
                        name: "standard|shadow-caster-vs:vert|shadow-caster-fs:frag",
                        hash: 1518991842,
                        builtins: {
                            statistics: {
                                CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS: 179,
                                CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS: 22
                            },
                            globals: {
                                blocks: [{
                                    name: "CCShadow",
                                    defines: []
                                }],
                                samplerTextures: []
                            },
                            locals: {
                                blocks: [{
                                    name: "CCMorph",
                                    defines: ["CC_USE_MORPH"]
                                }, {
                                    name: "CCSkinningTexture",
                                    defines: ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
                                }, {
                                    name: "CCSkinningAnimation",
                                    defines: ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
                                }, {
                                    name: "CCSkinning",
                                    defines: ["CC_USE_SKINNING", "!CC_USE_BAKED_ANIMATION"]
                                }, {
                                    name: "CCLocalBatched",
                                    defines: ["!USE_INSTANCING", "USE_BATCHING"]
                                }, {
                                    name: "CCLocal",
                                    defines: ["!USE_INSTANCING", "!USE_BATCHING"]
                                }],
                                samplerTextures: [{
                                    name: "cc_PositionDisplacements",
                                    defines: ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_POSITION"]
                                }, {
                                    name: "cc_NormalDisplacements",
                                    defines: ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_NORMAL"]
                                }, {
                                    name: "cc_TangentDisplacements",
                                    defines: ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_TANGENT"]
                                }, {
                                    name: "cc_jointTexture",
                                    defines: ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
                                }]
                            }
                        },
                        defines: [{
                            name: "CC_USE_MORPH",
                            type: "boolean"
                        }, {
                            name: "CC_MORPH_TARGET_COUNT",
                            type: "number",
                            range: [2, 8]
                        }, {
                            name: "CC_MORPH_PRECOMPUTED",
                            type: "boolean"
                        }, {
                            name: "CC_MORPH_TARGET_HAS_POSITION",
                            type: "boolean"
                        }, {
                            name: "CC_MORPH_TARGET_HAS_NORMAL",
                            type: "boolean"
                        }, {
                            name: "CC_MORPH_TARGET_HAS_TANGENT",
                            type: "boolean"
                        }, {
                            name: "CC_USE_SKINNING",
                            type: "boolean"
                        }, {
                            name: "CC_USE_BAKED_ANIMATION",
                            type: "boolean"
                        }, {
                            name: "USE_INSTANCING",
                            type: "boolean"
                        }, {
                            name: "USE_BATCHING",
                            type: "boolean"
                        }, {
                            name: "USE_LIGHTMAP",
                            type: "boolean"
                        }, {
                            name: "HAS_SECOND_UV",
                            type: "boolean"
                        }, {
                            name: "USE_ALBEDO_MAP",
                            type: "boolean"
                        }, {
                            name: "ALBEDO_UV",
                            type: "string",
                            options: ["v_uv", "v_uv1"]
                        }, {
                            name: "USE_ALPHA_TEST",
                            type: "boolean"
                        }, {
                            name: "ALPHA_TEST_CHANNEL",
                            type: "string",
                            options: ["a", "r"]
                        }],
                        blocks: [{
                            name: "Constants",
                            defines: [],
                            binding: 0,
                            stageFlags: 17,
                            members: [{
                                name: "tilingOffset",
                                type: 16,
                                count: 1
                            }, {
                                name: "albedo",
                                type: 16,
                                count: 1
                            }, {
                                name: "albedoScaleAndCutoff",
                                type: 16,
                                count: 1
                            }, {
                                name: "pbrParams",
                                type: 16,
                                count: 1
                            }, {
                                name: "emissive",
                                type: 16,
                                count: 1
                            }, {
                                name: "emissiveScaleParam",
                                type: 16,
                                count: 1
                            }]
                        }],
                        samplerTextures: [{
                            name: "albedoMap",
                            type: 28,
                            count: 1,
                            defines: ["USE_ALBEDO_MAP"],
                            stageFlags: 16,
                            binding: 1
                        }],
                        attributes: [{
                            name: "a_position",
                            type: 15,
                            count: 1,
                            defines: [],
                            stageFlags: 1,
                            format: 32,
                            location: 0
                        }, {
                            name: "a_normal",
                            type: 15,
                            count: 1,
                            defines: [],
                            stageFlags: 1,
                            format: 32,
                            location: 1
                        }, {
                            name: "a_texCoord",
                            type: 14,
                            count: 1,
                            defines: [],
                            stageFlags: 1,
                            format: 21,
                            location: 2
                        }, {
                            name: "a_tangent",
                            type: 16,
                            count: 1,
                            defines: [],
                            stageFlags: 1,
                            format: 44,
                            location: 3
                        }, {
                            name: "a_vertexId",
                            type: 13,
                            count: 1,
                            defines: ["CC_USE_MORPH"],
                            stageFlags: 1,
                            format: 11,
                            location: 6
                        }, {
                            name: "a_joints",
                            type: "u32vec4",
                            count: 1,
                            defines: ["CC_USE_SKINNING"],
                            stageFlags: 1,
                            location: 4
                        }, {
                            name: "a_weights",
                            type: 16,
                            count: 1,
                            defines: ["CC_USE_SKINNING"],
                            stageFlags: 1,
                            format: 44,
                            location: 5
                        }, {
                            name: "a_jointAnimInfo",
                            type: 16,
                            count: 1,
                            defines: ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION", "USE_INSTANCING"],
                            stageFlags: 1,
                            format: 44,
                            isInstanced: !0,
                            location: 7
                        }, {
                            name: "a_matWorld0",
                            type: 16,
                            count: 1,
                            defines: ["USE_INSTANCING"],
                            stageFlags: 1,
                            format: 44,
                            isInstanced: !0,
                            location: 8
                        }, {
                            name: "a_matWorld1",
                            type: 16,
                            count: 1,
                            defines: ["USE_INSTANCING"],
                            stageFlags: 1,
                            format: 44,
                            isInstanced: !0,
                            location: 9
                        }, {
                            name: "a_matWorld2",
                            type: 16,
                            count: 1,
                            defines: ["USE_INSTANCING"],
                            stageFlags: 1,
                            format: 44,
                            isInstanced: !0,
                            location: 10
                        }, {
                            name: "a_lightingMapUVParam",
                            type: 16,
                            count: 1,
                            defines: ["USE_INSTANCING", "USE_LIGHTMAP"],
                            stageFlags: 1,
                            format: 44,
                            isInstanced: !0,
                            location: 11
                        }, {
                            name: "a_dyn_batch_id",
                            type: 13,
                            count: 1,
                            defines: ["!USE_INSTANCING", "USE_BATCHING"],
                            stageFlags: 1,
                            format: 11,
                            location: 12
                        }, {
                            name: "a_texCoord1",
                            type: 14,
                            count: 1,
                            defines: [],
                            stageFlags: 1,
                            format: 21,
                            location: 13
                        }]
                    }]
                }, {
                    name: "terrain",
                    techniques: [{
                        name: "opaque",
                        passes: [{
                            program: "terrain|terrain-vs|terrain-fs",
                            properties: {
                                UVScale: {
                                    value: [1, 1, 1, 1],
                                    type: 16
                                },
                                lightMapUVParam: {
                                    value: [0, 0, 0, 0],
                                    type: 16
                                },
                                metallic: {
                                    value: [0, 0, 0, 0],
                                    type: 16
                                },
                                roughness: {
                                    value: [1, 1, 1, 1],
                                    type: 16
                                },
                                weightMap: {
                                    value: "black",
                                    type: 28
                                },
                                detailMap0: {
                                    value: "grey",
                                    type: 28
                                },
                                detailMap1: {
                                    value: "grey",
                                    type: 28
                                },
                                detailMap2: {
                                    value: "grey",
                                    type: 28
                                },
                                detailMap3: {
                                    value: "grey",
                                    type: 28
                                },
                                normalMap0: {
                                    value: "normal",
                                    type: 28
                                },
                                normalMap1: {
                                    value: "normal",
                                    type: 28
                                },
                                normalMap2: {
                                    value: "normal",
                                    type: 28
                                },
                                normalMap3: {
                                    value: "normal",
                                    type: 28
                                },
                                lightMap: {
                                    value: "grey",
                                    type: 28
                                }
                            }
                        }, {
                            phase: "deferred",
                            propertyIndex: 0,
                            blendState: {
                                targets: [{
                                    blend: !1
                                }, {
                                    blend: !1
                                }, {
                                    blend: !1
                                }, {
                                    blend: !1
                                }]
                            },
                            program: "terrain|terrain-vs|terrain-fs",
                            properties: {
                                UVScale: {
                                    value: [1, 1, 1, 1],
                                    type: 16
                                },
                                lightMapUVParam: {
                                    value: [0, 0, 0, 0],
                                    type: 16
                                },
                                metallic: {
                                    value: [0, 0, 0, 0],
                                    type: 16
                                },
                                roughness: {
                                    value: [1, 1, 1, 1],
                                    type: 16
                                },
                                weightMap: {
                                    value: "black",
                                    type: 28
                                },
                                detailMap0: {
                                    value: "grey",
                                    type: 28
                                },
                                detailMap1: {
                                    value: "grey",
                                    type: 28
                                },
                                detailMap2: {
                                    value: "grey",
                                    type: 28
                                },
                                detailMap3: {
                                    value: "grey",
                                    type: 28
                                },
                                normalMap0: {
                                    value: "normal",
                                    type: 28
                                },
                                normalMap1: {
                                    value: "normal",
                                    type: 28
                                },
                                normalMap2: {
                                    value: "normal",
                                    type: 28
                                },
                                normalMap3: {
                                    value: "normal",
                                    type: 28
                                },
                                lightMap: {
                                    value: "grey",
                                    type: 28
                                }
                            }
                        }, {
                            phase: "forward-add",
                            propertyIndex: 0,
                            embeddedMacros: {
                                CC_FORWARD_ADD: !0
                            },
                            blendState: {
                                targets: [{
                                    blend: !0,
                                    blendSrc: 1,
                                    blendDst: 1,
                                    blendSrcAlpha: 0,
                                    blendDstAlpha: 1
                                }]
                            },
                            program: "terrain|terrain-vs|terrain-fs",
                            depthStencilState: {
                                depthFunc: 2,
                                depthTest: !0,
                                depthWrite: !1
                            },
                            properties: {
                                UVScale: {
                                    value: [1, 1, 1, 1],
                                    type: 16
                                },
                                lightMapUVParam: {
                                    value: [0, 0, 0, 0],
                                    type: 16
                                },
                                metallic: {
                                    value: [0, 0, 0, 0],
                                    type: 16
                                },
                                roughness: {
                                    value: [1, 1, 1, 1],
                                    type: 16
                                },
                                weightMap: {
                                    value: "black",
                                    type: 28
                                },
                                detailMap0: {
                                    value: "grey",
                                    type: 28
                                },
                                detailMap1: {
                                    value: "grey",
                                    type: 28
                                },
                                detailMap2: {
                                    value: "grey",
                                    type: 28
                                },
                                detailMap3: {
                                    value: "grey",
                                    type: 28
                                },
                                normalMap0: {
                                    value: "normal",
                                    type: 28
                                },
                                normalMap1: {
                                    value: "normal",
                                    type: 28
                                },
                                normalMap2: {
                                    value: "normal",
                                    type: 28
                                },
                                normalMap3: {
                                    value: "normal",
                                    type: 28
                                },
                                lightMap: {
                                    value: "grey",
                                    type: 28
                                }
                            }
                        }, {
                            phase: "shadow-add",
                            propertyIndex: 0,
                            rasterizerState: {
                                cullMode: 2
                            },
                            program: "terrain|shadow-caster-vs:vert|shadow-caster-fs:frag"
                        }]
                    }],
                    shaders: [{
                        name: "terrain|terrain-vs|terrain-fs",
                        hash: 2532494361,
                        builtins: {
                            statistics: {
                                CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS: 64,
                                CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS: 55
                            },
                            globals: {
                                blocks: [{
                                    name: "CCGlobal",
                                    defines: []
                                }, {
                                    name: "CCCamera",
                                    defines: []
                                }, {
                                    name: "CCShadow",
                                    defines: []
                                }],
                                samplerTextures: [{
                                    name: "cc_shadowMap",
                                    defines: ["CC_RECEIVE_SHADOW"]
                                }, {
                                    name: "cc_spotLightingMap",
                                    defines: ["CC_RECEIVE_SHADOW"]
                                }, {
                                    name: "cc_environment",
                                    defines: ["CC_USE_IBL"]
                                }]
                            },
                            locals: {
                                blocks: [{
                                    name: "CCLocal",
                                    defines: []
                                }, {
                                    name: "CCForwardLight",
                                    defines: ["CC_FORWARD_ADD"]
                                }],
                                samplerTextures: [{
                                    name: "cc_lightingMap",
                                    defines: ["USE_LIGHTMAP", "!USE_BATCHING", "!CC_FORWARD_ADD"]
                                }]
                            }
                        },
                        defines: [{
                            name: "CC_USE_FOG",
                            type: "number",
                            range: [0, 4]
                        }, {
                            name: "CC_FORWARD_ADD",
                            type: "boolean"
                        }, {
                            name: "CC_RECEIVE_SHADOW",
                            type: "boolean"
                        }, {
                            name: "USE_NORMALMAP",
                            type: "boolean"
                        }, {
                            name: "USE_LIGHTMAP",
                            type: "boolean"
                        }, {
                            name: "CC_USE_IBL",
                            type: "number",
                            range: [0, 2]
                        }, {
                            name: "USE_BATCHING",
                            type: "boolean"
                        }, {
                            name: "CC_USE_HDR",
                            type: "boolean"
                        }, {
                            name: "LAYERS",
                            type: "number",
                            range: [0, 4]
                        }, {
                            name: "USE_PBR",
                            type: "boolean"
                        }, {
                            name: "CC_PIPELINE_TYPE",
                            type: "number",
                            range: [0, 1]
                        }],
                        blocks: [{
                            name: "TexCoords",
                            defines: [],
                            binding: 0,
                            stageFlags: 1,
                            members: [{
                                name: "UVScale",
                                type: 16,
                                count: 1
                            }, {
                                name: "lightMapUVParam",
                                type: 16,
                                count: 1
                            }]
                        }, {
                            name: "PbrParams",
                            defines: [],
                            binding: 1,
                            stageFlags: 16,
                            members: [{
                                name: "metallic",
                                type: 16,
                                count: 1
                            }, {
                                name: "roughness",
                                type: 16,
                                count: 1
                            }]
                        }],
                        samplerTextures: [{
                            name: "weightMap",
                            type: 28,
                            count: 1,
                            defines: [],
                            stageFlags: 16,
                            binding: 2
                        }, {
                            name: "detailMap0",
                            type: 28,
                            count: 1,
                            defines: [],
                            stageFlags: 16,
                            binding: 3
                        }, {
                            name: "detailMap1",
                            type: 28,
                            count: 1,
                            defines: [],
                            stageFlags: 16,
                            binding: 4
                        }, {
                            name: "detailMap2",
                            type: 28,
                            count: 1,
                            defines: [],
                            stageFlags: 16,
                            binding: 5
                        }, {
                            name: "detailMap3",
                            type: 28,
                            count: 1,
                            defines: [],
                            stageFlags: 16,
                            binding: 6
                        }, {
                            name: "normalMap0",
                            type: 28,
                            count: 1,
                            defines: [],
                            stageFlags: 16,
                            binding: 7
                        }, {
                            name: "normalMap1",
                            type: 28,
                            count: 1,
                            defines: [],
                            stageFlags: 16,
                            binding: 8
                        }, {
                            name: "normalMap2",
                            type: 28,
                            count: 1,
                            defines: [],
                            stageFlags: 16,
                            binding: 9
                        }, {
                            name: "normalMap3",
                            type: 28,
                            count: 1,
                            defines: [],
                            stageFlags: 16,
                            binding: 10
                        }, {
                            name: "lightMap",
                            type: 28,
                            count: 1,
                            defines: [],
                            stageFlags: 16,
                            binding: 11
                        }],
                        attributes: [{
                            name: "a_position",
                            type: 15,
                            count: 1,
                            defines: [],
                            stageFlags: 1,
                            format: 32,
                            location: 0
                        }, {
                            name: "a_normal",
                            type: 15,
                            count: 1,
                            defines: [],
                            stageFlags: 1,
                            format: 32,
                            location: 1
                        }, {
                            name: "a_texCoord",
                            type: 14,
                            count: 1,
                            defines: [],
                            stageFlags: 1,
                            format: 21,
                            location: 2
                        }]
                    }, {
                        name: "terrain|shadow-caster-vs:vert|shadow-caster-fs:frag",
                        hash: 3874167763,
                        builtins: {
                            statistics: {
                                CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS: 62,
                                CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS: 0
                            },
                            globals: {
                                blocks: [{
                                    name: "CCGlobal",
                                    defines: []
                                }, {
                                    name: "CCCamera",
                                    defines: []
                                }, {
                                    name: "CCShadow",
                                    defines: []
                                }],
                                samplerTextures: []
                            },
                            locals: {
                                blocks: [{
                                    name: "CCLocal",
                                    defines: []
                                }],
                                samplerTextures: []
                            }
                        },
                        defines: [],
                        blocks: [],
                        samplerTextures: [],
                        attributes: [{
                            name: "a_position",
                            type: 15,
                            count: 1,
                            defines: [],
                            stageFlags: 1,
                            format: 32,
                            location: 0
                        }, {
                            name: "a_normal",
                            type: 15,
                            count: 1,
                            defines: [],
                            stageFlags: 1,
                            format: 32,
                            location: 1
                        }, {
                            name: "a_texCoord",
                            type: 14,
                            count: 1,
                            defines: [],
                            stageFlags: 1,
                            format: 21,
                            location: 2
                        }]
                    }]
                }, {
                    name: "unlit",
                    techniques: [{
                        name: "opaque",
                        passes: [{
                            program: "unlit|unlit-vs:vert|unlit-fs:frag",
                            properties: {
                                mainTexture: {
                                    value: "grey",
                                    type: 28
                                },
                                tilingOffset: {
                                    value: [1, 1, 0, 0],
                                    type: 16
                                },
                                mainColor: {
                                    value: [1, 1, 1, 1],
                                    type: 16
                                },
                                colorScale: {
                                    value: [1, 1, 1],
                                    type: 15,
                                    handleInfo: ["colorScaleAndCutoff", 0, 15]
                                },
                                alphaThreshold: {
                                    value: [.5],
                                    type: 13,
                                    handleInfo: ["colorScaleAndCutoff", 3, 13]
                                },
                                color: {
                                    type: 16,
                                    handleInfo: ["mainColor", 0, 16]
                                },
                                colorScaleAndCutoff: {
                                    type: 16,
                                    value: [1, 1, 1, .5]
                                }
                            }
                        }]
                    }],
                    shaders: [{
                        name: "unlit|unlit-vs:vert|unlit-fs:frag",
                        hash: 3579616855,
                        builtins: {
                            statistics: {
                                CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS: 195,
                                CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS: 39
                            },
                            globals: {
                                blocks: [{
                                    name: "CCGlobal",
                                    defines: []
                                }, {
                                    name: "CCCamera",
                                    defines: []
                                }],
                                samplerTextures: []
                            },
                            locals: {
                                blocks: [{
                                    name: "CCMorph",
                                    defines: ["CC_USE_MORPH"]
                                }, {
                                    name: "CCSkinningTexture",
                                    defines: ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
                                }, {
                                    name: "CCSkinningAnimation",
                                    defines: ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
                                }, {
                                    name: "CCSkinning",
                                    defines: ["CC_USE_SKINNING", "!CC_USE_BAKED_ANIMATION"]
                                }, {
                                    name: "CCLocalBatched",
                                    defines: ["!USE_INSTANCING", "USE_BATCHING"]
                                }, {
                                    name: "CCLocal",
                                    defines: ["!USE_INSTANCING", "!USE_BATCHING"]
                                }],
                                samplerTextures: [{
                                    name: "cc_PositionDisplacements",
                                    defines: ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_POSITION"]
                                }, {
                                    name: "cc_NormalDisplacements",
                                    defines: ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_NORMAL"]
                                }, {
                                    name: "cc_TangentDisplacements",
                                    defines: ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_TANGENT"]
                                }, {
                                    name: "cc_jointTexture",
                                    defines: ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
                                }]
                            }
                        },
                        defines: [{
                            name: "CC_USE_MORPH",
                            type: "boolean"
                        }, {
                            name: "CC_MORPH_TARGET_COUNT",
                            type: "number",
                            range: [2, 8]
                        }, {
                            name: "CC_MORPH_PRECOMPUTED",
                            type: "boolean"
                        }, {
                            name: "CC_MORPH_TARGET_HAS_POSITION",
                            type: "boolean"
                        }, {
                            name: "CC_MORPH_TARGET_HAS_NORMAL",
                            type: "boolean"
                        }, {
                            name: "CC_MORPH_TARGET_HAS_TANGENT",
                            type: "boolean"
                        }, {
                            name: "CC_USE_SKINNING",
                            type: "boolean"
                        }, {
                            name: "CC_USE_BAKED_ANIMATION",
                            type: "boolean"
                        }, {
                            name: "USE_INSTANCING",
                            type: "boolean"
                        }, {
                            name: "USE_BATCHING",
                            type: "boolean"
                        }, {
                            name: "USE_LIGHTMAP",
                            type: "boolean"
                        }, {
                            name: "CC_USE_FOG",
                            type: "number",
                            range: [0, 4]
                        }, {
                            name: "CC_FORWARD_ADD",
                            type: "boolean"
                        }, {
                            name: "USE_VERTEX_COLOR",
                            type: "boolean"
                        }, {
                            name: "USE_TEXTURE",
                            type: "boolean"
                        }, {
                            name: "SAMPLE_FROM_RT",
                            type: "boolean"
                        }, {
                            name: "CC_USE_HDR",
                            type: "boolean"
                        }, {
                            name: "USE_ALPHA_TEST",
                            type: "boolean"
                        }, {
                            name: "ALPHA_TEST_CHANNEL",
                            type: "string",
                            options: ["a", "r", "g", "b"]
                        }],
                        blocks: [{
                            name: "TexCoords",
                            defines: ["USE_TEXTURE"],
                            binding: 0,
                            stageFlags: 1,
                            members: [{
                                name: "tilingOffset",
                                type: 16,
                                count: 1
                            }]
                        }, {
                            name: "Constant",
                            defines: [],
                            binding: 1,
                            stageFlags: 16,
                            members: [{
                                name: "mainColor",
                                type: 16,
                                count: 1
                            }, {
                                name: "colorScaleAndCutoff",
                                type: 16,
                                count: 1
                            }]
                        }],
                        samplerTextures: [{
                            name: "mainTexture",
                            type: 28,
                            count: 1,
                            defines: ["USE_TEXTURE"],
                            stageFlags: 16,
                            binding: 2
                        }],
                        attributes: [{
                            name: "a_position",
                            type: 15,
                            count: 1,
                            defines: [],
                            stageFlags: 1,
                            format: 32,
                            location: 0
                        }, {
                            name: "a_normal",
                            type: 15,
                            count: 1,
                            defines: [],
                            stageFlags: 1,
                            format: 32,
                            location: 1
                        }, {
                            name: "a_texCoord",
                            type: 14,
                            count: 1,
                            defines: [],
                            stageFlags: 1,
                            format: 21,
                            location: 2
                        }, {
                            name: "a_tangent",
                            type: 16,
                            count: 1,
                            defines: [],
                            stageFlags: 1,
                            format: 44,
                            location: 3
                        }, {
                            name: "a_vertexId",
                            type: 13,
                            count: 1,
                            defines: ["CC_USE_MORPH"],
                            stageFlags: 1,
                            format: 11,
                            location: 6
                        }, {
                            name: "a_joints",
                            type: "u32vec4",
                            count: 1,
                            defines: ["CC_USE_SKINNING"],
                            stageFlags: 1,
                            location: 4
                        }, {
                            name: "a_weights",
                            type: 16,
                            count: 1,
                            defines: ["CC_USE_SKINNING"],
                            stageFlags: 1,
                            format: 44,
                            location: 5
                        }, {
                            name: "a_jointAnimInfo",
                            type: 16,
                            count: 1,
                            defines: ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION", "USE_INSTANCING"],
                            stageFlags: 1,
                            format: 44,
                            isInstanced: !0,
                            location: 7
                        }, {
                            name: "a_matWorld0",
                            type: 16,
                            count: 1,
                            defines: ["USE_INSTANCING"],
                            stageFlags: 1,
                            format: 44,
                            isInstanced: !0,
                            location: 8
                        }, {
                            name: "a_matWorld1",
                            type: 16,
                            count: 1,
                            defines: ["USE_INSTANCING"],
                            stageFlags: 1,
                            format: 44,
                            isInstanced: !0,
                            location: 9
                        }, {
                            name: "a_matWorld2",
                            type: 16,
                            count: 1,
                            defines: ["USE_INSTANCING"],
                            stageFlags: 1,
                            format: 44,
                            isInstanced: !0,
                            location: 10
                        }, {
                            name: "a_lightingMapUVParam",
                            type: 16,
                            count: 1,
                            defines: ["USE_INSTANCING", "USE_LIGHTMAP"],
                            stageFlags: 1,
                            format: 44,
                            isInstanced: !0,
                            location: 11
                        }, {
                            name: "a_dyn_batch_id",
                            type: 13,
                            count: 1,
                            defines: ["!USE_INSTANCING", "USE_BATCHING"],
                            stageFlags: 1,
                            format: 11,
                            location: 12
                        }, {
                            name: "a_color",
                            type: 16,
                            count: 1,
                            defines: ["USE_VERTEX_COLOR"],
                            stageFlags: 1,
                            format: 44,
                            location: 13
                        }]
                    }]
                }, {
                    name: "deferred-lighting",
                    techniques: [{
                        passes: [{
                            phase: "deferred-lighting",
                            program: "deferred-lighting|lighting-vs|lighting-fs",
                            depthStencilState: {
                                depthFunc: 4,
                                depthTest: !0,
                                depthWrite: !1
                            }
                        }]
                    }],
                    shaders: [{
                        name: "deferred-lighting|lighting-vs|lighting-fs",
                        hash: 4181944545,
                        builtins: {
                            statistics: {
                                CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS: 37,
                                CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS: 53
                            },
                            globals: {
                                blocks: [{
                                    name: "CCGlobal",
                                    defines: []
                                }, {
                                    name: "CCCamera",
                                    defines: []
                                }, {
                                    name: "CCShadow",
                                    defines: []
                                }],
                                samplerTextures: [{
                                    name: "cc_shadowMap",
                                    defines: ["CC_RECEIVE_SHADOW"]
                                }, {
                                    name: "cc_spotLightingMap",
                                    defines: ["CC_RECEIVE_SHADOW"]
                                }, {
                                    name: "cc_environment",
                                    defines: ["CC_USE_IBL"]
                                }, {
                                    name: "cc_gbuffer_albedoMap",
                                    defines: []
                                }, {
                                    name: "cc_gbuffer_positionMap",
                                    defines: []
                                }, {
                                    name: "cc_gbuffer_normalMap",
                                    defines: []
                                }, {
                                    name: "cc_gbuffer_emissiveMap",
                                    defines: []
                                }]
                            },
                            locals: {
                                blocks: [{
                                    name: "CCForwardLight",
                                    defines: []
                                }],
                                samplerTextures: []
                            }
                        },
                        defines: [{
                            name: "CC_RECEIVE_SHADOW",
                            type: "boolean"
                        }, {
                            name: "CC_USE_IBL",
                            type: "number",
                            range: [0, 2]
                        }, {
                            name: "USE_LIGHTMAP",
                            type: "boolean"
                        }, {
                            name: "USE_BATCHING",
                            type: "boolean"
                        }, {
                            name: "CC_FORWARD_ADD",
                            type: "boolean"
                        }, {
                            name: "CC_USE_HDR",
                            type: "boolean"
                        }, {
                            name: "CC_PIPELINE_TYPE",
                            type: "number",
                            range: [0, 1]
                        }, {
                            name: "CC_USE_FOG",
                            type: "number",
                            range: [0, 4]
                        }],
                        blocks: [],
                        samplerTextures: [],
                        attributes: [{
                            name: "a_position",
                            type: 15,
                            count: 1,
                            defines: [],
                            stageFlags: 1,
                            format: 32,
                            location: 0
                        }, {
                            name: "a_normal",
                            type: 15,
                            count: 1,
                            defines: [],
                            stageFlags: 1,
                            format: 32,
                            location: 1
                        }, {
                            name: "a_texCoord",
                            type: 14,
                            count: 1,
                            defines: [],
                            stageFlags: 1,
                            format: 21,
                            location: 2
                        }, {
                            name: "a_tangent",
                            type: 16,
                            count: 1,
                            defines: [],
                            stageFlags: 1,
                            format: 44,
                            location: 3
                        }]
                    }]
                }, {
                    name: "planar-shadow",
                    techniques: [{
                        passes: [{
                            phase: "planarShadow",
                            blendState: {
                                targets: [{
                                    blend: !0,
                                    blendSrc: 2,
                                    blendDst: 4,
                                    blendDstAlpha: 4
                                }]
                            },
                            program: "planar-shadow|planar-shadow-vs:vert|planar-shadow-fs:frag",
                            depthStencilState: {
                                depthTest: !0,
                                depthWrite: !1,
                                stencilTestFront: !0,
                                stencilFuncFront: 5,
                                stencilPassOpFront: 2,
                                stencilRefBack: 128,
                                stencilRefFront: 128,
                                stencilReadMaskBack: 128,
                                stencilReadMaskFront: 128,
                                stencilWriteMaskBack: 128,
                                stencilWriteMaskFront: 128
                            }
                        }]
                    }],
                    shaders: [{
                        name: "planar-shadow|planar-shadow-vs:vert|planar-shadow-fs:frag",
                        hash: 3940098901,
                        builtins: {
                            statistics: {
                                CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS: 210,
                                CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS: 53
                            },
                            globals: {
                                blocks: [{
                                    name: "CCGlobal",
                                    defines: []
                                }, {
                                    name: "CCCamera",
                                    defines: []
                                }, {
                                    name: "CCShadow",
                                    defines: []
                                }],
                                samplerTextures: []
                            },
                            locals: {
                                blocks: [{
                                    name: "CCMorph",
                                    defines: ["CC_USE_MORPH"]
                                }, {
                                    name: "CCSkinningTexture",
                                    defines: ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
                                }, {
                                    name: "CCSkinningAnimation",
                                    defines: ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
                                }, {
                                    name: "CCSkinning",
                                    defines: ["CC_USE_SKINNING", "!CC_USE_BAKED_ANIMATION"]
                                }, {
                                    name: "CCLocalBatched",
                                    defines: ["!USE_INSTANCING", "USE_BATCHING"]
                                }, {
                                    name: "CCLocal",
                                    defines: ["!USE_INSTANCING", "!USE_BATCHING"]
                                }],
                                samplerTextures: [{
                                    name: "cc_PositionDisplacements",
                                    defines: ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_POSITION"]
                                }, {
                                    name: "cc_NormalDisplacements",
                                    defines: ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_NORMAL"]
                                }, {
                                    name: "cc_TangentDisplacements",
                                    defines: ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_TANGENT"]
                                }, {
                                    name: "cc_jointTexture",
                                    defines: ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
                                }]
                            }
                        },
                        defines: [{
                            name: "CC_USE_MORPH",
                            type: "boolean"
                        }, {
                            name: "CC_MORPH_TARGET_COUNT",
                            type: "number",
                            range: [2, 8]
                        }, {
                            name: "CC_MORPH_PRECOMPUTED",
                            type: "boolean"
                        }, {
                            name: "CC_MORPH_TARGET_HAS_POSITION",
                            type: "boolean"
                        }, {
                            name: "CC_MORPH_TARGET_HAS_NORMAL",
                            type: "boolean"
                        }, {
                            name: "CC_MORPH_TARGET_HAS_TANGENT",
                            type: "boolean"
                        }, {
                            name: "CC_USE_SKINNING",
                            type: "boolean"
                        }, {
                            name: "CC_USE_BAKED_ANIMATION",
                            type: "boolean"
                        }, {
                            name: "USE_INSTANCING",
                            type: "boolean"
                        }, {
                            name: "USE_BATCHING",
                            type: "boolean"
                        }, {
                            name: "USE_LIGHTMAP",
                            type: "boolean"
                        }, {
                            name: "CC_USE_HDR",
                            type: "boolean"
                        }],
                        blocks: [],
                        samplerTextures: [],
                        attributes: [{
                            name: "a_position",
                            type: 15,
                            count: 1,
                            defines: [],
                            stageFlags: 1,
                            format: 32,
                            location: 0
                        }, {
                            name: "a_normal",
                            type: 15,
                            count: 1,
                            defines: [],
                            stageFlags: 1,
                            format: 32,
                            location: 1
                        }, {
                            name: "a_texCoord",
                            type: 14,
                            count: 1,
                            defines: [],
                            stageFlags: 1,
                            format: 21,
                            location: 2
                        }, {
                            name: "a_tangent",
                            type: 16,
                            count: 1,
                            defines: [],
                            stageFlags: 1,
                            format: 44,
                            location: 3
                        }, {
                            name: "a_vertexId",
                            type: 13,
                            count: 1,
                            defines: ["CC_USE_MORPH"],
                            stageFlags: 1,
                            format: 11,
                            location: 6
                        }, {
                            name: "a_joints",
                            type: "u32vec4",
                            count: 1,
                            defines: ["CC_USE_SKINNING"],
                            stageFlags: 1,
                            location: 4
                        }, {
                            name: "a_weights",
                            type: 16,
                            count: 1,
                            defines: ["CC_USE_SKINNING"],
                            stageFlags: 1,
                            format: 44,
                            location: 5
                        }, {
                            name: "a_jointAnimInfo",
                            type: 16,
                            count: 1,
                            defines: ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION", "USE_INSTANCING"],
                            stageFlags: 1,
                            format: 44,
                            isInstanced: !0,
                            location: 7
                        }, {
                            name: "a_matWorld0",
                            type: 16,
                            count: 1,
                            defines: ["USE_INSTANCING"],
                            stageFlags: 1,
                            format: 44,
                            isInstanced: !0,
                            location: 8
                        }, {
                            name: "a_matWorld1",
                            type: 16,
                            count: 1,
                            defines: ["USE_INSTANCING"],
                            stageFlags: 1,
                            format: 44,
                            isInstanced: !0,
                            location: 9
                        }, {
                            name: "a_matWorld2",
                            type: 16,
                            count: 1,
                            defines: ["USE_INSTANCING"],
                            stageFlags: 1,
                            format: 44,
                            isInstanced: !0,
                            location: 10
                        }, {
                            name: "a_lightingMapUVParam",
                            type: 16,
                            count: 1,
                            defines: ["USE_INSTANCING", "USE_LIGHTMAP"],
                            stageFlags: 1,
                            format: 44,
                            isInstanced: !0,
                            location: 11
                        }, {
                            name: "a_dyn_batch_id",
                            type: 13,
                            count: 1,
                            defines: ["!USE_INSTANCING", "USE_BATCHING"],
                            stageFlags: 1,
                            format: 11,
                            location: 12
                        }]
                    }]
                }, {
                    name: "post-process",
                    techniques: [{
                        passes: [{
                            phase: "post-process",
                            blendState: {
                                targets: [{
                                    blend: !0,
                                    blendSrc: 2,
                                    blendDst: 4,
                                    blendSrcAlpha: 2,
                                    blendDstAlpha: 4
                                }]
                            },
                            program: "post-process|post-process-vs|post-process-fs",
                            depthStencilState: {
                                depthTest: !1,
                                depthWrite: !1
                            }
                        }]
                    }],
                    shaders: [{
                        name: "post-process|post-process-vs|post-process-fs",
                        hash: 2054814724,
                        builtins: {
                            statistics: {
                                CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS: 145,
                                CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS: 37
                            },
                            globals: {
                                blocks: [{
                                    name: "CCGlobal",
                                    defines: []
                                }, {
                                    name: "CCCamera",
                                    defines: []
                                }],
                                samplerTextures: [{
                                    name: "cc_lighting_resultMap",
                                    defines: []
                                }]
                            },
                            locals: {
                                blocks: [{
                                    name: "CCMorph",
                                    defines: ["CC_USE_MORPH"]
                                }, {
                                    name: "CCSkinningTexture",
                                    defines: ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
                                }, {
                                    name: "CCSkinningAnimation",
                                    defines: ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
                                }, {
                                    name: "CCSkinning",
                                    defines: ["CC_USE_SKINNING", "!CC_USE_BAKED_ANIMATION"]
                                }],
                                samplerTextures: [{
                                    name: "cc_PositionDisplacements",
                                    defines: ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_POSITION"]
                                }, {
                                    name: "cc_NormalDisplacements",
                                    defines: ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_NORMAL"]
                                }, {
                                    name: "cc_TangentDisplacements",
                                    defines: ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_TANGENT"]
                                }, {
                                    name: "cc_jointTexture",
                                    defines: ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
                                }]
                            }
                        },
                        defines: [{
                            name: "CC_USE_MORPH",
                            type: "boolean"
                        }, {
                            name: "CC_MORPH_TARGET_COUNT",
                            type: "number",
                            range: [2, 8]
                        }, {
                            name: "CC_MORPH_PRECOMPUTED",
                            type: "boolean"
                        }, {
                            name: "CC_MORPH_TARGET_HAS_POSITION",
                            type: "boolean"
                        }, {
                            name: "CC_MORPH_TARGET_HAS_NORMAL",
                            type: "boolean"
                        }, {
                            name: "CC_MORPH_TARGET_HAS_TANGENT",
                            type: "boolean"
                        }, {
                            name: "CC_USE_SKINNING",
                            type: "boolean"
                        }, {
                            name: "CC_USE_BAKED_ANIMATION",
                            type: "boolean"
                        }, {
                            name: "USE_INSTANCING",
                            type: "boolean"
                        }],
                        blocks: [],
                        samplerTextures: [],
                        attributes: [{
                            name: "a_position",
                            type: 15,
                            count: 1,
                            defines: [],
                            stageFlags: 1,
                            format: 32,
                            location: 0
                        }, {
                            name: "a_normal",
                            type: 15,
                            count: 1,
                            defines: [],
                            stageFlags: 1,
                            format: 32,
                            location: 1
                        }, {
                            name: "a_texCoord",
                            type: 14,
                            count: 1,
                            defines: [],
                            stageFlags: 1,
                            format: 21,
                            location: 2
                        }, {
                            name: "a_tangent",
                            type: 16,
                            count: 1,
                            defines: [],
                            stageFlags: 1,
                            format: 44,
                            location: 3
                        }, {
                            name: "a_vertexId",
                            type: 13,
                            count: 1,
                            defines: ["CC_USE_MORPH"],
                            stageFlags: 1,
                            format: 11,
                            location: 6
                        }, {
                            name: "a_joints",
                            type: "u32vec4",
                            count: 1,
                            defines: ["CC_USE_SKINNING"],
                            stageFlags: 1,
                            location: 4
                        }, {
                            name: "a_weights",
                            type: 16,
                            count: 1,
                            defines: ["CC_USE_SKINNING"],
                            stageFlags: 1,
                            format: 44,
                            location: 5
                        }, {
                            name: "a_jointAnimInfo",
                            type: 16,
                            count: 1,
                            defines: ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION", "USE_INSTANCING"],
                            stageFlags: 1,
                            format: 44,
                            isInstanced: !0,
                            location: 7
                        }]
                    }]
                }, {
                    name: "skybox",
                    techniques: [{
                        passes: [{
                            rasterizerState: {
                                cullMode: 0
                            },
                            program: "skybox|sky-vs:vert|sky-fs:frag",
                            priority: 245,
                            depthStencilState: {
                                depthTest: !0,
                                depthWrite: !1
                            }
                        }]
                    }],
                    shaders: [{
                        name: "skybox|sky-vs:vert|sky-fs:frag",
                        hash: 553035852,
                        builtins: {
                            statistics: {
                                CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS: 37,
                                CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS: 37
                            },
                            globals: {
                                blocks: [{
                                    name: "CCGlobal",
                                    defines: []
                                }, {
                                    name: "CCCamera",
                                    defines: []
                                }],
                                samplerTextures: [{
                                    name: "cc_environment",
                                    defines: []
                                }]
                            },
                            locals: {
                                blocks: [],
                                samplerTextures: []
                            }
                        },
                        defines: [{
                            name: "CC_USE_IBL",
                            type: "number",
                            range: [0, 2]
                        }, {
                            name: "CC_USE_HDR",
                            type: "boolean"
                        }, {
                            name: "USE_RGBE_CUBEMAP",
                            type: "boolean"
                        }],
                        blocks: [],
                        samplerTextures: [],
                        attributes: [{
                            name: "a_position",
                            type: 15,
                            count: 1,
                            defines: [],
                            stageFlags: 1,
                            format: 32,
                            location: 0
                        }, {
                            name: "a_normal",
                            type: 15,
                            count: 1,
                            defines: [],
                            stageFlags: 1,
                            format: 32,
                            location: 1
                        }, {
                            name: "a_texCoord",
                            type: 14,
                            count: 1,
                            defines: [],
                            stageFlags: 1,
                            format: 21,
                            location: 2
                        }, {
                            name: "a_tangent",
                            type: 16,
                            count: 1,
                            defines: [],
                            stageFlags: 1,
                            format: 44,
                            location: 3
                        }]
                    }]
                }, {
                    name: "profiler",
                    techniques: [{
                        passes: [{
                            blendState: {
                                targets: [{
                                    blend: !0,
                                    blendSrc: 2,
                                    blendDst: 4,
                                    blendDstAlpha: 4
                                }]
                            },
                            rasterizerState: {
                                cullMode: 0
                            },
                            program: "profiler|profiler-vs:vert|profiler-fs:frag",
                            depthStencilState: {
                                depthTest: !1,
                                depthWrite: !1
                            }
                        }]
                    }],
                    shaders: [{
                        name: "profiler|profiler-vs:vert|profiler-fs:frag",
                        hash: 3108604430,
                        builtins: {
                            statistics: {
                                CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS: 58,
                                CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS: 37
                            },
                            globals: {
                                blocks: [{
                                    name: "CCGlobal",
                                    defines: []
                                }, {
                                    name: "CCCamera",
                                    defines: []
                                }],
                                samplerTextures: []
                            },
                            locals: {
                                blocks: [],
                                samplerTextures: []
                            }
                        },
                        defines: [{
                            name: "CC_USE_HDR",
                            type: "boolean"
                        }],
                        blocks: [{
                            name: "Constants",
                            defines: [],
                            binding: 0,
                            stageFlags: 1,
                            members: [{
                                name: "offset",
                                type: 16,
                                count: 1
                            }]
                        }, {
                            name: "PerFrameInfo",
                            defines: [],
                            binding: 1,
                            stageFlags: 1,
                            members: [{
                                name: "digits",
                                type: 16,
                                count: 20
                            }]
                        }],
                        samplerTextures: [{
                            name: "mainTexture",
                            type: 28,
                            count: 1,
                            defines: [],
                            stageFlags: 16,
                            binding: 2
                        }],
                        attributes: [{
                            name: "a_position",
                            type: 15,
                            count: 1,
                            defines: [],
                            stageFlags: 1,
                            format: 32,
                            location: 0
                        }, {
                            name: "a_color",
                            type: 16,
                            count: 1,
                            defines: [],
                            stageFlags: 1,
                            format: 44,
                            location: 1
                        }]
                    }]
                }, {
                    name: "splash-screen",
                    techniques: [{
                        name: "default",
                        passes: [{
                            blendState: {
                                targets: [{
                                    blend: !0,
                                    blendSrc: 2,
                                    blendDst: 4,
                                    blendDstAlpha: 4
                                }]
                            },
                            rasterizerState: {
                                cullMode: 0
                            },
                            program: "splash-screen|splash-screen-vs:vert|splash-screen-fs:frag",
                            depthStencilState: {
                                depthTest: !1,
                                depthWrite: !1
                            },
                            properties: {
                                mainTexture: {
                                    value: "grey",
                                    type: 28
                                },
                                resolution: {
                                    value: [640, 960],
                                    type: 14,
                                    handleInfo: ["u_buffer0", 0, 14]
                                },
                                precent: {
                                    value: [.5],
                                    type: 13,
                                    handleInfo: ["u_buffer0", 2, 13]
                                },
                                scale: {
                                    value: [200, 500],
                                    type: 14,
                                    handleInfo: ["u_buffer1", 0, 14]
                                },
                                translate: {
                                    value: [320, 480],
                                    type: 14,
                                    handleInfo: ["u_buffer1", 2, 14]
                                },
                                u_buffer0: {
                                    type: 16,
                                    value: [640, 960, .5, 0]
                                },
                                u_buffer1: {
                                    type: 16,
                                    value: [200, 500, 320, 480]
                                }
                            }
                        }]
                    }],
                    shaders: [{
                        name: "splash-screen|splash-screen-vs:vert|splash-screen-fs:frag",
                        hash: 624029864,
                        builtins: {
                            statistics: {
                                CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS: 6,
                                CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS: 0
                            },
                            globals: {
                                blocks: [],
                                samplerTextures: []
                            },
                            locals: {
                                blocks: [],
                                samplerTextures: []
                            }
                        },
                        defines: [],
                        blocks: [{
                            name: "Constant",
                            defines: [],
                            binding: 0,
                            stageFlags: 1,
                            members: [{
                                name: "u_buffer0",
                                type: 16,
                                count: 1
                            }, {
                                name: "u_buffer1",
                                type: 16,
                                count: 1
                            }, {
                                name: "u_projection",
                                type: 25,
                                count: 1
                            }]
                        }],
                        samplerTextures: [{
                            name: "mainTexture",
                            type: 28,
                            count: 1,
                            defines: [],
                            stageFlags: 16,
                            binding: 1
                        }],
                        attributes: [{
                            name: "a_position",
                            type: 14,
                            count: 1,
                            defines: [],
                            stageFlags: 1,
                            format: 21,
                            location: 0
                        }, {
                            name: "a_texCoord",
                            type: 14,
                            count: 1,
                            defines: [],
                            stageFlags: 1,
                            format: 21,
                            location: 1
                        }]
                    }]
                }]),
                bp = 4026531840,
                Rp = 264241152,
                wp = 3145728,
                Ip = 1032192;
            ! function(e) {
                e[e.BUFFER = 0] = "BUFFER", e[e.TEXTURE = 1] = "TEXTURE"
            }(xp || (xp = {}));
            var Pp = function(e, t, n, i, r) {
                    return void 0 === r && (r = 0), e << 28 & bp | i << 22 & Rp | t << 20 & wp | n << 14 & Ip | 16383 & r
                },
                Op = function(e) {
                    return (e & bp) >>> 28
                },
                Dp = function(e) {
                    return (e & Rp) >>> 22
                },
                Np = function(e) {
                    return (e & Ip) >>> 14
                },
                Mp = function(e) {
                    return 16383 & e
                },
                Lp = function(e, t) {
                    return e & ~Rp | t << 22 & Rp
                },
                Bp = ((Tp = {})[Aa.UNKNOWN] = function() {
                    return console.warn("illegal uniform handle")
                }, Tp[Aa.INT] = function(e, t, n) {
                    return void 0 === n && (n = 0), e[n]
                }, Tp[Aa.INT2] = function(e, t, n) {
                    return void 0 === n && (n = 0), Gn.fromArray(t, e, n)
                }, Tp[Aa.INT3] = function(e, t, n) {
                    return void 0 === n && (n = 0), En.fromArray(t, e, n)
                }, Tp[Aa.INT4] = function(e, t, n) {
                    return void 0 === n && (n = 0), Wn.fromArray(t, e, n)
                }, Tp[Aa.FLOAT] = function(e, t, n) {
                    return void 0 === n && (n = 0), e[n]
                }, Tp[Aa.FLOAT2] = function(e, t, n) {
                    return void 0 === n && (n = 0), Gn.fromArray(t, e, n)
                }, Tp[Aa.FLOAT3] = function(e, t, n) {
                    return void 0 === n && (n = 0), En.fromArray(t, e, n)
                }, Tp[Aa.FLOAT4] = function(e, t, n) {
                    return void 0 === n && (n = 0), Wn.fromArray(t, e, n)
                }, Tp[Aa.MAT3] = function(e, t, n) {
                    return void 0 === n && (n = 0), Cn.fromArray(t, e, n)
                }, Tp[Aa.MAT4] = function(e, t, n) {
                    return void 0 === n && (n = 0), Bn.fromArray(t, e, n)
                }, Tp),
                Fp = ((Ap = {})[Aa.UNKNOWN] = function() {
                    return console.warn("illegal uniform handle")
                }, Ap[Aa.INT] = function(e, t, n) {
                    return void 0 === n && (n = 0), e[n] = t
                }, Ap[Aa.INT2] = function(e, t, n) {
                    return void 0 === n && (n = 0), Gn.toArray(e, t, n)
                }, Ap[Aa.INT3] = function(e, t, n) {
                    return void 0 === n && (n = 0), En.toArray(e, t, n)
                }, Ap[Aa.INT4] = function(e, t, n) {
                    return void 0 === n && (n = 0), Wn.toArray(e, t, n)
                }, Ap[Aa.FLOAT] = function(e, t, n) {
                    return void 0 === n && (n = 0), e[n] = t
                }, Ap[Aa.FLOAT2] = function(e, t, n) {
                    return void 0 === n && (n = 0), Gn.toArray(e, t, n)
                }, Ap[Aa.FLOAT3] = function(e, t, n) {
                    return void 0 === n && (n = 0), En.toArray(e, t, n)
                }, Ap[Aa.FLOAT4] = function(e, t, n) {
                    return void 0 === n && (n = 0), Wn.toArray(e, t, n)
                }, Ap[Aa.MAT3] = function(e, t, n) {
                    return void 0 === n && (n = 0), Cn.toArray(e, t, n)
                }, Ap[Aa.MAT4] = function(e, t, n) {
                    return void 0 === n && (n = 0), Bn.toArray(e, t, n)
                }, Ap),
                zp = [Object.freeze([0]), Object.freeze([0, 0]), Object.freeze([0, 0, 0, 0]), Object.freeze([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])];

            function Up(e) {
                switch (e) {
                    case Aa.BOOL:
                    case Aa.INT:
                    case Aa.UINT:
                    case Aa.FLOAT:
                        return zp[0];
                    case Aa.BOOL2:
                    case Aa.INT2:
                    case Aa.UINT2:
                    case Aa.FLOAT2:
                        return zp[1];
                    case Aa.BOOL4:
                    case Aa.INT4:
                    case Aa.UINT4:
                    case Aa.FLOAT4:
                        return zp[2];
                    case Aa.MAT4:
                        return zp[3];
                    case Aa.SAMPLER2D:
                        return "default-texture";
                    case Aa.SAMPLER_CUBE:
                        return "default-cube-texture"
                }
                return zp[0]
            }

            function Gp(e, t) {
                for (var n = Object.entries(t), i = !1, r = 0; r < n.length; r++) e[n[r][0]] !== n[r][1] && (e[n[r][0]] = n[r][1], i = !0);
                return i
            }
            var Hp = new js;

            function kp(e) {
                return Math.ceil(Math.log2(Math.max(e, 2)))
            }

            function Vp(e, t) {
                switch (e.type) {
                    case "boolean":
                        return "number" == typeof t ? t.toString() : t ? "1" : "0";
                    case "string":
                        return void 0 !== t ? t : e.options[0];
                    case "number":
                        return void 0 !== t ? t.toString() : e.range[0].toString();
                    default:
                        return console.warn("unknown define type '" + e.type + "'"), "-1"
                }
            }

            function Wp(e, t, n, i, r) {
                for (var o = e.builtins[i], a = [], s = function(e) {
                        var t = o.blocks[e],
                            i = n.layouts[t.name],
                            s = i && n.bindings.find((function(e) {
                                return e.binding === i.binding
                            }));
                        if (!(i && s && s.descriptorType & nc)) return console.warn("builtin UBO '" + t.name + "' not available!"), "continue";
                        a.push(i), r && !r.includes(s) && r.push(s)
                    }, c = 0; c < o.blocks.length; c++) s(c);
                Array.prototype.unshift.apply(t.gfxBlocks, a);
                for (var l = [], u = function(e) {
                        var t = o.samplerTextures[e],
                            i = n.layouts[t.name],
                            a = i && n.bindings.find((function(e) {
                                return e.binding === i.binding
                            }));
                        if (!(i && a && a.descriptorType & ic)) return console.warn("builtin samplerTexture '" + t.name + "' not available!"), "continue";
                        l.push(i), r && !r.includes(a) && r.push(a)
                    }, h = 0; h < o.samplerTextures.length; h++) u(h);
                Array.prototype.unshift.apply(t.gfxSamplerTextures, l), r && r.sort((function(e, t) {
                    return e.binding - t.binding
                }))
            }

            function jp(e) {
                return e.members.reduce((function(e, t) {
                    return e + lc(t.type) * t.count
                }), 0)
            }

            function qp(e, t) {
                for (var n = 0; n < e.length; n++) {
                    var i = e[n];
                    if ("!" === i[0]) {
                        if (t[i.slice(1)]) return !1
                    } else if (!t[i]) return !1
                }
                return !0
            }

            function Xp(e) {
                switch (e.gfxAPI) {
                    case va.GLES2:
                    case va.WEBGL:
                        return "glsl1";
                    case va.GLES3:
                    case va.WEBGL2:
                        return "glsl3";
                    default:
                        return "glsl4"
                }
            }
            var Yp = new(function() {
                function e() {
                    this._templates = {}, this._cache = {}, this._templateInfos = {}
                }
                var t = e.prototype;
                return t.register = function(e) {
                    for (var t = 0; t < e.shaders.length; t++) this.define(e.shaders[t]).effectName = e.name
                }, t.define = function(e) {
                    var t = this._templates[e.name];
                    if (t && t.hash === e.hash) return t;
                    for (var n = Z({}, e), i = 0, r = function(e) {
                            var t = n.defines[e],
                                r = 1;
                            if ("number" === t.type) {
                                var o = t.range;
                                r = kp(o[1] - o[0] + 1), t._map = function(e) {
                                    return e - o[0]
                                }
                            } else "string" === t.type ? (r = kp(t.options.length), t._map = function(e) {
                                return Math.max(0, t.options.findIndex((function(t) {
                                    return t === e
                                })))
                            }) : "boolean" === t.type && (t._map = function(e) {
                                return e ? 1 : 0
                            });
                            t._offset = i, i += r
                        }, o = 0; o < n.defines.length; o++) r(o);
                    for (var a in i > 31 && (n.uber = !0), n.constantMacros = "", n.builtins.statistics) n.constantMacros += "#define " + a + " " + n.builtins.statistics[a] + "\n";
                    if (this._templates[e.name] = n, !this._templateInfos[n.hash]) {
                        var s = {};
                        s.samplerStartBinding = n.blocks.length, s.gfxBlocks = [], s.gfxSamplerTextures = [], s.bindings = [], s.blockSizes = [];
                        for (var c = 0; c < n.blocks.length; c++) {
                            var l = n.blocks[c];
                            s.blockSizes.push(jp(l)), s.bindings.push(new Ws(l.binding, l.descriptorType || Za.UNIFORM_BUFFER, 1, l.stageFlags)), s.gfxBlocks.push(new bs(Vu.MATERIAL, l.binding, l.name, l.members.map((function(e) {
                                return new Cs(e.name, e.type, e.count)
                            })), 1))
                        }
                        for (var u = 0; u < n.samplerTextures.length; u++) {
                            var h = n.samplerTextures[u];
                            s.bindings.push(new Ws(h.binding, h.descriptorType || Za.SAMPLER_TEXTURE, h.count, h.stageFlags)), s.gfxSamplerTextures.push(new Rs(Vu.MATERIAL, h.binding, h.name, h.type, h.count))
                        }
                        s.gfxAttributes = [];
                        for (var _ = 0; _ < n.attributes.length; _++) {
                            var f = n.attributes[_];
                            s.gfxAttributes.push(new Ms(f.name, f.format, f.isNormalized, 0, f.isInstanced, f.location))
                        }
                        Wp(n, s, Uu, "locals"), s.gfxStages = [], s.gfxStages.push(new Ns(Ua.VERTEX, "")), s.gfxStages.push(new Ns(Ua.FRAGMENT, "")), s.handleMap = function(e) {
                            for (var t = {}, n = 0; n < e.blocks.length; n++)
                                for (var i = e.blocks[n], r = i.members, o = 0, a = 0; a < r.length; a++) {
                                    var s = r[a];
                                    t[s.name] = Pp(xp.BUFFER, Vu.MATERIAL, i.binding, s.type, o), o += (lc(s.type) >> 2) * s.count
                                }
                            for (var c = 0; c < e.samplerTextures.length; c++) {
                                var l = e.samplerTextures[c];
                                t[l.name] = Pp(xp.TEXTURE, Vu.MATERIAL, l.binding, l.type)
                            }
                            return t
                        }(n), s.hPipelineLayout = 0, s.setLayouts = [], this._templateInfos[n.hash] = s
                    }
                    return n
                }, t.getTemplate = function(e) {
                    return this._templates[e]
                }, t.getTemplateInfo = function(e) {
                    var t = this._templates[e].hash;
                    return this._templateInfos[t]
                }, t.getDescriptorSetLayout = function(e, t, n) {
                    void 0 === n && (n = !1);
                    var i = this._templates[t],
                        r = this._templateInfos[i.hash];
                    return r.setLayouts.length || (Hp.bindings = r.bindings, r.setLayouts[Vu.MATERIAL] = e.createDescriptorSetLayout(Hp), Hp.bindings = Uu.bindings, r.setLayouts[Vu.LOCAL] = e.createDescriptorSetLayout(Hp)), r.setLayouts[n ? Vu.LOCAL : Vu.MATERIAL]
                }, t.hasProgram = function(e) {
                    return void 0 !== this._templates[e]
                }, t.getKey = function(e, t) {
                    var n = this._templates[e],
                        i = n.defines;
                    if (n.uber) {
                        for (var r = "", o = 0; o < i.length; o++) {
                            var a = i[o],
                                s = t[a.name];
                            if (s && a._map) {
                                var c = a._map(s);
                                r += "" + a._offset + c + "|"
                            }
                        }
                        return "" + r + n.hash
                    }
                    for (var l = 0, u = 0; u < i.length; u++) {
                        var h = i[u],
                            _ = t[h.name];
                        _ && h._map && (l |= h._map(_) << h._offset)
                    }
                    return l.toString(16) + "|" + n.hash
                }, t.destroyShaderByDefines = function(e) {
                    var t = this,
                        n = Object.keys(e);
                    if (n.length)
                        for (var i = n.map((function(t) {
                                var n = e[t];
                                return "boolean" == typeof n && (n = n ? "1" : "0"), new RegExp("" + t + n)
                            })), r = Object.keys(this._cache).filter((function(e) {
                                return i.every((function(n) {
                                    return n.test(vr.get(t._cache[e]).name)
                                }))
                            })), o = 0; o < r.length; o++) {
                            var a = r[o],
                                s = vr.get(this._cache[a]);
                            console.log("destroyed shader " + s.name), s.destroy(), delete this._cache[a]
                        }
                }, t.getGFXShader = function(e, t, n, i, r) {
                    Object.assign(n, i.macros), r || (r = this.getKey(t, n));
                    var o = this._cache[r];
                    if (o) return o;
                    var a = this._templates[t],
                        s = this._templateInfos[a.hash];
                    s.hPipelineLayout || (this.getDescriptorSetLayout(e, t), Wp(a, s, zu, "globals"), s.setLayouts[Vu.GLOBAL] = i.descriptorSetLayout, s.hPipelineLayout = Er.alloc(e, new Xs(s.setLayouts)));
                    var c = function(e, t) {
                            for (var n = [], i = 0; i < t.length; i++) {
                                var r = t[i],
                                    o = r.name,
                                    a = e[o],
                                    s = Vp(r, a),
                                    c = !a || "0" === a;
                                n.push({
                                    name: o,
                                    value: s,
                                    isDefault: c
                                })
                            }
                            return n
                        }(n, a.defines),
                        l = i.constantMacros + a.constantMacros + c.reduce((function(e, t) {
                            return e + "#define " + t.name + " " + t.value + "\n"
                        }), ""),
                        u = a.glsl3,
                        h = Xp(e);
                    h ? u = a[h] : console.error("Invalid GFX API!"), s.gfxStages[0].source = l + u.vert, s.gfxStages[1].source = l + u.frag;
                    var _ = function(e, t, n) {
                            for (var i = [], r = e.attributes, o = t.gfxAttributes, a = 0; a < r.length; a++) qp(r[a].defines, n) && i.push(o[a]);
                            return i
                        }(a, s, n),
                        f = function(e, t) {
                            return e + t.reduce((function(e, t) {
                                return t.isDefault ? e : e + "|" + t.name + t.value
                            }), "")
                        }(t, c),
                        d = new Ls(f, s.gfxStages, _, s.gfxBlocks);
                    return d.samplerTextures = s.gfxSamplerTextures, this._cache[r] = vr.alloc(e, d)
                }, e
            }());
            i.programLib = Yp;
            var Kp, Zp, Qp, Jp = {
                    glsl1: [
                        [{
                            vert: "\nprecision mediump float;\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matViewInv;\nuniform highp mat4 cc_matViewProj;\nuniform highp mat4 cc_matWorld;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\nmat3 m = mat3(xAxis,yAxis,zAxis);\nfloat trace = m[0][0] + m[1][1] + m[2][2];\nvec4 quat;\nif (trace > 0.) {\nfloat s = 0.5 / sqrt(trace + 1.0);\nquat.w = 0.25 / s;\nquat.x = (m[2][1] - m[1][2]) * s;\nquat.y = (m[0][2] - m[2][0]) * s;\nquat.z = (m[1][0] - m[0][1]) * s;\n} else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\nfloat s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\nquat.w = (m[2][1] - m[1][2]) / s;\nquat.x = 0.25 * s;\nquat.y = (m[0][1] + m[1][0]) / s;\nquat.z = (m[0][2] + m[2][0]) / s;\n} else if (m[1][1] > m[2][2]) {\nfloat s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\nquat.w = (m[0][2] - m[2][0]) / s;\nquat.x = (m[0][1] + m[1][0]) / s;\nquat.y = 0.25 * s;\nquat.z = (m[1][2] + m[2][1]) / s;\n} else {\nfloat s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\nquat.w = (m[1][0] - m[0][1]) / s;\nquat.x = (m[0][2] + m[2][0]) / s;\nquat.y = (m[1][2] + m[2][1]) / s;\nquat.z = 0.25 * s;\n}\nfloat len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\nif (len > 0.) {\nlen = 1. / sqrt(len);\nquat.x = quat.x * len;\nquat.y = quat.y * len;\nquat.z = quat.z * len;\nquat.w = quat.w * len;\n}\nreturn quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\nfloat x = angle.x / 2.;\nfloat y = angle.y / 2.;\nfloat z = angle.z / 2.;\nfloat sx = sin(x);\nfloat cx = cos(x);\nfloat sy = sin(y);\nfloat cy = cos(y);\nfloat sz = sin(z);\nfloat cz = cos(z);\nvec4 quat = vec4(0);\nquat.x = sx * cy * cz + cx * sy * sz;\nquat.y = cx * sy * cz + sx * cy * sz;\nquat.z = cx * cy * sz - sx * sy * cz;\nquat.w = cx * cy * cz - sx * sy * sz;\nreturn quat;\n}\nvec4 quatMultiply (vec4 a, vec4 b){\nvec4 quat;\nquat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\nquat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\nquat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\nquat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\nreturn quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\nfloat ix = q.w * v.x + q.y * v.z - q.z * v.y;\nfloat iy = q.w * v.y + q.z * v.x - q.x * v.z;\nfloat iz = q.w * v.z + q.x * v.y - q.y * v.x;\nfloat iw = -q.x * v.x - q.y * v.y - q.z * v.z;\nv.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\nv.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\nv.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\nvec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\nvec4 rotQuat = quatMultiply(viewQuat, q);\nrotateVecFromQuat(pos, rotQuat);\nreturn pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\nfloat xOS = cos(angle) * corner.x - sin(angle) * corner.y;\nfloat yOS = sin(angle) * corner.x + cos(angle) * corner.y;\ncorner.x = xOS;\ncorner.y = yOS;\n}\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n, mat4 viewInv\n) {\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nvec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\nvec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\nvec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\npos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n}\nattribute vec3 a_position;\nattribute vec2 a_texCoord;\nattribute vec4 a_color;\nuniform vec4 cc_size_rotation;\nvec4 vs_main() {\nvec4 pos = vec4(a_position, 1);\npos = cc_matWorld * pos;\nvec2 vertOffset = a_texCoord.xy - 0.5;\ncomputeVertPos(pos, vertOffset, quaternionFromEuler(vec3(0., 0., cc_size_rotation.z)), vec3(cc_size_rotation.xy, 0.), cc_matViewInv);\npos = cc_matViewProj * pos;\nuv = a_texCoord.xy;\ncolor = a_color;\nreturn pos;\n}\nvoid main() { gl_Position = vs_main(); }",
                            frag: "\nprecision mediump float;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n#endif\nreturn color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\nuniform vec4 tintColor;\nvec4 add () {\nvec4 col = 2.0 * color * tintColor * texture2D(mainTexture, uv);\nreturn CCFragOutput(col);\n}\nvoid main() { gl_FragColor = add(); }"
                        }],
                        [{
                            vert: "\nprecision highp float;\nattribute vec3 a_position;\nvec4 vert () {\nvec4 pos = vec4(a_position, 1);\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
                            frag: "\nprecision highp float;\nvec4 frag () {\nvec4 o = vec4(1.0);\nreturn o;\n}\nvoid main() { gl_FragColor = frag(); }"
                        }],
                        [{
                            vert: "\nprecision highp float;\nuniform highp mat4 cc_matViewProj;\nuniform highp mat4 cc_matWorld;\nattribute vec3 a_position;\nattribute vec4 a_color;\nvarying vec4 v_color;\nattribute float a_dist;\nvarying float v_dist;\nvec4 vert () {\nvec4 pos = vec4(a_position, 1);\npos = cc_matViewProj * cc_matWorld * pos;\nv_color = a_color;\nv_dist = a_dist;\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
                            frag: "\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives: enable\n#endif\nprecision highp float;\nvarying vec4 v_color;\nvarying float v_dist;\nvec4 frag () {\nvec4 o = v_color;\n#ifdef GL_OES_standard_derivatives\nfloat aa = fwidth(v_dist);\n#else\nfloat aa = 0.05;\n#endif\nfloat alpha = 1. - smoothstep(-aa, 0., abs(v_dist) - 1.0);\no.rgb *= o.a;\no *= alpha;\nreturn o;\n}\nvoid main() { gl_FragColor = frag(); }"
                        }],
                        [{
                            vert: "\nprecision mediump float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\nmat3 m = mat3(xAxis,yAxis,zAxis);\nfloat trace = m[0][0] + m[1][1] + m[2][2];\nvec4 quat;\nif (trace > 0.) {\nfloat s = 0.5 / sqrt(trace + 1.0);\nquat.w = 0.25 / s;\nquat.x = (m[2][1] - m[1][2]) * s;\nquat.y = (m[0][2] - m[2][0]) * s;\nquat.z = (m[1][0] - m[0][1]) * s;\n} else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\nfloat s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\nquat.w = (m[2][1] - m[1][2]) / s;\nquat.x = 0.25 * s;\nquat.y = (m[0][1] + m[1][0]) / s;\nquat.z = (m[0][2] + m[2][0]) / s;\n} else if (m[1][1] > m[2][2]) {\nfloat s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\nquat.w = (m[0][2] - m[2][0]) / s;\nquat.x = (m[0][1] + m[1][0]) / s;\nquat.y = 0.25 * s;\nquat.z = (m[1][2] + m[2][1]) / s;\n} else {\nfloat s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\nquat.w = (m[1][0] - m[0][1]) / s;\nquat.x = (m[0][2] + m[2][0]) / s;\nquat.y = (m[1][2] + m[2][1]) / s;\nquat.z = 0.25 * s;\n}\nfloat len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\nif (len > 0.) {\nlen = 1. / sqrt(len);\nquat.x = quat.x * len;\nquat.y = quat.y * len;\nquat.z = quat.z * len;\nquat.w = quat.w * len;\n}\nreturn quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\nfloat x = angle.x / 2.;\nfloat y = angle.y / 2.;\nfloat z = angle.z / 2.;\nfloat sx = sin(x);\nfloat cx = cos(x);\nfloat sy = sin(y);\nfloat cy = cos(y);\nfloat sz = sin(z);\nfloat cz = cos(z);\nvec4 quat = vec4(0);\nquat.x = sx * cy * cz + cx * sy * sz;\nquat.y = cx * sy * cz + sx * cy * sz;\nquat.z = cx * cy * sz - sx * sy * cz;\nquat.w = cx * cy * cz - sx * sy * sz;\nreturn quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\nfloat x2 = q.x + q.x;\nfloat y2 = q.y + q.y;\nfloat z2 = q.z + q.z;\nfloat xx = q.x * x2;\nfloat xy = q.x * y2;\nfloat xz = q.x * z2;\nfloat yy = q.y * y2;\nfloat yz = q.y * z2;\nfloat zz = q.z * z2;\nfloat wx = q.w * x2;\nfloat wy = q.w * y2;\nfloat wz = q.w * z2;\nreturn mat4(\n1. - (yy + zz), xy + wz, xz - wy, 0,\nxy - wz, 1. - (xx + zz), yz + wx, 0,\nxz + wy, yz - wx, 1. - (xx + yy), 0,\np.x, p.y, p.z, 1\n);\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\nfloat x = q.x, y = q.y, z = q.z, w = q.w;\nfloat x2 = x + x;\nfloat y2 = y + y;\nfloat z2 = z + z;\nfloat xx = x * x2;\nfloat xy = x * y2;\nfloat xz = x * z2;\nfloat yy = y * y2;\nfloat yz = y * z2;\nfloat zz = z * z2;\nfloat wx = w * x2;\nfloat wy = w * y2;\nfloat wz = w * z2;\nfloat sx = s.x;\nfloat sy = s.y;\nfloat sz = s.z;\nreturn mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n(xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n(xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\nt.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\nvec4 quat;\nquat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\nquat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\nquat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\nquat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\nreturn quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\nfloat ix = q.w * v.x + q.y * v.z - q.z * v.y;\nfloat iy = q.w * v.y + q.z * v.x - q.x * v.z;\nfloat iz = q.w * v.z + q.x * v.y - q.y * v.x;\nfloat iw = -q.x * v.x - q.y * v.y - q.z * v.z;\nv.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\nv.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\nv.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\nvec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\nvec4 rotQuat = quatMultiply(viewQuat, q);\nrotateVecFromQuat(pos, rotQuat);\nreturn pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\nfloat xOS = cos(angle) * corner.x - sin(angle) * corner.y;\nfloat yOS = sin(angle) * corner.x + cos(angle) * corner.y;\ncorner.x = xOS;\ncorner.y = yOS;\n}\nuniform vec4 mainTiling_Offset;\nuniform vec4 frameTile_velLenScale;\nuniform vec4 scale;\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matViewInv;\nuniform highp mat4 cc_matViewProj;\nuniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n, mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n, vec3 eye\n, vec4 velocity\n, float velocityScale\n, float lengthScale\n, float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nvec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\nvec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\nvec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\npos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\nvec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\nvec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\npos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nvec3 camX = vec3(1, 0, 0);\nvec3 camY = vec3(0, 0, -1);\npos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\nvec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\nrotateCorner(viewSpaceVert, q.z);\nvec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\nvec3 camY = vec3(0, 1, 0);\nvec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\npos.xyz += offset;\n#else\npos.x += vertOffset.x;\npos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\nvec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\naniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\nvertIndex.y = 1. - vertIndex.y;\n#endif\nreturn (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nuniform vec4 u_sampleInfo;\nuniform vec4 u_worldRot;\nuniform vec4 u_timeDelta;\nattribute vec4 a_position_starttime;\nattribute vec4 a_size_uv;\nattribute vec4 a_rotation_uv;\nattribute vec4 a_color;\nattribute vec4 a_dir_life;\nattribute float a_rndSeed;\n#if CC_RENDER_MODE == 4\nattribute vec3 a_texCoord;\nattribute vec3 a_texCoord3;\nattribute vec3 a_normal;\nattribute vec4 a_color1;\n#endif\nvec3 unpackCurveData (sampler2D tex, vec2 coord) {\nvec4 a = texture2D(tex, coord);\nvec4 b = texture2D(tex, coord + u_sampleInfo.y);\nfloat c = fract(coord.x * u_sampleInfo.x);\nreturn mix(a.xyz, b.xyz, c);\n}\nvec3 unpackCurveData (sampler2D tex, vec2 coord, out float w) {\nvec4 a = texture2D(tex, coord);\nvec4 b = texture2D(tex, coord + u_sampleInfo.y);\nfloat c = fract(coord.x * u_sampleInfo.x);\nw = mix(a.w, b.w, c);\nreturn mix(a.xyz, b.xyz, c);\n}\nfloat pseudoRandom (float seed) {\nseed = mod(seed, 233280.);\nfloat q = (seed * 9301. + 49297.) / 233280.;\nreturn fract(q);\n}\n#if COLOR_OVER_TIME_MODULE_ENABLE\nuniform sampler2D color_over_time_tex0;\nuniform int u_color_mode;\n#endif\n#if ROTATION_OVER_TIME_MODULE_ENABLE\nuniform sampler2D rotation_over_time_tex0;\nuniform int u_rotation_mode;\n#endif\n#if SIZE_OVER_TIME_MODULE_ENABLE\nuniform sampler2D size_over_time_tex0;\nuniform int u_size_mode;\n#endif\n#if FORCE_OVER_TIME_MODULE_ENABLE\nuniform sampler2D force_over_time_tex0;\nuniform int u_force_mode;\nuniform int u_force_space;\n#endif\n#if VELOCITY_OVER_TIME_MODULE_ENABLE\nuniform sampler2D velocity_over_time_tex0;\nuniform int u_velocity_mode;\nuniform int u_velocity_space;\n#endif\n#if TEXTURE_ANIMATION_MODULE_ENABLE\nuniform sampler2D texture_animation_tex0;\nuniform vec4 u_anim_info;\n#endif\nfloat repeat (float t, float length) {\nreturn t - floor(t / length) * length;\n}\nvec4 rotateQuat (vec4 p, vec4 q) {\nvec3 iv = cross(q.xyz, p.xyz) + q.w * p.xyz;\nvec3 res = p.xyz + 2.0 * cross(q.xyz, iv);\nreturn vec4(res.xyz, p.w);\n}\nvec4 gpvs_main () {\nfloat activeTime = u_timeDelta.x - a_position_starttime.w;\nfloat normalizedTime = clamp(activeTime / a_dir_life.w, 0.0, 1.0);\nvec2 timeCoord0 = vec2(normalizedTime, 0.);\nvec2 timeCoord1 = vec2(normalizedTime, 1.);\n#if CC_RENDER_MODE == 4\nvec2 vertIdx = vec2(a_texCoord.x, a_texCoord.y);\n#else\nvec2 vertIdx = vec2(a_size_uv.w, a_rotation_uv.w);\n#endif\nvec4 velocity = vec4(a_dir_life.xyz, 0.);\nvec4 pos = vec4(a_position_starttime.xyz, 1.);\nvec3 size = a_size_uv.xyz;\n#if SIZE_OVER_TIME_MODULE_ENABLE\nif (u_size_mode == 1) {\nsize *= unpackCurveData(size_over_time_tex0, timeCoord0);\n} else {\nvec3 size_0 = unpackCurveData(size_over_time_tex0, timeCoord0);\nvec3 size_1 = unpackCurveData(size_over_time_tex0, timeCoord1);\nfloat factor_s = pseudoRandom(a_rndSeed + 39825.);\nsize *= mix(size_0, size_1, factor_s);\n}\n#endif\nvec3 compScale = scale.xyz * size;\n#if FORCE_OVER_TIME_MODULE_ENABLE\nvec3 forceAnim = vec3(0.);\nif (u_force_mode == 1) {\nforceAnim = unpackCurveData(force_over_time_tex0, timeCoord0);\n} else {\nvec3 force_0 = unpackCurveData(force_over_time_tex0, timeCoord0);\nvec3 force_1 = unpackCurveData(force_over_time_tex0, timeCoord1);\nfloat factor_f =  pseudoRandom(a_rndSeed + 212165.);\nforceAnim = mix(force_0, force_1, factor_f);\n}\nvec4 forceTrack = vec4(forceAnim, 0.);\nif (u_force_space == 0) {\nforceTrack = rotateQuat(forceTrack, u_worldRot);\n}\nvelocity.xyz += forceTrack.xyz;\n#endif\n#if VELOCITY_OVER_TIME_MODULE_ENABLE\nfloat speedModifier0 = 1.;\nfloat speedModifier1 = 1.;\nvec3 velocityAnim = vec3(0.);\nif (u_velocity_mode == 1) {\nvelocityAnim = unpackCurveData(velocity_over_time_tex0, timeCoord0, speedModifier0);\n} else {\nvec3 vectory_0 = unpackCurveData(velocity_over_time_tex0, timeCoord0, speedModifier0);\nvec3 vectory_1 = unpackCurveData(velocity_over_time_tex0, timeCoord1, speedModifier1);\nfloat factor_v = pseudoRandom(a_rndSeed + 197866.);\nvelocityAnim = mix(vectory_0, vectory_1, factor_v);\nspeedModifier0 = mix(speedModifier0, speedModifier1, factor_v);\n}\nvec4 velocityTrack = vec4(velocityAnim, 0.);\nif (u_velocity_space == 0) {\nvelocityTrack = rotateQuat(velocityTrack, u_worldRot);\n}\nvelocity.xyz += velocityTrack.xyz;\nvelocity.xyz *= speedModifier0;\n#endif\npos.xyz += velocity.xyz * normalizedTime * a_dir_life.w;\n#if !CC_USE_WORLD_SPACE\npos = cc_matWorld * pos;\n#if CC_RENDER_MODE == 1\nvelocity = rotateQuat(velocity, u_worldRot);\n#endif\n#endif\nvec3 rotation = a_rotation_uv.xyz;\n#if ROTATION_OVER_TIME_MODULE_ENABLE\nif (u_rotation_mode == 1) {\nrotation += unpackCurveData(rotation_over_time_tex0, timeCoord0) * normalizedTime * a_dir_life.w;\n} else {\nvec3 rotation_0 = unpackCurveData(rotation_over_time_tex0, timeCoord0);\nvec3 rotation_1 = unpackCurveData(rotation_over_time_tex0, timeCoord1);\nfloat factor_r = pseudoRandom(a_rndSeed + 125292.);\nrotation += mix(rotation_0, rotation_1, factor_r) * normalizedTime * a_dir_life.w;\n}\n#endif\n#if COLOR_OVER_TIME_MODULE_ENABLE\nif (u_color_mode == 1) {\ncolor = a_color * texture2D(color_over_time_tex0, timeCoord0);\n} else {\nvec4 color_0 = texture2D(color_over_time_tex0, timeCoord0);\nvec4 color_1 = texture2D(color_over_time_tex0, timeCoord1);\nfloat factor_c = pseudoRandom(a_rndSeed + 91041.);\ncolor = a_color * mix(color_0, color_1, factor_c);\n}\n#else\ncolor = a_color;\n#endif\n#if CC_RENDER_MODE != 4\nvec2 cornerOffset = vec2((vertIdx - 0.5));\n#if CC_RENDER_MODE == 0\nvec3 rotEuler = rotation.xyz;\n#elif CC_RENDER_MODE == 1\nvec3 rotEuler = vec3(0.);\n#else\nvec3 rotEuler = vec3(0., 0., rotation.z);\n#endif\ncomputeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n, cc_matViewInv\n#endif\n#if CC_RENDER_MODE == 1\n, cc_cameraPos.xyz\n, velocity\n, frameTile_velLenScale.z\n, frameTile_velLenScale.w\n, a_size_uv.w\n#endif\n);\n#else\nmat4 xformNoScale = matrixFromRT(quaternionFromEuler(rotation), pos.xyz);\nmat4 xform = matFromRTS(quaternionFromEuler(rotation), pos.xyz, compScale);\npos = xform * vec4(a_texCoord3, 1);\nvec4 normal = xformNoScale * vec4(a_normal, 0);\ncolor *= a_color1;\n#endif\npos = cc_matViewProj * pos;\nfloat frameIndex = 0.;\n#if TEXTURE_ANIMATION_MODULE_ENABLE\nfloat startFrame = 0.;\nvec3 frameInfo = vec3(0.);\nif (int(u_anim_info.x) == 1) {\nframeInfo = unpackCurveData(texture_animation_tex0, timeCoord0);\n} else {\nvec3 frameInfo0 = unpackCurveData(texture_animation_tex0, timeCoord0);\nvec3 frameInfo1 = unpackCurveData(texture_animation_tex0, timeCoord1);\nfloat factor_t = pseudoRandom(a_rndSeed + 90794.);\nframeInfo = mix(frameInfo0, frameInfo1, factor_t);\n}\nstartFrame = frameInfo.x / u_anim_info.y;\nframeIndex = repeat(u_anim_info.z * (frameInfo.y + startFrame), 1.);\n#endif\nuv = computeUV(frameIndex, vertIdx, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\nreturn pos;\n}\nvoid main() { gl_Position = gpvs_main(); }",
                            frag: "\nprecision mediump float;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n#endif\nreturn color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\nuniform vec4 tintColor;\nvec4 add () {\nvec4 col = 2.0 * color * tintColor * texture2D(mainTexture, uv);\nreturn CCFragOutput(col);\n}\nvoid main() { gl_FragColor = add(); }"
                        }],
                        [{
                            vert: "\nprecision mediump float;\nuniform vec4 mainTiling_Offset;\nuniform highp mat4 cc_matViewProj;\nuniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nattribute vec3 a_position;\nattribute vec4 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_DRAW_WIRE_FRAME\nvarying vec3 vBarycentric;\n#endif\nvec4 vs_main() {\nhighp vec4 pos = vec4(a_position, 1);\nvec4 velocity = vec4(a_texCoord1.xyz, 0);\n#if !CC_USE_WORLD_SPACE\npos = cc_matWorld * pos;\nvelocity = cc_matWorld * velocity;\n#endif\nfloat vertOffset = (a_texCoord.x - 0.5) * a_texCoord.y;\nvec3 camUp = normalize(cross(pos.xyz - cc_cameraPos.xyz, velocity.xyz));\npos.xyz += camUp * vertOffset;\npos = cc_matViewProj * pos;\nuv = a_texCoord.zw * mainTiling_Offset.xy + mainTiling_Offset.zw;;\ncolor = a_color;\n#if CC_DRAW_WIRE_FRAME\nvBarycentric = a_texCoord2;\n#endif\nreturn pos;\n}\nvoid main() { gl_Position = vs_main(); }",
                            frag: "\nprecision mediump float;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n#endif\nreturn color;\n}\nvarying vec2 uv;\nvarying vec4 color;\n#if CC_DRAW_WIRE_FRAME\nvarying vec3 vBarycentric;\n#endif\nuniform sampler2D mainTexture;\nuniform vec4 tintColor;\nvec4 add () {\nvec4 col = 2.0 * color * tintColor * texture2D(mainTexture, uv);\n#if CC_DRAW_WIRE_FRAME\nif (any(lessThan(vBarycentric, vec3(0.02)))) {\ncol = vec4(0., 1., 1., 1.);\n}\n#endif\nreturn CCFragOutput(col);\n}\nvoid main() { gl_FragColor = add(); }"
                        }],
                        [{
                            vert: "\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\nmat3 m = mat3(xAxis,yAxis,zAxis);\nfloat trace = m[0][0] + m[1][1] + m[2][2];\nvec4 quat;\nif (trace > 0.) {\nfloat s = 0.5 / sqrt(trace + 1.0);\nquat.w = 0.25 / s;\nquat.x = (m[2][1] - m[1][2]) * s;\nquat.y = (m[0][2] - m[2][0]) * s;\nquat.z = (m[1][0] - m[0][1]) * s;\n} else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\nfloat s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\nquat.w = (m[2][1] - m[1][2]) / s;\nquat.x = 0.25 * s;\nquat.y = (m[0][1] + m[1][0]) / s;\nquat.z = (m[0][2] + m[2][0]) / s;\n} else if (m[1][1] > m[2][2]) {\nfloat s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\nquat.w = (m[0][2] - m[2][0]) / s;\nquat.x = (m[0][1] + m[1][0]) / s;\nquat.y = 0.25 * s;\nquat.z = (m[1][2] + m[2][1]) / s;\n} else {\nfloat s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\nquat.w = (m[1][0] - m[0][1]) / s;\nquat.x = (m[0][2] + m[2][0]) / s;\nquat.y = (m[1][2] + m[2][1]) / s;\nquat.z = 0.25 * s;\n}\nfloat len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\nif (len > 0.) {\nlen = 1. / sqrt(len);\nquat.x = quat.x * len;\nquat.y = quat.y * len;\nquat.z = quat.z * len;\nquat.w = quat.w * len;\n}\nreturn quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\nfloat x = angle.x / 2.;\nfloat y = angle.y / 2.;\nfloat z = angle.z / 2.;\nfloat sx = sin(x);\nfloat cx = cos(x);\nfloat sy = sin(y);\nfloat cy = cos(y);\nfloat sz = sin(z);\nfloat cz = cos(z);\nvec4 quat = vec4(0);\nquat.x = sx * cy * cz + cx * sy * sz;\nquat.y = cx * sy * cz + sx * cy * sz;\nquat.z = cx * cy * sz - sx * sy * cz;\nquat.w = cx * cy * cz - sx * sy * sz;\nreturn quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\nfloat x2 = q.x + q.x;\nfloat y2 = q.y + q.y;\nfloat z2 = q.z + q.z;\nfloat xx = q.x * x2;\nfloat xy = q.x * y2;\nfloat xz = q.x * z2;\nfloat yy = q.y * y2;\nfloat yz = q.y * z2;\nfloat zz = q.z * z2;\nfloat wx = q.w * x2;\nfloat wy = q.w * y2;\nfloat wz = q.w * z2;\nreturn mat4(\n1. - (yy + zz), xy + wz, xz - wy, 0,\nxy - wz, 1. - (xx + zz), yz + wx, 0,\nxz + wy, yz - wx, 1. - (xx + yy), 0,\np.x, p.y, p.z, 1\n);\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\nfloat x = q.x, y = q.y, z = q.z, w = q.w;\nfloat x2 = x + x;\nfloat y2 = y + y;\nfloat z2 = z + z;\nfloat xx = x * x2;\nfloat xy = x * y2;\nfloat xz = x * z2;\nfloat yy = y * y2;\nfloat yz = y * z2;\nfloat zz = z * z2;\nfloat wx = w * x2;\nfloat wy = w * y2;\nfloat wz = w * z2;\nfloat sx = s.x;\nfloat sy = s.y;\nfloat sz = s.z;\nreturn mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n(xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n(xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\nt.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\nvec4 quat;\nquat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\nquat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\nquat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\nquat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\nreturn quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\nfloat ix = q.w * v.x + q.y * v.z - q.z * v.y;\nfloat iy = q.w * v.y + q.z * v.x - q.x * v.z;\nfloat iz = q.w * v.z + q.x * v.y - q.y * v.x;\nfloat iw = -q.x * v.x - q.y * v.y - q.z * v.z;\nv.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\nv.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\nv.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\nvec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\nvec4 rotQuat = quatMultiply(viewQuat, q);\nrotateVecFromQuat(pos, rotQuat);\nreturn pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\nfloat xOS = cos(angle) * corner.x - sin(angle) * corner.y;\nfloat yOS = sin(angle) * corner.x + cos(angle) * corner.y;\ncorner.x = xOS;\ncorner.y = yOS;\n}\nuniform vec4 mainTiling_Offset;\nuniform vec4 frameTile_velLenScale;\nuniform vec4 scale;\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matViewInv;\nuniform highp mat4 cc_matViewProj;\nuniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n, mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n, vec3 eye\n, vec4 velocity\n, float velocityScale\n, float lengthScale\n, float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nvec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\nvec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\nvec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\npos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\nvec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\nvec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\npos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nvec3 camX = vec3(1, 0, 0);\nvec3 camY = vec3(0, 0, -1);\npos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\nvec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\nrotateCorner(viewSpaceVert, q.z);\nvec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\nvec3 camY = vec3(0, 1, 0);\nvec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\npos.xyz += offset;\n#else\npos.x += vertOffset.x;\npos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\nvec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\naniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\nvertIndex.y = 1. - vertIndex.y;\n#endif\nreturn (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nattribute vec3 a_position;\nattribute vec3 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_RENDER_MODE == 1\nattribute vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\nattribute vec3 a_texCoord3;\nattribute vec3 a_normal;\nattribute vec4 a_color1;\n#endif\nvec4 lpvs_main () {\nvec3 compScale = scale.xyz * a_texCoord1;\nvec4 pos = vec4(a_position, 1);\n#if CC_RENDER_MODE == 1\nvec4 velocity = vec4(a_color1.xyz, 0);\n#endif\n#if !CC_USE_WORLD_SPACE\npos = cc_matWorld * pos;\n#if CC_RENDER_MODE == 1\nvelocity = cc_matWorld * velocity;\n#endif\n#endif\n#if CC_RENDER_MODE != 4\nvec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n#if CC_RENDER_MODE == 0\nvec3 rotEuler = a_texCoord2;\n#elif CC_RENDER_MODE == 1\nvec3 rotEuler = vec3(0.);\n#else\nvec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n#endif\ncomputeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n, cc_matViewInv\n#endif\n#if CC_RENDER_MODE == 1\n, cc_cameraPos.xyz\n, velocity\n, frameTile_velLenScale.z\n, frameTile_velLenScale.w\n, a_texCoord.x\n#endif\n);\ncolor = a_color;\n#else\nmat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\nmat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\npos = xform * vec4(a_texCoord3, 1);\nvec4 normal = xformNoScale * vec4(a_normal, 0);\ncolor = a_color * a_color1;\n#endif\nuv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\npos = cc_matViewProj * pos;\nreturn pos;\n}\nvoid main() { gl_Position = lpvs_main(); }",
                            frag: "\nprecision mediump float;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n#endif\nreturn color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\nuniform vec4 tintColor;\nvec4 add () {\nvec4 col = 2.0 * color * tintColor * texture2D(mainTexture, uv);\nreturn CCFragOutput(col);\n}\nvoid main() { gl_FragColor = add(); }"
                        }],
                        [{
                            vert: "\nprecision highp float;\nuniform highp mat4 cc_matViewProj;\n#if USE_LOCAL\nuniform highp mat4 cc_matWorld;\n#endif\nattribute vec3 a_position;\nattribute vec2 a_texCoord;\nattribute vec4 a_color;\nvarying vec4 v_light;\nvarying vec2 uv0;\n#if TWO_COLORED\nattribute vec4 a_color2;\nvarying vec4 v_dark;\n#endif\nvec4 vert () {\nvec4 pos = vec4(a_position, 1);\n#if USE_LOCAL\npos = cc_matWorld * pos;\n#endif\npos = cc_matViewProj * pos;\nuv0 = a_texCoord;\nv_light = a_color;\n#if TWO_COLORED\nv_dark = a_color2;\n#endif\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
                            frag: "\nprecision highp float;\n#if USE_ALPHA_TEST\nuniform float alphaThreshold;\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n#if USE_ALPHA_TEST\nif (color.a < alphaThreshold) discard;\n#endif\n}\nvoid ALPHA_TEST (in float alpha) {\n#if USE_ALPHA_TEST\nif (alpha < alphaThreshold) discard;\n#endif\n}\nvarying vec4 v_light;\n#if TWO_COLORED\nvarying vec4 v_dark;\n#endif\nvarying vec2 uv0;\nuniform sampler2D cc_spriteTexture;\nvec4 frag () {\nvec4 o = vec4(1, 1, 1, 1);\n#if TWO_COLORED\nvec4 texColor = vec4(1, 1, 1, 1);\ntexColor *= texture2D(cc_spriteTexture, uv0);\no.a = texColor.a * v_light.a;\no.rgb = ((texColor.a - 1.0) * v_dark.a + 1.0 - texColor.rgb) * v_dark.rgb + texColor.rgb * v_light.rgb;\n#else\no *= texture2D(cc_spriteTexture, uv0);\no *= v_light;\n#endif\nALPHA_TEST(o);\nreturn o;\n}\nvoid main() { gl_FragColor = frag(); }"
                        }],
                        [{
                            vert: "\nprecision highp float;\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matProj;\nuniform highp mat4 cc_matViewProj;\nuniform highp vec4 cc_cameraPos;\n#if USE_LOCAL\nuniform highp mat4 cc_matWorld;\n#endif\n#if SAMPLE_FROM_RT\n#endif\nattribute vec3 a_position;\nattribute vec2 a_texCoord;\nattribute vec4 a_color;\nvarying vec4 color;\nvarying vec2 uv0;\nvec4 vert () {\nvec4 pos = vec4(a_position, 1);\n#if USE_LOCAL\npos = cc_matWorld * pos;\n#endif\n#if USE_PIXEL_ALIGNMENT\npos = cc_matView * pos;\npos.xyz = floor(pos.xyz);\npos = cc_matProj * pos;\n#else\npos = cc_matViewProj * pos;\n#endif\nuv0 = a_texCoord;\n#if SAMPLE_FROM_RT\nuv0 = cc_cameraPos.w > 1.0 ? vec2(uv0.x, 1.0 - uv0.y) : uv0;\n#endif\ncolor = a_color;\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
                            frag: "\nprecision highp float;\nvec4 CCSampleWithAlphaSeparated(sampler2D tex, vec2 uv) {\n#if CC_USE_EMBEDDED_ALPHA\nreturn vec4(texture2D(tex, uv).rgb, texture2D(tex, uv + vec2(0.0, 0.5)).r);\n#else\nreturn texture2D(tex, uv);\n#endif\n}\n#if USE_ALPHA_TEST\nuniform float alphaThreshold;\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n#if USE_ALPHA_TEST\nif (color.a < alphaThreshold) discard;\n#endif\n}\nvoid ALPHA_TEST (in float alpha) {\n#if USE_ALPHA_TEST\nif (alpha < alphaThreshold) discard;\n#endif\n}\nvarying vec4 color;\n#if USE_TEXTURE\nvarying vec2 uv0;\nuniform sampler2D cc_spriteTexture;\n#endif\nvec4 frag () {\nvec4 o = vec4(1, 1, 1, 1);\n#if USE_TEXTURE\no *= CCSampleWithAlphaSeparated(cc_spriteTexture, uv0);\n#if IS_GRAY\nfloat gray  = 0.2126 * o.r + 0.7152 * o.g + 0.0722 * o.b;\no.r = o.g = o.b = gray;\n#endif\n#endif\no *= color;\nALPHA_TEST(o);\nreturn o;\n}\nvoid main() { gl_FragColor = frag(); }"
                        }],
                        [{
                            vert: "\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_MORPH\nattribute float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\nuniform vec4 cc_displacementWeights[15];\nuniform vec4 cc_displacementTextureInfo;\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\nreturn texture2D(tex, uv);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture2D(tex, x)),\ndecode32(texture2D(tex, y)),\ndecode32(texture2D(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nattr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nattr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nattr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nattribute vec4 a_joints;\nattribute vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n#if USE_INSTANCING\nattribute highp vec4 a_jointAnimInfo;\n#endif\nuniform highp vec4 cc_jointTextureInfo;\nuniform highp vec4 cc_jointAnimInfo;\nuniform highp sampler2D cc_jointTexture;\n#else\nuniform highp vec4 cc_joints[90];\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\n#if USE_INSTANCING\nhighp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n#else\nhighp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n#endif\nhighp float invSize = cc_jointTextureInfo.w;\nhighp float y = floor(j * invSize);\nhighp float x = floor(j - y * cc_jointTextureInfo.x);\ny = (y + 0.5) * invSize;\nvec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\n#if USE_INSTANCING\nhighp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n#else\nhighp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n#endif\nhighp float invSize = cc_jointTextureInfo.w;\nhighp float y = floor(j * invSize);\nhighp float x = floor(j - y * cc_jointTextureInfo.x);\ny = (y + 0.5) * invSize;\nvec4 v1 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\nmat4 m = skinMatrix();\nattr.position = m * attr.position;\nattr.normal = (m * vec4(attr.normal, 0.0)).xyz;\nattr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matProj;\nuniform highp vec4 cc_cameraPos;\nuniform mediump vec4 cc_fogBase;\nuniform mediump vec4 cc_fogAdd;\n#if USE_INSTANCING\nattribute vec4 a_matWorld0;\nattribute vec4 a_matWorld1;\nattribute vec4 a_matWorld2;\n#if USE_LIGHTMAP\nattribute vec4 a_lightingMapUVParam;\n#endif\n#elif USE_BATCHING\nattribute float a_dyn_batch_id;\nuniform highp mat4 cc_matWorlds[10];\n#else\nuniform highp mat4 cc_matWorld;\nuniform highp mat4 cc_matWorldIT;\nuniform highp vec4 cc_lightingMapUVParam;\n#endif\nuniform vec4 tilingOffset;\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nvarying float v_fog_factor;\nvarying highp vec4 v_shadowPos;\nuniform highp mat4 cc_matLightViewProj;\n#if CC_RECEIVE_SHADOW\nuniform sampler2D cc_shadowMap;\nuniform sampler2D cc_spotLightingMap;\n#endif\n#if USE_VERTEX_COLOR\nattribute vec4 a_color;\nvarying vec4 v_color;\n#endif\nvarying vec3 v_position;\nvarying vec3 v_normal;\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\n#if USE_NORMAL_MAP\nvarying vec3 v_tangent;\nvarying vec3 v_bitangent;\n#endif\n#if HAS_SECOND_UV || USE_LIGHTMAP\nattribute vec2 a_texCoord1;\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nvarying vec3 v_luv;\nvoid CCLightingMapCaclUV()\n{\n#if !USE_INSTANCING\nv_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.zw;\nv_luv.z = cc_lightingMapUVParam.z;\n#else\nv_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.zw;\nv_luv.z = a_lightingMapUVParam.z;\n#endif\n}\n#endif\nvoid main () {\nStandardVertInput In;\nIn.position = vec4(a_position, 1.0);\nIn.normal = a_normal;\nIn.tangent = a_tangent;\n#if CC_USE_MORPH\napplyMorph(In);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In);\n#endif\nmat4 matWorld, matWorldIT;\n#if USE_INSTANCING\nmatWorld = mat4(\nvec4(a_matWorld0.xyz, 0.0),\nvec4(a_matWorld1.xyz, 0.0),\nvec4(a_matWorld2.xyz, 0.0),\nvec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n);\nmatWorldIT = matWorld;\n#elif USE_BATCHING\nmatWorld = cc_matWorlds[int(a_dyn_batch_id)];\nmatWorldIT = matWorld;\n#else\nmatWorld = cc_matWorld;\nmatWorldIT = cc_matWorldIT;\n#endif\nvec4 pos = matWorld * In.position;\nv_position = pos.xyz;\nv_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n#if USE_NORMAL_MAP\nv_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\nv_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n#endif\nv_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n#if SAMPLE_FROM_RT\nv_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n#endif\n#if HAS_SECOND_UV\nv_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n#if SAMPLE_FROM_RT\nv_uv1 = cc_cameraPos.w > 1.0 ? vec2(v_uv1.x, 1.0 - v_uv1.y) : v_uv1;\n#endif\n#endif\n#if USE_VERTEX_COLOR\nv_color = a_color;\n#endif\n#if CC_USE_FOG == 0\nv_fog_factor = LinearFog(pos);\n#elif CC_USE_FOG == 1\nv_fog_factor = ExpFog(pos);\n#elif CC_USE_FOG == 2\nv_fog_factor = ExpSquaredFog(pos);\n#elif CC_USE_FOG == 3\nv_fog_factor = LayeredFog(pos);\n#else\nv_fog_factor = 1.0;\n#endif\nv_shadowPos = cc_matLightViewProj * pos;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nCCLightingMapCaclUV();\n#endif\ngl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}",
                            frag: "\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers: enable\n#endif\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\nprecision highp float;\nuniform highp vec4 cc_cameraPos;\nuniform mediump vec4 cc_exposure;\nuniform mediump vec4 cc_mainLitDir;\nuniform mediump vec4 cc_mainLitColor;\nuniform mediump vec4 cc_ambientSky;\nuniform mediump vec4 cc_ambientGround;\nuniform mediump vec4 cc_fogColor;\nuniform vec4 albedo;\nuniform vec4 albedoScaleAndCutoff;\nuniform vec4 pbrParams;\nuniform vec4 emissive;\nuniform vec4 emissiveScaleParam;\nvarying float v_fog_factor;\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nuniform highp mat4 cc_matLightView;\nuniform lowp vec4 cc_shadowNFLSInfo;\nuniform lowp vec4 cc_shadowWHPBInfo;\nuniform lowp vec4 cc_shadowLPNNInfo;\nuniform lowp vec4 cc_shadowColor;\n#if CC_RECEIVE_SHADOW\nuniform sampler2D cc_shadowMap;\nuniform sampler2D cc_spotLightingMap;\nfloat CCGetLinearDepth (vec3 worldPos) {\nvec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\nfloat dist = length(viewStartPos.xyz);\nreturn cc_shadowNFLSInfo.x + (-dist / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x));\n}\nfloat CCGetShadowFactorX1 (vec4 shadowPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nclosestDepth = dot(texture2D(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n} else {\nclosestDepth = texture2D(cc_shadowMap, clipPos.xy).x;\n}\nshadow = step(closestDepth, clipPos.z- cc_shadowWHPBInfo.w);\nreturn shadow;\n}\nfloat CCGetShadowFactorX5 (vec4 shadowPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\nfloat offsetx = 1.0 / cc_shadowWHPBInfo.x;\nfloat offsety = 1.0 / cc_shadowWHPBInfo.y;\nfloat shadow = 0.0;\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nfloat closestDepth = dot(texture2D(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\nclosestDepth = dot(texture2D(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\nclosestDepth = dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\nclosestDepth = dot(texture2D(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\nclosestDepth = dot(texture2D(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n} else {\nfloat closestDepth = texture2D(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)).x;\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\nclosestDepth = texture2D(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)).x;\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\nclosestDepth = texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x;\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\nclosestDepth = texture2D(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)).x;\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\nclosestDepth = texture2D(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)).x;\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n}\nreturn shadow / 5.0;\n}\nfloat CCGetShadowFactorX9 (vec4 shadowPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\nfloat offsetx = 1.0 / cc_shadowWHPBInfo.x;\nfloat offsety = 1.0 / cc_shadowWHPBInfo.y;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nfor (int i = -1; i <= 1; i++) {\nfor (int j = -1; j <= 1; j++) {\nfloat closestDepth = dot(texture2D(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n}\n}\n} else {\nfor (int i = -1; i <= 1; i++) {\nfor (int j = -1; j <= 1; j++) {\nfloat closestDepth = texture2D(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)).x;\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n}\n}\n}\nreturn shadow / 9.0;\n}\nfloat CCGetShadowFactorX25 (vec4 shadowPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\nfloat offsetx = 1.0 / cc_shadowWHPBInfo.x;\nfloat offsety = 1.0 / cc_shadowWHPBInfo.y;\nfloat shadow = 0.0;\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nfor (int i = -2; i <= 2; i++) {\nfor (int j = -2; j <= 2; j++) {\nfloat closestDepth = dot(texture2D(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n}\n}\n} else {\nfor (int i = -2; i <= 2; i++) {\nfor (int j = -2; j <= 2; j++) {\nfloat closestDepth = texture2D(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)).x;\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n}\n}\n}\nreturn shadow / 25.0;\n}\nfloat CCGetDirLightShadowFactorX1 (vec4 shadowPos, vec3 worldPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nfloat depth = 0.0;\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nif (cc_shadowLPNNInfo.y > 0.000001) {\nclosestDepth = dot(texture2D(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n} else {\nclosestDepth = texture2D(cc_spotLightingMap, clipPos.xy).x;\n}\nshadow = step(closestDepth, depth - cc_shadowWHPBInfo.w);\nreturn shadow;\n}\nfloat CCGetDirLightShadowFactorX5 (vec4 shadowPos, vec3 worldPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\nfloat offsetx = 1.0 / cc_shadowWHPBInfo.x;\nfloat offsety = 1.0 / cc_shadowWHPBInfo.y;\nfloat shadow = 0.0;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nfloat closestDepth = dot(texture2D(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\nclosestDepth = dot(texture2D(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\nclosestDepth = dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\nclosestDepth = dot(texture2D(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\nclosestDepth = dot(texture2D(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n} else {\nfloat closestDepth = texture2D(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)).x;\nshadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\nclosestDepth = texture2D(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)).x;\nshadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\nclosestDepth = texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x;\nshadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\nclosestDepth = texture2D(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)).x;\nshadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\nclosestDepth = texture2D(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)).x;\nshadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n}\nreturn shadow / 5.0;\n}\nfloat CCGetDirLightShadowFactorX9 (vec4 shadowPos, vec3 worldPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\nfloat offsetx = 1.0 / cc_shadowWHPBInfo.x;\nfloat offsety = 1.0 / cc_shadowWHPBInfo.y;\nfloat shadow = 0.0;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nfor (int i = -1; i <= 1; i++) {\nfor (int j = -1; j <= 1; j++) {\nfloat closestDepth = dot(texture2D(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n}\n}\n} else {\nfor (int i = -1; i <= 1; i++) {\nfor (int j = -1; j <= 1; j++) {\nfloat closestDepth = texture2D(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)).x;\nshadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n}\n}\n}\nreturn shadow / 9.0;\n}\nfloat CCGetDirLightShadowFactorX25 (vec4 shadowPos, vec3 worldPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\nfloat offsetx = 1.0 / cc_shadowWHPBInfo.x;\nfloat offsety = 1.0 / cc_shadowWHPBInfo.y;\nfloat depth = 0.0;\nfloat shadow = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nfor (int i = -2; i <= 2; i++) {\nfor (int j = -2; j <= 2; j++) {\nfloat closestDepth = dot(texture2D(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n}\n}\n} else {\nfor (int i = -2; i <= 2; i++) {\nfor (int j = -2; j <= 2; j++) {\nfloat closestDepth = texture2D(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)).x;\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n}\n}\n}\nreturn shadow / 25.0;\n}\n#endif\n#if CC_USE_IBL\nuniform samplerCube cc_environment;\nvec3 unpackRGBE (vec4 rgbe) {\nreturn rgbe.rgb * pow(2.0, rgbe.a * 255.0 - 128.0);\n}\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n#ifdef GL_EXT_shader_texture_lod\nreturn texture2DLodEXT(tex, coord, lod);\n#else\nreturn texture2D(tex, coord, lod);\n#endif\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n#ifdef GL_EXT_shader_texture_lod\nreturn textureCubeLodEXT(tex, coord, lod);\n#else\nreturn textureCube(tex, coord, lod);\n#endif\n}\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\nvec3 NxH = cross(N, H);\nfloat OneMinusNoHSqr = dot(NxH, NxH);\nfloat a = roughness * roughness;\nfloat n = NoH * a;\nfloat p = a / (OneMinusNoHSqr + n * n);\nreturn p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\nreturn (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\nconst vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\nconst vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\nvec4 r = roughness * c0 + c1;\nfloat a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\nvec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\nAB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\nreturn specular * AB.x + AB.y;\n}\nstruct StandardSurface {\nvec4 albedo;\nvec3 position;\nvec3 normal;\nvec3 emissive;\nvec3 lightmap;\nfloat lightmap_test;\nfloat roughness;\nfloat metallic;\nfloat occlusion;\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - s.position);\nfloat NV = max(abs(dot(N, V)), 0.001);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 L = normalize(-cc_mainLitDir.xyz);\nvec3 H = normalize(L + V);\nfloat NH = max(dot(N, H), 0.0);\nfloat NL = max(dot(N, L), 0.001);\nvec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\nvec3 diffuseContrib = diffuse;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nif (s.lightmap_test > 0.0001) {\nfinalColor = s.lightmap.rgb;\n}\n#else\ndiffuseContrib /= 3.14159265359;\n#endif\nvec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\nfinalColor *= (diffuseContrib + specularContrib);\nfloat fAmb = 0.5 - N.y * 0.5;\nvec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\nfinalColor += (ambDiff.rgb * diffuse);\n#if CC_USE_IBL\nvec3 R = normalize(reflect(-V, N));\nvec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n#if CC_USE_IBL == 2\nvec3 env = unpackRGBE(envmap);\n#else\nvec3 env = SRGBToLinear(envmap.rgb);\n#endif\nfinalColor += env * cc_ambientSky.w * specular;\n#endif\nfinalColor = finalColor * s.occlusion;\n#if CC_USE_HDR\ns.emissive *= cc_exposure.w;\n#endif\nfinalColor += s.emissive;\n#if CC_RECEIVE_SHADOW\n{\nfloat pcf = cc_shadowWHPBInfo.z + 0.001;\nfloat shadowAttenuation = 0.0;\nfloat cosAngle = clamp(1.0 - dot(N, L.xyz), 0.0, 1.0);\nvec3 projWorldPos = shadowPos.xyz + cosAngle * cc_shadowLPNNInfo.z * N;\nvec4 pos = vec4(projWorldPos.xyz, shadowPos.w);\nif (pcf > 3.0) shadowAttenuation = CCGetShadowFactorX25(pos);\nelse if (pcf > 2.0) shadowAttenuation = CCGetShadowFactorX9(pos);\nelse if (pcf > 1.0) shadowAttenuation = CCGetShadowFactorX5(pos);\nelse shadowAttenuation = CCGetShadowFactorX1(pos);\nvec3 shadowColor = cc_shadowColor.rgb * cc_shadowColor.a + finalColor.rgb * (1.0 - cc_shadowColor.a);\nif (cc_shadowNFLSInfo.w > 0.000001) {\nfinalColor.rgb = shadowColor.rgb * shadowAttenuation + finalColor.rgb * (1.0 - shadowAttenuation);\n} else {\nfinalColor.rgb = shadowColor.rgb * shadowAttenuation * NL + finalColor.rgb * (1.0 - shadowAttenuation * NL);\n}\n}\n#endif\nreturn vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\ncolor = min(color, vec3(8.0));\nconst float A = 2.51;\nconst float B = 0.03;\nconst float C = 2.43;\nconst float D = 0.59;\nconst float E = 0.14;\nreturn (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n#if !CC_USE_HDR\ncolor.rgb = sqrt(ACESToneMap(color.rgb));\n#endif\nreturn color;\n}\nvarying highp vec4 v_shadowPos;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nvarying vec3 v_luv;\nuniform sampler2D cc_lightingMap;\nvec3 UnpackLightingmap(vec4 color) {\nvec3 c;\nfloat e = 1.0 + color.a * (8.0 - 1.0);\nc.r = color.r * e;\nc.g = color.g * e;\nc.b = color.b * e;\nreturn c;\n}\n#endif\nvarying vec3 v_position;\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\nvarying vec3 v_normal;\n#if USE_VERTEX_COLOR\nvarying vec4 v_color;\n#endif\n#if USE_ALBEDO_MAP\nuniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\nvarying vec3 v_tangent;\nvarying vec3 v_bitangent;\nuniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\nuniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\nuniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\nuniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\nuniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\nvec4 baseColor = albedo;\n#if USE_VERTEX_COLOR\nbaseColor *= v_color;\n#endif\n#if USE_ALBEDO_MAP\nvec4 texColor = texture2D(albedoMap, ALBEDO_UV);\ntexColor.rgb = SRGBToLinear(texColor.rgb);\nbaseColor *= texColor;\n#endif\ns.albedo = baseColor;\ns.albedo.rgb *= albedoScaleAndCutoff.xyz;\n#if USE_ALPHA_TEST\nif (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nvec4 lightColor = texture2D(cc_lightingMap, v_luv.xy);\ns.lightmap = UnpackLightingmap(lightColor);\ns.lightmap_test = v_luv.z;\n#endif\ns.normal = v_normal;\n#if USE_NORMAL_MAP\nvec3 nmmp = texture2D(normalMap, NORMAL_UV).xyz - vec3(0.5);\ns.normal =\n(nmmp.x * pbrParams.w) * normalize(v_tangent) +\n(nmmp.y * pbrParams.w) * normalize(v_bitangent) +\nnmmp.z * normalize(s.normal);\n#endif\ns.position = v_position;\nvec4 pbr = pbrParams;\n#if USE_PBR_MAP\nvec4 res = texture2D(pbrMap, PBR_UV);\npbr.x *= res.r;\npbr.y *= res.g;\npbr.z *= res.b;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\nvec4 metallicRoughness = texture2D(metallicRoughnessMap, PBR_UV);\npbr.z *= metallicRoughness.b;\npbr.y *= metallicRoughness.g;\n#endif\n#if USE_OCCLUSION_MAP\npbr.x *= texture2D(occlusionMap, PBR_UV).r;\n#endif\ns.occlusion = clamp(pbr.x, 0.0, 0.96);\ns.roughness = clamp(pbr.y, 0.04, 1.0);\ns.metallic = pbr.z;\ns.emissive = emissive.rgb * emissiveScaleParam.xyz;\n#if USE_EMISSIVE_MAP\ns.emissive *= SRGBToLinear(texture2D(emissiveMap, EMISSIVE_UV).rgb);\n#endif\n}\n#if CC_FORWARD_ADD\n#if CC_PIPELINE_TYPE == 0\n# define LIGHTS_PER_PASS 1\n#else\n# define LIGHTS_PER_PASS 10\n#endif\nuniform highp vec4 cc_lightPos[LIGHTS_PER_PASS];\nuniform vec4 cc_lightColor[LIGHTS_PER_PASS];\nuniform vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\nuniform vec4 cc_lightDir[LIGHTS_PER_PASS];\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\nfloat factor = distSqr * invSqrAttRadius;\nfloat smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\nreturn smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\nfloat attenuation = 1.0 / max(distSqr, 0.01*0.01);\nattenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\nreturn attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\nfloat cd = dot(litDir, L);\nfloat attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\nreturn (attenuation * attenuation);\n}\nvec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 diffuseContrib = diffuse / 3.14159265359;\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - s.position);\nfloat NV = max(abs(dot(N, V)), 0.001);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 finalColor = vec3(0.0);\nint numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\nfor (int i = 0; i < LIGHTS_PER_PASS; i++) {\nif (i >= numLights) break;\nvec3 SLU = cc_lightPos[i].xyz - s.position;\nvec3 SL = normalize(SLU);\nvec3 SH = normalize(SL + V);\nfloat SNL = max(dot(N, SL), 0.001);\nfloat SNH = max(dot(N, SH), 0.0);\nfloat distSqr = dot(SLU, SLU);\nfloat litRadius = cc_lightSizeRangeAngle[i].x;\nfloat litRadiusSqr = litRadius * litRadius;\nfloat illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\nfloat attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\nattRadiusSqrInv *= attRadiusSqrInv;\nfloat att = GetDistAtt(distSqr, attRadiusSqrInv);\nvec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\nif (cc_lightPos[i].w > 0.0) {\nfloat cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\nfloat cosOuter = cc_lightSizeRangeAngle[i].z;\nfloat litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\nfloat litAngleOffset = -cosOuter * litAngleScale;\natt *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n}\nvec3 lightColor = cc_lightColor[i].rgb;\n#if CC_RECEIVE_SHADOW\nif (cc_lightPos[i].w > 0.0) {\n{\nfloat pcf = cc_shadowWHPBInfo.z + 0.001;\nfloat shadowAttenuation = 0.0;\nfloat cosAngle = clamp(1.0 - dot(N, normalize(cc_lightPos[i].xyz - s.position.xyz)), 0.0, 1.0);\nvec3 projWorldPos = shadowPos.xyz + cosAngle * cc_shadowLPNNInfo.z * N;\nvec4 pos = vec4(projWorldPos.xyz, shadowPos.w);\nif (pcf > 3.0) shadowAttenuation = CCGetDirLightShadowFactorX25(pos, s.position);\nelse if (pcf > 2.0) shadowAttenuation = CCGetDirLightShadowFactorX9(pos, s.position);\nelse if (pcf > 1.0) shadowAttenuation = CCGetDirLightShadowFactorX5(pos, s.position);\nelse shadowAttenuation = CCGetDirLightShadowFactorX1(pos, s.position);\nlightColor *= 1.0 - shadowAttenuation;\n}\n}\n#endif\nfinalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n}\nfinalColor = finalColor * s.occlusion;\nreturn vec4(finalColor, 0.0);\n}\nvoid main () {\nStandardSurface s; surf(s);\nvec4 color = CCStandardShadingAdditive(s, v_shadowPos);\ncolor = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, color.rgb, v_fog_factor), color.a);\ngl_FragData[0] = CCFragOutput(color);\n}\n#elif CC_PIPELINE_TYPE == 0\nvoid main () {\nStandardSurface s; surf(s);\nvec4 color = CCStandardShadingBase(s, v_shadowPos);\ncolor = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, color.rgb, v_fog_factor), color.a);\ngl_FragData[0] = CCFragOutput(color);\n}\n#elif CC_PIPELINE_TYPE == 1\nvoid main () {\nStandardSurface s; surf(s);\ngl_FragData[0] = s.albedo;\ngl_FragData[1] = vec4(s.position, s.roughness);\ngl_FragData[2] = vec4(s.normal, s.metallic);\ngl_FragData[3] = vec4(s.emissive, s.occlusion);\n}\n#endif"
                        }, {
                            vert: "\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_MORPH\nattribute float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\nuniform vec4 cc_displacementWeights[15];\nuniform vec4 cc_displacementTextureInfo;\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\nreturn texture2D(tex, uv);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture2D(tex, x)),\ndecode32(texture2D(tex, y)),\ndecode32(texture2D(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nattr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nattr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nattr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nattribute vec4 a_joints;\nattribute vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n#if USE_INSTANCING\nattribute highp vec4 a_jointAnimInfo;\n#endif\nuniform highp vec4 cc_jointTextureInfo;\nuniform highp vec4 cc_jointAnimInfo;\nuniform highp sampler2D cc_jointTexture;\n#else\nuniform highp vec4 cc_joints[90];\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\n#if USE_INSTANCING\nhighp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n#else\nhighp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n#endif\nhighp float invSize = cc_jointTextureInfo.w;\nhighp float y = floor(j * invSize);\nhighp float x = floor(j - y * cc_jointTextureInfo.x);\ny = (y + 0.5) * invSize;\nvec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\n#if USE_INSTANCING\nhighp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n#else\nhighp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n#endif\nhighp float invSize = cc_jointTextureInfo.w;\nhighp float y = floor(j * invSize);\nhighp float x = floor(j - y * cc_jointTextureInfo.x);\ny = (y + 0.5) * invSize;\nvec4 v1 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\nmat4 m = skinMatrix();\nattr.position = m * attr.position;\nattr.normal = (m * vec4(attr.normal, 0.0)).xyz;\nattr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\n#if USE_INSTANCING\nattribute vec4 a_matWorld0;\nattribute vec4 a_matWorld1;\nattribute vec4 a_matWorld2;\n#if USE_LIGHTMAP\nattribute vec4 a_lightingMapUVParam;\n#endif\n#elif USE_BATCHING\nattribute float a_dyn_batch_id;\nuniform highp mat4 cc_matWorlds[10];\n#else\nuniform highp mat4 cc_matWorld;\nuniform highp mat4 cc_matWorldIT;\n#endif\nuniform vec4 tilingOffset;\nuniform highp mat4 cc_matLightViewProj;\n#if HAS_SECOND_UV || USE_LIGHTMAP\nattribute vec2 a_texCoord1;\n#endif\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\nvarying vec4 v_worldPos;\nvarying float v_clip_depth;\nvec4 vert () {\nStandardVertInput In;\nIn.position = vec4(a_position, 1.0);\nIn.normal = a_normal;\nIn.tangent = a_tangent;\n#if CC_USE_MORPH\napplyMorph(In);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In);\n#endif\nmat4 matWorld, matWorldIT;\n#if USE_INSTANCING\nmatWorld = mat4(\nvec4(a_matWorld0.xyz, 0.0),\nvec4(a_matWorld1.xyz, 0.0),\nvec4(a_matWorld2.xyz, 0.0),\nvec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n);\nmatWorldIT = matWorld;\n#elif USE_BATCHING\nmatWorld = cc_matWorlds[int(a_dyn_batch_id)];\nmatWorldIT = matWorld;\n#else\nmatWorld = cc_matWorld;\nmatWorldIT = cc_matWorldIT;\n#endif\nv_worldPos = matWorld * In.position;\nvec4 clipPos = cc_matLightViewProj * v_worldPos;\nv_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n#if HAS_SECOND_UV\nv_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n#endif\nv_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\nreturn clipPos;\n}\nvoid main() { gl_Position = vert(); }",
                            frag: "\nprecision highp float;\nuniform vec4 albedo;\nuniform vec4 albedoScaleAndCutoff;\nvec4 packDepthToRGBA (float depth) {\nvec4 ret = vec4(1.0, 255.0, 65025.0, 160581375.0) * depth;\nret = fract(ret);\nret -= ret.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\nreturn ret;\n}\nuniform highp mat4 cc_matLightView;\nuniform lowp vec4 cc_shadowNFLSInfo;\nuniform lowp vec4 cc_shadowLPNNInfo;\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\nvarying vec4 v_worldPos;\nvarying float v_clip_depth;\n#if USE_ALBEDO_MAP\nuniform sampler2D albedoMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\nvec4 baseColor = albedo;\n#if USE_ALBEDO_MAP\nbaseColor *= texture2D(albedoMap, ALBEDO_UV);\n#endif\n#if USE_ALPHA_TEST\nif (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n#endif\nif(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\nif (cc_shadowNFLSInfo.z > 0.000001) {\nvec4 viewStartPos = cc_matLightView * v_worldPos;\nfloat dist = length(viewStartPos.xyz);\nfloat linearDepth = cc_shadowNFLSInfo.x + (-dist / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x));\nreturn vec4(linearDepth, 1.0, 1.0, 1.0);\n}\n}\nif (cc_shadowLPNNInfo.y > 0.000001) {\nreturn packDepthToRGBA(v_clip_depth);\n}\nreturn vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nvoid main() { gl_FragColor = frag(); }"
                        }],
                        [{
                            vert: "\nprecision mediump float;\nuniform highp mat4 cc_matViewProj;\nuniform highp vec4 cc_cameraPos;\nuniform mediump vec4 cc_fogBase;\nuniform mediump vec4 cc_fogAdd;\nuniform highp mat4 cc_matWorld;\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nvarying float v_fog_factor;\nvarying highp vec4 v_shadowPos;\nuniform highp mat4 cc_matLightViewProj;\n#if CC_RECEIVE_SHADOW\nuniform sampler2D cc_shadowMap;\nuniform sampler2D cc_spotLightingMap;\n#endif\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nvarying highp vec3 v_position;\nvarying mediump vec3 v_normal;\n#if USE_NORMALMAP\nvarying mediump vec3 v_tangent;\nvarying mediump vec3 v_binormal;\n#endif\nvarying mediump vec2 uvw;\nvarying mediump vec2 uv0;\nvarying mediump vec2 uv1;\nvarying mediump vec2 uv2;\nvarying mediump vec2 uv3;\nvarying mediump vec3 luv;\nvarying mediump vec3 diffuse;\nuniform vec4 UVScale;\nuniform vec4 lightMapUVParam;\nvoid main () {\nvec3 worldPos;\nworldPos.x = cc_matWorld[3][0] + a_position.x;\nworldPos.y = cc_matWorld[3][1] + a_position.y;\nworldPos.z = cc_matWorld[3][2] + a_position.z;\nvec4 pos = vec4(worldPos, 1.0);\npos = cc_matViewProj * pos;\nuvw = a_texCoord;\nuv0 = a_position.xz * UVScale.x;\nuv1 = a_position.xz * UVScale.y;\nuv2 = a_position.xz * UVScale.z;\nuv3 = a_position.xz * UVScale.w;\n#if USE_LIGHTMAP\nluv.xy = lightMapUVParam.xy + a_texCoord * lightMapUVParam.zw;\nluv.z = lightMapUVParam.z;\n#endif\nv_position = worldPos;\nv_normal = a_normal;\n#if CC_USE_FOG == 0\nv_fog_factor = LinearFog(vec4(worldPos, 1.0));\n#elif CC_USE_FOG == 1\nv_fog_factor = ExpFog(vec4(worldPos, 1.0));\n#elif CC_USE_FOG == 2\nv_fog_factor = ExpSquaredFog(vec4(worldPos, 1.0));\n#elif CC_USE_FOG == 3\nv_fog_factor = LayeredFog(vec4(worldPos, 1.0));\n#else\nv_fog_factor = 1.0;\n#endif\n#if USE_NORMALMAP\nv_tangent = vec3(1.0, 0.0, 0.0);\nv_binormal = vec3(0.0, 0.0, 1.0);\nv_binormal = cross(v_tangent, a_normal);\nv_tangent = cross(a_normal, v_binormal);\n#endif\nv_shadowPos = cc_matLightViewProj * vec4(worldPos, 1.0);\ngl_Position = pos;\n}",
                            frag: "\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers: enable\n#endif\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\nprecision highp float;\nuniform highp vec4 cc_cameraPos;\nuniform mediump vec4 cc_exposure;\nuniform mediump vec4 cc_mainLitDir;\nuniform mediump vec4 cc_mainLitColor;\nuniform mediump vec4 cc_ambientSky;\nuniform mediump vec4 cc_ambientGround;\nuniform mediump vec4 cc_fogColor;\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nuniform highp mat4 cc_matLightView;\nuniform lowp vec4 cc_shadowNFLSInfo;\nuniform lowp vec4 cc_shadowWHPBInfo;\nuniform lowp vec4 cc_shadowLPNNInfo;\nuniform lowp vec4 cc_shadowColor;\n#if CC_RECEIVE_SHADOW\nuniform sampler2D cc_shadowMap;\nuniform sampler2D cc_spotLightingMap;\nfloat CCGetLinearDepth (vec3 worldPos) {\nvec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\nfloat dist = length(viewStartPos.xyz);\nreturn cc_shadowNFLSInfo.x + (-dist / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x));\n}\nfloat CCGetShadowFactorX1 (vec4 shadowPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nclosestDepth = dot(texture2D(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n} else {\nclosestDepth = texture2D(cc_shadowMap, clipPos.xy).x;\n}\nshadow = step(closestDepth, clipPos.z- cc_shadowWHPBInfo.w);\nreturn shadow;\n}\nfloat CCGetShadowFactorX5 (vec4 shadowPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\nfloat offsetx = 1.0 / cc_shadowWHPBInfo.x;\nfloat offsety = 1.0 / cc_shadowWHPBInfo.y;\nfloat shadow = 0.0;\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nfloat closestDepth = dot(texture2D(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\nclosestDepth = dot(texture2D(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\nclosestDepth = dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\nclosestDepth = dot(texture2D(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\nclosestDepth = dot(texture2D(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n} else {\nfloat closestDepth = texture2D(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)).x;\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\nclosestDepth = texture2D(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)).x;\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\nclosestDepth = texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x;\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\nclosestDepth = texture2D(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)).x;\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\nclosestDepth = texture2D(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)).x;\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n}\nreturn shadow / 5.0;\n}\nfloat CCGetShadowFactorX9 (vec4 shadowPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\nfloat offsetx = 1.0 / cc_shadowWHPBInfo.x;\nfloat offsety = 1.0 / cc_shadowWHPBInfo.y;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nfor (int i = -1; i <= 1; i++) {\nfor (int j = -1; j <= 1; j++) {\nfloat closestDepth = dot(texture2D(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n}\n}\n} else {\nfor (int i = -1; i <= 1; i++) {\nfor (int j = -1; j <= 1; j++) {\nfloat closestDepth = texture2D(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)).x;\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n}\n}\n}\nreturn shadow / 9.0;\n}\nfloat CCGetShadowFactorX25 (vec4 shadowPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\nfloat offsetx = 1.0 / cc_shadowWHPBInfo.x;\nfloat offsety = 1.0 / cc_shadowWHPBInfo.y;\nfloat shadow = 0.0;\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nfor (int i = -2; i <= 2; i++) {\nfor (int j = -2; j <= 2; j++) {\nfloat closestDepth = dot(texture2D(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n}\n}\n} else {\nfor (int i = -2; i <= 2; i++) {\nfor (int j = -2; j <= 2; j++) {\nfloat closestDepth = texture2D(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)).x;\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n}\n}\n}\nreturn shadow / 25.0;\n}\nfloat CCGetDirLightShadowFactorX1 (vec4 shadowPos, vec3 worldPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nfloat depth = 0.0;\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nif (cc_shadowLPNNInfo.y > 0.000001) {\nclosestDepth = dot(texture2D(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n} else {\nclosestDepth = texture2D(cc_spotLightingMap, clipPos.xy).x;\n}\nshadow = step(closestDepth, depth - cc_shadowWHPBInfo.w);\nreturn shadow;\n}\nfloat CCGetDirLightShadowFactorX5 (vec4 shadowPos, vec3 worldPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\nfloat offsetx = 1.0 / cc_shadowWHPBInfo.x;\nfloat offsety = 1.0 / cc_shadowWHPBInfo.y;\nfloat shadow = 0.0;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nfloat closestDepth = dot(texture2D(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\nclosestDepth = dot(texture2D(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\nclosestDepth = dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\nclosestDepth = dot(texture2D(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\nclosestDepth = dot(texture2D(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n} else {\nfloat closestDepth = texture2D(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)).x;\nshadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\nclosestDepth = texture2D(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)).x;\nshadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\nclosestDepth = texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x;\nshadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\nclosestDepth = texture2D(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)).x;\nshadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\nclosestDepth = texture2D(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)).x;\nshadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n}\nreturn shadow / 5.0;\n}\nfloat CCGetDirLightShadowFactorX9 (vec4 shadowPos, vec3 worldPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\nfloat offsetx = 1.0 / cc_shadowWHPBInfo.x;\nfloat offsety = 1.0 / cc_shadowWHPBInfo.y;\nfloat shadow = 0.0;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nfor (int i = -1; i <= 1; i++) {\nfor (int j = -1; j <= 1; j++) {\nfloat closestDepth = dot(texture2D(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n}\n}\n} else {\nfor (int i = -1; i <= 1; i++) {\nfor (int j = -1; j <= 1; j++) {\nfloat closestDepth = texture2D(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)).x;\nshadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n}\n}\n}\nreturn shadow / 9.0;\n}\nfloat CCGetDirLightShadowFactorX25 (vec4 shadowPos, vec3 worldPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\nfloat offsetx = 1.0 / cc_shadowWHPBInfo.x;\nfloat offsety = 1.0 / cc_shadowWHPBInfo.y;\nfloat depth = 0.0;\nfloat shadow = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nfor (int i = -2; i <= 2; i++) {\nfor (int j = -2; j <= 2; j++) {\nfloat closestDepth = dot(texture2D(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n}\n}\n} else {\nfor (int i = -2; i <= 2; i++) {\nfor (int j = -2; j <= 2; j++) {\nfloat closestDepth = texture2D(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)).x;\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n}\n}\n}\nreturn shadow / 25.0;\n}\n#endif\n#if CC_USE_IBL\nuniform samplerCube cc_environment;\nvec3 unpackRGBE (vec4 rgbe) {\nreturn rgbe.rgb * pow(2.0, rgbe.a * 255.0 - 128.0);\n}\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n#ifdef GL_EXT_shader_texture_lod\nreturn texture2DLodEXT(tex, coord, lod);\n#else\nreturn texture2D(tex, coord, lod);\n#endif\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n#ifdef GL_EXT_shader_texture_lod\nreturn textureCubeLodEXT(tex, coord, lod);\n#else\nreturn textureCube(tex, coord, lod);\n#endif\n}\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\nvec3 NxH = cross(N, H);\nfloat OneMinusNoHSqr = dot(NxH, NxH);\nfloat a = roughness * roughness;\nfloat n = NoH * a;\nfloat p = a / (OneMinusNoHSqr + n * n);\nreturn p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\nreturn (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\nconst vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\nconst vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\nvec4 r = roughness * c0 + c1;\nfloat a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\nvec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\nAB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\nreturn specular * AB.x + AB.y;\n}\nstruct StandardSurface {\nvec4 albedo;\nvec3 position;\nvec3 normal;\nvec3 emissive;\nvec3 lightmap;\nfloat lightmap_test;\nfloat roughness;\nfloat metallic;\nfloat occlusion;\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - s.position);\nfloat NV = max(abs(dot(N, V)), 0.001);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 L = normalize(-cc_mainLitDir.xyz);\nvec3 H = normalize(L + V);\nfloat NH = max(dot(N, H), 0.0);\nfloat NL = max(dot(N, L), 0.001);\nvec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\nvec3 diffuseContrib = diffuse;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nif (s.lightmap_test > 0.0001) {\nfinalColor = s.lightmap.rgb;\n}\n#else\ndiffuseContrib /= 3.14159265359;\n#endif\nvec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\nfinalColor *= (diffuseContrib + specularContrib);\nfloat fAmb = 0.5 - N.y * 0.5;\nvec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\nfinalColor += (ambDiff.rgb * diffuse);\n#if CC_USE_IBL\nvec3 R = normalize(reflect(-V, N));\nvec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n#if CC_USE_IBL == 2\nvec3 env = unpackRGBE(envmap);\n#else\nvec3 env = SRGBToLinear(envmap.rgb);\n#endif\nfinalColor += env * cc_ambientSky.w * specular;\n#endif\nfinalColor = finalColor * s.occlusion;\n#if CC_USE_HDR\ns.emissive *= cc_exposure.w;\n#endif\nfinalColor += s.emissive;\n#if CC_RECEIVE_SHADOW\n{\nfloat pcf = cc_shadowWHPBInfo.z + 0.001;\nfloat shadowAttenuation = 0.0;\nfloat cosAngle = clamp(1.0 - dot(N, L.xyz), 0.0, 1.0);\nvec3 projWorldPos = shadowPos.xyz + cosAngle * cc_shadowLPNNInfo.z * N;\nvec4 pos = vec4(projWorldPos.xyz, shadowPos.w);\nif (pcf > 3.0) shadowAttenuation = CCGetShadowFactorX25(pos);\nelse if (pcf > 2.0) shadowAttenuation = CCGetShadowFactorX9(pos);\nelse if (pcf > 1.0) shadowAttenuation = CCGetShadowFactorX5(pos);\nelse shadowAttenuation = CCGetShadowFactorX1(pos);\nvec3 shadowColor = cc_shadowColor.rgb * cc_shadowColor.a + finalColor.rgb * (1.0 - cc_shadowColor.a);\nif (cc_shadowNFLSInfo.w > 0.000001) {\nfinalColor.rgb = shadowColor.rgb * shadowAttenuation + finalColor.rgb * (1.0 - shadowAttenuation);\n} else {\nfinalColor.rgb = shadowColor.rgb * shadowAttenuation * NL + finalColor.rgb * (1.0 - shadowAttenuation * NL);\n}\n}\n#endif\nreturn vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\ncolor = min(color, vec3(8.0));\nconst float A = 2.51;\nconst float B = 0.03;\nconst float C = 2.43;\nconst float D = 0.59;\nconst float E = 0.14;\nreturn (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n#if !CC_USE_HDR\ncolor.rgb = sqrt(ACESToneMap(color.rgb));\n#endif\nreturn color;\n}\nvarying float v_fog_factor;\nvarying highp vec4 v_shadowPos;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nvarying vec3 v_luv;\nuniform sampler2D cc_lightingMap;\nvec3 UnpackLightingmap(vec4 color) {\nvec3 c;\nfloat e = 1.0 + color.a * (8.0 - 1.0);\nc.r = color.r * e;\nc.g = color.g * e;\nc.b = color.b * e;\nreturn c;\n}\n#endif\nvarying highp vec3 v_position;\nvarying mediump vec3 v_normal;\n#if USE_NORMALMAP\nvarying mediump vec3 v_tangent;\nvarying mediump vec3 v_binormal;\n#endif\nvarying mediump vec2 uvw;\nvarying mediump vec2 uv0;\nvarying mediump vec2 uv1;\nvarying mediump vec2 uv2;\nvarying mediump vec2 uv3;\nvarying mediump vec3 diffuse;\nvarying mediump vec3 luv;\nuniform vec4 metallic;\nuniform vec4 roughness;\nuniform sampler2D weightMap;\nuniform sampler2D detailMap0;\nuniform sampler2D detailMap1;\nuniform sampler2D detailMap2;\nuniform sampler2D detailMap3;\nuniform sampler2D normalMap0;\nuniform sampler2D normalMap1;\nuniform sampler2D normalMap2;\nuniform sampler2D normalMap3;\nuniform sampler2D lightMap;\nvoid surf (out StandardSurface s) {\n#if LAYERS > 1\nvec4 w = texture2D(weightMap, uvw);\n#endif\nvec4 baseColor = vec4(0, 0, 0, 0);\n#if LAYERS == 1\nbaseColor = texture2D(detailMap0, uv0);\n#elif LAYERS == 2\nbaseColor += texture2D(detailMap0, uv0) * w.r;\nbaseColor += texture2D(detailMap1, uv1) * w.g;\n#elif LAYERS == 3\nbaseColor += texture2D(detailMap0, uv0) * w.r;\nbaseColor += texture2D(detailMap1, uv1) * w.g;\nbaseColor += texture2D(detailMap2, uv2) * w.b;\n#elif LAYERS == 4\nbaseColor += texture2D(detailMap0, uv0) * w.r;\nbaseColor += texture2D(detailMap1, uv1) * w.g;\nbaseColor += texture2D(detailMap2, uv2) * w.b;\nbaseColor += texture2D(detailMap3, uv3) * w.a;\n#else\nbaseColor = texture2D(detailMap0, uv0);\n#endif\ns.position = v_position;\n#if USE_NORMALMAP\nvec4 baseNormal = vec4(0, 0, 0, 0);\n#if LAYERS == 1\nbaseNormal = texture2D(normalMap0, uv0);\n#elif LAYERS == 2\nbaseNormal += texture2D(normalMap0, uv0) * w.r;\nbaseNormal += texture2D(normalMap1, uv1) * w.g;\n#elif LAYERS == 3\nbaseNormal += texture2D(normalMap0, uv0) * w.r;\nbaseNormal += texture2D(normalMap1, uv1) * w.g;\nbaseNormal += texture2D(normalMap2, uv2) * w.b;\n#elif LAYERS == 4\nbaseNormal += texture2D(normalMap0, uv0) * w.r;\nbaseNormal += texture2D(normalMap1, uv1) * w.g;\nbaseNormal += texture2D(normalMap2, uv2) * w.b;\nbaseNormal += texture2D(normalMap3, uv3) * w.a;\n#else\nbaseNormal = texture2D(normalMap0, uv0);\n#endif\nvec3 nmmp = baseNormal.xyz - vec3(0.5);\ns.normal =\nnmmp.x * normalize(v_tangent) +\nnmmp.y * normalize(v_binormal) +\nnmmp.z * normalize(v_normal);\n#else\ns.normal = v_normal;\n#endif\ns.albedo = vec4(SRGBToLinear(baseColor.rgb), 1.0);\ns.occlusion = 1.0;\n#if USE_PBR\ns.roughness = 0.0;\n#if LAYERS == 1\ns.roughness = roughness.x;\n#elif LAYERS == 2\ns.roughness += roughness.x * w.r;\ns.roughness += roughness.y * w.g;\n#elif LAYERS == 3\ns.roughness += roughness.x * w.r;\ns.roughness += roughness.y * w.g;\ns.roughness += roughness.z * w.b;\n#elif LAYERS == 4\ns.roughness += roughness.x * w.r;\ns.roughness += roughness.y * w.g;\ns.roughness += roughness.z * w.b;\ns.roughness += roughness.w * w.a;\n#else\ns.roughness = 1.0;\n#endif\ns.metallic = 0.0;\n#if LAYERS == 1\ns.metallic = metallic.x;\n#elif LAYERS == 2\ns.metallic += metallic.x * w.r;\ns.metallic += metallic.y * w.g;\n#elif LAYERS == 3\ns.metallic += metallic.x * w.r;\ns.metallic += metallic.y * w.g;\ns.metallic += metallic.z * w.b;\n#elif LAYERS == 4\ns.metallic += metallic.x * w.r;\ns.metallic += metallic.y * w.g;\ns.metallic += metallic.z * w.b;\ns.metallic += metallic.w * w.a;\n#else\ns.metallic = 0.0;\n#endif\n#else\ns.roughness = 1.0;\ns.metallic = 0.0;\n#endif\ns.emissive = vec3(0.0, 0.0, 0.0);\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nvec4 lightColor = texture2D(lightMap, luv.xy);\ns.lightmap = UnpackLightingmap(lightColor);\ns.lightmap_test = luv.z;\n#endif\n}\n#if CC_FORWARD_ADD\n#if CC_PIPELINE_TYPE == 0\n# define LIGHTS_PER_PASS 1\n#else\n# define LIGHTS_PER_PASS 10\n#endif\nuniform highp vec4 cc_lightPos[LIGHTS_PER_PASS];\nuniform vec4 cc_lightColor[LIGHTS_PER_PASS];\nuniform vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\nuniform vec4 cc_lightDir[LIGHTS_PER_PASS];\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\nfloat factor = distSqr * invSqrAttRadius;\nfloat smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\nreturn smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\nfloat attenuation = 1.0 / max(distSqr, 0.01*0.01);\nattenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\nreturn attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\nfloat cd = dot(litDir, L);\nfloat attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\nreturn (attenuation * attenuation);\n}\nvec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 diffuseContrib = diffuse / 3.14159265359;\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - s.position);\nfloat NV = max(abs(dot(N, V)), 0.001);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 finalColor = vec3(0.0);\nint numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\nfor (int i = 0; i < LIGHTS_PER_PASS; i++) {\nif (i >= numLights) break;\nvec3 SLU = cc_lightPos[i].xyz - s.position;\nvec3 SL = normalize(SLU);\nvec3 SH = normalize(SL + V);\nfloat SNL = max(dot(N, SL), 0.001);\nfloat SNH = max(dot(N, SH), 0.0);\nfloat distSqr = dot(SLU, SLU);\nfloat litRadius = cc_lightSizeRangeAngle[i].x;\nfloat litRadiusSqr = litRadius * litRadius;\nfloat illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\nfloat attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\nattRadiusSqrInv *= attRadiusSqrInv;\nfloat att = GetDistAtt(distSqr, attRadiusSqrInv);\nvec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\nif (cc_lightPos[i].w > 0.0) {\nfloat cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\nfloat cosOuter = cc_lightSizeRangeAngle[i].z;\nfloat litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\nfloat litAngleOffset = -cosOuter * litAngleScale;\natt *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n}\nvec3 lightColor = cc_lightColor[i].rgb;\n#if CC_RECEIVE_SHADOW\nif (cc_lightPos[i].w > 0.0) {\n{\nfloat pcf = cc_shadowWHPBInfo.z + 0.001;\nfloat shadowAttenuation = 0.0;\nfloat cosAngle = clamp(1.0 - dot(N, normalize(cc_lightPos[i].xyz - s.position.xyz)), 0.0, 1.0);\nvec3 projWorldPos = shadowPos.xyz + cosAngle * cc_shadowLPNNInfo.z * N;\nvec4 pos = vec4(projWorldPos.xyz, shadowPos.w);\nif (pcf > 3.0) shadowAttenuation = CCGetDirLightShadowFactorX25(pos, s.position);\nelse if (pcf > 2.0) shadowAttenuation = CCGetDirLightShadowFactorX9(pos, s.position);\nelse if (pcf > 1.0) shadowAttenuation = CCGetDirLightShadowFactorX5(pos, s.position);\nelse shadowAttenuation = CCGetDirLightShadowFactorX1(pos, s.position);\nlightColor *= 1.0 - shadowAttenuation;\n}\n}\n#endif\nfinalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n}\nfinalColor = finalColor * s.occlusion;\nreturn vec4(finalColor, 0.0);\n}\nvoid main () {\nStandardSurface s; surf(s);\nvec4 color = CCStandardShadingAdditive(s, v_shadowPos);\ncolor = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, color.rgb, v_fog_factor), color.a);\ngl_FragData[0] = CCFragOutput(color);\n}\n#elif CC_PIPELINE_TYPE == 0\nvoid main () {\nStandardSurface s; surf(s);\nvec4 color = CCStandardShadingBase(s, v_shadowPos);\ncolor = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, color.rgb, v_fog_factor), color.a);\ngl_FragData[0] = CCFragOutput(color);\n}\n#elif CC_PIPELINE_TYPE == 1\nvoid main () {\nStandardSurface s; surf(s);\ngl_FragData[0] = s.albedo;\ngl_FragData[1] = vec4(s.position, s.roughness);\ngl_FragData[2] = vec4(s.normal, s.metallic);\ngl_FragData[3] = vec4(s.emissive, s.occlusion);\n}\n#endif"
                        }, {
                            vert: "\nprecision highp float;\nuniform highp mat4 cc_matWorld;\nuniform highp mat4 cc_matLightViewProj;\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nvarying vec2 v_clip_depth;\nvec4 vert () {\nvec4 worldPos;\nworldPos.x = cc_matWorld[3][0] + a_position.x;\nworldPos.y = cc_matWorld[3][1] + a_position.y;\nworldPos.z = cc_matWorld[3][2] + a_position.z;\nworldPos.w = 1.0;\nvec4 clipPos = cc_matLightViewProj * worldPos;\nv_clip_depth = clipPos.zw;\nreturn clipPos;\n}\nvoid main() { gl_Position = vert(); }",
                            frag: "\nprecision highp float;\nvec4 packDepthToRGBA (float depth) {\nvec4 ret = vec4(1.0, 255.0, 65025.0, 160581375.0) * depth;\nret = fract(ret);\nret -= ret.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\nreturn ret;\n}\nvarying vec2 v_clip_depth;\nvec4 frag () {\nreturn packDepthToRGBA(v_clip_depth.x / v_clip_depth.y * 0.5 + 0.5);\n}\nvoid main() { gl_FragColor = frag(); }"
                        }],
                        [{
                            vert: "\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_MORPH\nattribute float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\nuniform vec4 cc_displacementWeights[15];\nuniform vec4 cc_displacementTextureInfo;\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\nreturn texture2D(tex, uv);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture2D(tex, x)),\ndecode32(texture2D(tex, y)),\ndecode32(texture2D(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nattr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nattr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nattr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nattribute vec4 a_joints;\nattribute vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n#if USE_INSTANCING\nattribute highp vec4 a_jointAnimInfo;\n#endif\nuniform highp vec4 cc_jointTextureInfo;\nuniform highp vec4 cc_jointAnimInfo;\nuniform highp sampler2D cc_jointTexture;\n#else\nuniform highp vec4 cc_joints[90];\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\n#if USE_INSTANCING\nhighp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n#else\nhighp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n#endif\nhighp float invSize = cc_jointTextureInfo.w;\nhighp float y = floor(j * invSize);\nhighp float x = floor(j - y * cc_jointTextureInfo.x);\ny = (y + 0.5) * invSize;\nvec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\n#if USE_INSTANCING\nhighp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n#else\nhighp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n#endif\nhighp float invSize = cc_jointTextureInfo.w;\nhighp float y = floor(j * invSize);\nhighp float x = floor(j - y * cc_jointTextureInfo.x);\ny = (y + 0.5) * invSize;\nvec4 v1 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\nmat4 m = skinMatrix();\nattr.position = m * attr.position;\nattr.normal = (m * vec4(attr.normal, 0.0)).xyz;\nattr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matProj;\nuniform highp vec4 cc_cameraPos;\nuniform mediump vec4 cc_fogBase;\nuniform mediump vec4 cc_fogAdd;\n#if USE_INSTANCING\nattribute vec4 a_matWorld0;\nattribute vec4 a_matWorld1;\nattribute vec4 a_matWorld2;\n#if USE_LIGHTMAP\nattribute vec4 a_lightingMapUVParam;\n#endif\n#elif USE_BATCHING\nattribute float a_dyn_batch_id;\nuniform highp mat4 cc_matWorlds[10];\n#else\nuniform highp mat4 cc_matWorld;\n#endif\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nvarying float v_fog_factor;\n#if USE_VERTEX_COLOR\nattribute lowp vec4 a_color;\nvarying lowp vec4 v_color;\n#endif\n#if USE_TEXTURE\nvarying vec2 v_uv;\nuniform vec4 tilingOffset;\n#endif\nvec4 vert () {\nvec4 position;\nposition = vec4(a_position, 1.0);\n#if CC_USE_MORPH\napplyMorph(position);\n#endif\n#if CC_USE_SKINNING\nCCSkin(position);\n#endif\nmat4 matWorld;\n#if USE_INSTANCING\nmatWorld = mat4(\nvec4(a_matWorld0.xyz, 0.0),\nvec4(a_matWorld1.xyz, 0.0),\nvec4(a_matWorld2.xyz, 0.0),\nvec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n);\n#elif USE_BATCHING\nmatWorld = cc_matWorlds[int(a_dyn_batch_id)];\n#else\nmatWorld = cc_matWorld;\n#endif\n#if USE_TEXTURE\nv_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n#if SAMPLE_FROM_RT\nv_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n#endif\n#endif\n#if USE_VERTEX_COLOR\nv_color = a_color;\n#endif\n#if CC_USE_FOG == 0\nv_fog_factor = LinearFog(matWorld * position);\n#elif CC_USE_FOG == 1\nv_fog_factor = ExpFog(matWorld * position);\n#elif CC_USE_FOG == 2\nv_fog_factor = ExpSquaredFog(matWorld * position);\n#elif CC_USE_FOG == 3\nv_fog_factor = LayeredFog(matWorld * position);\n#else\nv_fog_factor = 1.0;\n#endif\nreturn cc_matProj * (cc_matView * matWorld) * position;\n}\nvoid main() { gl_Position = vert(); }",
                            frag: "\nprecision highp float;\nuniform mediump vec4 cc_exposure;\nuniform mediump vec4 cc_fogColor;\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n#endif\nreturn color;\n}\nvarying float v_fog_factor;\n#if USE_ALPHA_TEST\n#endif\n#if USE_TEXTURE\nvarying vec2 v_uv;\nuniform sampler2D mainTexture;\n#endif\nuniform vec4 mainColor;\nuniform vec4 colorScaleAndCutoff;\n#if USE_VERTEX_COLOR\nvarying lowp vec4 v_color;\n#endif\nvec4 frag () {\nvec4 o = mainColor;\no.rgb *= colorScaleAndCutoff.xyz;\n#if USE_VERTEX_COLOR\no *= v_color;\n#endif\n#if USE_TEXTURE\no *= texture2D(mainTexture, v_uv);\n#endif\n#if USE_ALPHA_TEST\nif (o.ALPHA_TEST_CHANNEL < colorScaleAndCutoff.w) discard;\n#endif\no = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, o.rgb, v_fog_factor), o.a);\nreturn CCFragOutput(o);\n}\nvoid main() { gl_FragColor = frag(); }"
                        }],
                        [{
                            vert: "\nprecision highp float;\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\nuniform highp vec4 cc_cameraPos;\nvarying vec2 v_uv;\nvoid main () {\nvec4 position;\nposition = vec4(a_position, 1.0);\nposition.xy = cc_cameraPos.w == 0.0 ? vec2(position.xy.x, -position.xy.y) : position.xy;\ngl_Position = vec4(position.x, position.y, 1.0, 1.0);\nv_uv = a_texCoord;\n}",
                            frag: "\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\nprecision highp float;\nuniform highp vec4 cc_cameraPos;\nuniform mediump vec4 cc_exposure;\nuniform mediump vec4 cc_mainLitDir;\nuniform mediump vec4 cc_mainLitColor;\nuniform mediump vec4 cc_ambientSky;\nuniform mediump vec4 cc_ambientGround;\nuniform mediump vec4 cc_fogColor;\nuniform mediump vec4 cc_fogBase;\nuniform mediump vec4 cc_fogAdd;\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nuniform highp mat4 cc_matLightView;\nuniform highp mat4 cc_matLightViewProj;\nuniform lowp vec4 cc_shadowNFLSInfo;\nuniform lowp vec4 cc_shadowWHPBInfo;\nuniform lowp vec4 cc_shadowLPNNInfo;\nuniform lowp vec4 cc_shadowColor;\n#if CC_RECEIVE_SHADOW\nuniform sampler2D cc_shadowMap;\nuniform sampler2D cc_spotLightingMap;\nfloat CCGetLinearDepth (vec3 worldPos) {\nvec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\nfloat dist = length(viewStartPos.xyz);\nreturn cc_shadowNFLSInfo.x + (-dist / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x));\n}\nfloat CCGetShadowFactorX1 (vec4 shadowPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nclosestDepth = dot(texture2D(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n} else {\nclosestDepth = texture2D(cc_shadowMap, clipPos.xy).x;\n}\nshadow = step(closestDepth, clipPos.z- cc_shadowWHPBInfo.w);\nreturn shadow;\n}\nfloat CCGetShadowFactorX5 (vec4 shadowPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\nfloat offsetx = 1.0 / cc_shadowWHPBInfo.x;\nfloat offsety = 1.0 / cc_shadowWHPBInfo.y;\nfloat shadow = 0.0;\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nfloat closestDepth = dot(texture2D(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\nclosestDepth = dot(texture2D(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\nclosestDepth = dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\nclosestDepth = dot(texture2D(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\nclosestDepth = dot(texture2D(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n} else {\nfloat closestDepth = texture2D(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)).x;\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\nclosestDepth = texture2D(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)).x;\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\nclosestDepth = texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x;\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\nclosestDepth = texture2D(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)).x;\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\nclosestDepth = texture2D(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)).x;\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n}\nreturn shadow / 5.0;\n}\nfloat CCGetShadowFactorX9 (vec4 shadowPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\nfloat offsetx = 1.0 / cc_shadowWHPBInfo.x;\nfloat offsety = 1.0 / cc_shadowWHPBInfo.y;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nfor (int i = -1; i <= 1; i++) {\nfor (int j = -1; j <= 1; j++) {\nfloat closestDepth = dot(texture2D(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n}\n}\n} else {\nfor (int i = -1; i <= 1; i++) {\nfor (int j = -1; j <= 1; j++) {\nfloat closestDepth = texture2D(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)).x;\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n}\n}\n}\nreturn shadow / 9.0;\n}\nfloat CCGetShadowFactorX25 (vec4 shadowPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\nfloat offsetx = 1.0 / cc_shadowWHPBInfo.x;\nfloat offsety = 1.0 / cc_shadowWHPBInfo.y;\nfloat shadow = 0.0;\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nfor (int i = -2; i <= 2; i++) {\nfor (int j = -2; j <= 2; j++) {\nfloat closestDepth = dot(texture2D(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n}\n}\n} else {\nfor (int i = -2; i <= 2; i++) {\nfor (int j = -2; j <= 2; j++) {\nfloat closestDepth = texture2D(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)).x;\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n}\n}\n}\nreturn shadow / 25.0;\n}\nfloat CCGetDirLightShadowFactorX1 (vec4 shadowPos, vec3 worldPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nfloat depth = 0.0;\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nif (cc_shadowLPNNInfo.y > 0.000001) {\nclosestDepth = dot(texture2D(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n} else {\nclosestDepth = texture2D(cc_spotLightingMap, clipPos.xy).x;\n}\nshadow = step(closestDepth, depth - cc_shadowWHPBInfo.w);\nreturn shadow;\n}\nfloat CCGetDirLightShadowFactorX5 (vec4 shadowPos, vec3 worldPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\nfloat offsetx = 1.0 / cc_shadowWHPBInfo.x;\nfloat offsety = 1.0 / cc_shadowWHPBInfo.y;\nfloat shadow = 0.0;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nfloat closestDepth = dot(texture2D(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\nclosestDepth = dot(texture2D(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\nclosestDepth = dot(texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\nclosestDepth = dot(texture2D(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\nclosestDepth = dot(texture2D(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n} else {\nfloat closestDepth = texture2D(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)).x;\nshadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\nclosestDepth = texture2D(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)).x;\nshadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\nclosestDepth = texture2D(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x;\nshadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\nclosestDepth = texture2D(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)).x;\nshadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\nclosestDepth = texture2D(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)).x;\nshadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n}\nreturn shadow / 5.0;\n}\nfloat CCGetDirLightShadowFactorX9 (vec4 shadowPos, vec3 worldPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\nfloat offsetx = 1.0 / cc_shadowWHPBInfo.x;\nfloat offsety = 1.0 / cc_shadowWHPBInfo.y;\nfloat shadow = 0.0;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nfor (int i = -1; i <= 1; i++) {\nfor (int j = -1; j <= 1; j++) {\nfloat closestDepth = dot(texture2D(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n}\n}\n} else {\nfor (int i = -1; i <= 1; i++) {\nfor (int j = -1; j <= 1; j++) {\nfloat closestDepth = texture2D(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)).x;\nshadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n}\n}\n}\nreturn shadow / 9.0;\n}\nfloat CCGetDirLightShadowFactorX25 (vec4 shadowPos, vec3 worldPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\nfloat offsetx = 1.0 / cc_shadowWHPBInfo.x;\nfloat offsety = 1.0 / cc_shadowWHPBInfo.y;\nfloat depth = 0.0;\nfloat shadow = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nfor (int i = -2; i <= 2; i++) {\nfor (int j = -2; j <= 2; j++) {\nfloat closestDepth = dot(texture2D(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n}\n}\n} else {\nfor (int i = -2; i <= 2; i++) {\nfor (int j = -2; j <= 2; j++) {\nfloat closestDepth = texture2D(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)).x;\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n}\n}\n}\nreturn shadow / 25.0;\n}\n#endif\n#if CC_USE_IBL\nuniform samplerCube cc_environment;\nvec3 unpackRGBE (vec4 rgbe) {\nreturn rgbe.rgb * pow(2.0, rgbe.a * 255.0 - 128.0);\n}\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n#ifdef GL_EXT_shader_texture_lod\nreturn texture2DLodEXT(tex, coord, lod);\n#else\nreturn texture2D(tex, coord, lod);\n#endif\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n#ifdef GL_EXT_shader_texture_lod\nreturn textureCubeLodEXT(tex, coord, lod);\n#else\nreturn textureCube(tex, coord, lod);\n#endif\n}\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\nvec3 NxH = cross(N, H);\nfloat OneMinusNoHSqr = dot(NxH, NxH);\nfloat a = roughness * roughness;\nfloat n = NoH * a;\nfloat p = a / (OneMinusNoHSqr + n * n);\nreturn p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\nreturn (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\nconst vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\nconst vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\nvec4 r = roughness * c0 + c1;\nfloat a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\nvec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\nAB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\nreturn specular * AB.x + AB.y;\n}\nstruct StandardSurface {\nvec4 albedo;\nvec3 position;\nvec3 normal;\nvec3 emissive;\nvec3 lightmap;\nfloat lightmap_test;\nfloat roughness;\nfloat metallic;\nfloat occlusion;\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - s.position);\nfloat NV = max(abs(dot(N, V)), 0.001);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 L = normalize(-cc_mainLitDir.xyz);\nvec3 H = normalize(L + V);\nfloat NH = max(dot(N, H), 0.0);\nfloat NL = max(dot(N, L), 0.001);\nvec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\nvec3 diffuseContrib = diffuse;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nif (s.lightmap_test > 0.0001) {\nfinalColor = s.lightmap.rgb;\n}\n#else\ndiffuseContrib /= 3.14159265359;\n#endif\nvec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\nfinalColor *= (diffuseContrib + specularContrib);\nfloat fAmb = 0.5 - N.y * 0.5;\nvec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\nfinalColor += (ambDiff.rgb * diffuse);\n#if CC_USE_IBL\nvec3 R = normalize(reflect(-V, N));\nvec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n#if CC_USE_IBL == 2\nvec3 env = unpackRGBE(envmap);\n#else\nvec3 env = SRGBToLinear(envmap.rgb);\n#endif\nfinalColor += env * cc_ambientSky.w * specular;\n#endif\nfinalColor = finalColor * s.occlusion;\n#if CC_USE_HDR\ns.emissive *= cc_exposure.w;\n#endif\nfinalColor += s.emissive;\n#if CC_RECEIVE_SHADOW\n{\nfloat pcf = cc_shadowWHPBInfo.z + 0.001;\nfloat shadowAttenuation = 0.0;\nfloat cosAngle = clamp(1.0 - dot(N, L.xyz), 0.0, 1.0);\nvec3 projWorldPos = shadowPos.xyz + cosAngle * cc_shadowLPNNInfo.z * N;\nvec4 pos = vec4(projWorldPos.xyz, shadowPos.w);\nif (pcf > 3.0) shadowAttenuation = CCGetShadowFactorX25(pos);\nelse if (pcf > 2.0) shadowAttenuation = CCGetShadowFactorX9(pos);\nelse if (pcf > 1.0) shadowAttenuation = CCGetShadowFactorX5(pos);\nelse shadowAttenuation = CCGetShadowFactorX1(pos);\nvec3 shadowColor = cc_shadowColor.rgb * cc_shadowColor.a + finalColor.rgb * (1.0 - cc_shadowColor.a);\nif (cc_shadowNFLSInfo.w > 0.000001) {\nfinalColor.rgb = shadowColor.rgb * shadowAttenuation + finalColor.rgb * (1.0 - shadowAttenuation);\n} else {\nfinalColor.rgb = shadowColor.rgb * shadowAttenuation * NL + finalColor.rgb * (1.0 - shadowAttenuation * NL);\n}\n}\n#endif\nreturn vec4(finalColor, s.albedo.a);\n}\n#if CC_PIPELINE_TYPE == 0\n# define LIGHTS_PER_PASS 1\n#else\n# define LIGHTS_PER_PASS 10\n#endif\nuniform highp vec4 cc_lightPos[LIGHTS_PER_PASS];\nuniform vec4 cc_lightColor[LIGHTS_PER_PASS];\nuniform vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\nuniform vec4 cc_lightDir[LIGHTS_PER_PASS];\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\nfloat factor = distSqr * invSqrAttRadius;\nfloat smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\nreturn smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\nfloat attenuation = 1.0 / max(distSqr, 0.01*0.01);\nattenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\nreturn attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\nfloat cd = dot(litDir, L);\nfloat attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\nreturn (attenuation * attenuation);\n}\nvec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 diffuseContrib = diffuse / 3.14159265359;\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - s.position);\nfloat NV = max(abs(dot(N, V)), 0.001);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 finalColor = vec3(0.0);\nint numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\nfor (int i = 0; i < LIGHTS_PER_PASS; i++) {\nif (i >= numLights) break;\nvec3 SLU = cc_lightPos[i].xyz - s.position;\nvec3 SL = normalize(SLU);\nvec3 SH = normalize(SL + V);\nfloat SNL = max(dot(N, SL), 0.001);\nfloat SNH = max(dot(N, SH), 0.0);\nfloat distSqr = dot(SLU, SLU);\nfloat litRadius = cc_lightSizeRangeAngle[i].x;\nfloat litRadiusSqr = litRadius * litRadius;\nfloat illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\nfloat attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\nattRadiusSqrInv *= attRadiusSqrInv;\nfloat att = GetDistAtt(distSqr, attRadiusSqrInv);\nvec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\nif (cc_lightPos[i].w > 0.0) {\nfloat cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\nfloat cosOuter = cc_lightSizeRangeAngle[i].z;\nfloat litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\nfloat litAngleOffset = -cosOuter * litAngleScale;\natt *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n}\nvec3 lightColor = cc_lightColor[i].rgb;\n#if CC_RECEIVE_SHADOW\nif (cc_lightPos[i].w > 0.0) {\n{\nfloat pcf = cc_shadowWHPBInfo.z + 0.001;\nfloat shadowAttenuation = 0.0;\nfloat cosAngle = clamp(1.0 - dot(N, normalize(cc_lightPos[i].xyz - s.position.xyz)), 0.0, 1.0);\nvec3 projWorldPos = shadowPos.xyz + cosAngle * cc_shadowLPNNInfo.z * N;\nvec4 pos = vec4(projWorldPos.xyz, shadowPos.w);\nif (pcf > 3.0) shadowAttenuation = CCGetDirLightShadowFactorX25(pos, s.position);\nelse if (pcf > 2.0) shadowAttenuation = CCGetDirLightShadowFactorX9(pos, s.position);\nelse if (pcf > 1.0) shadowAttenuation = CCGetDirLightShadowFactorX5(pos, s.position);\nelse shadowAttenuation = CCGetDirLightShadowFactorX1(pos, s.position);\nlightColor *= 1.0 - shadowAttenuation;\n}\n}\n#endif\nfinalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n}\nfinalColor = finalColor * s.occlusion;\nreturn vec4(finalColor, 0.0);\n}\nvec3 ACESToneMap (vec3 color) {\ncolor = min(color, vec3(8.0));\nconst float A = 2.51;\nconst float B = 0.03;\nconst float C = 2.43;\nconst float D = 0.59;\nconst float E = 0.14;\nreturn (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n#if !CC_USE_HDR\ncolor.rgb = sqrt(ACESToneMap(color.rgb));\n#endif\nreturn color;\n}\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nvarying vec2 v_uv;\nuniform sampler2D cc_gbuffer_albedoMap;\nuniform sampler2D cc_gbuffer_positionMap;\nuniform sampler2D cc_gbuffer_normalMap;\nuniform sampler2D cc_gbuffer_emissiveMap;\nvoid main () {\nStandardSurface s;\nvec4 albedoMap = texture2D(cc_gbuffer_albedoMap,v_uv);\nvec4 positionMap = texture2D(cc_gbuffer_positionMap,v_uv);\nvec4 normalMap = texture2D(cc_gbuffer_normalMap,v_uv);\nvec4 emissiveMap = texture2D(cc_gbuffer_emissiveMap,v_uv);\ns.albedo = albedoMap;\ns.position = positionMap.xyz;\ns.roughness = positionMap.w;\ns.normal = normalMap.xyz;\ns.metallic = normalMap.w;\ns.emissive = emissiveMap.xyz;\ns.occlusion = emissiveMap.w;\nfloat fogFactor;\n#if CC_USE_FOG == 0\nfogFactor = LinearFog(vec4(s.position, 1));\n#elif CC_USE_FOG == 1\nfogFactor = ExpFog(vec4(s.position, 1));\n#elif CC_USE_FOG == 2\nfogFactor = ExpSquaredFog(vec4(s.position, 1));\n#elif CC_USE_FOG == 3\nfogFactor = LayeredFog(vec4(s.position, 1));\n#else\nfogFactor = 1.0;\n#endif\nvec4 shadowPos;\nshadowPos = cc_matLightViewProj * vec4(s.position, 1);\nvec4 color = CCStandardShadingBase(s, shadowPos) +\nCCStandardShadingAdditive(s, shadowPos);\ncolor = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, color.rgb, fogFactor), color.a);\ngl_FragColor = CCFragOutput(color);\n}"
                        }],
                        [{
                            vert: "\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_MORPH\nattribute float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\nuniform vec4 cc_displacementWeights[15];\nuniform vec4 cc_displacementTextureInfo;\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\nreturn texture2D(tex, uv);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture2D(tex, x)),\ndecode32(texture2D(tex, y)),\ndecode32(texture2D(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nattr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nattr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nattr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nattribute vec4 a_joints;\nattribute vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n#if USE_INSTANCING\nattribute highp vec4 a_jointAnimInfo;\n#endif\nuniform highp vec4 cc_jointTextureInfo;\nuniform highp vec4 cc_jointAnimInfo;\nuniform highp sampler2D cc_jointTexture;\n#else\nuniform highp vec4 cc_joints[90];\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\n#if USE_INSTANCING\nhighp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n#else\nhighp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n#endif\nhighp float invSize = cc_jointTextureInfo.w;\nhighp float y = floor(j * invSize);\nhighp float x = floor(j - y * cc_jointTextureInfo.x);\ny = (y + 0.5) * invSize;\nvec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\n#if USE_INSTANCING\nhighp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n#else\nhighp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n#endif\nhighp float invSize = cc_jointTextureInfo.w;\nhighp float y = floor(j * invSize);\nhighp float x = floor(j - y * cc_jointTextureInfo.x);\ny = (y + 0.5) * invSize;\nvec4 v1 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\nmat4 m = skinMatrix();\nattr.position = m * attr.position;\nattr.normal = (m * vec4(attr.normal, 0.0)).xyz;\nattr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matProj;\n#if USE_INSTANCING\nattribute vec4 a_matWorld0;\nattribute vec4 a_matWorld1;\nattribute vec4 a_matWorld2;\n#if USE_LIGHTMAP\nattribute vec4 a_lightingMapUVParam;\n#endif\n#elif USE_BATCHING\nattribute float a_dyn_batch_id;\nuniform highp mat4 cc_matWorlds[10];\n#else\nuniform highp mat4 cc_matWorld;\n#endif\nuniform highp mat4 cc_matLightPlaneProj;\nvec4 vert () {\nvec4 position;\nposition = vec4(a_position, 1.0);\n#if CC_USE_MORPH\napplyMorph(position);\n#endif\n#if CC_USE_SKINNING\nCCSkin(position);\n#endif\nmat4 matWorld;\n#if USE_INSTANCING\nmatWorld = mat4(\nvec4(a_matWorld0.xyz, 0.0),\nvec4(a_matWorld1.xyz, 0.0),\nvec4(a_matWorld2.xyz, 0.0),\nvec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n);\n#elif USE_BATCHING\nmatWorld = cc_matWorlds[int(a_dyn_batch_id)];\n#else\nmatWorld = cc_matWorld;\n#endif\nposition = cc_matProj * (cc_matView * cc_matLightPlaneProj * matWorld) * position;\nposition.z -= 0.0001;\nreturn position;\n}\nvoid main() { gl_Position = vert(); }",
                            frag: "\nprecision mediump float;\nuniform lowp vec4 cc_shadowColor;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n#endif\nreturn color;\n}\nvec4 frag () {\nreturn CCFragOutput(cc_shadowColor);\n}\nvoid main() { gl_FragColor = frag(); }"
                        }],
                        [{
                            vert: "\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_MORPH\nattribute float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\nuniform vec4 cc_displacementWeights[15];\nuniform vec4 cc_displacementTextureInfo;\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\nreturn texture2D(tex, uv);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture2D(tex, x)),\ndecode32(texture2D(tex, y)),\ndecode32(texture2D(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nattr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nattr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nattr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nattribute vec4 a_joints;\nattribute vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n#if USE_INSTANCING\nattribute highp vec4 a_jointAnimInfo;\n#endif\nuniform highp vec4 cc_jointTextureInfo;\nuniform highp vec4 cc_jointAnimInfo;\nuniform highp sampler2D cc_jointTexture;\n#else\nuniform highp vec4 cc_joints[90];\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\n#if USE_INSTANCING\nhighp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n#else\nhighp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n#endif\nhighp float invSize = cc_jointTextureInfo.w;\nhighp float y = floor(j * invSize);\nhighp float x = floor(j - y * cc_jointTextureInfo.x);\ny = (y + 0.5) * invSize;\nvec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\n#if USE_INSTANCING\nhighp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n#else\nhighp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n#endif\nhighp float invSize = cc_jointTextureInfo.w;\nhighp float y = floor(j * invSize);\nhighp float x = floor(j - y * cc_jointTextureInfo.x);\ny = (y + 0.5) * invSize;\nvec4 v1 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\nmat4 m = skinMatrix();\nattr.position = m * attr.position;\nattr.normal = (m * vec4(attr.normal, 0.0)).xyz;\nattr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nuniform highp vec4 cc_cameraPos;\nvarying vec2 v_uv;\nvoid main () {\nStandardVertInput In;\nIn.position = vec4(a_position, 1.0);\nIn.normal = a_normal;\nIn.tangent = a_tangent;\n#if CC_USE_MORPH\napplyMorph(In);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In);\n#endif\nIn.position.xy = cc_cameraPos.w == 0.0 ? vec2(In.position.xy.x, -In.position.xy.y) : In.position.xy;\ngl_Position = In.position;\ngl_Position.y = gl_Position.y;\nv_uv = a_texCoord;\n}",
                            frag: "\nprecision highp float;\nuniform mediump vec4 cc_screenSize;\nvarying vec2 v_uv;\nuniform sampler2D cc_lighting_resultMap;\nvoid texcoords(vec2 fragCoord, vec2 resolution,\nout vec2 v_rgbNW, out vec2 v_rgbNE,\nout vec2 v_rgbSW, out vec2 v_rgbSE,\nout vec2 v_rgbM) {\nvec2 inverseVP = 1.0 / resolution.xy;\nv_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\nv_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\nv_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\nv_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\nv_rgbM = vec2(fragCoord * inverseVP);\n}\nvec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 resolution,\nvec2 v_rgbNW, vec2 v_rgbNE,\nvec2 v_rgbSW, vec2 v_rgbSE,\nvec2 v_rgbM) {\nvec4 color;\nmediump vec2 inverseVP = vec2(1.0 / resolution.x, 1.0 / resolution.y);\nvec3 rgbNW = texture2D(tex, v_rgbNW).xyz;\nvec3 rgbNE = texture2D(tex, v_rgbNE).xyz;\nvec3 rgbSW = texture2D(tex, v_rgbSW).xyz;\nvec3 rgbSE = texture2D(tex, v_rgbSE).xyz;\nvec4 texColor = texture2D(tex, v_rgbM);\nvec3 rgbM  = texColor.xyz;\nvec3 luma = vec3(0.299, 0.587, 0.114);\nfloat lumaNW = dot(rgbNW, luma);\nfloat lumaNE = dot(rgbNE, luma);\nfloat lumaSW = dot(rgbSW, luma);\nfloat lumaSE = dot(rgbSE, luma);\nfloat lumaM  = dot(rgbM,  luma);\nfloat lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\nfloat lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\nmediump vec2 dir;\ndir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\ndir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\nfloat dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n(0.25 * (1.0 / 8.0)), (1.0/ 128.0));\nfloat rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\ndir = min(vec2(8.0, 8.0),\nmax(vec2(-8.0, -8.0),\ndir * rcpDirMin)) * inverseVP;\nvec3 rgbA = 0.5 * (\ntexture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\ntexture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\nvec3 rgbB = rgbA * 0.5 + 0.25 * (\ntexture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +\ntexture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);\nfloat lumaB = dot(rgbB, luma);\nif ((lumaB < lumaMin) || (lumaB > lumaMax))\ncolor = vec4(rgbA, texColor.a);\nelse\ncolor = vec4(rgbB, texColor.a);\nreturn color;\n}\nvoid main () {\nmediump vec2 v_rgbNW;\nmediump vec2 v_rgbNE;\nmediump vec2 v_rgbSW;\nmediump vec2 v_rgbSE;\nmediump vec2 v_rgbM;\nvec2 resolution = cc_screenSize.xy;\nvec2 fragCoord = v_uv * resolution;\ntexcoords(fragCoord, resolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\ngl_FragColor = fxaa(cc_lighting_resultMap, fragCoord, resolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n}"
                        }],
                        [{
                            vert: "\nprecision highp float;\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matProj;\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\nvarying mediump vec4 viewDir;\nvec4 vert () {\nviewDir = vec4(a_position, 1.0);\nmat4 matViewRotOnly = mat4(mat3(cc_matView));\nmat4 matProj = cc_matProj;\nif (matProj[3].w > 0.0) {\nvec2 scale = vec2(48.0, 24.0);\nmatProj[0].xy *= scale;\nmatProj[1].xy *= scale;\nmatProj[2].zw = vec2(-1.0);\nmatProj[3].zw = vec2(0.0);\n}\nvec4 pos = matProj * matViewRotOnly * viewDir;\npos.z = 0.99999 * pos.w;\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
                            frag: "\nprecision mediump float;\nuniform mediump vec4 cc_ambientSky;\nuniform samplerCube cc_environment;\nvec3 unpackRGBE (vec4 rgbe) {\nreturn rgbe.rgb * pow(2.0, rgbe.a * 255.0 - 128.0);\n}\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvec3 ACESToneMap (vec3 color) {\ncolor = min(color, vec3(8.0));\nconst float A = 2.51;\nconst float B = 0.03;\nconst float C = 2.43;\nconst float D = 0.59;\nconst float E = 0.14;\nreturn (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n#if !CC_USE_HDR\ncolor.rgb = sqrt(ACESToneMap(color.rgb));\n#endif\nreturn color;\n}\nvarying mediump vec4 viewDir;\nvec4 frag () {\n#if USE_RGBE_CUBEMAP\nvec3 c = unpackRGBE(textureCube(cc_environment, viewDir.xyz));\n#else\nvec3 c = SRGBToLinear(textureCube(cc_environment, viewDir.xyz).rgb);\n#endif\nreturn CCFragOutput(vec4(c * cc_ambientSky.w, 1.0));\n}\nvoid main() { gl_FragColor = frag(); }"
                        }],
                        [{
                            vert: "\nprecision mediump float;\nuniform highp mat4 cc_matViewProj;\nattribute vec3 a_position;\nattribute vec4 a_color;\nvarying vec2 v_uv;\nuniform vec4 offset;\nuniform vec4 digits[20];\nfloat getComponent(vec4 v, float i) {\nif (i < 1.0) { return v.x; }\nelse if (i < 2.0) { return v.y; }\nelse if (i < 3.0) { return v.z; }\nelse { return v.w; }\n}\nvec4 vert () {\nvec4 position = cc_matViewProj * vec4(a_position, 1.0);\nposition.xy += offset.xy;\nv_uv = a_color.xy;\nif (a_color.z >= 0.0) {\nfloat n = getComponent(digits[int(a_color.z)], a_color.w);\nv_uv += vec2(offset.z * n, 0.0);\n}\nreturn position;\n}\nvoid main() { gl_Position = vert(); }",
                            frag: "\nprecision mediump float;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n#endif\nreturn color;\n}\nvarying vec2 v_uv;\nuniform sampler2D mainTexture;\nvec4 frag () {\nreturn CCFragOutput(texture2D(mainTexture, v_uv));\n}\nvoid main() { gl_FragColor = frag(); }"
                        }],
                        [{
                            vert: "\nprecision mediump float;\nattribute vec2 a_position;\nattribute vec2 a_texCoord;\nvarying vec2 v_uv;\nvarying float v_percent;\nuniform vec4 u_buffer0;\nuniform vec4 u_buffer1;\nuniform mat4 u_projection;\nvec4 vert () {\nvec2 worldPos = a_position * u_buffer1.xy + u_buffer1.zw;\nvec2 clipSpace = worldPos / u_buffer0.xy * 2.0 - 1.0;\nvec4 screenPos = u_projection * vec4(clipSpace, 0.0, 1.0);\nv_uv = a_texCoord;\nv_percent = u_buffer0.z;\nreturn screenPos;\n}\nvoid main() { gl_Position = vert(); }",
                            frag: "\nprecision mediump float;\nvarying vec2 v_uv;\nvarying float v_percent;\nuniform sampler2D mainTexture;\nvec4 frag () {\nvec4 color = texture2D(mainTexture, v_uv);\nfloat precent = clamp(v_percent, 0.0, 1.0);\ncolor.xyz *= precent;\nreturn color;\n}\nvoid main() { gl_FragColor = frag(); }"
                        }]
                    ],
                    glsl3: [
                        [{
                            vert: "\nprecision mediump float;\nlayout(std140) uniform Constants {\nvec4 mainTiling_Offset;\nvec4 frameTile_velLenScale;\nvec4 scale;\n};\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\nmat3 m = mat3(xAxis,yAxis,zAxis);\nfloat trace = m[0][0] + m[1][1] + m[2][2];\nvec4 quat;\nif (trace > 0.) {\nfloat s = 0.5 / sqrt(trace + 1.0);\nquat.w = 0.25 / s;\nquat.x = (m[2][1] - m[1][2]) * s;\nquat.y = (m[0][2] - m[2][0]) * s;\nquat.z = (m[1][0] - m[0][1]) * s;\n} else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\nfloat s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\nquat.w = (m[2][1] - m[1][2]) / s;\nquat.x = 0.25 * s;\nquat.y = (m[0][1] + m[1][0]) / s;\nquat.z = (m[0][2] + m[2][0]) / s;\n} else if (m[1][1] > m[2][2]) {\nfloat s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\nquat.w = (m[0][2] - m[2][0]) / s;\nquat.x = (m[0][1] + m[1][0]) / s;\nquat.y = 0.25 * s;\nquat.z = (m[1][2] + m[2][1]) / s;\n} else {\nfloat s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\nquat.w = (m[1][0] - m[0][1]) / s;\nquat.x = (m[0][2] + m[2][0]) / s;\nquat.y = (m[1][2] + m[2][1]) / s;\nquat.z = 0.25 * s;\n}\nfloat len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\nif (len > 0.) {\nlen = 1. / sqrt(len);\nquat.x = quat.x * len;\nquat.y = quat.y * len;\nquat.z = quat.z * len;\nquat.w = quat.w * len;\n}\nreturn quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\nfloat x = angle.x / 2.;\nfloat y = angle.y / 2.;\nfloat z = angle.z / 2.;\nfloat sx = sin(x);\nfloat cx = cos(x);\nfloat sy = sin(y);\nfloat cy = cos(y);\nfloat sz = sin(z);\nfloat cz = cos(z);\nvec4 quat = vec4(0);\nquat.x = sx * cy * cz + cx * sy * sz;\nquat.y = cx * sy * cz + sx * cy * sz;\nquat.z = cx * cy * sz - sx * sy * cz;\nquat.w = cx * cy * cz - sx * sy * sz;\nreturn quat;\n}\nvec4 quatMultiply (vec4 a, vec4 b){\nvec4 quat;\nquat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\nquat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\nquat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\nquat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\nreturn quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\nfloat ix = q.w * v.x + q.y * v.z - q.z * v.y;\nfloat iy = q.w * v.y + q.z * v.x - q.x * v.z;\nfloat iz = q.w * v.z + q.x * v.y - q.y * v.x;\nfloat iw = -q.x * v.x - q.y * v.y - q.z * v.z;\nv.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\nv.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\nv.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\nvec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\nvec4 rotQuat = quatMultiply(viewQuat, q);\nrotateVecFromQuat(pos, rotQuat);\nreturn pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\nfloat xOS = cos(angle) * corner.x - sin(angle) * corner.y;\nfloat yOS = sin(angle) * corner.x + cos(angle) * corner.y;\ncorner.x = xOS;\ncorner.y = yOS;\n}\nout mediump vec2 uv;\nout mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n, mat4 viewInv\n) {\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nvec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\nvec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\nvec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\npos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n}\nin vec3 a_position;\nin vec2 a_texCoord;\nin vec4 a_color;\nlayout(std140) uniform builtin {\nvec4 cc_size_rotation;\n};\nvec4 vs_main() {\nvec4 pos = vec4(a_position, 1);\npos = cc_matWorld * pos;\nvec2 vertOffset = a_texCoord.xy - 0.5;\ncomputeVertPos(pos, vertOffset, quaternionFromEuler(vec3(0., 0., cc_size_rotation.z)), vec3(cc_size_rotation.xy, 0.), cc_matViewInv);\npos = cc_matViewProj * pos;\nuv = a_texCoord.xy;\ncolor = a_color;\nreturn pos;\n}\nvoid main() { gl_Position = vs_main(); }",
                            frag: "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n#endif\nreturn color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nlayout(std140) uniform FragConstants {\nvec4 tintColor;\n};\nvec4 add () {\nvec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\nreturn CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"
                        }],
                        [{
                            vert: "\nprecision highp float;\nin vec3 a_position;\nvec4 vert () {\nvec4 pos = vec4(a_position, 1);\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
                            frag: "\nprecision highp float;\nvec4 frag () {\nvec4 o = vec4(1.0);\nreturn o;\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
                        }],
                        [{
                            vert: "\nprecision highp float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\nin vec3 a_position;\nin vec4 a_color;\nout vec4 v_color;\nin float a_dist;\nout float v_dist;\nvec4 vert () {\nvec4 pos = vec4(a_position, 1);\npos = cc_matViewProj * cc_matWorld * pos;\nv_color = a_color;\nv_dist = a_dist;\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
                            frag: "\nprecision highp float;\nin vec4 v_color;\nin float v_dist;\nvec4 frag () {\nvec4 o = v_color;\nfloat aa = fwidth(v_dist);\nfloat alpha = 1. - smoothstep(-aa, 0., abs(v_dist) - 1.0);\no.rgb *= o.a;\no *= alpha;\nreturn o;\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
                        }],
                        [{
                            vert: "\nprecision mediump float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\nmat3 m = mat3(xAxis,yAxis,zAxis);\nfloat trace = m[0][0] + m[1][1] + m[2][2];\nvec4 quat;\nif (trace > 0.) {\nfloat s = 0.5 / sqrt(trace + 1.0);\nquat.w = 0.25 / s;\nquat.x = (m[2][1] - m[1][2]) * s;\nquat.y = (m[0][2] - m[2][0]) * s;\nquat.z = (m[1][0] - m[0][1]) * s;\n} else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\nfloat s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\nquat.w = (m[2][1] - m[1][2]) / s;\nquat.x = 0.25 * s;\nquat.y = (m[0][1] + m[1][0]) / s;\nquat.z = (m[0][2] + m[2][0]) / s;\n} else if (m[1][1] > m[2][2]) {\nfloat s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\nquat.w = (m[0][2] - m[2][0]) / s;\nquat.x = (m[0][1] + m[1][0]) / s;\nquat.y = 0.25 * s;\nquat.z = (m[1][2] + m[2][1]) / s;\n} else {\nfloat s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\nquat.w = (m[1][0] - m[0][1]) / s;\nquat.x = (m[0][2] + m[2][0]) / s;\nquat.y = (m[1][2] + m[2][1]) / s;\nquat.z = 0.25 * s;\n}\nfloat len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\nif (len > 0.) {\nlen = 1. / sqrt(len);\nquat.x = quat.x * len;\nquat.y = quat.y * len;\nquat.z = quat.z * len;\nquat.w = quat.w * len;\n}\nreturn quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\nfloat x = angle.x / 2.;\nfloat y = angle.y / 2.;\nfloat z = angle.z / 2.;\nfloat sx = sin(x);\nfloat cx = cos(x);\nfloat sy = sin(y);\nfloat cy = cos(y);\nfloat sz = sin(z);\nfloat cz = cos(z);\nvec4 quat = vec4(0);\nquat.x = sx * cy * cz + cx * sy * sz;\nquat.y = cx * sy * cz + sx * cy * sz;\nquat.z = cx * cy * sz - sx * sy * cz;\nquat.w = cx * cy * cz - sx * sy * sz;\nreturn quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\nfloat x2 = q.x + q.x;\nfloat y2 = q.y + q.y;\nfloat z2 = q.z + q.z;\nfloat xx = q.x * x2;\nfloat xy = q.x * y2;\nfloat xz = q.x * z2;\nfloat yy = q.y * y2;\nfloat yz = q.y * z2;\nfloat zz = q.z * z2;\nfloat wx = q.w * x2;\nfloat wy = q.w * y2;\nfloat wz = q.w * z2;\nreturn mat4(\n1. - (yy + zz), xy + wz, xz - wy, 0,\nxy - wz, 1. - (xx + zz), yz + wx, 0,\nxz + wy, yz - wx, 1. - (xx + yy), 0,\np.x, p.y, p.z, 1\n);\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\nfloat x = q.x, y = q.y, z = q.z, w = q.w;\nfloat x2 = x + x;\nfloat y2 = y + y;\nfloat z2 = z + z;\nfloat xx = x * x2;\nfloat xy = x * y2;\nfloat xz = x * z2;\nfloat yy = y * y2;\nfloat yz = y * z2;\nfloat zz = z * z2;\nfloat wx = w * x2;\nfloat wy = w * y2;\nfloat wz = w * z2;\nfloat sx = s.x;\nfloat sy = s.y;\nfloat sz = s.z;\nreturn mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n(xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n(xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\nt.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\nvec4 quat;\nquat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\nquat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\nquat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\nquat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\nreturn quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\nfloat ix = q.w * v.x + q.y * v.z - q.z * v.y;\nfloat iy = q.w * v.y + q.z * v.x - q.x * v.z;\nfloat iz = q.w * v.z + q.x * v.y - q.y * v.x;\nfloat iw = -q.x * v.x - q.y * v.y - q.z * v.z;\nv.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\nv.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\nv.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\nvec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\nvec4 rotQuat = quatMultiply(viewQuat, q);\nrotateVecFromQuat(pos, rotQuat);\nreturn pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\nfloat xOS = cos(angle) * corner.x - sin(angle) * corner.y;\nfloat yOS = sin(angle) * corner.x + cos(angle) * corner.y;\ncorner.x = xOS;\ncorner.y = yOS;\n}\nlayout(std140) uniform Constants {\nvec4 mainTiling_Offset;\nvec4 frameTile_velLenScale;\nvec4 scale;\n};\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\nout mediump vec2 uv;\nout mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n, mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n, vec3 eye\n, vec4 velocity\n, float velocityScale\n, float lengthScale\n, float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nvec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\nvec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\nvec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\npos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\nvec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\nvec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\npos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nvec3 camX = vec3(1, 0, 0);\nvec3 camY = vec3(0, 0, -1);\npos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\nvec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\nrotateCorner(viewSpaceVert, q.z);\nvec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\nvec3 camY = vec3(0, 1, 0);\nvec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\npos.xyz += offset;\n#else\npos.x += vertOffset.x;\npos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\nvec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\naniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\nvertIndex.y = 1. - vertIndex.y;\n#endif\nreturn (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nlayout(std140) uniform SampleConstants {\nvec4 u_sampleInfo;\n};\nlayout(std140) uniform TickConstants {\nvec4 u_worldRot;\nvec4 u_timeDelta;\n};\nin vec4 a_position_starttime;\nin vec4 a_size_uv;\nin vec4 a_rotation_uv;\nin vec4 a_color;\nin vec4 a_dir_life;\nin float a_rndSeed;\n#if CC_RENDER_MODE == 4\nin vec3 a_texCoord;\nin vec3 a_texCoord3;\nin vec3 a_normal;\nin vec4 a_color1;\n#endif\nvec3 unpackCurveData (sampler2D tex, vec2 coord) {\nvec4 a = texture(tex, coord);\nvec4 b = texture(tex, coord + u_sampleInfo.y);\nfloat c = fract(coord.x * u_sampleInfo.x);\nreturn mix(a.xyz, b.xyz, c);\n}\nvec3 unpackCurveData (sampler2D tex, vec2 coord, out float w) {\nvec4 a = texture(tex, coord);\nvec4 b = texture(tex, coord + u_sampleInfo.y);\nfloat c = fract(coord.x * u_sampleInfo.x);\nw = mix(a.w, b.w, c);\nreturn mix(a.xyz, b.xyz, c);\n}\nfloat pseudoRandom (float seed) {\nseed = mod(seed, 233280.);\nfloat q = (seed * 9301. + 49297.) / 233280.;\nreturn fract(q);\n}\n#if COLOR_OVER_TIME_MODULE_ENABLE\nuniform sampler2D color_over_time_tex0;\nlayout(std140) uniform ColorConstant {\nint u_color_mode;\n};\n#endif\n#if ROTATION_OVER_TIME_MODULE_ENABLE\nuniform sampler2D rotation_over_time_tex0;\nlayout(std140) uniform RotationConstant {\nint u_rotation_mode;\n};\n#endif\n#if SIZE_OVER_TIME_MODULE_ENABLE\nuniform sampler2D size_over_time_tex0;\nlayout(std140) uniform SizeConstant {\nint u_size_mode;\n};\n#endif\n#if FORCE_OVER_TIME_MODULE_ENABLE\nuniform sampler2D force_over_time_tex0;\nlayout(std140) uniform ForceConstant {\nint u_force_mode;\nint u_force_space;\n};\n#endif\n#if VELOCITY_OVER_TIME_MODULE_ENABLE\nuniform sampler2D velocity_over_time_tex0;\nlayout(std140) uniform VelocityConstant {\nint u_velocity_mode;\nint u_velocity_space;\n};\n#endif\n#if TEXTURE_ANIMATION_MODULE_ENABLE\nuniform sampler2D texture_animation_tex0;\nlayout(std140) uniform AnimationConstant {\nvec4 u_anim_info;\n};\n#endif\nfloat repeat (float t, float length) {\nreturn t - floor(t / length) * length;\n}\nvec4 rotateQuat (vec4 p, vec4 q) {\nvec3 iv = cross(q.xyz, p.xyz) + q.w * p.xyz;\nvec3 res = p.xyz + 2.0 * cross(q.xyz, iv);\nreturn vec4(res.xyz, p.w);\n}\nvec4 gpvs_main () {\nfloat activeTime = u_timeDelta.x - a_position_starttime.w;\nfloat normalizedTime = clamp(activeTime / a_dir_life.w, 0.0, 1.0);\nvec2 timeCoord0 = vec2(normalizedTime, 0.);\nvec2 timeCoord1 = vec2(normalizedTime, 1.);\n#if CC_RENDER_MODE == 4\nvec2 vertIdx = vec2(a_texCoord.x, a_texCoord.y);\n#else\nvec2 vertIdx = vec2(a_size_uv.w, a_rotation_uv.w);\n#endif\nvec4 velocity = vec4(a_dir_life.xyz, 0.);\nvec4 pos = vec4(a_position_starttime.xyz, 1.);\nvec3 size = a_size_uv.xyz;\n#if SIZE_OVER_TIME_MODULE_ENABLE\nif (u_size_mode == 1) {\nsize *= unpackCurveData(size_over_time_tex0, timeCoord0);\n} else {\nvec3 size_0 = unpackCurveData(size_over_time_tex0, timeCoord0);\nvec3 size_1 = unpackCurveData(size_over_time_tex0, timeCoord1);\nfloat factor_s = pseudoRandom(a_rndSeed + 39825.);\nsize *= mix(size_0, size_1, factor_s);\n}\n#endif\nvec3 compScale = scale.xyz * size;\n#if FORCE_OVER_TIME_MODULE_ENABLE\nvec3 forceAnim = vec3(0.);\nif (u_force_mode == 1) {\nforceAnim = unpackCurveData(force_over_time_tex0, timeCoord0);\n} else {\nvec3 force_0 = unpackCurveData(force_over_time_tex0, timeCoord0);\nvec3 force_1 = unpackCurveData(force_over_time_tex0, timeCoord1);\nfloat factor_f =  pseudoRandom(a_rndSeed + 212165.);\nforceAnim = mix(force_0, force_1, factor_f);\n}\nvec4 forceTrack = vec4(forceAnim, 0.);\nif (u_force_space == 0) {\nforceTrack = rotateQuat(forceTrack, u_worldRot);\n}\nvelocity.xyz += forceTrack.xyz;\n#endif\n#if VELOCITY_OVER_TIME_MODULE_ENABLE\nfloat speedModifier0 = 1.;\nfloat speedModifier1 = 1.;\nvec3 velocityAnim = vec3(0.);\nif (u_velocity_mode == 1) {\nvelocityAnim = unpackCurveData(velocity_over_time_tex0, timeCoord0, speedModifier0);\n} else {\nvec3 vectory_0 = unpackCurveData(velocity_over_time_tex0, timeCoord0, speedModifier0);\nvec3 vectory_1 = unpackCurveData(velocity_over_time_tex0, timeCoord1, speedModifier1);\nfloat factor_v = pseudoRandom(a_rndSeed + 197866.);\nvelocityAnim = mix(vectory_0, vectory_1, factor_v);\nspeedModifier0 = mix(speedModifier0, speedModifier1, factor_v);\n}\nvec4 velocityTrack = vec4(velocityAnim, 0.);\nif (u_velocity_space == 0) {\nvelocityTrack = rotateQuat(velocityTrack, u_worldRot);\n}\nvelocity.xyz += velocityTrack.xyz;\nvelocity.xyz *= speedModifier0;\n#endif\npos.xyz += velocity.xyz * normalizedTime * a_dir_life.w;\n#if !CC_USE_WORLD_SPACE\npos = cc_matWorld * pos;\n#if CC_RENDER_MODE == 1\nvelocity = rotateQuat(velocity, u_worldRot);\n#endif\n#endif\nvec3 rotation = a_rotation_uv.xyz;\n#if ROTATION_OVER_TIME_MODULE_ENABLE\nif (u_rotation_mode == 1) {\nrotation += unpackCurveData(rotation_over_time_tex0, timeCoord0) * normalizedTime * a_dir_life.w;\n} else {\nvec3 rotation_0 = unpackCurveData(rotation_over_time_tex0, timeCoord0);\nvec3 rotation_1 = unpackCurveData(rotation_over_time_tex0, timeCoord1);\nfloat factor_r = pseudoRandom(a_rndSeed + 125292.);\nrotation += mix(rotation_0, rotation_1, factor_r) * normalizedTime * a_dir_life.w;\n}\n#endif\n#if COLOR_OVER_TIME_MODULE_ENABLE\nif (u_color_mode == 1) {\ncolor = a_color * texture(color_over_time_tex0, timeCoord0);\n} else {\nvec4 color_0 = texture(color_over_time_tex0, timeCoord0);\nvec4 color_1 = texture(color_over_time_tex0, timeCoord1);\nfloat factor_c = pseudoRandom(a_rndSeed + 91041.);\ncolor = a_color * mix(color_0, color_1, factor_c);\n}\n#else\ncolor = a_color;\n#endif\n#if CC_RENDER_MODE != 4\nvec2 cornerOffset = vec2((vertIdx - 0.5));\n#if CC_RENDER_MODE == 0\nvec3 rotEuler = rotation.xyz;\n#elif CC_RENDER_MODE == 1\nvec3 rotEuler = vec3(0.);\n#else\nvec3 rotEuler = vec3(0., 0., rotation.z);\n#endif\ncomputeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n, cc_matViewInv\n#endif\n#if CC_RENDER_MODE == 1\n, cc_cameraPos.xyz\n, velocity\n, frameTile_velLenScale.z\n, frameTile_velLenScale.w\n, a_size_uv.w\n#endif\n);\n#else\nmat4 xformNoScale = matrixFromRT(quaternionFromEuler(rotation), pos.xyz);\nmat4 xform = matFromRTS(quaternionFromEuler(rotation), pos.xyz, compScale);\npos = xform * vec4(a_texCoord3, 1);\nvec4 normal = xformNoScale * vec4(a_normal, 0);\ncolor *= a_color1;\n#endif\npos = cc_matViewProj * pos;\nfloat frameIndex = 0.;\n#if TEXTURE_ANIMATION_MODULE_ENABLE\nfloat startFrame = 0.;\nvec3 frameInfo = vec3(0.);\nif (int(u_anim_info.x) == 1) {\nframeInfo = unpackCurveData(texture_animation_tex0, timeCoord0);\n} else {\nvec3 frameInfo0 = unpackCurveData(texture_animation_tex0, timeCoord0);\nvec3 frameInfo1 = unpackCurveData(texture_animation_tex0, timeCoord1);\nfloat factor_t = pseudoRandom(a_rndSeed + 90794.);\nframeInfo = mix(frameInfo0, frameInfo1, factor_t);\n}\nstartFrame = frameInfo.x / u_anim_info.y;\nframeIndex = repeat(u_anim_info.z * (frameInfo.y + startFrame), 1.);\n#endif\nuv = computeUV(frameIndex, vertIdx, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\nreturn pos;\n}\nvoid main() { gl_Position = gpvs_main(); }",
                            frag: "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n#endif\nreturn color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nlayout(std140) uniform FragConstants {\nvec4 tintColor;\n};\nvec4 add () {\nvec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\nreturn CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"
                        }],
                        [{
                            vert: "\nprecision mediump float;\nlayout(std140) uniform Constants {\nvec4 mainTiling_Offset;\nvec4 frameTile_velLenScale;\nvec4 scale;\n};\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\nout mediump vec2 uv;\nout mediump vec4 color;\nin vec3 a_position;\nin vec4 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_DRAW_WIRE_FRAME\nout vec3 vBarycentric;\n#endif\nvec4 vs_main() {\nhighp vec4 pos = vec4(a_position, 1);\nvec4 velocity = vec4(a_texCoord1.xyz, 0);\n#if !CC_USE_WORLD_SPACE\npos = cc_matWorld * pos;\nvelocity = cc_matWorld * velocity;\n#endif\nfloat vertOffset = (a_texCoord.x - 0.5) * a_texCoord.y;\nvec3 camUp = normalize(cross(pos.xyz - cc_cameraPos.xyz, velocity.xyz));\npos.xyz += camUp * vertOffset;\npos = cc_matViewProj * pos;\nuv = a_texCoord.zw * mainTiling_Offset.xy + mainTiling_Offset.zw;;\ncolor = a_color;\n#if CC_DRAW_WIRE_FRAME\nvBarycentric = a_texCoord2;\n#endif\nreturn pos;\n}\nvoid main() { gl_Position = vs_main(); }",
                            frag: "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n#endif\nreturn color;\n}\nin vec2 uv;\nin vec4 color;\n#if CC_DRAW_WIRE_FRAME\nin vec3 vBarycentric;\n#endif\nuniform sampler2D mainTexture;\nlayout(std140) uniform FragConstants {\nvec4 tintColor;\n};\nvec4 add () {\nvec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\n#if CC_DRAW_WIRE_FRAME\nif (any(lessThan(vBarycentric, vec3(0.02)))) {\ncol = vec4(0., 1., 1., 1.);\n}\n#endif\nreturn CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"
                        }],
                        [{
                            vert: "\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\nmat3 m = mat3(xAxis,yAxis,zAxis);\nfloat trace = m[0][0] + m[1][1] + m[2][2];\nvec4 quat;\nif (trace > 0.) {\nfloat s = 0.5 / sqrt(trace + 1.0);\nquat.w = 0.25 / s;\nquat.x = (m[2][1] - m[1][2]) * s;\nquat.y = (m[0][2] - m[2][0]) * s;\nquat.z = (m[1][0] - m[0][1]) * s;\n} else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\nfloat s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\nquat.w = (m[2][1] - m[1][2]) / s;\nquat.x = 0.25 * s;\nquat.y = (m[0][1] + m[1][0]) / s;\nquat.z = (m[0][2] + m[2][0]) / s;\n} else if (m[1][1] > m[2][2]) {\nfloat s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\nquat.w = (m[0][2] - m[2][0]) / s;\nquat.x = (m[0][1] + m[1][0]) / s;\nquat.y = 0.25 * s;\nquat.z = (m[1][2] + m[2][1]) / s;\n} else {\nfloat s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\nquat.w = (m[1][0] - m[0][1]) / s;\nquat.x = (m[0][2] + m[2][0]) / s;\nquat.y = (m[1][2] + m[2][1]) / s;\nquat.z = 0.25 * s;\n}\nfloat len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\nif (len > 0.) {\nlen = 1. / sqrt(len);\nquat.x = quat.x * len;\nquat.y = quat.y * len;\nquat.z = quat.z * len;\nquat.w = quat.w * len;\n}\nreturn quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\nfloat x = angle.x / 2.;\nfloat y = angle.y / 2.;\nfloat z = angle.z / 2.;\nfloat sx = sin(x);\nfloat cx = cos(x);\nfloat sy = sin(y);\nfloat cy = cos(y);\nfloat sz = sin(z);\nfloat cz = cos(z);\nvec4 quat = vec4(0);\nquat.x = sx * cy * cz + cx * sy * sz;\nquat.y = cx * sy * cz + sx * cy * sz;\nquat.z = cx * cy * sz - sx * sy * cz;\nquat.w = cx * cy * cz - sx * sy * sz;\nreturn quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\nfloat x2 = q.x + q.x;\nfloat y2 = q.y + q.y;\nfloat z2 = q.z + q.z;\nfloat xx = q.x * x2;\nfloat xy = q.x * y2;\nfloat xz = q.x * z2;\nfloat yy = q.y * y2;\nfloat yz = q.y * z2;\nfloat zz = q.z * z2;\nfloat wx = q.w * x2;\nfloat wy = q.w * y2;\nfloat wz = q.w * z2;\nreturn mat4(\n1. - (yy + zz), xy + wz, xz - wy, 0,\nxy - wz, 1. - (xx + zz), yz + wx, 0,\nxz + wy, yz - wx, 1. - (xx + yy), 0,\np.x, p.y, p.z, 1\n);\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\nfloat x = q.x, y = q.y, z = q.z, w = q.w;\nfloat x2 = x + x;\nfloat y2 = y + y;\nfloat z2 = z + z;\nfloat xx = x * x2;\nfloat xy = x * y2;\nfloat xz = x * z2;\nfloat yy = y * y2;\nfloat yz = y * z2;\nfloat zz = z * z2;\nfloat wx = w * x2;\nfloat wy = w * y2;\nfloat wz = w * z2;\nfloat sx = s.x;\nfloat sy = s.y;\nfloat sz = s.z;\nreturn mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n(xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n(xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\nt.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\nvec4 quat;\nquat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\nquat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\nquat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\nquat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\nreturn quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\nfloat ix = q.w * v.x + q.y * v.z - q.z * v.y;\nfloat iy = q.w * v.y + q.z * v.x - q.x * v.z;\nfloat iz = q.w * v.z + q.x * v.y - q.y * v.x;\nfloat iw = -q.x * v.x - q.y * v.y - q.z * v.z;\nv.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\nv.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\nv.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\nvec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\nvec4 rotQuat = quatMultiply(viewQuat, q);\nrotateVecFromQuat(pos, rotQuat);\nreturn pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\nfloat xOS = cos(angle) * corner.x - sin(angle) * corner.y;\nfloat yOS = sin(angle) * corner.x + cos(angle) * corner.y;\ncorner.x = xOS;\ncorner.y = yOS;\n}\nlayout(std140) uniform Constants {\nvec4 mainTiling_Offset;\nvec4 frameTile_velLenScale;\nvec4 scale;\n};\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\nout mediump vec2 uv;\nout mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n, mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n, vec3 eye\n, vec4 velocity\n, float velocityScale\n, float lengthScale\n, float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nvec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\nvec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\nvec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\npos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\nvec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\nvec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\npos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\nvec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\nvec3 camX = vec3(1, 0, 0);\nvec3 camY = vec3(0, 0, -1);\npos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\nvec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\nrotateCorner(viewSpaceVert, q.z);\nvec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\nvec3 camY = vec3(0, 1, 0);\nvec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\npos.xyz += offset;\n#else\npos.x += vertOffset.x;\npos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\nvec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\naniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\nvertIndex.y = 1. - vertIndex.y;\n#endif\nreturn (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nin vec3 a_position;\nin vec3 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_RENDER_MODE == 1\nin vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\nin vec3 a_texCoord3;\nin vec3 a_normal;\nin vec4 a_color1;\n#endif\nvec4 lpvs_main () {\nvec3 compScale = scale.xyz * a_texCoord1;\nvec4 pos = vec4(a_position, 1);\n#if CC_RENDER_MODE == 1\nvec4 velocity = vec4(a_color1.xyz, 0);\n#endif\n#if !CC_USE_WORLD_SPACE\npos = cc_matWorld * pos;\n#if CC_RENDER_MODE == 1\nvelocity = cc_matWorld * velocity;\n#endif\n#endif\n#if CC_RENDER_MODE != 4\nvec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n#if CC_RENDER_MODE == 0\nvec3 rotEuler = a_texCoord2;\n#elif CC_RENDER_MODE == 1\nvec3 rotEuler = vec3(0.);\n#else\nvec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n#endif\ncomputeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n, cc_matViewInv\n#endif\n#if CC_RENDER_MODE == 1\n, cc_cameraPos.xyz\n, velocity\n, frameTile_velLenScale.z\n, frameTile_velLenScale.w\n, a_texCoord.x\n#endif\n);\ncolor = a_color;\n#else\nmat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\nmat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\npos = xform * vec4(a_texCoord3, 1);\nvec4 normal = xformNoScale * vec4(a_normal, 0);\ncolor = a_color * a_color1;\n#endif\nuv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\npos = cc_matViewProj * pos;\nreturn pos;\n}\nvoid main() { gl_Position = lpvs_main(); }",
                            frag: "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n#endif\nreturn color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nlayout(std140) uniform FragConstants {\nvec4 tintColor;\n};\nvec4 add () {\nvec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\nreturn CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"
                        }],
                        [{
                            vert: "\nprecision highp float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\n#if USE_LOCAL\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\n#endif\nin vec3 a_position;\nin vec2 a_texCoord;\nin vec4 a_color;\nout vec4 v_light;\nout vec2 uv0;\n#if TWO_COLORED\nin vec4 a_color2;\nout vec4 v_dark;\n#endif\nvec4 vert () {\nvec4 pos = vec4(a_position, 1);\n#if USE_LOCAL\npos = cc_matWorld * pos;\n#endif\npos = cc_matViewProj * pos;\nuv0 = a_texCoord;\nv_light = a_color;\n#if TWO_COLORED\nv_dark = a_color2;\n#endif\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
                            frag: "\nprecision highp float;\n#if USE_ALPHA_TEST\nlayout(std140) uniform ALPHA_TEST_DATA {\nfloat alphaThreshold;\n};\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n#if USE_ALPHA_TEST\nif (color.a < alphaThreshold) discard;\n#endif\n}\nvoid ALPHA_TEST (in float alpha) {\n#if USE_ALPHA_TEST\nif (alpha < alphaThreshold) discard;\n#endif\n}\nin vec4 v_light;\n#if TWO_COLORED\nin vec4 v_dark;\n#endif\nin vec2 uv0;\nuniform sampler2D cc_spriteTexture;\nvec4 frag () {\nvec4 o = vec4(1, 1, 1, 1);\n#if TWO_COLORED\nvec4 texColor = vec4(1, 1, 1, 1);\ntexColor *= texture(cc_spriteTexture, uv0);\no.a = texColor.a * v_light.a;\no.rgb = ((texColor.a - 1.0) * v_dark.a + 1.0 - texColor.rgb) * v_dark.rgb + texColor.rgb * v_light.rgb;\n#else\no *= texture(cc_spriteTexture, uv0);\no *= v_light;\n#endif\nALPHA_TEST(o);\nreturn o;\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
                        }],
                        [{
                            vert: "\nprecision highp float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\n#if USE_LOCAL\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\n#endif\n#if SAMPLE_FROM_RT\n#endif\nin vec3 a_position;\nin vec2 a_texCoord;\nin vec4 a_color;\nout vec4 color;\nout vec2 uv0;\nvec4 vert () {\nvec4 pos = vec4(a_position, 1);\n#if USE_LOCAL\npos = cc_matWorld * pos;\n#endif\n#if USE_PIXEL_ALIGNMENT\npos = cc_matView * pos;\npos.xyz = floor(pos.xyz);\npos = cc_matProj * pos;\n#else\npos = cc_matViewProj * pos;\n#endif\nuv0 = a_texCoord;\n#if SAMPLE_FROM_RT\nuv0 = cc_cameraPos.w > 1.0 ? vec2(uv0.x, 1.0 - uv0.y) : uv0;\n#endif\ncolor = a_color;\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
                            frag: "\nprecision highp float;\nvec4 CCSampleWithAlphaSeparated(sampler2D tex, vec2 uv) {\n#if CC_USE_EMBEDDED_ALPHA\nreturn vec4(texture(tex, uv).rgb, texture(tex, uv + vec2(0.0, 0.5)).r);\n#else\nreturn texture(tex, uv);\n#endif\n}\n#if USE_ALPHA_TEST\nlayout(std140) uniform ALPHA_TEST_DATA {\nfloat alphaThreshold;\n};\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n#if USE_ALPHA_TEST\nif (color.a < alphaThreshold) discard;\n#endif\n}\nvoid ALPHA_TEST (in float alpha) {\n#if USE_ALPHA_TEST\nif (alpha < alphaThreshold) discard;\n#endif\n}\nin vec4 color;\n#if USE_TEXTURE\nin vec2 uv0;\nuniform sampler2D cc_spriteTexture;\n#endif\nvec4 frag () {\nvec4 o = vec4(1, 1, 1, 1);\n#if USE_TEXTURE\no *= CCSampleWithAlphaSeparated(cc_spriteTexture, uv0);\n#if IS_GRAY\nfloat gray  = 0.2126 * o.r + 0.7152 * o.g + 0.0722 * o.b;\no.r = o.g = o.b = gray;\n#endif\n#endif\no *= color;\nALPHA_TEST(o);\nreturn o;\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
                        }],
                        [{
                            vert: "\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_MORPH\nin float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\nlayout(std140) uniform CCMorph {\nvec4 cc_displacementWeights[15];\nvec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\nivec2 texSize = textureSize(tex, 0);\nreturn texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture(tex, x)),\ndecode32(texture(tex, y)),\ndecode32(texture(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nattr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nattr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nattr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nin vec4 a_joints;\nin vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n#if USE_INSTANCING\nin highp vec4 a_jointAnimInfo;\n#endif\nlayout(std140) uniform CCSkinningTexture {\nhighp vec4 cc_jointTextureInfo;\n};\nlayout(std140) uniform CCSkinningAnimation {\nhighp vec4 cc_jointAnimInfo;\n};\nuniform highp sampler2D cc_jointTexture;\n#else\nlayout(std140) uniform CCSkinning {\nhighp vec4 cc_joints[30 * 3];\n};\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\n#if USE_INSTANCING\nhighp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n#else\nhighp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n#endif\nhighp float invSize = cc_jointTextureInfo.w;\nhighp float y = floor(j * invSize);\nhighp float x = floor(j - y * cc_jointTextureInfo.x);\ny = (y + 0.5) * invSize;\nvec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\n#if USE_INSTANCING\nhighp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n#else\nhighp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n#endif\nhighp float invSize = cc_jointTextureInfo.w;\nhighp float y = floor(j * invSize);\nhighp float x = floor(j - y * cc_jointTextureInfo.x);\ny = (y + 0.5) * invSize;\nvec4 v1 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\nmat4 m = skinMatrix();\nattr.position = m * attr.position;\nattr.normal = (m * vec4(attr.normal, 0.0)).xyz;\nattr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\n#if USE_INSTANCING\nin vec4 a_matWorld0;\nin vec4 a_matWorld1;\nin vec4 a_matWorld2;\n#if USE_LIGHTMAP\nin vec4 a_lightingMapUVParam;\n#endif\n#elif USE_BATCHING\nin float a_dyn_batch_id;\nlayout(std140) uniform CCLocalBatched {\nhighp mat4 cc_matWorlds[10];\n};\n#else\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\n#endif\nlayout(std140) uniform Constants {\nvec4 tilingOffset;\nvec4 albedo;\nvec4 albedoScaleAndCutoff;\nvec4 pbrParams;\nvec4 emissive;\nvec4 emissiveScaleParam;\n};\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nout float v_fog_factor;\nout highp vec4 v_shadowPos;\nlayout(std140) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nlowp  vec4 cc_shadowNFLSInfo;\nlowp  vec4 cc_shadowWHPBInfo;\nlowp  vec4 cc_shadowLPNNInfo;\nlowp  vec4 cc_shadowColor;\n};\n#if CC_RECEIVE_SHADOW\nuniform sampler2D cc_shadowMap;\nuniform sampler2D cc_spotLightingMap;\n#endif\n#if USE_VERTEX_COLOR\nin vec4 a_color;\nout vec4 v_color;\n#endif\nout vec3 v_position;\nout vec3 v_normal;\nout vec2 v_uv;\nout vec2 v_uv1;\n#if USE_NORMAL_MAP\nout vec3 v_tangent;\nout vec3 v_bitangent;\n#endif\n#if HAS_SECOND_UV || USE_LIGHTMAP\nin vec2 a_texCoord1;\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nout vec3 v_luv;\nvoid CCLightingMapCaclUV()\n{\n#if !USE_INSTANCING\nv_luv.xy = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.zw;\nv_luv.z = cc_lightingMapUVParam.z;\n#else\nv_luv.xy = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.zw;\nv_luv.z = a_lightingMapUVParam.z;\n#endif\n}\n#endif\nvoid main () {\nStandardVertInput In;\nIn.position = vec4(a_position, 1.0);\nIn.normal = a_normal;\nIn.tangent = a_tangent;\n#if CC_USE_MORPH\napplyMorph(In);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In);\n#endif\nmat4 matWorld, matWorldIT;\n#if USE_INSTANCING\nmatWorld = mat4(\nvec4(a_matWorld0.xyz, 0.0),\nvec4(a_matWorld1.xyz, 0.0),\nvec4(a_matWorld2.xyz, 0.0),\nvec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n);\nmatWorldIT = matWorld;\n#elif USE_BATCHING\nmatWorld = cc_matWorlds[int(a_dyn_batch_id)];\nmatWorldIT = matWorld;\n#else\nmatWorld = cc_matWorld;\nmatWorldIT = cc_matWorldIT;\n#endif\nvec4 pos = matWorld * In.position;\nv_position = pos.xyz;\nv_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n#if USE_NORMAL_MAP\nv_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\nv_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n#endif\nv_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n#if SAMPLE_FROM_RT\nv_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n#endif\n#if HAS_SECOND_UV\nv_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n#if SAMPLE_FROM_RT\nv_uv1 = cc_cameraPos.w > 1.0 ? vec2(v_uv1.x, 1.0 - v_uv1.y) : v_uv1;\n#endif\n#endif\n#if USE_VERTEX_COLOR\nv_color = a_color;\n#endif\n#if CC_USE_FOG == 0\nv_fog_factor = LinearFog(pos);\n#elif CC_USE_FOG == 1\nv_fog_factor = ExpFog(pos);\n#elif CC_USE_FOG == 2\nv_fog_factor = ExpSquaredFog(pos);\n#elif CC_USE_FOG == 3\nv_fog_factor = LayeredFog(pos);\n#else\nv_fog_factor = 1.0;\n#endif\nv_shadowPos = cc_matLightViewProj * pos;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nCCLightingMapCaclUV();\n#endif\ngl_Position = cc_matProj * (cc_matView * matWorld) * In.position;\n}",
                            frag: "\nprecision highp float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nlayout(std140) uniform Constants {\nvec4 tilingOffset;\nvec4 albedo;\nvec4 albedoScaleAndCutoff;\nvec4 pbrParams;\nvec4 emissive;\nvec4 emissiveScaleParam;\n};\nin float v_fog_factor;\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nlayout(std140) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nlowp  vec4 cc_shadowNFLSInfo;\nlowp  vec4 cc_shadowWHPBInfo;\nlowp  vec4 cc_shadowLPNNInfo;\nlowp  vec4 cc_shadowColor;\n};\n#if CC_RECEIVE_SHADOW\nuniform sampler2D cc_shadowMap;\nuniform sampler2D cc_spotLightingMap;\nfloat CCGetLinearDepth (vec3 worldPos) {\nvec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\nfloat dist = length(viewStartPos.xyz);\nreturn cc_shadowNFLSInfo.x + (-dist / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x));\n}\nfloat CCGetShadowFactorX1 (vec4 shadowPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nclosestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n} else {\nclosestDepth = texture(cc_shadowMap, clipPos.xy).x;\n}\nshadow = step(closestDepth, clipPos.z- cc_shadowWHPBInfo.w);\nreturn shadow;\n}\nfloat CCGetShadowFactorX5 (vec4 shadowPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\nfloat offsetx = 1.0 / cc_shadowWHPBInfo.x;\nfloat offsety = 1.0 / cc_shadowWHPBInfo.y;\nfloat shadow = 0.0;\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nfloat closestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\nclosestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\nclosestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\nclosestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\nclosestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n} else {\nfloat closestDepth = texture(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)).x;\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\nclosestDepth = texture(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)).x;\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\nclosestDepth = texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x;\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\nclosestDepth = texture(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)).x;\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\nclosestDepth = texture(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)).x;\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n}\nreturn shadow / 5.0;\n}\nfloat CCGetShadowFactorX9 (vec4 shadowPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\nfloat offsetx = 1.0 / cc_shadowWHPBInfo.x;\nfloat offsety = 1.0 / cc_shadowWHPBInfo.y;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nfor (int i = -1; i <= 1; i++) {\nfor (int j = -1; j <= 1; j++) {\nfloat closestDepth = dot(texture(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n}\n}\n} else {\nfor (int i = -1; i <= 1; i++) {\nfor (int j = -1; j <= 1; j++) {\nfloat closestDepth = texture(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)).x;\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n}\n}\n}\nreturn shadow / 9.0;\n}\nfloat CCGetShadowFactorX25 (vec4 shadowPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\nfloat offsetx = 1.0 / cc_shadowWHPBInfo.x;\nfloat offsety = 1.0 / cc_shadowWHPBInfo.y;\nfloat shadow = 0.0;\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nfor (int i = -2; i <= 2; i++) {\nfor (int j = -2; j <= 2; j++) {\nfloat closestDepth = dot(texture(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n}\n}\n} else {\nfor (int i = -2; i <= 2; i++) {\nfor (int j = -2; j <= 2; j++) {\nfloat closestDepth = texture(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)).x;\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n}\n}\n}\nreturn shadow / 25.0;\n}\nfloat CCGetDirLightShadowFactorX1 (vec4 shadowPos, vec3 worldPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nfloat depth = 0.0;\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nif (cc_shadowLPNNInfo.y > 0.000001) {\nclosestDepth = dot(texture(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n} else {\nclosestDepth = texture(cc_spotLightingMap, clipPos.xy).x;\n}\nshadow = step(closestDepth, depth - cc_shadowWHPBInfo.w);\nreturn shadow;\n}\nfloat CCGetDirLightShadowFactorX5 (vec4 shadowPos, vec3 worldPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\nfloat offsetx = 1.0 / cc_shadowWHPBInfo.x;\nfloat offsety = 1.0 / cc_shadowWHPBInfo.y;\nfloat shadow = 0.0;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nfloat closestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\nclosestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\nclosestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\nclosestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\nclosestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n} else {\nfloat closestDepth = texture(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)).x;\nshadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\nclosestDepth = texture(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)).x;\nshadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\nclosestDepth = texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x;\nshadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\nclosestDepth = texture(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)).x;\nshadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\nclosestDepth = texture(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)).x;\nshadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n}\nreturn shadow / 5.0;\n}\nfloat CCGetDirLightShadowFactorX9 (vec4 shadowPos, vec3 worldPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\nfloat offsetx = 1.0 / cc_shadowWHPBInfo.x;\nfloat offsety = 1.0 / cc_shadowWHPBInfo.y;\nfloat shadow = 0.0;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nfor (int i = -1; i <= 1; i++) {\nfor (int j = -1; j <= 1; j++) {\nfloat closestDepth = dot(texture(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n}\n}\n} else {\nfor (int i = -1; i <= 1; i++) {\nfor (int j = -1; j <= 1; j++) {\nfloat closestDepth = texture(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)).x;\nshadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n}\n}\n}\nreturn shadow / 9.0;\n}\nfloat CCGetDirLightShadowFactorX25 (vec4 shadowPos, vec3 worldPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\nfloat offsetx = 1.0 / cc_shadowWHPBInfo.x;\nfloat offsety = 1.0 / cc_shadowWHPBInfo.y;\nfloat depth = 0.0;\nfloat shadow = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nfor (int i = -2; i <= 2; i++) {\nfor (int j = -2; j <= 2; j++) {\nfloat closestDepth = dot(texture(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n}\n}\n} else {\nfor (int i = -2; i <= 2; i++) {\nfor (int j = -2; j <= 2; j++) {\nfloat closestDepth = texture(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)).x;\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n}\n}\n}\nreturn shadow / 25.0;\n}\n#endif\n#if CC_USE_IBL\nuniform samplerCube cc_environment;\nvec3 unpackRGBE (vec4 rgbe) {\nreturn rgbe.rgb * pow(2.0, rgbe.a * 255.0 - 128.0);\n}\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\nreturn textureLod(tex, coord, lod);\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\nreturn textureLod(tex, coord, lod);\n}\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\nvec3 NxH = cross(N, H);\nfloat OneMinusNoHSqr = dot(NxH, NxH);\nfloat a = roughness * roughness;\nfloat n = NoH * a;\nfloat p = a / (OneMinusNoHSqr + n * n);\nreturn p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\nreturn (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\nconst vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\nconst vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\nvec4 r = roughness * c0 + c1;\nfloat a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\nvec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\nAB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\nreturn specular * AB.x + AB.y;\n}\nstruct StandardSurface {\nvec4 albedo;\nvec3 position;\nvec3 normal;\nvec3 emissive;\nvec3 lightmap;\nfloat lightmap_test;\nfloat roughness;\nfloat metallic;\nfloat occlusion;\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - s.position);\nfloat NV = max(abs(dot(N, V)), 0.001);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 L = normalize(-cc_mainLitDir.xyz);\nvec3 H = normalize(L + V);\nfloat NH = max(dot(N, H), 0.0);\nfloat NL = max(dot(N, L), 0.001);\nvec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\nvec3 diffuseContrib = diffuse;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nif (s.lightmap_test > 0.0001) {\nfinalColor = s.lightmap.rgb;\n}\n#else\ndiffuseContrib /= 3.14159265359;\n#endif\nvec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\nfinalColor *= (diffuseContrib + specularContrib);\nfloat fAmb = 0.5 - N.y * 0.5;\nvec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\nfinalColor += (ambDiff.rgb * diffuse);\n#if CC_USE_IBL\nvec3 R = normalize(reflect(-V, N));\nvec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n#if CC_USE_IBL == 2\nvec3 env = unpackRGBE(envmap);\n#else\nvec3 env = SRGBToLinear(envmap.rgb);\n#endif\nfinalColor += env * cc_ambientSky.w * specular;\n#endif\nfinalColor = finalColor * s.occlusion;\n#if CC_USE_HDR\ns.emissive *= cc_exposure.w;\n#endif\nfinalColor += s.emissive;\n#if CC_RECEIVE_SHADOW\n{\nfloat pcf = cc_shadowWHPBInfo.z + 0.001;\nfloat shadowAttenuation = 0.0;\nfloat cosAngle = clamp(1.0 - dot(N, L.xyz), 0.0, 1.0);\nvec3 projWorldPos = shadowPos.xyz + cosAngle * cc_shadowLPNNInfo.z * N;\nvec4 pos = vec4(projWorldPos.xyz, shadowPos.w);\nif (pcf > 3.0) shadowAttenuation = CCGetShadowFactorX25(pos);\nelse if (pcf > 2.0) shadowAttenuation = CCGetShadowFactorX9(pos);\nelse if (pcf > 1.0) shadowAttenuation = CCGetShadowFactorX5(pos);\nelse shadowAttenuation = CCGetShadowFactorX1(pos);\nvec3 shadowColor = cc_shadowColor.rgb * cc_shadowColor.a + finalColor.rgb * (1.0 - cc_shadowColor.a);\nif (cc_shadowNFLSInfo.w > 0.000001) {\nfinalColor.rgb = shadowColor.rgb * shadowAttenuation + finalColor.rgb * (1.0 - shadowAttenuation);\n} else {\nfinalColor.rgb = shadowColor.rgb * shadowAttenuation * NL + finalColor.rgb * (1.0 - shadowAttenuation * NL);\n}\n}\n#endif\nreturn vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\ncolor = min(color, vec3(8.0));\nconst float A = 2.51;\nconst float B = 0.03;\nconst float C = 2.43;\nconst float D = 0.59;\nconst float E = 0.14;\nreturn (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n#if !CC_USE_HDR\ncolor.rgb = sqrt(ACESToneMap(color.rgb));\n#endif\nreturn color;\n}\nin highp vec4 v_shadowPos;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nin vec3 v_luv;\nuniform sampler2D cc_lightingMap;\nvec3 UnpackLightingmap(vec4 color) {\nvec3 c;\nfloat e = 1.0 + color.a * (8.0 - 1.0);\nc.r = color.r * e;\nc.g = color.g * e;\nc.b = color.b * e;\nreturn c;\n}\n#endif\nin vec3 v_position;\nin vec2 v_uv;\nin vec2 v_uv1;\nin vec3 v_normal;\n#if USE_VERTEX_COLOR\nin vec4 v_color;\n#endif\n#if USE_ALBEDO_MAP\nuniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\nin vec3 v_tangent;\nin vec3 v_bitangent;\nuniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\nuniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\nuniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\nuniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\nuniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\nvec4 baseColor = albedo;\n#if USE_VERTEX_COLOR\nbaseColor *= v_color;\n#endif\n#if USE_ALBEDO_MAP\nvec4 texColor = texture(albedoMap, ALBEDO_UV);\ntexColor.rgb = SRGBToLinear(texColor.rgb);\nbaseColor *= texColor;\n#endif\ns.albedo = baseColor;\ns.albedo.rgb *= albedoScaleAndCutoff.xyz;\n#if USE_ALPHA_TEST\nif (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nvec4 lightColor = texture(cc_lightingMap, v_luv.xy);\ns.lightmap = UnpackLightingmap(lightColor);\ns.lightmap_test = v_luv.z;\n#endif\ns.normal = v_normal;\n#if USE_NORMAL_MAP\nvec3 nmmp = texture(normalMap, NORMAL_UV).xyz - vec3(0.5);\ns.normal =\n(nmmp.x * pbrParams.w) * normalize(v_tangent) +\n(nmmp.y * pbrParams.w) * normalize(v_bitangent) +\nnmmp.z * normalize(s.normal);\n#endif\ns.position = v_position;\nvec4 pbr = pbrParams;\n#if USE_PBR_MAP\nvec4 res = texture(pbrMap, PBR_UV);\npbr.x *= res.r;\npbr.y *= res.g;\npbr.z *= res.b;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\nvec4 metallicRoughness = texture(metallicRoughnessMap, PBR_UV);\npbr.z *= metallicRoughness.b;\npbr.y *= metallicRoughness.g;\n#endif\n#if USE_OCCLUSION_MAP\npbr.x *= texture(occlusionMap, PBR_UV).r;\n#endif\ns.occlusion = clamp(pbr.x, 0.0, 0.96);\ns.roughness = clamp(pbr.y, 0.04, 1.0);\ns.metallic = pbr.z;\ns.emissive = emissive.rgb * emissiveScaleParam.xyz;\n#if USE_EMISSIVE_MAP\ns.emissive *= SRGBToLinear(texture(emissiveMap, EMISSIVE_UV).rgb);\n#endif\n}\n#if CC_FORWARD_ADD\n#if CC_PIPELINE_TYPE == 0\n# define LIGHTS_PER_PASS 1\n#else\n# define LIGHTS_PER_PASS 10\n#endif\nlayout(std140) uniform CCForwardLight {\nhighp vec4 cc_lightPos[LIGHTS_PER_PASS];\nvec4 cc_lightColor[LIGHTS_PER_PASS];\nvec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\nvec4 cc_lightDir[LIGHTS_PER_PASS];\n};\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\nfloat factor = distSqr * invSqrAttRadius;\nfloat smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\nreturn smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\nfloat attenuation = 1.0 / max(distSqr, 0.01*0.01);\nattenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\nreturn attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\nfloat cd = dot(litDir, L);\nfloat attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\nreturn (attenuation * attenuation);\n}\nvec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 diffuseContrib = diffuse / 3.14159265359;\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - s.position);\nfloat NV = max(abs(dot(N, V)), 0.001);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 finalColor = vec3(0.0);\nint numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\nfor (int i = 0; i < LIGHTS_PER_PASS; i++) {\nif (i >= numLights) break;\nvec3 SLU = cc_lightPos[i].xyz - s.position;\nvec3 SL = normalize(SLU);\nvec3 SH = normalize(SL + V);\nfloat SNL = max(dot(N, SL), 0.001);\nfloat SNH = max(dot(N, SH), 0.0);\nfloat distSqr = dot(SLU, SLU);\nfloat litRadius = cc_lightSizeRangeAngle[i].x;\nfloat litRadiusSqr = litRadius * litRadius;\nfloat illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\nfloat attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\nattRadiusSqrInv *= attRadiusSqrInv;\nfloat att = GetDistAtt(distSqr, attRadiusSqrInv);\nvec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\nif (cc_lightPos[i].w > 0.0) {\nfloat cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\nfloat cosOuter = cc_lightSizeRangeAngle[i].z;\nfloat litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\nfloat litAngleOffset = -cosOuter * litAngleScale;\natt *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n}\nvec3 lightColor = cc_lightColor[i].rgb;\n#if CC_RECEIVE_SHADOW\nif (cc_lightPos[i].w > 0.0) {\n{\nfloat pcf = cc_shadowWHPBInfo.z + 0.001;\nfloat shadowAttenuation = 0.0;\nfloat cosAngle = clamp(1.0 - dot(N, normalize(cc_lightPos[i].xyz - s.position.xyz)), 0.0, 1.0);\nvec3 projWorldPos = shadowPos.xyz + cosAngle * cc_shadowLPNNInfo.z * N;\nvec4 pos = vec4(projWorldPos.xyz, shadowPos.w);\nif (pcf > 3.0) shadowAttenuation = CCGetDirLightShadowFactorX25(pos, s.position);\nelse if (pcf > 2.0) shadowAttenuation = CCGetDirLightShadowFactorX9(pos, s.position);\nelse if (pcf > 1.0) shadowAttenuation = CCGetDirLightShadowFactorX5(pos, s.position);\nelse shadowAttenuation = CCGetDirLightShadowFactorX1(pos, s.position);\nlightColor *= 1.0 - shadowAttenuation;\n}\n}\n#endif\nfinalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n}\nfinalColor = finalColor * s.occlusion;\nreturn vec4(finalColor, 0.0);\n}\nlayout(location = 0) out vec4 fragColorX;\nvoid main () {\nStandardSurface s; surf(s);\nvec4 color = CCStandardShadingAdditive(s, v_shadowPos);\ncolor = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, color.rgb, v_fog_factor), color.a);\nfragColorX = CCFragOutput(color);\n}\n#elif CC_PIPELINE_TYPE == 0\nlayout(location = 0) out vec4 fragColorX;\nvoid main () {\nStandardSurface s; surf(s);\nvec4 color = CCStandardShadingBase(s, v_shadowPos);\ncolor = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, color.rgb, v_fog_factor), color.a);\nfragColorX = CCFragOutput(color);\n}\n#elif CC_PIPELINE_TYPE == 1\nlayout(location = 0) out vec4 fragColor0;\nlayout(location = 1) out vec4 fragColor1;\nlayout(location = 2) out vec4 fragColor2;\nlayout(location = 3) out vec4 fragColor3;\nvoid main () {\nStandardSurface s; surf(s);\nfragColor0 = s.albedo;\nfragColor1 = vec4(s.position, s.roughness);\nfragColor2 = vec4(s.normal, s.metallic);\nfragColor3 = vec4(s.emissive, s.occlusion);\n}\n#endif"
                        }, {
                            vert: "\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_MORPH\nin float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\nlayout(std140) uniform CCMorph {\nvec4 cc_displacementWeights[15];\nvec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\nivec2 texSize = textureSize(tex, 0);\nreturn texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture(tex, x)),\ndecode32(texture(tex, y)),\ndecode32(texture(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nattr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nattr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nattr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nin vec4 a_joints;\nin vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n#if USE_INSTANCING\nin highp vec4 a_jointAnimInfo;\n#endif\nlayout(std140) uniform CCSkinningTexture {\nhighp vec4 cc_jointTextureInfo;\n};\nlayout(std140) uniform CCSkinningAnimation {\nhighp vec4 cc_jointAnimInfo;\n};\nuniform highp sampler2D cc_jointTexture;\n#else\nlayout(std140) uniform CCSkinning {\nhighp vec4 cc_joints[30 * 3];\n};\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\n#if USE_INSTANCING\nhighp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n#else\nhighp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n#endif\nhighp float invSize = cc_jointTextureInfo.w;\nhighp float y = floor(j * invSize);\nhighp float x = floor(j - y * cc_jointTextureInfo.x);\ny = (y + 0.5) * invSize;\nvec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\n#if USE_INSTANCING\nhighp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n#else\nhighp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n#endif\nhighp float invSize = cc_jointTextureInfo.w;\nhighp float y = floor(j * invSize);\nhighp float x = floor(j - y * cc_jointTextureInfo.x);\ny = (y + 0.5) * invSize;\nvec4 v1 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\nmat4 m = skinMatrix();\nattr.position = m * attr.position;\nattr.normal = (m * vec4(attr.normal, 0.0)).xyz;\nattr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\n#if USE_INSTANCING\nin vec4 a_matWorld0;\nin vec4 a_matWorld1;\nin vec4 a_matWorld2;\n#if USE_LIGHTMAP\nin vec4 a_lightingMapUVParam;\n#endif\n#elif USE_BATCHING\nin float a_dyn_batch_id;\nlayout(std140) uniform CCLocalBatched {\nhighp mat4 cc_matWorlds[10];\n};\n#else\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\n#endif\nlayout(std140) uniform Constants {\nvec4 tilingOffset;\nvec4 albedo;\nvec4 albedoScaleAndCutoff;\nvec4 pbrParams;\nvec4 emissive;\nvec4 emissiveScaleParam;\n};\nlayout(std140) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nlowp  vec4 cc_shadowNFLSInfo;\nlowp  vec4 cc_shadowWHPBInfo;\nlowp  vec4 cc_shadowLPNNInfo;\nlowp  vec4 cc_shadowColor;\n};\n#if HAS_SECOND_UV || USE_LIGHTMAP\nin vec2 a_texCoord1;\n#endif\nout vec2 v_uv;\nout vec2 v_uv1;\nout vec4 v_worldPos;\nout float v_clip_depth;\nvec4 vert () {\nStandardVertInput In;\nIn.position = vec4(a_position, 1.0);\nIn.normal = a_normal;\nIn.tangent = a_tangent;\n#if CC_USE_MORPH\napplyMorph(In);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In);\n#endif\nmat4 matWorld, matWorldIT;\n#if USE_INSTANCING\nmatWorld = mat4(\nvec4(a_matWorld0.xyz, 0.0),\nvec4(a_matWorld1.xyz, 0.0),\nvec4(a_matWorld2.xyz, 0.0),\nvec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n);\nmatWorldIT = matWorld;\n#elif USE_BATCHING\nmatWorld = cc_matWorlds[int(a_dyn_batch_id)];\nmatWorldIT = matWorld;\n#else\nmatWorld = cc_matWorld;\nmatWorldIT = cc_matWorldIT;\n#endif\nv_worldPos = matWorld * In.position;\nvec4 clipPos = cc_matLightViewProj * v_worldPos;\nv_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n#if HAS_SECOND_UV\nv_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n#endif\nv_clip_depth = clipPos.z / clipPos.w * 0.5 + 0.5;\nreturn clipPos;\n}\nvoid main() { gl_Position = vert(); }",
                            frag: "\nprecision highp float;\nlayout(std140) uniform Constants {\nvec4 tilingOffset;\nvec4 albedo;\nvec4 albedoScaleAndCutoff;\nvec4 pbrParams;\nvec4 emissive;\nvec4 emissiveScaleParam;\n};\nvec4 packDepthToRGBA (float depth) {\nvec4 ret = vec4(1.0, 255.0, 65025.0, 160581375.0) * depth;\nret = fract(ret);\nret -= ret.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\nreturn ret;\n}\nlayout(std140) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nlowp  vec4 cc_shadowNFLSInfo;\nlowp  vec4 cc_shadowWHPBInfo;\nlowp  vec4 cc_shadowLPNNInfo;\nlowp  vec4 cc_shadowColor;\n};\nin vec2 v_uv;\nin vec2 v_uv1;\nin vec4 v_worldPos;\nin float v_clip_depth;\n#if USE_ALBEDO_MAP\nuniform sampler2D albedoMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\nvec4 baseColor = albedo;\n#if USE_ALBEDO_MAP\nbaseColor *= texture(albedoMap, ALBEDO_UV);\n#endif\n#if USE_ALPHA_TEST\nif (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n#endif\nif(cc_shadowLPNNInfo.x > 0.000001 && cc_shadowLPNNInfo.x < 1.999999) {\nif (cc_shadowNFLSInfo.z > 0.000001) {\nvec4 viewStartPos = cc_matLightView * v_worldPos;\nfloat dist = length(viewStartPos.xyz);\nfloat linearDepth = cc_shadowNFLSInfo.x + (-dist / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x));\nreturn vec4(linearDepth, 1.0, 1.0, 1.0);\n}\n}\nif (cc_shadowLPNNInfo.y > 0.000001) {\nreturn packDepthToRGBA(v_clip_depth);\n}\nreturn vec4(v_clip_depth, 1.0, 1.0, 1.0);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
                        }],
                        [{
                            vert: "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nout float v_fog_factor;\nout highp vec4 v_shadowPos;\nlayout(std140) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nlowp  vec4 cc_shadowNFLSInfo;\nlowp  vec4 cc_shadowWHPBInfo;\nlowp  vec4 cc_shadowLPNNInfo;\nlowp  vec4 cc_shadowColor;\n};\n#if CC_RECEIVE_SHADOW\nuniform sampler2D cc_shadowMap;\nuniform sampler2D cc_spotLightingMap;\n#endif\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nout highp vec3 v_position;\nout mediump vec3 v_normal;\n#if USE_NORMALMAP\nout mediump vec3 v_tangent;\nout mediump vec3 v_binormal;\n#endif\nout mediump vec2 uvw;\nout mediump vec2 uv0;\nout mediump vec2 uv1;\nout mediump vec2 uv2;\nout mediump vec2 uv3;\nout mediump vec3 luv;\nout mediump vec3 diffuse;\nlayout(std140) uniform TexCoords {\nvec4 UVScale;\nvec4 lightMapUVParam;\n};\nvoid main () {\nvec3 worldPos;\nworldPos.x = cc_matWorld[3][0] + a_position.x;\nworldPos.y = cc_matWorld[3][1] + a_position.y;\nworldPos.z = cc_matWorld[3][2] + a_position.z;\nvec4 pos = vec4(worldPos, 1.0);\npos = cc_matViewProj * pos;\nuvw = a_texCoord;\nuv0 = a_position.xz * UVScale.x;\nuv1 = a_position.xz * UVScale.y;\nuv2 = a_position.xz * UVScale.z;\nuv3 = a_position.xz * UVScale.w;\n#if USE_LIGHTMAP\nluv.xy = lightMapUVParam.xy + a_texCoord * lightMapUVParam.zw;\nluv.z = lightMapUVParam.z;\n#endif\nv_position = worldPos;\nv_normal = a_normal;\n#if CC_USE_FOG == 0\nv_fog_factor = LinearFog(vec4(worldPos, 1.0));\n#elif CC_USE_FOG == 1\nv_fog_factor = ExpFog(vec4(worldPos, 1.0));\n#elif CC_USE_FOG == 2\nv_fog_factor = ExpSquaredFog(vec4(worldPos, 1.0));\n#elif CC_USE_FOG == 3\nv_fog_factor = LayeredFog(vec4(worldPos, 1.0));\n#else\nv_fog_factor = 1.0;\n#endif\n#if USE_NORMALMAP\nv_tangent = vec3(1.0, 0.0, 0.0);\nv_binormal = vec3(0.0, 0.0, 1.0);\nv_binormal = cross(v_tangent, a_normal);\nv_tangent = cross(a_normal, v_binormal);\n#endif\nv_shadowPos = cc_matLightViewProj * vec4(worldPos, 1.0);\ngl_Position = pos;\n}",
                            frag: "\nprecision highp float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nlayout(std140) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nlowp  vec4 cc_shadowNFLSInfo;\nlowp  vec4 cc_shadowWHPBInfo;\nlowp  vec4 cc_shadowLPNNInfo;\nlowp  vec4 cc_shadowColor;\n};\n#if CC_RECEIVE_SHADOW\nuniform sampler2D cc_shadowMap;\nuniform sampler2D cc_spotLightingMap;\nfloat CCGetLinearDepth (vec3 worldPos) {\nvec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\nfloat dist = length(viewStartPos.xyz);\nreturn cc_shadowNFLSInfo.x + (-dist / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x));\n}\nfloat CCGetShadowFactorX1 (vec4 shadowPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nclosestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n} else {\nclosestDepth = texture(cc_shadowMap, clipPos.xy).x;\n}\nshadow = step(closestDepth, clipPos.z- cc_shadowWHPBInfo.w);\nreturn shadow;\n}\nfloat CCGetShadowFactorX5 (vec4 shadowPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\nfloat offsetx = 1.0 / cc_shadowWHPBInfo.x;\nfloat offsety = 1.0 / cc_shadowWHPBInfo.y;\nfloat shadow = 0.0;\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nfloat closestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\nclosestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\nclosestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\nclosestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\nclosestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n} else {\nfloat closestDepth = texture(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)).x;\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\nclosestDepth = texture(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)).x;\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\nclosestDepth = texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x;\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\nclosestDepth = texture(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)).x;\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\nclosestDepth = texture(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)).x;\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n}\nreturn shadow / 5.0;\n}\nfloat CCGetShadowFactorX9 (vec4 shadowPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\nfloat offsetx = 1.0 / cc_shadowWHPBInfo.x;\nfloat offsety = 1.0 / cc_shadowWHPBInfo.y;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nfor (int i = -1; i <= 1; i++) {\nfor (int j = -1; j <= 1; j++) {\nfloat closestDepth = dot(texture(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n}\n}\n} else {\nfor (int i = -1; i <= 1; i++) {\nfor (int j = -1; j <= 1; j++) {\nfloat closestDepth = texture(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)).x;\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n}\n}\n}\nreturn shadow / 9.0;\n}\nfloat CCGetShadowFactorX25 (vec4 shadowPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\nfloat offsetx = 1.0 / cc_shadowWHPBInfo.x;\nfloat offsety = 1.0 / cc_shadowWHPBInfo.y;\nfloat shadow = 0.0;\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nfor (int i = -2; i <= 2; i++) {\nfor (int j = -2; j <= 2; j++) {\nfloat closestDepth = dot(texture(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n}\n}\n} else {\nfor (int i = -2; i <= 2; i++) {\nfor (int j = -2; j <= 2; j++) {\nfloat closestDepth = texture(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)).x;\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n}\n}\n}\nreturn shadow / 25.0;\n}\nfloat CCGetDirLightShadowFactorX1 (vec4 shadowPos, vec3 worldPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nfloat depth = 0.0;\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nif (cc_shadowLPNNInfo.y > 0.000001) {\nclosestDepth = dot(texture(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n} else {\nclosestDepth = texture(cc_spotLightingMap, clipPos.xy).x;\n}\nshadow = step(closestDepth, depth - cc_shadowWHPBInfo.w);\nreturn shadow;\n}\nfloat CCGetDirLightShadowFactorX5 (vec4 shadowPos, vec3 worldPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\nfloat offsetx = 1.0 / cc_shadowWHPBInfo.x;\nfloat offsety = 1.0 / cc_shadowWHPBInfo.y;\nfloat shadow = 0.0;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nfloat closestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\nclosestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\nclosestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\nclosestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\nclosestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n} else {\nfloat closestDepth = texture(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)).x;\nshadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\nclosestDepth = texture(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)).x;\nshadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\nclosestDepth = texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x;\nshadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\nclosestDepth = texture(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)).x;\nshadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\nclosestDepth = texture(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)).x;\nshadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n}\nreturn shadow / 5.0;\n}\nfloat CCGetDirLightShadowFactorX9 (vec4 shadowPos, vec3 worldPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\nfloat offsetx = 1.0 / cc_shadowWHPBInfo.x;\nfloat offsety = 1.0 / cc_shadowWHPBInfo.y;\nfloat shadow = 0.0;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nfor (int i = -1; i <= 1; i++) {\nfor (int j = -1; j <= 1; j++) {\nfloat closestDepth = dot(texture(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n}\n}\n} else {\nfor (int i = -1; i <= 1; i++) {\nfor (int j = -1; j <= 1; j++) {\nfloat closestDepth = texture(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)).x;\nshadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n}\n}\n}\nreturn shadow / 9.0;\n}\nfloat CCGetDirLightShadowFactorX25 (vec4 shadowPos, vec3 worldPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\nfloat offsetx = 1.0 / cc_shadowWHPBInfo.x;\nfloat offsety = 1.0 / cc_shadowWHPBInfo.y;\nfloat depth = 0.0;\nfloat shadow = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nfor (int i = -2; i <= 2; i++) {\nfor (int j = -2; j <= 2; j++) {\nfloat closestDepth = dot(texture(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n}\n}\n} else {\nfor (int i = -2; i <= 2; i++) {\nfor (int j = -2; j <= 2; j++) {\nfloat closestDepth = texture(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)).x;\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n}\n}\n}\nreturn shadow / 25.0;\n}\n#endif\n#if CC_USE_IBL\nuniform samplerCube cc_environment;\nvec3 unpackRGBE (vec4 rgbe) {\nreturn rgbe.rgb * pow(2.0, rgbe.a * 255.0 - 128.0);\n}\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\nreturn textureLod(tex, coord, lod);\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\nreturn textureLod(tex, coord, lod);\n}\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\nvec3 NxH = cross(N, H);\nfloat OneMinusNoHSqr = dot(NxH, NxH);\nfloat a = roughness * roughness;\nfloat n = NoH * a;\nfloat p = a / (OneMinusNoHSqr + n * n);\nreturn p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\nreturn (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\nconst vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\nconst vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\nvec4 r = roughness * c0 + c1;\nfloat a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\nvec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\nAB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\nreturn specular * AB.x + AB.y;\n}\nstruct StandardSurface {\nvec4 albedo;\nvec3 position;\nvec3 normal;\nvec3 emissive;\nvec3 lightmap;\nfloat lightmap_test;\nfloat roughness;\nfloat metallic;\nfloat occlusion;\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - s.position);\nfloat NV = max(abs(dot(N, V)), 0.001);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 L = normalize(-cc_mainLitDir.xyz);\nvec3 H = normalize(L + V);\nfloat NH = max(dot(N, H), 0.0);\nfloat NL = max(dot(N, L), 0.001);\nvec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\nvec3 diffuseContrib = diffuse;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nif (s.lightmap_test > 0.0001) {\nfinalColor = s.lightmap.rgb;\n}\n#else\ndiffuseContrib /= 3.14159265359;\n#endif\nvec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\nfinalColor *= (diffuseContrib + specularContrib);\nfloat fAmb = 0.5 - N.y * 0.5;\nvec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\nfinalColor += (ambDiff.rgb * diffuse);\n#if CC_USE_IBL\nvec3 R = normalize(reflect(-V, N));\nvec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n#if CC_USE_IBL == 2\nvec3 env = unpackRGBE(envmap);\n#else\nvec3 env = SRGBToLinear(envmap.rgb);\n#endif\nfinalColor += env * cc_ambientSky.w * specular;\n#endif\nfinalColor = finalColor * s.occlusion;\n#if CC_USE_HDR\ns.emissive *= cc_exposure.w;\n#endif\nfinalColor += s.emissive;\n#if CC_RECEIVE_SHADOW\n{\nfloat pcf = cc_shadowWHPBInfo.z + 0.001;\nfloat shadowAttenuation = 0.0;\nfloat cosAngle = clamp(1.0 - dot(N, L.xyz), 0.0, 1.0);\nvec3 projWorldPos = shadowPos.xyz + cosAngle * cc_shadowLPNNInfo.z * N;\nvec4 pos = vec4(projWorldPos.xyz, shadowPos.w);\nif (pcf > 3.0) shadowAttenuation = CCGetShadowFactorX25(pos);\nelse if (pcf > 2.0) shadowAttenuation = CCGetShadowFactorX9(pos);\nelse if (pcf > 1.0) shadowAttenuation = CCGetShadowFactorX5(pos);\nelse shadowAttenuation = CCGetShadowFactorX1(pos);\nvec3 shadowColor = cc_shadowColor.rgb * cc_shadowColor.a + finalColor.rgb * (1.0 - cc_shadowColor.a);\nif (cc_shadowNFLSInfo.w > 0.000001) {\nfinalColor.rgb = shadowColor.rgb * shadowAttenuation + finalColor.rgb * (1.0 - shadowAttenuation);\n} else {\nfinalColor.rgb = shadowColor.rgb * shadowAttenuation * NL + finalColor.rgb * (1.0 - shadowAttenuation * NL);\n}\n}\n#endif\nreturn vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\ncolor = min(color, vec3(8.0));\nconst float A = 2.51;\nconst float B = 0.03;\nconst float C = 2.43;\nconst float D = 0.59;\nconst float E = 0.14;\nreturn (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n#if !CC_USE_HDR\ncolor.rgb = sqrt(ACESToneMap(color.rgb));\n#endif\nreturn color;\n}\nin float v_fog_factor;\nin highp vec4 v_shadowPos;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nin vec3 v_luv;\nuniform sampler2D cc_lightingMap;\nvec3 UnpackLightingmap(vec4 color) {\nvec3 c;\nfloat e = 1.0 + color.a * (8.0 - 1.0);\nc.r = color.r * e;\nc.g = color.g * e;\nc.b = color.b * e;\nreturn c;\n}\n#endif\nin highp vec3 v_position;\nin mediump vec3 v_normal;\n#if USE_NORMALMAP\nin mediump vec3 v_tangent;\nin mediump vec3 v_binormal;\n#endif\nin mediump vec2 uvw;\nin mediump vec2 uv0;\nin mediump vec2 uv1;\nin mediump vec2 uv2;\nin mediump vec2 uv3;\nin mediump vec3 diffuse;\nin mediump vec3 luv;\nlayout(std140) uniform PbrParams {\nvec4 metallic;\nvec4 roughness;\n};\nuniform sampler2D weightMap;\nuniform sampler2D detailMap0;\nuniform sampler2D detailMap1;\nuniform sampler2D detailMap2;\nuniform sampler2D detailMap3;\nuniform sampler2D normalMap0;\nuniform sampler2D normalMap1;\nuniform sampler2D normalMap2;\nuniform sampler2D normalMap3;\nuniform sampler2D lightMap;\nvoid surf (out StandardSurface s) {\n#if LAYERS > 1\nvec4 w = texture(weightMap, uvw);\n#endif\nvec4 baseColor = vec4(0, 0, 0, 0);\n#if LAYERS == 1\nbaseColor = texture(detailMap0, uv0);\n#elif LAYERS == 2\nbaseColor += texture(detailMap0, uv0) * w.r;\nbaseColor += texture(detailMap1, uv1) * w.g;\n#elif LAYERS == 3\nbaseColor += texture(detailMap0, uv0) * w.r;\nbaseColor += texture(detailMap1, uv1) * w.g;\nbaseColor += texture(detailMap2, uv2) * w.b;\n#elif LAYERS == 4\nbaseColor += texture(detailMap0, uv0) * w.r;\nbaseColor += texture(detailMap1, uv1) * w.g;\nbaseColor += texture(detailMap2, uv2) * w.b;\nbaseColor += texture(detailMap3, uv3) * w.a;\n#else\nbaseColor = texture(detailMap0, uv0);\n#endif\ns.position = v_position;\n#if USE_NORMALMAP\nvec4 baseNormal = vec4(0, 0, 0, 0);\n#if LAYERS == 1\nbaseNormal = texture(normalMap0, uv0);\n#elif LAYERS == 2\nbaseNormal += texture(normalMap0, uv0) * w.r;\nbaseNormal += texture(normalMap1, uv1) * w.g;\n#elif LAYERS == 3\nbaseNormal += texture(normalMap0, uv0) * w.r;\nbaseNormal += texture(normalMap1, uv1) * w.g;\nbaseNormal += texture(normalMap2, uv2) * w.b;\n#elif LAYERS == 4\nbaseNormal += texture(normalMap0, uv0) * w.r;\nbaseNormal += texture(normalMap1, uv1) * w.g;\nbaseNormal += texture(normalMap2, uv2) * w.b;\nbaseNormal += texture(normalMap3, uv3) * w.a;\n#else\nbaseNormal = texture(normalMap0, uv0);\n#endif\nvec3 nmmp = baseNormal.xyz - vec3(0.5);\ns.normal =\nnmmp.x * normalize(v_tangent) +\nnmmp.y * normalize(v_binormal) +\nnmmp.z * normalize(v_normal);\n#else\ns.normal = v_normal;\n#endif\ns.albedo = vec4(SRGBToLinear(baseColor.rgb), 1.0);\ns.occlusion = 1.0;\n#if USE_PBR\ns.roughness = 0.0;\n#if LAYERS == 1\ns.roughness = roughness.x;\n#elif LAYERS == 2\ns.roughness += roughness.x * w.r;\ns.roughness += roughness.y * w.g;\n#elif LAYERS == 3\ns.roughness += roughness.x * w.r;\ns.roughness += roughness.y * w.g;\ns.roughness += roughness.z * w.b;\n#elif LAYERS == 4\ns.roughness += roughness.x * w.r;\ns.roughness += roughness.y * w.g;\ns.roughness += roughness.z * w.b;\ns.roughness += roughness.w * w.a;\n#else\ns.roughness = 1.0;\n#endif\ns.metallic = 0.0;\n#if LAYERS == 1\ns.metallic = metallic.x;\n#elif LAYERS == 2\ns.metallic += metallic.x * w.r;\ns.metallic += metallic.y * w.g;\n#elif LAYERS == 3\ns.metallic += metallic.x * w.r;\ns.metallic += metallic.y * w.g;\ns.metallic += metallic.z * w.b;\n#elif LAYERS == 4\ns.metallic += metallic.x * w.r;\ns.metallic += metallic.y * w.g;\ns.metallic += metallic.z * w.b;\ns.metallic += metallic.w * w.a;\n#else\ns.metallic = 0.0;\n#endif\n#else\ns.roughness = 1.0;\ns.metallic = 0.0;\n#endif\ns.emissive = vec3(0.0, 0.0, 0.0);\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nvec4 lightColor = texture(lightMap, luv.xy);\ns.lightmap = UnpackLightingmap(lightColor);\ns.lightmap_test = luv.z;\n#endif\n}\n#if CC_FORWARD_ADD\n#if CC_PIPELINE_TYPE == 0\n# define LIGHTS_PER_PASS 1\n#else\n# define LIGHTS_PER_PASS 10\n#endif\nlayout(std140) uniform CCForwardLight {\nhighp vec4 cc_lightPos[LIGHTS_PER_PASS];\nvec4 cc_lightColor[LIGHTS_PER_PASS];\nvec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\nvec4 cc_lightDir[LIGHTS_PER_PASS];\n};\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\nfloat factor = distSqr * invSqrAttRadius;\nfloat smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\nreturn smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\nfloat attenuation = 1.0 / max(distSqr, 0.01*0.01);\nattenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\nreturn attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\nfloat cd = dot(litDir, L);\nfloat attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\nreturn (attenuation * attenuation);\n}\nvec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 diffuseContrib = diffuse / 3.14159265359;\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - s.position);\nfloat NV = max(abs(dot(N, V)), 0.001);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 finalColor = vec3(0.0);\nint numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\nfor (int i = 0; i < LIGHTS_PER_PASS; i++) {\nif (i >= numLights) break;\nvec3 SLU = cc_lightPos[i].xyz - s.position;\nvec3 SL = normalize(SLU);\nvec3 SH = normalize(SL + V);\nfloat SNL = max(dot(N, SL), 0.001);\nfloat SNH = max(dot(N, SH), 0.0);\nfloat distSqr = dot(SLU, SLU);\nfloat litRadius = cc_lightSizeRangeAngle[i].x;\nfloat litRadiusSqr = litRadius * litRadius;\nfloat illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\nfloat attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\nattRadiusSqrInv *= attRadiusSqrInv;\nfloat att = GetDistAtt(distSqr, attRadiusSqrInv);\nvec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\nif (cc_lightPos[i].w > 0.0) {\nfloat cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\nfloat cosOuter = cc_lightSizeRangeAngle[i].z;\nfloat litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\nfloat litAngleOffset = -cosOuter * litAngleScale;\natt *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n}\nvec3 lightColor = cc_lightColor[i].rgb;\n#if CC_RECEIVE_SHADOW\nif (cc_lightPos[i].w > 0.0) {\n{\nfloat pcf = cc_shadowWHPBInfo.z + 0.001;\nfloat shadowAttenuation = 0.0;\nfloat cosAngle = clamp(1.0 - dot(N, normalize(cc_lightPos[i].xyz - s.position.xyz)), 0.0, 1.0);\nvec3 projWorldPos = shadowPos.xyz + cosAngle * cc_shadowLPNNInfo.z * N;\nvec4 pos = vec4(projWorldPos.xyz, shadowPos.w);\nif (pcf > 3.0) shadowAttenuation = CCGetDirLightShadowFactorX25(pos, s.position);\nelse if (pcf > 2.0) shadowAttenuation = CCGetDirLightShadowFactorX9(pos, s.position);\nelse if (pcf > 1.0) shadowAttenuation = CCGetDirLightShadowFactorX5(pos, s.position);\nelse shadowAttenuation = CCGetDirLightShadowFactorX1(pos, s.position);\nlightColor *= 1.0 - shadowAttenuation;\n}\n}\n#endif\nfinalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n}\nfinalColor = finalColor * s.occlusion;\nreturn vec4(finalColor, 0.0);\n}\nlayout(location = 0) out vec4 fragColorX;\nvoid main () {\nStandardSurface s; surf(s);\nvec4 color = CCStandardShadingAdditive(s, v_shadowPos);\ncolor = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, color.rgb, v_fog_factor), color.a);\nfragColorX = CCFragOutput(color);\n}\n#elif CC_PIPELINE_TYPE == 0\nlayout(location = 0) out vec4 fragColorX;\nvoid main () {\nStandardSurface s; surf(s);\nvec4 color = CCStandardShadingBase(s, v_shadowPos);\ncolor = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, color.rgb, v_fog_factor), color.a);\nfragColorX = CCFragOutput(color);\n}\n#elif CC_PIPELINE_TYPE == 1\nlayout(location = 0) out vec4 fragColor0;\nlayout(location = 1) out vec4 fragColor1;\nlayout(location = 2) out vec4 fragColor2;\nlayout(location = 3) out vec4 fragColor3;\nvoid main () {\nStandardSurface s; surf(s);\nfragColor0 = s.albedo;\nfragColor1 = vec4(s.position, s.roughness);\nfragColor2 = vec4(s.normal, s.metallic);\nfragColor3 = vec4(s.emissive, s.occlusion);\n}\n#endif"
                        }, {
                            vert: "\nprecision highp float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\nlayout(std140) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nlowp  vec4 cc_shadowNFLSInfo;\nlowp  vec4 cc_shadowWHPBInfo;\nlowp  vec4 cc_shadowLPNNInfo;\nlowp  vec4 cc_shadowColor;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nout vec2 v_clip_depth;\nvec4 vert () {\nvec4 worldPos;\nworldPos.x = cc_matWorld[3][0] + a_position.x;\nworldPos.y = cc_matWorld[3][1] + a_position.y;\nworldPos.z = cc_matWorld[3][2] + a_position.z;\nworldPos.w = 1.0;\nvec4 clipPos = cc_matLightViewProj * worldPos;\nv_clip_depth = clipPos.zw;\nreturn clipPos;\n}\nvoid main() { gl_Position = vert(); }",
                            frag: "\nprecision highp float;\nvec4 packDepthToRGBA (float depth) {\nvec4 ret = vec4(1.0, 255.0, 65025.0, 160581375.0) * depth;\nret = fract(ret);\nret -= ret.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\nreturn ret;\n}\nin vec2 v_clip_depth;\nvec4 frag () {\nreturn packDepthToRGBA(v_clip_depth.x / v_clip_depth.y * 0.5 + 0.5);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
                        }],
                        [{
                            vert: "\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_MORPH\nin float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\nlayout(std140) uniform CCMorph {\nvec4 cc_displacementWeights[15];\nvec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\nivec2 texSize = textureSize(tex, 0);\nreturn texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture(tex, x)),\ndecode32(texture(tex, y)),\ndecode32(texture(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nattr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nattr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nattr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nin vec4 a_joints;\nin vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n#if USE_INSTANCING\nin highp vec4 a_jointAnimInfo;\n#endif\nlayout(std140) uniform CCSkinningTexture {\nhighp vec4 cc_jointTextureInfo;\n};\nlayout(std140) uniform CCSkinningAnimation {\nhighp vec4 cc_jointAnimInfo;\n};\nuniform highp sampler2D cc_jointTexture;\n#else\nlayout(std140) uniform CCSkinning {\nhighp vec4 cc_joints[30 * 3];\n};\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\n#if USE_INSTANCING\nhighp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n#else\nhighp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n#endif\nhighp float invSize = cc_jointTextureInfo.w;\nhighp float y = floor(j * invSize);\nhighp float x = floor(j - y * cc_jointTextureInfo.x);\ny = (y + 0.5) * invSize;\nvec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\n#if USE_INSTANCING\nhighp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n#else\nhighp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n#endif\nhighp float invSize = cc_jointTextureInfo.w;\nhighp float y = floor(j * invSize);\nhighp float x = floor(j - y * cc_jointTextureInfo.x);\ny = (y + 0.5) * invSize;\nvec4 v1 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\nmat4 m = skinMatrix();\nattr.position = m * attr.position;\nattr.normal = (m * vec4(attr.normal, 0.0)).xyz;\nattr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\n#if USE_INSTANCING\nin vec4 a_matWorld0;\nin vec4 a_matWorld1;\nin vec4 a_matWorld2;\n#if USE_LIGHTMAP\nin vec4 a_lightingMapUVParam;\n#endif\n#elif USE_BATCHING\nin float a_dyn_batch_id;\nlayout(std140) uniform CCLocalBatched {\nhighp mat4 cc_matWorlds[10];\n};\n#else\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\n#endif\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nout float v_fog_factor;\n#if USE_VERTEX_COLOR\nin lowp vec4 a_color;\nout lowp vec4 v_color;\n#endif\n#if USE_TEXTURE\nout vec2 v_uv;\nlayout(std140) uniform TexCoords {\nvec4 tilingOffset;\n};\n#endif\nvec4 vert () {\nvec4 position;\nposition = vec4(a_position, 1.0);\n#if CC_USE_MORPH\napplyMorph(position);\n#endif\n#if CC_USE_SKINNING\nCCSkin(position);\n#endif\nmat4 matWorld;\n#if USE_INSTANCING\nmatWorld = mat4(\nvec4(a_matWorld0.xyz, 0.0),\nvec4(a_matWorld1.xyz, 0.0),\nvec4(a_matWorld2.xyz, 0.0),\nvec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n);\n#elif USE_BATCHING\nmatWorld = cc_matWorlds[int(a_dyn_batch_id)];\n#else\nmatWorld = cc_matWorld;\n#endif\n#if USE_TEXTURE\nv_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n#if SAMPLE_FROM_RT\nv_uv = cc_cameraPos.w > 1.0 ? vec2(v_uv.x, 1.0 - v_uv.y) : v_uv;\n#endif\n#endif\n#if USE_VERTEX_COLOR\nv_color = a_color;\n#endif\n#if CC_USE_FOG == 0\nv_fog_factor = LinearFog(matWorld * position);\n#elif CC_USE_FOG == 1\nv_fog_factor = ExpFog(matWorld * position);\n#elif CC_USE_FOG == 2\nv_fog_factor = ExpSquaredFog(matWorld * position);\n#elif CC_USE_FOG == 3\nv_fog_factor = LayeredFog(matWorld * position);\n#else\nv_fog_factor = 1.0;\n#endif\nreturn cc_matProj * (cc_matView * matWorld) * position;\n}\nvoid main() { gl_Position = vert(); }",
                            frag: "\nprecision highp float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n#endif\nreturn color;\n}\nin float v_fog_factor;\n#if USE_ALPHA_TEST\n#endif\n#if USE_TEXTURE\nin vec2 v_uv;\nuniform sampler2D mainTexture;\n#endif\nlayout(std140) uniform Constant {\nvec4 mainColor;\nvec4 colorScaleAndCutoff;\n};\n#if USE_VERTEX_COLOR\nin lowp vec4 v_color;\n#endif\nvec4 frag () {\nvec4 o = mainColor;\no.rgb *= colorScaleAndCutoff.xyz;\n#if USE_VERTEX_COLOR\no *= v_color;\n#endif\n#if USE_TEXTURE\no *= texture(mainTexture, v_uv);\n#endif\n#if USE_ALPHA_TEST\nif (o.ALPHA_TEST_CHANNEL < colorScaleAndCutoff.w) discard;\n#endif\no = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, o.rgb, v_fog_factor), o.a);\nreturn CCFragOutput(o);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
                        }],
                        [{
                            vert: "\nprecision highp float;\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nout vec2 v_uv;\nvoid main () {\nvec4 position;\nposition = vec4(a_position, 1.0);\nposition.xy = cc_cameraPos.w == 0.0 ? vec2(position.xy.x, -position.xy.y) : position.xy;\ngl_Position = vec4(position.x, position.y, 1.0, 1.0);\nv_uv = a_texCoord;\n}",
                            frag: "\nprecision highp float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nlayout(std140) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nlowp  vec4 cc_shadowNFLSInfo;\nlowp  vec4 cc_shadowWHPBInfo;\nlowp  vec4 cc_shadowLPNNInfo;\nlowp  vec4 cc_shadowColor;\n};\n#if CC_RECEIVE_SHADOW\nuniform sampler2D cc_shadowMap;\nuniform sampler2D cc_spotLightingMap;\nfloat CCGetLinearDepth (vec3 worldPos) {\nvec4 viewStartPos = cc_matLightView * vec4(worldPos.xyz, 1.0);\nfloat dist = length(viewStartPos.xyz);\nreturn cc_shadowNFLSInfo.x + (-dist / (cc_shadowNFLSInfo.y - cc_shadowNFLSInfo.x));\n}\nfloat CCGetShadowFactorX1 (vec4 shadowPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nclosestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n} else {\nclosestDepth = texture(cc_shadowMap, clipPos.xy).x;\n}\nshadow = step(closestDepth, clipPos.z- cc_shadowWHPBInfo.w);\nreturn shadow;\n}\nfloat CCGetShadowFactorX5 (vec4 shadowPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\nfloat offsetx = 1.0 / cc_shadowWHPBInfo.x;\nfloat offsety = 1.0 / cc_shadowWHPBInfo.y;\nfloat shadow = 0.0;\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nfloat closestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\nclosestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\nclosestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\nclosestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\nclosestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n} else {\nfloat closestDepth = texture(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)).x;\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\nclosestDepth = texture(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)).x;\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\nclosestDepth = texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x;\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\nclosestDepth = texture(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)).x;\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\nclosestDepth = texture(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)).x;\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n}\nreturn shadow / 5.0;\n}\nfloat CCGetShadowFactorX9 (vec4 shadowPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\nfloat offsetx = 1.0 / cc_shadowWHPBInfo.x;\nfloat offsety = 1.0 / cc_shadowWHPBInfo.y;\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nfor (int i = -1; i <= 1; i++) {\nfor (int j = -1; j <= 1; j++) {\nfloat closestDepth = dot(texture(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n}\n}\n} else {\nfor (int i = -1; i <= 1; i++) {\nfor (int j = -1; j <= 1; j++) {\nfloat closestDepth = texture(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)).x;\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n}\n}\n}\nreturn shadow / 9.0;\n}\nfloat CCGetShadowFactorX25 (vec4 shadowPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\nfloat offsetx = 1.0 / cc_shadowWHPBInfo.x;\nfloat offsety = 1.0 / cc_shadowWHPBInfo.y;\nfloat shadow = 0.0;\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nfor (int i = -2; i <= 2; i++) {\nfor (int j = -2; j <= 2; j++) {\nfloat closestDepth = dot(texture(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n}\n}\n} else {\nfor (int i = -2; i <= 2; i++) {\nfor (int j = -2; j <= 2; j++) {\nfloat closestDepth = texture(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)).x;\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n}\n}\n}\nreturn shadow / 25.0;\n}\nfloat CCGetDirLightShadowFactorX1 (vec4 shadowPos, vec3 worldPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\nfloat shadow = 0.0;\nfloat closestDepth = 0.0;\nfloat depth = 0.0;\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nif (cc_shadowLPNNInfo.y > 0.000001) {\nclosestDepth = dot(texture(cc_spotLightingMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n} else {\nclosestDepth = texture(cc_spotLightingMap, clipPos.xy).x;\n}\nshadow = step(closestDepth, depth - cc_shadowWHPBInfo.w);\nreturn shadow;\n}\nfloat CCGetDirLightShadowFactorX5 (vec4 shadowPos, vec3 worldPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\nfloat offsetx = 1.0 / cc_shadowWHPBInfo.x;\nfloat offsety = 1.0 / cc_shadowWHPBInfo.y;\nfloat shadow = 0.0;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nfloat closestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\nclosestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\nclosestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\nclosestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\nclosestDepth = dot(texture(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n} else {\nfloat closestDepth = texture(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)).x;\nshadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\nclosestDepth = texture(cc_spotLightingMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)).x;\nshadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\nclosestDepth = texture(cc_spotLightingMap, vec2(clipPos.x, clipPos.y)).x;\nshadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\nclosestDepth = texture(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)).x;\nshadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\nclosestDepth = texture(cc_spotLightingMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)).x;\nshadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n}\nreturn shadow / 5.0;\n}\nfloat CCGetDirLightShadowFactorX9 (vec4 shadowPos, vec3 worldPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\nfloat offsetx = 1.0 / cc_shadowWHPBInfo.x;\nfloat offsety = 1.0 / cc_shadowWHPBInfo.y;\nfloat shadow = 0.0;\nfloat depth = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nfor (int i = -1; i <= 1; i++) {\nfor (int j = -1; j <= 1; j++) {\nfloat closestDepth = dot(texture(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n}\n}\n} else {\nfor (int i = -1; i <= 1; i++) {\nfor (int j = -1; j <= 1; j++) {\nfloat closestDepth = texture(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)).x;\nshadow += step(closestDepth, depth - cc_shadowWHPBInfo.w);\n}\n}\n}\nreturn shadow / 9.0;\n}\nfloat CCGetDirLightShadowFactorX25 (vec4 shadowPos, vec3 worldPos) {\nvec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\nif (clipPos.x < 0.0 || clipPos.x > 1.0 ||\nclipPos.y < 0.0 || clipPos.y > 1.0 ||\nclipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\nfloat offsetx = 1.0 / cc_shadowWHPBInfo.x;\nfloat offsety = 1.0 / cc_shadowWHPBInfo.y;\nfloat depth = 0.0;\nfloat shadow = 0.0;\nif (cc_shadowNFLSInfo.z > 0.000001) {\ndepth = CCGetLinearDepth(worldPos);\n} else {\ndepth = clipPos.z;\n}\nclipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\nif (cc_shadowLPNNInfo.y > 0.000001) {\nfor (int i = -2; i <= 2; i++) {\nfor (int j = -2; j <= 2; j++) {\nfloat closestDepth = dot(texture(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n}\n}\n} else {\nfor (int i = -2; i <= 2; i++) {\nfor (int j = -2; j <= 2; j++) {\nfloat closestDepth = texture(cc_spotLightingMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)).x;\nshadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n}\n}\n}\nreturn shadow / 25.0;\n}\n#endif\n#if CC_USE_IBL\nuniform samplerCube cc_environment;\nvec3 unpackRGBE (vec4 rgbe) {\nreturn rgbe.rgb * pow(2.0, rgbe.a * 255.0 - 128.0);\n}\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\nreturn textureLod(tex, coord, lod);\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\nreturn textureLod(tex, coord, lod);\n}\n#endif\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\nvec3 NxH = cross(N, H);\nfloat OneMinusNoHSqr = dot(NxH, NxH);\nfloat a = roughness * roughness;\nfloat n = NoH * a;\nfloat p = a / (OneMinusNoHSqr + n * n);\nreturn p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\nreturn (roughness * 0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\nconst vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\nconst vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\nvec4 r = roughness * c0 + c1;\nfloat a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\nvec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\nAB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\nreturn specular * AB.x + AB.y;\n}\nstruct StandardSurface {\nvec4 albedo;\nvec3 position;\nvec3 normal;\nvec3 emissive;\nvec3 lightmap;\nfloat lightmap_test;\nfloat roughness;\nfloat metallic;\nfloat occlusion;\n};\nvec4 CCStandardShadingBase (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - s.position);\nfloat NV = max(abs(dot(N, V)), 0.001);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 L = normalize(-cc_mainLitDir.xyz);\nvec3 H = normalize(L + V);\nfloat NH = max(dot(N, H), 0.0);\nfloat NL = max(dot(N, L), 0.001);\nvec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\nvec3 diffuseContrib = diffuse;\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\nif (s.lightmap_test > 0.0001) {\nfinalColor = s.lightmap.rgb;\n}\n#else\ndiffuseContrib /= 3.14159265359;\n#endif\nvec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\nfinalColor *= (diffuseContrib + specularContrib);\nfloat fAmb = 0.5 - N.y * 0.5;\nvec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\nfinalColor += (ambDiff.rgb * diffuse);\n#if CC_USE_IBL\nvec3 R = normalize(reflect(-V, N));\nvec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n#if CC_USE_IBL == 2\nvec3 env = unpackRGBE(envmap);\n#else\nvec3 env = SRGBToLinear(envmap.rgb);\n#endif\nfinalColor += env * cc_ambientSky.w * specular;\n#endif\nfinalColor = finalColor * s.occlusion;\n#if CC_USE_HDR\ns.emissive *= cc_exposure.w;\n#endif\nfinalColor += s.emissive;\n#if CC_RECEIVE_SHADOW\n{\nfloat pcf = cc_shadowWHPBInfo.z + 0.001;\nfloat shadowAttenuation = 0.0;\nfloat cosAngle = clamp(1.0 - dot(N, L.xyz), 0.0, 1.0);\nvec3 projWorldPos = shadowPos.xyz + cosAngle * cc_shadowLPNNInfo.z * N;\nvec4 pos = vec4(projWorldPos.xyz, shadowPos.w);\nif (pcf > 3.0) shadowAttenuation = CCGetShadowFactorX25(pos);\nelse if (pcf > 2.0) shadowAttenuation = CCGetShadowFactorX9(pos);\nelse if (pcf > 1.0) shadowAttenuation = CCGetShadowFactorX5(pos);\nelse shadowAttenuation = CCGetShadowFactorX1(pos);\nvec3 shadowColor = cc_shadowColor.rgb * cc_shadowColor.a + finalColor.rgb * (1.0 - cc_shadowColor.a);\nif (cc_shadowNFLSInfo.w > 0.000001) {\nfinalColor.rgb = shadowColor.rgb * shadowAttenuation + finalColor.rgb * (1.0 - shadowAttenuation);\n} else {\nfinalColor.rgb = shadowColor.rgb * shadowAttenuation * NL + finalColor.rgb * (1.0 - shadowAttenuation * NL);\n}\n}\n#endif\nreturn vec4(finalColor, s.albedo.a);\n}\n#if CC_PIPELINE_TYPE == 0\n# define LIGHTS_PER_PASS 1\n#else\n# define LIGHTS_PER_PASS 10\n#endif\nlayout(std140) uniform CCForwardLight {\nhighp vec4 cc_lightPos[LIGHTS_PER_PASS];\nvec4 cc_lightColor[LIGHTS_PER_PASS];\nvec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\nvec4 cc_lightDir[LIGHTS_PER_PASS];\n};\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\nfloat factor = distSqr * invSqrAttRadius;\nfloat smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\nreturn smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\nfloat attenuation = 1.0 / max(distSqr, 0.01*0.01);\nattenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\nreturn attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\nfloat cd = dot(litDir, L);\nfloat attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\nreturn (attenuation * attenuation);\n}\nvec4 CCStandardShadingAdditive (StandardSurface s, vec4 shadowPos) {\nvec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\nvec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\nvec3 diffuseContrib = diffuse / 3.14159265359;\nvec3 N = normalize(s.normal);\nvec3 V = normalize(cc_cameraPos.xyz - s.position);\nfloat NV = max(abs(dot(N, V)), 0.001);\nspecular = BRDFApprox(specular, s.roughness, NV);\nvec3 finalColor = vec3(0.0);\nint numLights = CC_PIPELINE_TYPE == 0 ? LIGHTS_PER_PASS : int(cc_lightDir[0].w);\nfor (int i = 0; i < LIGHTS_PER_PASS; i++) {\nif (i >= numLights) break;\nvec3 SLU = cc_lightPos[i].xyz - s.position;\nvec3 SL = normalize(SLU);\nvec3 SH = normalize(SL + V);\nfloat SNL = max(dot(N, SL), 0.001);\nfloat SNH = max(dot(N, SH), 0.0);\nfloat distSqr = dot(SLU, SLU);\nfloat litRadius = cc_lightSizeRangeAngle[i].x;\nfloat litRadiusSqr = litRadius * litRadius;\nfloat illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\nfloat attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\nattRadiusSqrInv *= attRadiusSqrInv;\nfloat att = GetDistAtt(distSqr, attRadiusSqrInv);\nvec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\nif (cc_lightPos[i].w > 0.0) {\nfloat cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\nfloat cosOuter = cc_lightSizeRangeAngle[i].z;\nfloat litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\nfloat litAngleOffset = -cosOuter * litAngleScale;\natt *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n}\nvec3 lightColor = cc_lightColor[i].rgb;\n#if CC_RECEIVE_SHADOW\nif (cc_lightPos[i].w > 0.0) {\n{\nfloat pcf = cc_shadowWHPBInfo.z + 0.001;\nfloat shadowAttenuation = 0.0;\nfloat cosAngle = clamp(1.0 - dot(N, normalize(cc_lightPos[i].xyz - s.position.xyz)), 0.0, 1.0);\nvec3 projWorldPos = shadowPos.xyz + cosAngle * cc_shadowLPNNInfo.z * N;\nvec4 pos = vec4(projWorldPos.xyz, shadowPos.w);\nif (pcf > 3.0) shadowAttenuation = CCGetDirLightShadowFactorX25(pos, s.position);\nelse if (pcf > 2.0) shadowAttenuation = CCGetDirLightShadowFactorX9(pos, s.position);\nelse if (pcf > 1.0) shadowAttenuation = CCGetDirLightShadowFactorX5(pos, s.position);\nelse shadowAttenuation = CCGetDirLightShadowFactorX1(pos, s.position);\nlightColor *= 1.0 - shadowAttenuation;\n}\n}\n#endif\nfinalColor += SNL * lightColor * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n}\nfinalColor = finalColor * s.occlusion;\nreturn vec4(finalColor, 0.0);\n}\nvec3 ACESToneMap (vec3 color) {\ncolor = min(color, vec3(8.0));\nconst float A = 2.51;\nconst float B = 0.03;\nconst float C = 2.43;\nconst float D = 0.59;\nconst float E = 0.14;\nreturn (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n#if !CC_USE_HDR\ncolor.rgb = sqrt(ACESToneMap(color.rgb));\n#endif\nreturn color;\n}\nfloat LinearFog(vec4 pos) {\nvec4 wPos = pos;\nfloat cam_dis = distance(cc_cameraPos, wPos);\nfloat fogStart = cc_fogBase.x;\nfloat fogEnd = cc_fogBase.y;\nreturn clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\nfloat f = exp(-cam_dis * fogDensity);\nreturn f;\n}\nfloat ExpSquaredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat fogDensity = cc_fogBase.z;\nfloat cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\nfloat f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\nreturn f;\n}\nfloat LayeredFog(vec4 pos) {\nvec4 wPos = pos;\nfloat fogAtten = cc_fogAdd.z;\nfloat _FogTop = cc_fogAdd.x;\nfloat _FogRange = cc_fogAdd.y;\nvec3 camWorldProj = cc_cameraPos.xyz;\ncamWorldProj.y = 0.;\nvec3 worldPosProj = wPos.xyz;\nworldPosProj.y = 0.;\nfloat fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\nfloat fDeltaY, fDensityIntegral;\nif (cc_cameraPos.y > _FogTop) {\nif (wPos.y < _FogTop) {\nfDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\nfDensityIntegral = fDeltaY * fDeltaY * 0.5;\n} else {\nfDeltaY = 0.;\nfDensityIntegral = 0.;\n}\n} else {\nif (wPos.y < _FogTop) {\nfloat fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfloat fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\nfDeltaY = abs(fDeltaA - fDeltaB);\nfDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n} else {\nfDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\nfDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n}\n}\nfloat fDensity;\nif (fDeltaY != 0.) {\nfDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n} else {\nfDensity = 0.;\n}\nfloat f = exp(-fDensity);\nreturn f;\n}\nin vec2 v_uv;\nuniform sampler2D cc_gbuffer_albedoMap;\nuniform sampler2D cc_gbuffer_positionMap;\nuniform sampler2D cc_gbuffer_normalMap;\nuniform sampler2D cc_gbuffer_emissiveMap;\nlayout(location = 0) out vec4 fragColor;\nvoid main () {\nStandardSurface s;\nvec4 albedoMap = texture(cc_gbuffer_albedoMap,v_uv);\nvec4 positionMap = texture(cc_gbuffer_positionMap,v_uv);\nvec4 normalMap = texture(cc_gbuffer_normalMap,v_uv);\nvec4 emissiveMap = texture(cc_gbuffer_emissiveMap,v_uv);\ns.albedo = albedoMap;\ns.position = positionMap.xyz;\ns.roughness = positionMap.w;\ns.normal = normalMap.xyz;\ns.metallic = normalMap.w;\ns.emissive = emissiveMap.xyz;\ns.occlusion = emissiveMap.w;\nfloat fogFactor;\n#if CC_USE_FOG == 0\nfogFactor = LinearFog(vec4(s.position, 1));\n#elif CC_USE_FOG == 1\nfogFactor = ExpFog(vec4(s.position, 1));\n#elif CC_USE_FOG == 2\nfogFactor = ExpSquaredFog(vec4(s.position, 1));\n#elif CC_USE_FOG == 3\nfogFactor = LayeredFog(vec4(s.position, 1));\n#else\nfogFactor = 1.0;\n#endif\nvec4 shadowPos;\nshadowPos = cc_matLightViewProj * vec4(s.position, 1);\nvec4 color = CCStandardShadingBase(s, shadowPos) +\nCCStandardShadingAdditive(s, shadowPos);\ncolor = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, color.rgb, fogFactor), color.a);\nfragColor = CCFragOutput(color);\n}"
                        }],
                        [{
                            vert: "\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_MORPH\nin float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\nlayout(std140) uniform CCMorph {\nvec4 cc_displacementWeights[15];\nvec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\nivec2 texSize = textureSize(tex, 0);\nreturn texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture(tex, x)),\ndecode32(texture(tex, y)),\ndecode32(texture(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nattr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nattr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nattr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nin vec4 a_joints;\nin vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n#if USE_INSTANCING\nin highp vec4 a_jointAnimInfo;\n#endif\nlayout(std140) uniform CCSkinningTexture {\nhighp vec4 cc_jointTextureInfo;\n};\nlayout(std140) uniform CCSkinningAnimation {\nhighp vec4 cc_jointAnimInfo;\n};\nuniform highp sampler2D cc_jointTexture;\n#else\nlayout(std140) uniform CCSkinning {\nhighp vec4 cc_joints[30 * 3];\n};\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\n#if USE_INSTANCING\nhighp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n#else\nhighp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n#endif\nhighp float invSize = cc_jointTextureInfo.w;\nhighp float y = floor(j * invSize);\nhighp float x = floor(j - y * cc_jointTextureInfo.x);\ny = (y + 0.5) * invSize;\nvec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\n#if USE_INSTANCING\nhighp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n#else\nhighp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n#endif\nhighp float invSize = cc_jointTextureInfo.w;\nhighp float y = floor(j * invSize);\nhighp float x = floor(j - y * cc_jointTextureInfo.x);\ny = (y + 0.5) * invSize;\nvec4 v1 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\nmat4 m = skinMatrix();\nattr.position = m * attr.position;\nattr.normal = (m * vec4(attr.normal, 0.0)).xyz;\nattr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\n#if USE_INSTANCING\nin vec4 a_matWorld0;\nin vec4 a_matWorld1;\nin vec4 a_matWorld2;\n#if USE_LIGHTMAP\nin vec4 a_lightingMapUVParam;\n#endif\n#elif USE_BATCHING\nin float a_dyn_batch_id;\nlayout(std140) uniform CCLocalBatched {\nhighp mat4 cc_matWorlds[10];\n};\n#else\nlayout(std140) uniform CCLocal {\nhighp mat4 cc_matWorld;\nhighp mat4 cc_matWorldIT;\nhighp vec4 cc_lightingMapUVParam;\n};\n#endif\nlayout(std140) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nlowp  vec4 cc_shadowNFLSInfo;\nlowp  vec4 cc_shadowWHPBInfo;\nlowp  vec4 cc_shadowLPNNInfo;\nlowp  vec4 cc_shadowColor;\n};\nvec4 vert () {\nvec4 position;\nposition = vec4(a_position, 1.0);\n#if CC_USE_MORPH\napplyMorph(position);\n#endif\n#if CC_USE_SKINNING\nCCSkin(position);\n#endif\nmat4 matWorld;\n#if USE_INSTANCING\nmatWorld = mat4(\nvec4(a_matWorld0.xyz, 0.0),\nvec4(a_matWorld1.xyz, 0.0),\nvec4(a_matWorld2.xyz, 0.0),\nvec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n);\n#elif USE_BATCHING\nmatWorld = cc_matWorlds[int(a_dyn_batch_id)];\n#else\nmatWorld = cc_matWorld;\n#endif\nposition = cc_matProj * (cc_matView * cc_matLightPlaneProj * matWorld) * position;\nposition.z -= 0.0001;\nreturn position;\n}\nvoid main() { gl_Position = vert(); }",
                            frag: "\nprecision mediump float;\nlayout(std140) uniform CCShadow {\nhighp mat4 cc_matLightPlaneProj;\nhighp mat4 cc_matLightView;\nhighp mat4 cc_matLightViewProj;\nlowp  vec4 cc_shadowNFLSInfo;\nlowp  vec4 cc_shadowWHPBInfo;\nlowp  vec4 cc_shadowLPNNInfo;\nlowp  vec4 cc_shadowColor;\n};\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n#endif\nreturn color;\n}\nvec4 frag () {\nreturn CCFragOutput(cc_shadowColor);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
                        }],
                        [{
                            vert: "\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\nrgba = rgba * 255.0;\nhighp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\nhighp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\nhighp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\nreturn Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_MORPH\nin float a_vertexId;\nint getVertexId() {\nreturn int(a_vertexId);\n}\nlayout(std140) uniform CCMorph {\nvec4 cc_displacementWeights[15];\nvec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\nfloat pixelIndexF = float(pixelIndex);\nfloat x = mod(pixelIndexF, textureResolution.x);\nfloat y = floor(pixelIndexF / textureResolution.x);\nreturn vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\nreturn (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\nivec2 texSize = textureSize(tex, 0);\nreturn texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n}\n#else\nvec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\nint pixelIndex = elementIndex * 4;\nvec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\nvec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\nvec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\nreturn vec4(\ndecode32(texture(tex, x)),\ndecode32(texture(tex, y)),\ndecode32(texture(tex, z)),\n1.0\n);\n}\n#endif\nfloat getDisplacementWeight(int index) {\nint quot = index / 4;\nint remainder = index - quot * 4;\nif (remainder == 0) {\nreturn cc_displacementWeights[quot].x;\n} else if (remainder == 1) {\nreturn cc_displacementWeights[quot].y;\n} else if (remainder == 2) {\nreturn cc_displacementWeights[quot].z;\n} else {\nreturn cc_displacementWeights[quot].w;\n}\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\nreturn fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\nvec3 result = vec3(0, 0, 0);\nint nVertices = int(cc_displacementTextureInfo.z);\nfor (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\nresult += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n}\nreturn result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\nuniform sampler2D cc_PositionDisplacements;\nvec3 getPositionDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nuniform sampler2D cc_NormalDisplacements;\nvec3 getNormalDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n}\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nuniform sampler2D cc_TangentDisplacements;\nvec3 getTangentDisplacement(int vertexId) {\nreturn getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n}\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\nint vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\nattr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\nattr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\nattr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\nposition.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nin vec4 a_joints;\nin vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n#if USE_INSTANCING\nin highp vec4 a_jointAnimInfo;\n#endif\nlayout(std140) uniform CCSkinningTexture {\nhighp vec4 cc_jointTextureInfo;\n};\nlayout(std140) uniform CCSkinningAnimation {\nhighp vec4 cc_jointAnimInfo;\n};\nuniform highp sampler2D cc_jointTexture;\n#else\nlayout(std140) uniform CCSkinning {\nhighp vec4 cc_joints[30 * 3];\n};\n#endif\n#if CC_USE_BAKED_ANIMATION\n#if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\nmat4 getJointMatrix (float i) {\n#if USE_INSTANCING\nhighp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n#else\nhighp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n#endif\nhighp float invSize = cc_jointTextureInfo.w;\nhighp float y = floor(j * invSize);\nhighp float x = floor(j - y * cc_jointTextureInfo.x);\ny = (y + 0.5) * invSize;\nvec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\nvec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\nvec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#else\nmat4 getJointMatrix (float i) {\n#if USE_INSTANCING\nhighp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n#else\nhighp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n#endif\nhighp float invSize = cc_jointTextureInfo.w;\nhighp float y = floor(j * invSize);\nhighp float x = floor(j - y * cc_jointTextureInfo.x);\ny = (y + 0.5) * invSize;\nvec4 v1 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n);\nvec4 v2 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n);\nvec4 v3 = vec4(\ndecode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\ndecode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n);\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\n#else\nmat4 getJointMatrix (float i) {\nint idx = int(i);\nvec4 v1 = cc_joints[idx * 3];\nvec4 v2 = cc_joints[idx * 3 + 1];\nvec4 v3 = cc_joints[idx * 3 + 2];\nreturn mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\n#endif\nmat4 skinMatrix () {\nvec4 joints = vec4(a_joints);\nreturn getJointMatrix(joints.x) * a_weights.x\n+ getJointMatrix(joints.y) * a_weights.y\n+ getJointMatrix(joints.z) * a_weights.z\n+ getJointMatrix(joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\nmat4 m = skinMatrix();\nposition = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\nmat4 m = skinMatrix();\nattr.position = m * attr.position;\nattr.normal = (m * vec4(attr.normal, 0.0)).xyz;\nattr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nout vec2 v_uv;\nvoid main () {\nStandardVertInput In;\nIn.position = vec4(a_position, 1.0);\nIn.normal = a_normal;\nIn.tangent = a_tangent;\n#if CC_USE_MORPH\napplyMorph(In);\n#endif\n#if CC_USE_SKINNING\nCCSkin(In);\n#endif\nIn.position.xy = cc_cameraPos.w == 0.0 ? vec2(In.position.xy.x, -In.position.xy.y) : In.position.xy;\ngl_Position = In.position;\ngl_Position.y = gl_Position.y;\nv_uv = a_texCoord;\n}",
                            frag: "\nprecision highp float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nin vec2 v_uv;\nuniform sampler2D cc_lighting_resultMap;\nlayout(location = 0) out vec4 fragColor;\nvoid texcoords(vec2 fragCoord, vec2 resolution,\nout vec2 v_rgbNW, out vec2 v_rgbNE,\nout vec2 v_rgbSW, out vec2 v_rgbSE,\nout vec2 v_rgbM) {\nvec2 inverseVP = 1.0 / resolution.xy;\nv_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\nv_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\nv_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\nv_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\nv_rgbM = vec2(fragCoord * inverseVP);\n}\nvec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 resolution,\nvec2 v_rgbNW, vec2 v_rgbNE,\nvec2 v_rgbSW, vec2 v_rgbSE,\nvec2 v_rgbM) {\nvec4 color;\nmediump vec2 inverseVP = vec2(1.0 / resolution.x, 1.0 / resolution.y);\nvec3 rgbNW = texture(tex, v_rgbNW).xyz;\nvec3 rgbNE = texture(tex, v_rgbNE).xyz;\nvec3 rgbSW = texture(tex, v_rgbSW).xyz;\nvec3 rgbSE = texture(tex, v_rgbSE).xyz;\nvec4 texColor = texture(tex, v_rgbM);\nvec3 rgbM  = texColor.xyz;\nvec3 luma = vec3(0.299, 0.587, 0.114);\nfloat lumaNW = dot(rgbNW, luma);\nfloat lumaNE = dot(rgbNE, luma);\nfloat lumaSW = dot(rgbSW, luma);\nfloat lumaSE = dot(rgbSE, luma);\nfloat lumaM  = dot(rgbM,  luma);\nfloat lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\nfloat lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\nmediump vec2 dir;\ndir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\ndir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\nfloat dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n(0.25 * (1.0 / 8.0)), (1.0/ 128.0));\nfloat rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\ndir = min(vec2(8.0, 8.0),\nmax(vec2(-8.0, -8.0),\ndir * rcpDirMin)) * inverseVP;\nvec3 rgbA = 0.5 * (\ntexture(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\ntexture(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\nvec3 rgbB = rgbA * 0.5 + 0.25 * (\ntexture(tex, fragCoord * inverseVP + dir * -0.5).xyz +\ntexture(tex, fragCoord * inverseVP + dir * 0.5).xyz);\nfloat lumaB = dot(rgbB, luma);\nif ((lumaB < lumaMin) || (lumaB > lumaMax))\ncolor = vec4(rgbA, texColor.a);\nelse\ncolor = vec4(rgbB, texColor.a);\nreturn color;\n}\nvoid main () {\nmediump vec2 v_rgbNW;\nmediump vec2 v_rgbNE;\nmediump vec2 v_rgbSW;\nmediump vec2 v_rgbSE;\nmediump vec2 v_rgbM;\nvec2 resolution = cc_screenSize.xy;\nvec2 fragCoord = v_uv * resolution;\ntexcoords(fragCoord, resolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\nfragColor = fxaa(cc_lighting_resultMap, fragCoord, resolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n}"
                        }],
                        [{
                            vert: "\nprecision highp float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nstruct StandardVertInput {\nhighp vec4 position;\nvec3 normal;\nvec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\nout mediump vec4 viewDir;\nvec4 vert () {\nviewDir = vec4(a_position, 1.0);\nmat4 matViewRotOnly = mat4(mat3(cc_matView));\nmat4 matProj = cc_matProj;\nif (matProj[3].w > 0.0) {\nvec2 scale = vec2(48.0, 24.0);\nmatProj[0].xy *= scale;\nmatProj[1].xy *= scale;\nmatProj[2].zw = vec2(-1.0);\nmatProj[3].zw = vec2(0.0);\n}\nvec4 pos = matProj * matViewRotOnly * viewDir;\npos.z = 0.99999 * pos.w;\nreturn pos;\n}\nvoid main() { gl_Position = vert(); }",
                            frag: "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nuniform samplerCube cc_environment;\nvec3 unpackRGBE (vec4 rgbe) {\nreturn rgbe.rgb * pow(2.0, rgbe.a * 255.0 - 128.0);\n}\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvec3 ACESToneMap (vec3 color) {\ncolor = min(color, vec3(8.0));\nconst float A = 2.51;\nconst float B = 0.03;\nconst float C = 2.43;\nconst float D = 0.59;\nconst float E = 0.14;\nreturn (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n#if !CC_USE_HDR\ncolor.rgb = sqrt(ACESToneMap(color.rgb));\n#endif\nreturn color;\n}\nin mediump vec4 viewDir;\nvec4 frag () {\n#if USE_RGBE_CUBEMAP\nvec3 c = unpackRGBE(texture(cc_environment, viewDir.xyz));\n#else\nvec3 c = SRGBToLinear(texture(cc_environment, viewDir.xyz).rgb);\n#endif\nreturn CCFragOutput(vec4(c * cc_ambientSky.w, 1.0));\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
                        }],
                        [{
                            vert: "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nin vec3 a_position;\nin vec4 a_color;\nout vec2 v_uv;\nlayout(std140) uniform Constants {\nvec4 offset;\n};\nlayout(std140) uniform PerFrameInfo {\nvec4 digits[8 * 10 / 4];\n};\nfloat getComponent(vec4 v, float i) {\nif (i < 1.0) { return v.x; }\nelse if (i < 2.0) { return v.y; }\nelse if (i < 3.0) { return v.z; }\nelse { return v.w; }\n}\nvec4 vert () {\nvec4 position = cc_matViewProj * vec4(a_position, 1.0);\nposition.xy += offset.xy;\nv_uv = a_color.xy;\nif (a_color.z >= 0.0) {\nfloat n = getComponent(digits[int(a_color.z)], a_color.w);\nv_uv += vec2(offset.z * n, 0.0);\n}\nreturn position;\n}\nvoid main() { gl_Position = vert(); }",
                            frag: "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\nhighp   vec4 cc_time;\nmediump vec4 cc_screenSize;\nmediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\nhighp   mat4 cc_matView;\nhighp   mat4 cc_matViewInv;\nhighp   mat4 cc_matProj;\nhighp   mat4 cc_matProjInv;\nhighp   mat4 cc_matViewProj;\nhighp   mat4 cc_matViewProjInv;\nhighp   vec4 cc_cameraPos;\nmediump vec4 cc_screenScale;\nmediump vec4 cc_exposure;\nmediump vec4 cc_mainLitDir;\nmediump vec4 cc_mainLitColor;\nmediump vec4 cc_ambientSky;\nmediump vec4 cc_ambientGround;\nmediump vec4 cc_fogColor;\nmediump vec4 cc_fogBase;\nmediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\nreturn gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n#if CC_USE_HDR\ncolor.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n#endif\nreturn color;\n}\nin vec2 v_uv;\nuniform sampler2D mainTexture;\nvec4 frag () {\nreturn CCFragOutput(texture(mainTexture, v_uv));\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
                        }],
                        [{
                            vert: "\nprecision mediump float;\nin vec2 a_position;\nin vec2 a_texCoord;\nout vec2 v_uv;\nout float v_percent;\nlayout(std140) uniform Constant {\nvec4 u_buffer0;\nvec4 u_buffer1;\nmat4 u_projection;\n};\nvec4 vert () {\nvec2 worldPos = a_position * u_buffer1.xy + u_buffer1.zw;\nvec2 clipSpace = worldPos / u_buffer0.xy * 2.0 - 1.0;\nvec4 screenPos = u_projection * vec4(clipSpace, 0.0, 1.0);\nv_uv = a_texCoord;\nv_percent = u_buffer0.z;\nreturn screenPos;\n}\nvoid main() { gl_Position = vert(); }",
                            frag: "\nprecision mediump float;\nin vec2 v_uv;\nin float v_percent;\nuniform sampler2D mainTexture;\nvec4 frag () {\nvec4 color = texture(mainTexture, v_uv);\nfloat precent = clamp(v_percent, 0.0, 1.0);\ncolor.xyz *= precent;\nreturn color;\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
                        }]
                    ]
                },
                $p = function() {
                    function e() {
                        this._device = null, this._resources = {}
                    }
                    var t = e.prototype;
                    return t.initBuiltinRes = function(e) {
                        var t = this;
                        this._device = e;
                        var n = this._resources,
                            r = document.createElement("canvas"),
                            o = r.getContext("2d"),
                            a = new Wf(r),
                            s = r.width = r.height = 2;
                        o.fillStyle = "#000", o.fillRect(0, 0, s, s);
                        var c = new yp;
                        c._uuid = "black-texture", c.image = a, n[c._uuid] = c, o.fillStyle = "rgba(0,0,0,0)", o.fillRect(0, 0, s, s);
                        var l = new yp;
                        l._uuid = "empty-texture", l.image = a, n[l._uuid] = l;
                        var u = new Sp;
                        u._uuid = "black-cube-texture", u.setMipFilter(Sp.Filter.NEAREST), u.image = {
                            front: new Wf(r),
                            back: new Wf(r),
                            left: new Wf(r),
                            right: new Wf(r),
                            top: new Wf(r),
                            bottom: new Wf(r)
                        }, n[u._uuid] = u, o.fillStyle = "#777", o.fillRect(0, 0, s, s);
                        var h = new yp;
                        h._uuid = "grey-texture", h.image = a, n[h._uuid] = h, o.fillStyle = "#fff", o.fillRect(0, 0, s, s);
                        var _ = new yp;
                        _._uuid = "white-texture", _.image = a, n[_._uuid] = _;
                        var f = new Sp;
                        f._uuid = "white-cube-texture", f.setMipFilter(Sp.Filter.NEAREST), f.image = {
                            front: new Wf(r),
                            back: new Wf(r),
                            left: new Wf(r),
                            right: new Wf(r),
                            top: new Wf(r),
                            bottom: new Wf(r)
                        }, n[f._uuid] = f, o.fillStyle = "#7f7fff", o.fillRect(0, 0, s, s);
                        var d = new yp;
                        d._uuid = "normal-texture", d.image = a, n[d._uuid] = d, r.width = r.height = 16, o.fillStyle = "#ddd", o.fillRect(0, 0, 16, 16), o.fillStyle = "#555", o.fillRect(0, 0, 8, 8), o.fillStyle = "#555", o.fillRect(8, 8, 8, 8);
                        var p = new yp;
                        p._uuid = "default-texture", p.image = a, n[p._uuid] = p;
                        var m = new Sp;
                        if (m.setMipFilter(Sp.Filter.NEAREST), m._uuid = "default-cube-texture", m.image = {
                                front: new Wf(r),
                                back: new Wf(r),
                                left: new Wf(r),
                                right: new Wf(r),
                                top: new Wf(r),
                                bottom: new Wf(r)
                            }, n[m._uuid] = m, i.SpriteFrame) {
                            var g = new i.SpriteFrame,
                                v = a._texture;
                            g.texture = v, g._uuid = "default-spriteframe", n[g._uuid] = g
                        }
                        var y = Xp(e);
                        if (!y) return Promise.reject(Error("Failed to initialize builtin shaders: unknown device."));
                        var S = Jp[y];
                        return S ? Promise.resolve().then((function() {
                            Cp.forEach((function(e, t) {
                                var n = Object.assign(new i.EffectAsset, e);
                                n.shaders.forEach((function(e, n) {
                                    var i = S[t][n];
                                    i && (e[y] = i)
                                })), n.hideInEditor = !0, n.onLoaded()
                            })), t._initMaterials()
                        })) : Promise.reject(Error("Current device is requiring builtin shaders of version " + y + " but shaders of that version are not assembled in this build."))
                    }, t.get = function(e) {
                        return this._resources[e]
                    }, t._initMaterials = function() {
                        var e = this._resources,
                            t = [],
                            n = new i.Material;
                        n._uuid = "standard-material", n.initialize({
                            effectName: "standard"
                        }), e[n._uuid] = n, t.push(n);
                        var r = new i.Material;
                        r._uuid = "missing-effect-material", r.initialize({
                            effectName: "unlit",
                            defines: {
                                USE_COLOR: !0
                            }
                        }), r.setProperty("mainColor", i.color("#ffff00")), e[r._uuid] = r, t.push(r);
                        var o = new i.Material;
                        o._uuid = "missing-material", o.initialize({
                            effectName: "unlit",
                            defines: {
                                USE_COLOR: !0
                            }
                        }), o.setProperty("mainColor", i.color("#ff00ff")), e[o._uuid] = o, t.push(o);
                        var a = new i.Material;
                        a._uuid = "default-clear-stencil", a.initialize({
                            defines: {
                                USE_TEXTURE: !1
                            },
                            effectName: "clear-stencil"
                        }), e[a._uuid] = a, t.push(a);
                        var s = new i.Material;
                        s._uuid = "ui-base-material", s.initialize({
                            defines: {
                                USE_TEXTURE: !1
                            },
                            effectName: "sprite"
                        }), e[s._uuid] = s, t.push(s);
                        var c = new i.Material;
                        c._uuid = "ui-sprite-material", c.initialize({
                            defines: {
                                USE_TEXTURE: !0,
                                CC_USE_EMBEDDED_ALPHA: !1,
                                IS_GRAY: !1
                            },
                            effectName: "sprite"
                        }), e[c._uuid] = c, t.push(c);
                        var l = new i.Material;
                        l._uuid = "ui-alpha-test-material", l.initialize({
                            defines: {
                                USE_TEXTURE: !0,
                                USE_ALPHA_TEST: !0,
                                CC_USE_EMBEDDED_ALPHA: !1,
                                IS_GRAY: !1
                            },
                            effectName: "sprite"
                        }), e[l._uuid] = l, t.push(l);
                        var u = new i.Material;
                        u._uuid = "ui-sprite-gray-material", u.initialize({
                            defines: {
                                USE_TEXTURE: !0,
                                CC_USE_EMBEDDED_ALPHA: !1,
                                IS_GRAY: !0
                            },
                            effectName: "sprite"
                        }), e[u._uuid] = u, t.push(u);
                        var h = new i.Material;
                        h._uuid = "ui-sprite-alpha-sep-material", h.initialize({
                            defines: {
                                USE_TEXTURE: !0,
                                CC_USE_EMBEDDED_ALPHA: !0,
                                IS_GRAY: !1
                            },
                            effectName: "sprite"
                        }), e[h._uuid] = h, t.push(h);
                        var _ = new i.Material;
                        _._uuid = "ui-sprite-gray-alpha-sep-material", _.initialize({
                            defines: {
                                USE_TEXTURE: !0,
                                CC_USE_EMBEDDED_ALPHA: !0,
                                IS_GRAY: !0
                            },
                            effectName: "sprite"
                        }), e[_._uuid] = _, t.push(_);
                        var f = new i.Material;
                        f._uuid = "ui-graphics-material", f.initialize({
                            effectName: "graphics"
                        }), e[f._uuid] = f, t.push(f);
                        var d = new i.Material;
                        d._uuid = "default-particle-material", d.initialize({
                            effectName: "particle"
                        }), e[d._uuid] = d, t.push(d);
                        var p = new i.Material;
                        p._uuid = "default-particle-gpu-material", p.initialize({
                            effectName: "particle-gpu"
                        }), e[p._uuid] = p, t.push(p);
                        var m = new i.Material;
                        m._uuid = "default-trail-material", m.initialize({
                            effectName: "particle-trail"
                        }), e[m._uuid] = m, t.push(m);
                        var g = new i.Material;
                        g._uuid = "default-billboard-material", g.initialize({
                            effectName: "billboard"
                        }), e[g._uuid] = g, t.push(g);
                        var v = new i.Material;
                        v._uuid = "default-spine-material", v.initialize({
                            defines: {
                                USE_TEXTURE: !0,
                                CC_USE_EMBEDDED_ALPHA: !1,
                                IS_GRAY: !1
                            },
                            effectName: "spine"
                        }), e[v._uuid] = v, t.push(v);
                        var y = new i.Material;
                        y._uuid = "builtin-deferred-material", y.initialize({
                            effectName: "deferred-lighting"
                        }), e[y._uuid] = y, t.push(y);
                        var S = new i.Material;
                        S._uuid = "builtin-post-process-material", S.initialize({
                            effectName: "post-process"
                        }), e[S._uuid] = S, t.push(S), i.game.on(i.Game.EVENT_RENDERER_INITED, (function() {
                            for (var e = 0; e < t.length; ++e)
                                for (var n = t[e], i = 0; i < n.passes.length; ++i) n.passes[i].tryCompile()
                        }))
                    }, e
                }(),
                em = e("builtinResMgr", i.builtinResMgr = new $p),
                tm = e("getPhaseID", (Kp = new Map, Zp = 0, function(e) {
                    return "number" == typeof e ? e : (Kp.has(e) || (Kp.set(e, 1 << Zp), Zp++), Kp.get(e))
                })),
                nm = new gs(xa.UNIFORM | xa.TRANSFER_DST, Ra.HOST | Ra.DEVICE),
                im = new vs(null),
                rm = new qs(null);
            ! function(e) {
                e[e.INSTANCING = 1] = "INSTANCING", e[e.VB_MERGING = 2] = "VB_MERGING"
            }(Qp || (Qp = {}));
            var om = function() {
                function e(e) {
                    this._rootBuffer = null, this._rootBufferDirty = !1, this._buffers = [], this._descriptorSet = null, this._passIndex = 0, this._propertyIndex = 0, this._programName = "", this._dynamics = {}, this._propertyHandleMap = {}, this._rootBlock = null, this._blocks = [], this._shaderInfo = null, this._defines = {}, this._properties = {}, this._root = void 0, this._device = void 0, this._hShaderDefault = 0, this._handle = 0, this._bs = new bc, this._dss = new xc, this._rs = new Ac, this._root = e, this._device = e.device
                }
                e.fillPipelineInfo = function(e, t) {
                    var n = e.handle;
                    void 0 !== t.priority && Mr.set(n, gr.PRIORITY, t.priority), void 0 !== t.primitive && Mr.set(n, gr.PRIMITIVE, t.primitive), void 0 !== t.stage && Mr.set(n, gr.STAGE, t.stage), void 0 !== t.dynamicStates && Mr.set(n, gr.DYNAMIC_STATES, t.dynamicStates), void 0 !== t.phase && Mr.set(n, gr.PHASE, tm(t.phase));
                    var i = e._bs;
                    if (t.blendState) {
                        var r = t.blendState,
                            o = r.targets;
                        o && o.forEach((function(e, t) {
                            i.setTarget(t, e)
                        })), void 0 !== r.isA2C && (i.isA2C = r.isA2C), void 0 !== r.isIndepend && (i.isIndepend = r.isIndepend), void 0 !== r.blendColor && (i.blendColor = r.blendColor)
                    }
                    e._rs.assign(t.rasterizerState), e._dss.assign(t.depthStencilState)
                }, e.getPassHash = function(e, t) {
                    var n, i = e.handle,
                        r = t + "," + Mr.get(i, gr.PRIMITIVE) + "," + Mr.get(i, gr.DYNAMIC_STATES);
                    return r += function(e) {
                        for (var t, n = ",bs," + e.isA2C, i = te(e.targets); !(t = i()).done;) {
                            var r = t.value;
                            n += ",bt," + r.blend + "," + r.blendEq + "," + r.blendAlphaEq + "," + r.blendColorMask, n += "," + r.blendSrc + "," + r.blendDst + "," + r.blendSrcAlpha + "," + r.blendDstAlpha
                        }
                        return n
                    }(e._bs), r += function(e) {
                        var t = ",dss," + e.depthTest + "," + e.depthWrite + "," + e.depthFunc;
                        return t += "," + e.stencilTestFront + "," + e.stencilFuncFront + "," + e.stencilRefFront + "," + e.stencilReadMaskFront, t += "," + e.stencilFailOpFront + "," + e.stencilZFailOpFront + "," + e.stencilPassOpFront + "," + e.stencilWriteMaskFront, (t += "," + e.stencilTestBack + "," + e.stencilFuncBack + "," + e.stencilRefBack + "," + e.stencilReadMaskBack) + "," + e.stencilFailOpBack + "," + e.stencilZFailOpBack + "," + e.stencilPassOpBack + "," + e.stencilWriteMaskBack
                    }(e._dss), vc(r += ",rs," + (n = e._rs).cullMode + "," + n.depthBias + "," + n.isFrontFaceCCW, 666)
                };
                var t = e.prototype;
                return t.initialize = function(e) {
                    this._doInit(e), this.resetUBOs(), this.resetTextures(), this.tryCompile()
                }, t.getHandle = function(e, t, n) {
                    void 0 === t && (t = 0), void 0 === n && (n = Aa.UNKNOWN);
                    var i = this._propertyHandleMap[e];
                    return i ? (n ? i = Lp(i, n) : t && (i = Lp(i, Dp(i) - t)), i + t) : 0
                }, t.getBinding = function(t) {
                    var n = this.getHandle(t);
                    return n ? e.getBindingFromHandle(n) : -1
                }, t.setUniform = function(t, n) {
                    var i = e.getBindingFromHandle(t),
                        r = e.getTypeFromHandle(t),
                        o = e.getOffsetFromHandle(t),
                        a = this._blocks[i];
                    Fp[r](a, n, o), this._rootBufferDirty = !0
                }, t.getUniform = function(t, n) {
                    var i = e.getBindingFromHandle(t),
                        r = e.getTypeFromHandle(t),
                        o = e.getOffsetFromHandle(t),
                        a = this._blocks[i];
                    return Bp[r](a, n, o)
                }, t.setUniformArray = function(t, n) {
                    for (var i = e.getBindingFromHandle(t), r = e.getTypeFromHandle(t), o = lc(r) >> 2, a = this._blocks[i], s = e.getOffsetFromHandle(t), c = 0; c < n.length; c++, s += o) null !== n[c] && Fp[r](a, n[c], s);
                    this._rootBufferDirty = !0
                }, t.bindTexture = function(e, t, n) {
                    this._descriptorSet.bindTexture(e, t, n || 0)
                }, t.bindSampler = function(e, t, n) {
                    this._descriptorSet.bindSampler(e, t, n || 0)
                }, t.setDynamicState = function(e, t) {
                    var n = this._dynamics[e];
                    n && n.value === t || (n.value = t, n.dirty = !0)
                }, t.overridePipelineStates = function() {
                    console.warn("base pass cannot override states, please use pass instance instead.")
                }, t.update = function() {
                    this._rootBufferDirty && this._rootBuffer && (this._rootBuffer.update(this._rootBlock), this._rootBufferDirty = !1), this._descriptorSet.update()
                }, t.destroy = function() {
                    for (var e = 0; e < this._shaderInfo.blocks.length; e++) {
                        var t = this._shaderInfo.blocks[e];
                        this._buffers[t.binding].destroy()
                    }
                    this._buffers = [], this._rootBuffer && (this._rootBuffer.destroy(), this._rootBlock = null), this._descriptorSet = null, this._rs.destroy(), this._dss.destroy(), this._bs.destroy(), this._handle && (yr.free(Mr.get(this._handle, gr.DESCRIPTOR_SET)), Mr.free(this._handle), this._handle = 0)
                }, t.resetUniform = function(t) {
                    var n = this.getHandle(t);
                    if (n) {
                        var i = e.getTypeFromHandle(n),
                            r = e.getBindingFromHandle(n),
                            o = e.getOffsetFromHandle(n),
                            a = this._blocks[r],
                            s = this._properties[t],
                            c = s && s.value || Up(i);
                        Fp[i](a, c, o), this._rootBufferDirty = !0
                    }
                }, t.resetTexture = function(t, n) {
                    var i = this.getHandle(t);
                    if (i) {
                        var r = e.getTypeFromHandle(i),
                            o = e.getBindingFromHandle(i),
                            a = this._properties[t],
                            s = a && a.value,
                            c = s ? s + "-texture" : Up(r),
                            l = em.get(c),
                            u = l && l.getGFXTexture(),
                            h = a && void 0 !== a.samplerHash ? a.samplerHash : l && l.getSamplerHash(),
                            _ = cd.getSampler(this._device, h);
                        this._descriptorSet.bindSampler(o, _, n), this._descriptorSet.bindTexture(o, u, n)
                    }
                }, t.resetUBOs = function() {
                    for (var e = 0; e < this._shaderInfo.blocks.length; e++)
                        for (var t = this._shaderInfo.blocks[e], n = this._blocks[t.binding], i = 0, r = 0; r < t.members.length; r++) {
                            for (var o = t.members[r], a = this._properties[o.name], s = a && a.value || Up(o.type), c = (lc(o.type) >> 2) * o.count, l = 0; l + s.length <= c; l += s.length) n.set(s, i + l);
                            i += c
                        }
                    this._rootBufferDirty = !0
                }, t.resetTextures = function() {
                    for (var e = 0; e < this._shaderInfo.samplerTextures.length; e++)
                        for (var t = this._shaderInfo.samplerTextures[e], n = 0; n < t.count; n++) this.resetTexture(t.name, n)
                }, t.tryCompile = function() {
                    var t = this._root.pipeline;
                    return !!t && (this._syncBatchingScheme(), this._hShaderDefault = Yp.getGFXShader(this._device, this._programName, this._defines, t), this._hShaderDefault ? (Mr.set(this._handle, gr.PIPELINE_LAYOUT, Yp.getTemplateInfo(this._programName).hPipelineLayout), Mr.set(this._handle, gr.HASH, e.getPassHash(this, this._hShaderDefault)), !0) : (console.warn("create shader " + this._programName + " failed"), !1))
                }, t.getShaderVariant = function(e) {
                    if (void 0 === e && (e = null), !this._hShaderDefault && !this.tryCompile()) return console.warn("pass resources incomplete"), 0;
                    if (!e) return this._hShaderDefault;
                    for (var t = this._root.pipeline, n = 0; n < e.length; n++) {
                        var i = e[n];
                        this._defines[i.name] = i.value
                    }
                    for (var r = Yp.getGFXShader(this._device, this._programName, this._defines, t), o = 0; o < e.length; o++) {
                        var a = e[o];
                        delete this._defines[a.name]
                    }
                    return r
                }, t.beginChangeStatesSilently = function() {}, t.endChangeStatesSilently = function() {}, t._doInit = function(t, n) {
                    void 0 === n && (n = !1);
                    var i = this._handle = Mr.alloc();
                    Mr.set(i, gr.PRIORITY, Du.DEFAULT), Mr.set(i, gr.STAGE, Ou.DEFAULT), Mr.set(i, gr.PHASE, tm("default")), Mr.set(i, gr.PRIMITIVE, Wa.TRIANGLE_LIST), Mr.set(i, gr.RASTERIZER_STATE, this._rs.handle), Mr.set(i, gr.DEPTH_STENCIL_STATE, this._dss.handle), Mr.set(i, gr.BLEND_STATE, this._bs.handle), this._passIndex = t.passIndex, this._propertyIndex = void 0 !== t.propertyIndex ? t.propertyIndex : t.passIndex, this._programName = t.program, this._defines = n ? Z({}, t.defines) : t.defines, this._shaderInfo = Yp.getTemplate(t.program), this._properties = t.properties || this._properties;
                    var r = this._device;
                    e.fillPipelineInfo(this, t), t.stateOverrides && e.fillPipelineInfo(this, t.stateOverrides), rm.layout = Yp.getDescriptorSetLayout(this._device, t.program);
                    var o = yr.alloc(this._device, rm);
                    Mr.set(this._handle, gr.DESCRIPTOR_SET, o), this._descriptorSet = yr.get(o);
                    for (var a = this._shaderInfo.blocks, s = Yp.getTemplateInfo(t.program), c = s.blockSizes, l = s.handleMap, u = r.capabilities.uboOffsetAlignment, h = [], _ = 0, f = 0, d = 0; d < a.length; d++) {
                        var p = c[d];
                        h.push(f), f += Math.ceil(p / u) * u, _ = p
                    }
                    var m = h[h.length - 1] + _;
                    m && (nm.size = 16 * Math.ceil(m / 16), this._rootBuffer = r.createBuffer(nm), this._rootBlock = new ArrayBuffer(m));
                    for (var g = 0, v = 0; g < a.length; g++) {
                        var y = a[g].binding,
                            S = c[g];
                        im.buffer = this._rootBuffer, im.offset = h[v++], im.range = 16 * Math.ceil(S / 16);
                        var E = this._buffers[y] = r.createBuffer(im);
                        this._blocks[y] = new Float32Array(this._rootBlock, im.offset, S / Float32Array.BYTES_PER_ELEMENT), this._descriptorSet.bindBuffer(y, E)
                    }
                    var T = this._propertyHandleMap = l,
                        A = {};
                    for (var x in this._properties) {
                        var C = this._properties[x];
                        C.handleInfo && (A[x] = this.getHandle.apply(this, C.handleInfo))
                    }
                    Object.assign(T, A)
                }, t._syncBatchingScheme = function() {
                    this._defines.USE_INSTANCING ? this._device.hasFeature(Sa.INSTANCED_ARRAYS) ? Mr.set(this._handle, gr.BATCHING_SCHEME, Qp.INSTANCING) : (this._defines.USE_INSTANCING = !1, Mr.set(this._handle, gr.BATCHING_SCHEME, 0)) : this._defines.USE_BATCHING ? Mr.set(this._handle, gr.BATCHING_SCHEME, Qp.VB_MERGING) : Mr.set(this._handle, gr.BATCHING_SCHEME, 0)
                }, t._destroyHandle = function() {
                    this._handle && (Mr.free(this._handle), this._handle = 0)
                }, t._initPassFromTarget = function(e, t, n, i) {
                    Mr.set(this.handle, gr.PRIORITY, e.priority), Mr.set(this.handle, gr.STAGE, e.stage), Mr.set(this.handle, gr.PHASE, e.phase), Mr.set(this.handle, gr.BATCHING_SCHEME, e.batchingScheme), Mr.set(this.handle, gr.PRIMITIVE, e.primitive), Mr.set(this.handle, gr.DYNAMIC_STATES, e.dynamicStates), this._descriptorSet = e.descriptorSet, Mr.set(this.handle, gr.DESCRIPTOR_SET, Mr.get(e.handle, gr.DESCRIPTOR_SET)), this._bs = n, Mr.set(this.handle, gr.BLEND_STATE, n.handle), this._rs = e.rasterizerState, Mr.set(this.handle, gr.RASTERIZER_STATE, Mr.get(e.handle, gr.RASTERIZER_STATE)), this._dss = t, Mr.set(this.handle, gr.DEPTH_STENCIL_STATE, t.handle), this._passIndex = e.passIndex, this._propertyIndex = e.propertyIndex, this._programName = e.program, this._defines = e.defines, this._shaderInfo = e._shaderInfo, this._properties = e._properties, this._blocks = e._blocks, this._dynamics = e._dynamics, this._hShaderDefault = e._hShaderDefault, Mr.set(this._handle, gr.PIPELINE_LAYOUT, Yp.getTemplateInfo(this._programName).hPipelineLayout);
                    var r = Mr.get(e.handle, gr.HASH);
                    Mr.set(this._handle, gr.HASH, r ^ i)
                }, K(e, [{
                    key: "root",
                    get: function() {
                        return this._root
                    }
                }, {
                    key: "device",
                    get: function() {
                        return this._device
                    }
                }, {
                    key: "shaderInfo",
                    get: function() {
                        return this._shaderInfo
                    }
                }, {
                    key: "localSetLayout",
                    get: function() {
                        return Yp.getDescriptorSetLayout(this._device, this._programName, !0)
                    }
                }, {
                    key: "program",
                    get: function() {
                        return this._programName
                    }
                }, {
                    key: "properties",
                    get: function() {
                        return this._properties
                    }
                }, {
                    key: "defines",
                    get: function() {
                        return this._defines
                    }
                }, {
                    key: "passIndex",
                    get: function() {
                        return this._passIndex
                    }
                }, {
                    key: "propertyIndex",
                    get: function() {
                        return this._propertyIndex
                    }
                }, {
                    key: "dynamics",
                    get: function() {
                        return this._dynamics
                    }
                }, {
                    key: "blocks",
                    get: function() {
                        return this._blocks
                    }
                }, {
                    key: "handle",
                    get: function() {
                        return this._handle
                    }
                }, {
                    key: "priority",
                    get: function() {
                        return Mr.get(this._handle, gr.PRIORITY)
                    }
                }, {
                    key: "primitive",
                    get: function() {
                        return Mr.get(this._handle, gr.PRIMITIVE)
                    }
                }, {
                    key: "stage",
                    get: function() {
                        return Mr.get(this._handle, gr.STAGE)
                    }
                }, {
                    key: "phase",
                    get: function() {
                        return Mr.get(this._handle, gr.PHASE)
                    }
                }, {
                    key: "rasterizerState",
                    get: function() {
                        return this._rs
                    }
                }, {
                    key: "depthStencilState",
                    get: function() {
                        return this._dss
                    }
                }, {
                    key: "blendState",
                    get: function() {
                        return this._bs
                    }
                }, {
                    key: "dynamicStates",
                    get: function() {
                        return Mr.get(this._handle, gr.DYNAMIC_STATES)
                    }
                }, {
                    key: "batchingScheme",
                    get: function() {
                        return Mr.get(this._handle, gr.BATCHING_SCHEME)
                    }
                }, {
                    key: "descriptorSet",
                    get: function() {
                        return this._descriptorSet
                    }
                }, {
                    key: "hash",
                    get: function() {
                        return Mr.get(this._handle, gr.HASH)
                    }
                }, {
                    key: "rootBufferDirty",
                    get: function() {
                        return this._rootBufferDirty
                    }
                }]), e
            }();
            om.PropertyType = xp, om.getPropertyTypeFromHandle = Op, om.getTypeFromHandle = Dp, om.getBindingFromHandle = Np, om.getOffsetFromHandle = Mp, G(d_.prototype, "RenderScene.prototype", [{
                name: "raycastUI2DNode"
            }, {
                name: "raycastUINode"
            }]), G(d_.prototype, "RenderScene.prototype", [{
                name: "raycastAll",
                suggest: "using intersect.rayModel in geometry"
            }, {
                name: "raycastAllModels",
                suggest: "using intersect.rayModel in geometry"
            }, {
                name: "raycastSingleModel",
                suggest: "using intersect.rayModel in geometry"
            }, {
                name: "raycastAllCanvas",
                suggest: "using intersect.rayAABB in geometry"
            }, {
                name: "rayResultCanvas"
            }, {
                name: "rayResultModels"
            }, {
                name: "rayResultAll"
            }, {
                name: "rayResultSingleModel"
            }]);
            var am = {};
            G(am, "CameraVisFlags", [{
                name: "GENERAL"
            }]), U(am, "CameraVisFlags", [{
                name: "PROFILER",
                newName: "PROFILER",
                target: Pu.BitMask,
                targetName: "PROFILER"
            }, {
                name: "GIZMOS",
                newName: "GIZMOS",
                target: Pu.BitMask,
                targetName: "GIZMOS"
            }, {
                name: "EDITOR",
                newName: "EDITOR",
                target: Pu.BitMask,
                targetName: "EDITOR"
            }, {
                name: "UI",
                newName: "UI",
                target: Pu.BitMask,
                targetName: "UI_3D"
            }, {
                name: "UI2D",
                newName: "UI2D",
                target: Pu.BitMask,
                targetName: "UI_2D"
            }]), i.CameraVisFlags = am;
            var sm, cm = {};

            function lm(e, t) {
                t < 1e3 ? t = 1e3 : t > 15e3 && (t = 15e3);
                var n = t * t,
                    i = (.860117757 + .000154118254 * t + 1.28641212e-7 * n) / (1 + .000842420235 * t + 7.08145163e-7 * n),
                    r = (.317398726 + 422806245e-13 * t + 4.20481691e-8 * n) / (1 - 289741816e-13 * t + 1.61456053e-7 * n),
                    o = 2 * i - 8 * r + 4,
                    a = 3 * i / o,
                    s = 2 * r / o,
                    c = 1 / s * a,
                    l = 1 / s * (1 - a - s);
                e.x = 3.2404542 * c - 1.5371385 + -.4985314 * l, e.y = -.969266 * c + 1.8760108 + .041556 * l, e.z = .0556434 * c - .2040259 + 1.0572252 * l
            }
            G(cm, "VisibilityFlags", [{
                    name: "GENERAL"
                }]), U(cm, "VisibilityFlags", [{
                    name: "ALWALS",
                    newName: "ALWALS",
                    target: Pu.Enum,
                    targetName: "ALWALS"
                }, {
                    name: "PROFILER",
                    newName: "PROFILER",
                    target: Pu.Enum,
                    targetName: "PROFILER"
                }, {
                    name: "GIZMOS",
                    newName: "GIZMOS",
                    target: Pu.Enum,
                    targetName: "GIZMOS"
                }, {
                    name: "EDITOR",
                    newName: "EDITOR",
                    target: Pu.Enum,
                    targetName: "EDITOR"
                }, {
                    name: "UI",
                    newName: "UI",
                    target: Pu.Enum,
                    targetName: "UI_3D"
                }, {
                    name: "UI2D",
                    newName: "UI2D",
                    target: Pu.Enum,
                    targetName: "UI_2D"
                }]), i.VisibilityFlags = cm, U(om.prototype, "Pass.prototype", [{
                    name: "getBindingTypeFromHandle",
                    newName: "getDescriptorTypeFromHandle"
                }]), G(f_.prototype, "Camera.prototype", [{
                    name: "getSplitFrustum"
                }]),
                function(e) {
                    e[e.DIRECTIONAL = 0] = "DIRECTIONAL", e[e.SPHERE = 1] = "SPHERE", e[e.SPOT = 2] = "SPOT", e[e.UNKNOWN = 3] = "UNKNOWN"
                }(sm || (sm = {}));
            var um = function(e) {
                    return 4 * Math.PI * Math.PI * e * e
                },
                hm = function() {
                    function e() {
                        this._baked = !1, this._color = new En(1, 1, 1), this._colorTemp = 6550, this._colorTempRGB = new En(1, 1, 1), this._scene = null, this._node = null, this._name = null, this._handle = 0
                    }
                    var t = e.prototype;
                    return t.initialize = function() {
                        this._handle = Io.alloc(), Io.setVec3(this._handle, xo.COLOR, this._color), Io.setVec3(this._handle, xo.COLOR_TEMPERATURE_RGB, this._colorTempRGB), Io.set(this._handle, xo.TYPE, sm.UNKNOWN)
                    }, t.attachToScene = function(e) {
                        this._scene = e
                    }, t.detachFromScene = function() {
                        this._scene = null
                    }, t.destroy = function() {
                        this._name = null, this._node = null, this._handle && (Io.free(this._handle), this._handle = 0)
                    }, t.update = function() {}, K(e, [{
                        key: "baked",
                        get: function() {
                            return this._baked
                        },
                        set: function(e) {
                            this._baked = e
                        }
                    }, {
                        key: "color",
                        get: function() {
                            return this._color
                        },
                        set: function(e) {
                            this._color.set(e), Io.setVec3(this._handle, xo.COLOR, e)
                        }
                    }, {
                        key: "useColorTemperature",
                        get: function() {
                            return 1 === Io.get(this._handle, xo.USE_COLOR_TEMPERATURE)
                        },
                        set: function(e) {
                            Io.set(this._handle, xo.USE_COLOR_TEMPERATURE, e ? 1 : 0)
                        }
                    }, {
                        key: "colorTemperature",
                        get: function() {
                            return this._colorTemp
                        },
                        set: function(e) {
                            this._colorTemp = e, lm(this._colorTempRGB, this._colorTemp), Io.setVec3(this._handle, xo.COLOR_TEMPERATURE_RGB, this._colorTempRGB)
                        }
                    }, {
                        key: "colorTemperatureRGB",
                        get: function() {
                            return this._colorTempRGB
                        }
                    }, {
                        key: "node",
                        get: function() {
                            return this._node
                        },
                        set: function(e) {
                            this._node = e, this._node && (this._node.hasChangedFlags |= r_.ROTATION, Io.set(this._handle, xo.NODE, this._node.handle))
                        }
                    }, {
                        key: "type",
                        get: function() {
                            return Io.get(this._handle, xo.TYPE)
                        }
                    }, {
                        key: "name",
                        get: function() {
                            return this._name
                        },
                        set: function(e) {
                            this._name = e
                        }
                    }, {
                        key: "scene",
                        get: function() {
                            return this._scene
                        }
                    }, {
                        key: "handle",
                        get: function() {
                            return this._handle
                        }
                    }]), e
                }(),
                _m = new En(0, 0, -1),
                fm = new En,
                dm = function(e) {
                    function t() {
                        var t;
                        return (t = e.call(this) || this)._dir = new En(1, -1, -1), t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.initialize = function() {
                        e.prototype.initialize.call(this), Io.set(this._handle, xo.ILLUMINANCE, Ko.SUN_ILLUM), Io.setVec3(this._handle, xo.DIRECTION, this._dir), Io.set(this._handle, xo.TYPE, sm.DIRECTIONAL)
                    }, n.update = function() {
                        this._node && this._node.hasChangedFlags && (this.direction = En.transformQuat(fm, _m, this._node.worldRotation))
                    }, K(t, [{
                        key: "direction",
                        get: function() {
                            return this._dir
                        },
                        set: function(e) {
                            En.normalize(this._dir, e), Io.setVec3(this._handle, xo.DIRECTION, this._dir)
                        }
                    }, {
                        key: "illuminance",
                        get: function() {
                            return Io.get(this._handle, xo.ILLUMINANCE)
                        },
                        set: function(e) {
                            Io.set(this._handle, xo.ILLUMINANCE, e)
                        }
                    }]), t
                }(hm);

            function pm(e, t) {
                for (var n, i = te(t); !(n = i()).done;) {
                    var r = n.value;
                    Array.isArray(r) ? pm(e, r) : e.push(r)
                }
            }

            function mm(e) {
                var t = [];
                return pm(t, e), t.join("")
            }
            var gm = ni.Flags.Destroyed,
                vm = ni.Flags.PersistentMask,
                ym = qt.IDENTIFIER_RE,
                Sm = "var ",
                Em = "o",
                Tm = {
                    "cc.ClickEvent": !1,
                    "cc.PrefabInfo": !1
                },
                Am = qt.escapeForJS,
                xm = function() {
                    function e(e, t) {
                        this.varName = void 0, this.expression = void 0, this.varName = e, this.expression = t
                    }
                    return e.prototype.toString = function() {
                        return Sm + this.varName + "=" + this.expression + ";"
                    }, e
                }();

            function Cm(e, t) {
                return t instanceof xm ? new xm(t.varName, e + t.expression) : e + t
            }

            function bm(e, t, n) {
                Array.isArray(n) ? (n[0] = Cm(t, n[0]), e.push(n)) : e.push(Cm(t, n) + ";")
            }
            var Rm = function() {
                function e(e) {
                    this._exps = void 0, this._targetExp = void 0, this._exps = [], this._targetExp = e
                }
                var t = e.prototype;
                return t.append = function(e, t) {
                    this._exps.push([e, t])
                }, t.writeCode = function(e) {
                    var t;
                    if (this._exps.length > 1) e.push("t=" + this._targetExp + ";"), t = "t";
                    else {
                        if (1 !== this._exps.length) return;
                        t = this._targetExp
                    }
                    for (var n = 0; n < this._exps.length; n++) {
                        var i = this._exps[n];
                        bm(e, t + wm(i[0]) + "=", i[1])
                    }
                }, e
            }();

            function wm(e) {
                return ym.test(e) ? "." + e : "[" + Am(e) + "]"
            }
            Rm.pool = void 0, Rm.pool = new Ke((function(e) {
                e._exps.length = 0, e._targetExp = null
            }), 1), Rm.pool.get = function(e) {
                var t = this._get() || new Rm;
                return t._targetExp = e, t
            };
            var Im = function() {
                function e(e, t) {
                    var n;
                    this.parent = void 0, this.objsToClear_iN$t = void 0, this.codeArray = void 0, this.objs = void 0, this.funcs = void 0, this.funcModuleCache = void 0, this.globalVariables = void 0, this.globalVariableId = void 0, this.localVariableId = void 0, this.result = void 0, this.parent = t, this.objsToClear_iN$t = [], this.codeArray = [], this.objs = [], this.funcs = [], this.funcModuleCache = Te(), Ne(this.funcModuleCache, Tm), this.globalVariables = [], this.globalVariableId = 0, this.localVariableId = 0, this.codeArray.push("var o,t;", "if(R){", "o=R;", "}else{", "o=R=new " + this.getFuncModule(e.constructor, !0) + "();", "}"), e._iN$t = {
                        globalVar: "R"
                    }, this.objsToClear_iN$t.push(e), this.enumerateObject(this.codeArray, e), this.globalVariables.length > 0 && (n = Sm + this.globalVariables.join(",") + ";");
                    var i = mm(["return (function(R){", n || [], this.codeArray, "return o;", "})"]);
                    this.result = Function("O", "F", i)(this.objs, this.funcs);
                    for (var r = 0, o = this.objsToClear_iN$t.length; r < o; ++r) this.objsToClear_iN$t[r]._iN$t = null;
                    this.objsToClear_iN$t.length = 0
                }
                var t = e.prototype;
                return t.getFuncModule = function(e, t) {
                    var n = Ae(e);
                    if (n) {
                        var i = this.funcModuleCache[n];
                        if (i) return i;
                        if (void 0 === i) {
                            var r = -1 !== n.indexOf(".");
                            if (r) try {
                                if (r = e === Function("return " + n)()) return this.funcModuleCache[n] = n, n
                            } catch (e) {}
                        }
                    }
                    var o = this.funcs.indexOf(e);
                    o < 0 && (o = this.funcs.length, this.funcs.push(e));
                    var a = "F[" + o + "]";
                    return t && (a = "(" + a + ")"), this.funcModuleCache[n] = a, a
                }, t.getObjRef = function(e) {
                    var t = this.objs.indexOf(e);
                    return t < 0 && (t = this.objs.length, this.objs.push(e)), "O[" + t + "]"
                }, t.setValueType = function(e, t, n, i) {
                    var r = Rm.pool.get(i),
                        o = t.constructor.__props__;
                    o || (o = Object.keys(t));
                    for (var a = 0; a < o.length; a++) {
                        var s = o[a],
                            c = n[s];
                        if (t[s] !== c) {
                            var l = this.enumerateField(n, s, c);
                            r.append(s, l)
                        }
                    }
                    r.writeCode(e), Rm.pool.put(r)
                }, t.enumerateCCClass = function(e, t, n) {
                    for (var r = n.__values__, o = At(n), a = 0; a < r.length; a++) {
                        var s = r[a],
                            c = t[s],
                            l = o[s + "$_$default"];
                        if (!Pm(l, c))
                            if ("object" == typeof c && c instanceof i.ValueType && (l = qt.getDefault(l)) && l.constructor === c.constructor) {
                                var u = Em + wm(s);
                                this.setValueType(e, l, c, u)
                            } else this.setObjProp(e, t, s, c)
                    }
                }, t.instantiateArray = function(e) {
                    if (0 === e.length) return "[]";
                    var t = "a" + ++this.localVariableId,
                        n = [new xm(t, "new Array(" + e.length + ")")];
                    e._iN$t = {
                        globalVar: "",
                        source: n
                    }, this.objsToClear_iN$t.push(e);
                    for (var i = 0; i < e.length; ++i) bm(n, t + "[" + i + "]=", this.enumerateField(e, i, e[i]));
                    return n
                }, t.instantiateTypedArray = function(e) {
                    var t = e.constructor.name;
                    if (0 === e.length) return "new " + t;
                    var n = "a" + ++this.localVariableId,
                        i = [new xm(n, "new " + t + "(" + e.length + ")")];
                    e._iN$t = {
                        globalVar: "",
                        source: i
                    }, this.objsToClear_iN$t.push(e);
                    for (var r = 0; r < e.length; ++r) 0 !== e[r] && bm(i, n + "[" + r + "]=", e[r]);
                    return i
                }, t.enumerateField = function(e, t, n) {
                    if ("object" == typeof n && n) {
                        var i = n._iN$t;
                        if (i) {
                            var r = i.globalVar;
                            if (!r) {
                                r = i.globalVar = "v" + ++this.globalVariableId, this.globalVariables.push(r);
                                var o = i.source[0];
                                i.source[0] = Cm(r + "=", o)
                            }
                            return r
                        }
                        return ArrayBuffer.isView(n) ? this.instantiateTypedArray(n) : Array.isArray(n) ? this.instantiateArray(n) : this.instantiateObj(n)
                    }
                    return "function" == typeof n ? this.getFuncModule(n) : "string" == typeof n ? Am(n) : ("_objFlags" === t && e instanceof ni && (n &= vm), n)
                }, t.setObjProp = function(e, t, n, i) {
                    bm(e, Em + wm(n) + "=", this.enumerateField(t, n, i))
                }, t.enumerateObject = function(e, t) {
                    var n = t.constructor;
                    if (i.Class._isCCClass(n)) this.enumerateCCClass(e, t, n);
                    else
                        for (var r in t)
                            if (t.hasOwnProperty(r) && (95 !== r.charCodeAt(0) || 95 !== r.charCodeAt(1) || "__type__" === r)) {
                                var o = t[r];
                                "object" == typeof o && o && o === t._iN$t || this.setObjProp(e, t, r, o)
                            }
                }, t.instantiateObj = function(e) {
                    if (e instanceof i.ValueType) return qt.getNewValueTypeCode(e);
                    if (e instanceof i.Asset) return this.getObjRef(e);
                    if (e._objFlags & gm) return null;
                    var t, n = e.constructor;
                    if (i.Class._isCCClass(n)) {
                        if (this.parent)
                            if (this.parent instanceof i.Component) {
                                if (e instanceof i._BaseNode || e instanceof i.Component) return this.getObjRef(e)
                            } else if (this.parent instanceof i._BaseNode)
                            if (e instanceof i._BaseNode) {
                                if (!e.isChildOf(this.parent)) return this.getObjRef(e)
                            } else if (e instanceof i.Component && !e.node.isChildOf(this.parent)) return this.getObjRef(e);
                        t = new xm(Em, "new " + this.getFuncModule(n, !0) + "()")
                    } else if (n === Object) t = new xm(Em, "{}");
                    else {
                        if (n) return this.getObjRef(e);
                        t = new xm(Em, "Object.create(null)")
                    }
                    var r = [t];
                    return e._iN$t = {
                        globalVar: "",
                        source: r
                    }, this.objsToClear_iN$t.push(e), this.enumerateObject(r, e), ["(function(){", r, "return o;})();"]
                }, e
            }();

            function Pm(e, t) {
                if ("function" == typeof e) try {
                    e = e()
                } catch (e) {
                    return !1
                }
                if (e === t) return !0;
                if (e && t && "object" == typeof e && "object" == typeof t && e.constructor === t.constructor)
                    if (e instanceof i.ValueType) {
                        if (e.equals(t)) return !0
                    } else {
                        if (Array.isArray(e)) return 0 === e.length && 0 === t.length;
                        if (e.constructor === Object) return me(e) && me(t)
                    }
                return !1
            }
            var Om, Dm = function() {
                function e(e) {
                    this._uiComp = null, this.opacity = 1, this.localOpacity = 1, this._uiTransformComp = null, this._node = void 0, this._node = e
                }
                return K(e, [{
                    key: "uiTransformComp",
                    get: function() {
                        return this._uiTransformComp || (this._uiTransformComp = this._node.getComponent("cc.UITransform")), this._uiTransformComp
                    },
                    set: function(e) {
                        this._uiTransformComp = e
                    }
                }, {
                    key: "uiComp",
                    get: function() {
                        return this._uiComp
                    },
                    set: function(e) {
                        this._uiComp && e ? x(12002) : this._uiComp = e
                    }
                }]), e
            }();
            ! function(e) {
                e.TOUCH_START = "touch-start", e.TOUCH_MOVE = "touch-move", e.TOUCH_END = "touch-end", e.TOUCH_CANCEL = "touch-cancel", e.MOUSE_DOWN = "mouse-down", e.MOUSE_MOVE = "mouse-move", e.MOUSE_UP = "mouse-up", e.MOUSE_WHEEL = "mouse-wheel", e.MOUSE_ENTER = "mouse-enter", e.MOUSE_LEAVE = "mouse-leave", e.KEY_DOWN = "keydown", e.KEY_UP = "keyup", e.DEVICEMOTION = "devicemotion", e.TRANSFORM_CHANGED = "transform-changed", e.SCENE_CHANGED_FOR_PERSISTS = "scene-changed-for-persists", e.SIZE_CHANGED = "size-changed", e.ANCHOR_CHANGED = "anchor-changed", e.COLOR_CHANGED = "color-changed", e.CHILD_ADDED = "child-added", e.CHILD_REMOVED = "child-removed", e.PARENT_CHANGED = "parent-changed", e.NODE_DESTROYED = "node-destroyed", e.LAYER_CHANGED = "layer-changed", e.SIBLING_ORDER_CHANGED = "sibling-order-changed"
            }(Om || (Om = e("SystemEventType", {}))), nt(Om), i.SystemEventType = Om;
            var Nm = function() {
                function e(e, t, n) {
                    this._cameraPriority = 0, this.owner = null, this.mask = null, this._previousIn = !1, this._target = null, this._onEvent = void 0, this._type = void 0, this._listenerID = void 0, this._registered = !1, this._fixedPriority = 0, this._node = null, this._paused = !0, this._isEnabled = !0, this._onEvent = n, this._type = e || 0, this._listenerID = t || ""
                }
                e.create = function(e) {
                    I(e && e.event, 1900);
                    var t = e.event;
                    delete e.event;
                    var n = null;
                    if (t === i.EventListener.TOUCH_ONE_BY_ONE ? n = new Bm : t === i.EventListener.TOUCH_ALL_AT_ONCE ? n = new Fm : t === i.EventListener.MOUSE ? n = new Lm : t === i.EventListener.KEYBOARD ? n = new Um : t === i.EventListener.ACCELERATION && (n = new zm(e.callback), delete e.callback), n)
                        for (var r = 0, o = Object.keys(e); r < o.length; r++) {
                            var a = o[r];
                            n[a] = e[a]
                        }
                    return n
                };
                var t = e.prototype;
                return t._setPaused = function(e) {
                    this._paused = e
                }, t._isPaused = function() {
                    return this._paused
                }, t._setRegistered = function(e) {
                    this._registered = e
                }, t._isRegistered = function() {
                    return this._registered
                }, t._getType = function() {
                    return this._type
                }, t._getListenerID = function() {
                    return this._listenerID
                }, t._setFixedPriority = function(e) {
                    this._fixedPriority = e
                }, t._getFixedPriority = function() {
                    return this._fixedPriority
                }, t._setSceneGraphPriority = function(e) {
                    this._target = e, this._node = e
                }, t._getSceneGraphPriority = function() {
                    return this._node
                }, t.checkAvailable = function() {
                    return null !== this._onEvent
                }, t.clone = function() {
                    return null
                }, t.setEnabled = function(e) {
                    this._isEnabled = e
                }, t.isEnabled = function() {
                    return this._isEnabled
                }, K(e, [{
                    key: "onEvent",
                    get: function() {
                        return this._onEvent
                    }
                }]), e
            }();
            Nm.UNKNOWN = 0, Nm.TOUCH_ONE_BY_ONE = 1, Nm.TOUCH_ALL_AT_ONCE = 2, Nm.KEYBOARD = 3, Nm.MOUSE = 4, Nm.ACCELERATION = 6, Nm.CUSTOM = 8, Nm.ListenerID = {
                MOUSE: "__cc_mouse",
                TOUCH_ONE_BY_ONE: "__cc_touch_one_by_one",
                TOUCH_ALL_AT_ONCE: "__cc_touch_all_at_once",
                KEYBOARD: "__cc_keyboard",
                ACCELERATION: "__cc_acceleration"
            };
            var Mm = Nm.ListenerID,
                Lm = function(e) {
                    function t() {
                        var t;
                        return (t = e.call(this, Nm.MOUSE, Mm.MOUSE, null) || this).onMouseDown = null, t.onMouseUp = null, t.onMouseMove = null, t.onMouseScroll = null, t._onEvent = function(e) {
                            return t._callback(e)
                        }, t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n._callback = function(e) {
                        switch (e.eventType) {
                            case Om.MOUSE_DOWN:
                                this.onMouseDown && this.onMouseDown(e);
                                break;
                            case Om.MOUSE_UP:
                                this.onMouseUp && this.onMouseUp(e);
                                break;
                            case Om.MOUSE_MOVE:
                                this.onMouseMove && this.onMouseMove(e);
                                break;
                            case Om.MOUSE_WHEEL:
                                this.onMouseScroll && this.onMouseScroll(e)
                        }
                    }, n.clone = function() {
                        var e = new t;
                        return e.onMouseDown = this.onMouseDown, e.onMouseUp = this.onMouseUp, e.onMouseMove = this.onMouseMove, e.onMouseScroll = this.onMouseScroll, e
                    }, n.checkAvailable = function() {
                        return !0
                    }, t
                }(Nm),
                Bm = function(e) {
                    function t() {
                        var t;
                        return (t = e.call(this, Nm.TOUCH_ONE_BY_ONE, Mm.TOUCH_ONE_BY_ONE, null) || this).swallowTouches = !1, t.onTouchBegan = null, t.onTouchMoved = null, t.onTouchEnded = null, t.onTouchCancelled = null, t._claimedTouches = [], t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.setSwallowTouches = function(e) {
                        this.swallowTouches = e
                    }, n.isSwallowTouches = function() {
                        return this.swallowTouches
                    }, n.clone = function() {
                        var e = new t;
                        return e.onTouchBegan = this.onTouchBegan, e.onTouchMoved = this.onTouchMoved, e.onTouchEnded = this.onTouchEnded, e.onTouchCancelled = this.onTouchCancelled, e.swallowTouches = this.swallowTouches, e
                    }, n.checkAvailable = function() {
                        return !!this.onTouchBegan || (T(1801), !1)
                    }, t
                }(Nm),
                Fm = function(e) {
                    function t() {
                        var t;
                        return (t = e.call(this, Nm.TOUCH_ALL_AT_ONCE, Mm.TOUCH_ALL_AT_ONCE, null) || this).onTouchesBegan = null, t.onTouchesMoved = null, t.onTouchesEnded = null, t.onTouchesCancelled = null, t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.clone = function() {
                        var e = new t;
                        return e.onTouchesBegan = this.onTouchesBegan, e.onTouchesMoved = this.onTouchesMoved, e.onTouchesEnded = this.onTouchesEnded, e.onTouchesCancelled = this.onTouchesCancelled, e
                    }, n.checkAvailable = function() {
                        return null !== this.onTouchesBegan || null !== this.onTouchesMoved || null !== this.onTouchesEnded || null !== this.onTouchesCancelled || (T(1802), !1)
                    }, t
                }(Nm),
                zm = function(e) {
                    function t(t) {
                        var n;
                        return (n = e.call(this, Nm.ACCELERATION, Mm.ACCELERATION, null) || this)._onAccelerationEvent = null, n._onEvent = function(e) {
                            return n._callback(e)
                        }, n._onAccelerationEvent = t, n
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n._callback = function(e) {
                        this._onAccelerationEvent && this._onAccelerationEvent(e.acc, e)
                    }, n.checkAvailable = function() {
                        return I(this._onAccelerationEvent, 1803), !0
                    }, n.clone = function() {
                        return new t(this._onAccelerationEvent)
                    }, t
                }(Nm),
                Um = function(e) {
                    function t() {
                        var t;
                        return (t = e.call(this, Nm.KEYBOARD, Mm.KEYBOARD, null) || this).onKeyPressed = null, t.onKeyReleased = null, t._onEvent = function(e) {
                            return t._callback(e)
                        }, t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n._callback = function(e) {
                        e.isPressed ? this.onKeyPressed && this.onKeyPressed(e.keyCode, e) : this.onKeyReleased && this.onKeyReleased(e.keyCode, e)
                    }, n.clone = function() {
                        var e = new t;
                        return e.onKeyPressed = this.onKeyPressed, e.onKeyReleased = this.onKeyReleased, e
                    }, n.checkAvailable = function() {
                        return null !== this.onKeyPressed || null !== this.onKeyReleased || (T(1800), !1)
                    }, t
                }(Nm);
            i.EventListener = Nm;
            var Gm = Nm.ListenerID,
                Hm = function() {
                    function e() {
                        this.gt0Index = 0, this._fixedListeners = [], this._sceneGraphListeners = []
                    }
                    var t = e.prototype;
                    return t.size = function() {
                        return this._fixedListeners.length + this._sceneGraphListeners.length
                    }, t.empty = function() {
                        return 0 === this._fixedListeners.length && 0 === this._sceneGraphListeners.length
                    }, t.push = function(e) {
                        0 === e._getFixedPriority() ? this._sceneGraphListeners.push(e) : this._fixedListeners.push(e)
                    }, t.clearSceneGraphListeners = function() {
                        this._sceneGraphListeners.length = 0
                    }, t.clearFixedListeners = function() {
                        this._fixedListeners.length = 0
                    }, t.clear = function() {
                        this._sceneGraphListeners.length = 0, this._fixedListeners.length = 0
                    }, t.getFixedPriorityListeners = function() {
                        return this._fixedListeners
                    }, t.getSceneGraphPriorityListeners = function() {
                        return this._sceneGraphListeners
                    }, e
                }(),
                km = function() {
                    function e() {
                        this._listenersMap = {}, this._priorityDirtyFlagMap = {}, this._nodeListenersMap = {}, this._toAddedListeners = [], this._toRemovedListeners = [], this._dirtyListeners = {}, this._inDispatch = 0, this._isEnabled = !1, this._internalCustomListenerIDs = [], this._currentTouch = null, this._currentTouchListener = null
                    }
                    var t = e.prototype;
                    return t.pauseTarget = function(e, t) {
                        if (void 0 === t && (t = !1), e instanceof i._BaseNode) {
                            var n = this._nodeListenersMap[e.uuid];
                            if (n)
                                for (var r = 0; r < n.length; ++r) n[r]._setPaused(!0);
                            if (!0 === t) {
                                var o = e.children;
                                if (o)
                                    for (var a = 0; a < o.length; ++a) {
                                        var s = o[a];
                                        this.pauseTarget(s, !0)
                                    }
                            }
                        } else x(3506)
                    }, t.resumeTarget = function(e, t) {
                        if (void 0 === t && (t = !1), e instanceof i._BaseNode) {
                            var n = this._nodeListenersMap[e.uuid];
                            if (n)
                                for (var r = 0; r < n.length; ++r) n[r]._setPaused(!1);
                            if (this._setDirtyForNode(e), !0 === t && e.children.length > 0) {
                                var o = e.children;
                                if (o)
                                    for (var a = 0; a < o.length; ++a) {
                                        var s = o[a];
                                        this.resumeTarget(s, !0)
                                    }
                            }
                        } else x(3506)
                    }, t.frameUpdateListeners = function() {
                        var e = this._listenersMap,
                            t = this._priorityDirtyFlagMap;
                        for (var n in e) e[n].empty() && (delete t[n], delete e[n]);
                        var i = this._toAddedListeners;
                        if (0 !== i.length) {
                            for (var r = 0, o = i.length; r < o; r++) this._forceAddEventListener(i[r]);
                            i.length = 0
                        }
                        0 !== this._toRemovedListeners.length && this._cleanToRemovedListeners()
                    }, t.hasEventListener = function(e) {
                        return !!this._getListeners(e)
                    }, t.addListener = function(e, t) {
                        if (I(e && t, 3503), !(i.js.isNumber(t) || t instanceof i._BaseNode)) return x(3506), null;
                        if (e instanceof i.EventListener) {
                            if (e._isRegistered()) return T(3505), null
                        } else I(!i.js.isNumber(t), 3504), e = i.EventListener.create(e);
                        if (!e.checkAvailable()) return null;
                        if (i.js.isNumber(t)) {
                            if (0 === t) return T(3500), null;
                            e._setSceneGraphPriority(null), e._setFixedPriority(t), e._setRegistered(!0), e._setPaused(!1), this._addListener(e)
                        } else {
                            if (!(n = t) || !n.getComponent("cc.UITransform")) return T(3512), null;
                            e._setSceneGraphPriority(t), e._setFixedPriority(0), e._setRegistered(!0), this._addListener(e)
                        }
                        var n;
                        return e
                    }, t.addCustomListener = function(e, t) {
                        var n = Nm.create({
                            event: i.EventListener.CUSTOM,
                            eventName: e,
                            callback: t
                        });
                        return this.addListener(n, 1), n
                    }, t.removeListener = function(e) {
                        if (null != e) {
                            var t = !1,
                                n = this._listenersMap;
                            for (var r in e === this._currentTouchListener && (this._currentTouchListener = this._currentTouch = null), n) {
                                var o = n[r],
                                    a = o.getFixedPriorityListeners(),
                                    s = o.getSceneGraphPriorityListeners();
                                if ((t = this._removeListenerInVector(s, e)) ? this._setDirty(e._getListenerID(), 2) : (t = this._removeListenerInVector(a, e)) && this._setDirty(e._getListenerID(), 1), o.empty() && (delete this._priorityDirtyFlagMap[e._getListenerID()], delete n[r]), t) break
                            }
                            if (!t)
                                for (var c = this._toAddedListeners, l = c.length - 1; l >= 0; l--) {
                                    var u = c[l];
                                    if (u === e) {
                                        i.js.array.removeAt(c, l), u._setRegistered(!1);
                                        break
                                    }
                                }
                        }
                    }, t.removeListeners = function(e, t) {
                        if (void 0 === t && (t = !1), i.js.isNumber(e) || e instanceof i._BaseNode)
                            if (void 0 !== e._id) {
                                var n = this._nodeListenersMap[e._id];
                                if (n) {
                                    for (var r = i.js.array.copy(n), o = 0; o < r.length; ++o) {
                                        var a = r[o];
                                        this.removeListener(a)
                                    }
                                    delete this._nodeListenersMap[e._id]
                                }
                                for (var s = this._toAddedListeners, c = 0; c < s.length;) {
                                    var l = s[c];
                                    l._getSceneGraphPriority() === e ? (l._setSceneGraphPriority(null), l._setRegistered(!1), s.splice(c, 1)) : ++c
                                }
                                if (!0 === t)
                                    for (var u = e.getChildren(), h = 0; h < u.length; ++h) {
                                        var _ = u[h];
                                        this.removeListeners(_, !0)
                                    }
                            } else e === i.EventListener.TOUCH_ONE_BY_ONE ? this._removeListenersForListenerID(Gm.TOUCH_ONE_BY_ONE) : e === i.EventListener.TOUCH_ALL_AT_ONCE ? this._removeListenersForListenerID(Gm.TOUCH_ALL_AT_ONCE) : e === i.EventListener.MOUSE ? this._removeListenersForListenerID(Gm.MOUSE) : e === i.EventListener.ACCELERATION ? this._removeListenersForListenerID(Gm.ACCELERATION) : e === i.EventListener.KEYBOARD ? this._removeListenersForListenerID(Gm.KEYBOARD) : T(3501);
                        else x(3506)
                    }, t.removeCustomListeners = function(e) {
                        this._removeListenersForListenerID(e)
                    }, t.removeAllListeners = function() {
                        var e = this._listenersMap,
                            t = this._internalCustomListenerIDs;
                        for (var n in e) - 1 === t.indexOf(n) && this._removeListenersForListenerID(n)
                    }, t.setPriority = function(e, t) {
                        if (null != e) {
                            var n = this._listenersMap;
                            for (var i in n) {
                                var r = n[i].getFixedPriorityListeners();
                                if (r && -1 !== r.indexOf(e)) return null != e._getSceneGraphPriority() && T(3502), void(e._getFixedPriority() !== t && (e._setFixedPriority(t), this._setDirty(e._getListenerID(), 1)))
                            }
                        }
                    }, t.setEnabled = function(e) {
                        this._isEnabled = e
                    }, t.isEnabled = function() {
                        return this._isEnabled
                    }, t.dispatchEvent = function(e) {
                        if (this._isEnabled)
                            if (this._updateDirtyFlagForSceneGraph(), this._inDispatch++, e && e.getType) {
                                if (e.getType().startsWith(i.Event.TOUCH)) return this._dispatchTouchEvent(e), void this._inDispatch--;
                                var t = function(e) {
                                    var t = Df,
                                        n = e.type;
                                    return n === t.ACCELERATION ? Gm.ACCELERATION : n === t.KEYBOARD ? Gm.KEYBOARD : n.startsWith(t.MOUSE) ? Gm.MOUSE : (n.startsWith(t.TOUCH) && T(2e3), "")
                                }(e);
                                this._sortEventListeners(t);
                                var n = this._listenersMap[t];
                                null != n && (this._dispatchEventToListeners(n, this._onListenerCallback, e), this._onUpdateListeners(n)), this._inDispatch--
                            } else b(3511)
                    }, t._onListenerCallback = function(e, t) {
                        t.currentTarget = e._target;
                        var n = e.onEvent;
                        return n && n(t), t.isStopped()
                    }, t.dispatchCustomEvent = function(e, t) {
                        var n = new i.Event.EventCustom(e);
                        n.setUserData(t), this.dispatchEvent(n)
                    }, t._setDirtyForNode = function(e) {
                        var t = this._nodeListenersMap[e._id];
                        if (void 0 !== t)
                            for (var n = 0, i = t.length; n < i; n++) {
                                var r = t[n]._getListenerID();
                                this._dirtyListeners[r] || (this._dirtyListeners[r] = !0)
                            }
                        if (e.children.length > 0)
                            for (var o = e.children, a = 0, s = o ? o.length : 0; a < s; a++) this._setDirtyForNode(o[a])
                    }, t._addListener = function(e) {
                        0 === this._inDispatch ? this._forceAddEventListener(e) : this._toAddedListeners.push(e)
                    }, t._forceAddEventListener = function(e) {
                        var t = e._getListenerID(),
                            n = this._listenersMap[t];
                        if (n || (n = new Hm, this._listenersMap[t] = n), n.push(e), 0 === e._getFixedPriority()) {
                            this._setDirty(t, 2);
                            var i = e._getSceneGraphPriority();
                            null === i && T(3507), this._associateNodeAndEventListener(i, e), i.activeInHierarchy && this.resumeTarget(i)
                        } else this._setDirty(t, 1)
                    }, t._getListeners = function(e) {
                        return this._listenersMap[e]
                    }, t._updateDirtyFlagForSceneGraph = function() {
                        var e = this._dirtyListeners;
                        for (var t in e) this._setDirty(t, 2), e[t] = !1
                    }, t._removeAllListenersInVector = function(e) {
                        if (e)
                            for (var t, n = e.length - 1; n >= 0; n--)(t = e[n])._setRegistered(!1), null != t._getSceneGraphPriority() && (this._dissociateNodeAndEventListener(t._getSceneGraphPriority(), t), t._setSceneGraphPriority(null)), 0 === this._inDispatch && i.js.array.removeAt(e, n)
                    }, t._removeListenersForListenerID = function(e) {
                        var t = this._listenersMap[e];
                        if (t) {
                            var n = t.getFixedPriorityListeners(),
                                r = t.getSceneGraphPriorityListeners();
                            this._removeAllListenersInVector(r), this._removeAllListenersInVector(n), delete this._priorityDirtyFlagMap[e], this._inDispatch || (t.clear(), delete this._listenersMap[e])
                        }
                        for (var o = this._toAddedListeners, a = o.length - 1; a >= 0; a--) {
                            var s = o[a];
                            s && s._getListenerID() === e && i.js.array.removeAt(o, a)
                        }
                    }, t._sortEventListeners = function(e) {
                        var t = 0,
                            n = this._priorityDirtyFlagMap;
                        n[e] && (t = n[e]), 0 !== t && (n[e] = 0, 1 & t && this._sortListenersOfFixedPriority(e), 2 & t && i.director.getScene() && this._sortListenersOfSceneGraphPriority(e))
                    }, t._sortListenersOfSceneGraphPriority = function(e) {
                        var t = this._getListeners(e);
                        if (t) {
                            var n = t.getSceneGraphPriorityListeners();
                            if (n && 0 !== n.length) {
                                var i = t.getSceneGraphPriorityListeners();
                                i.forEach((function(e) {
                                    var t = e._getSceneGraphPriority()._uiProps.uiTransformComp;
                                    e._cameraPriority = t.cameraPriority
                                })), i.sort(this._sortEventListenersOfSceneGraphPriorityDes)
                            }
                        }
                    }, t._sortEventListenersOfSceneGraphPriorityDes = function(e, t) {
                        var n = e._getSceneGraphPriority(),
                            i = t._getSceneGraphPriority();
                        if (!(t && i && i._activeInHierarchy && i._uiProps.uiTransformComp)) return -1;
                        if (!(e && n && n._activeInHierarchy && n._uiProps.uiTransformComp)) return 1;
                        var r = n,
                            o = i,
                            a = !1;
                        if (e._cameraPriority !== t._cameraPriority) return t._cameraPriority - e._cameraPriority;
                        for (; r.parent._id !== o.parent._id;) r = null === r.parent.parent ? (a = !0) && i : r.parent, o = null === o.parent.parent ? (a = !0) && n : o.parent;
                        if (r._id === o._id) {
                            if (r._id === i._id) return -1;
                            if (r._id === n._id) return 1
                        }
                        var s = r.getSiblingIndex(),
                            c = o.getSiblingIndex();
                        return a ? s - c : c - s
                    }, t._sortListenersOfFixedPriority = function(e) {
                        var t = this._listenersMap[e];
                        if (t) {
                            var n = t.getFixedPriorityListeners();
                            if (n && 0 !== n.length) {
                                n.sort(this._sortListenersOfFixedPriorityAsc);
                                for (var i = 0, r = n.length; i < r && !(n[i]._getFixedPriority() >= 0);) ++i;
                                t.gt0Index = i
                            }
                        }
                    }, t._sortListenersOfFixedPriorityAsc = function(e, t) {
                        return e._getFixedPriority() - t._getFixedPriority()
                    }, t._onUpdateListeners = function(e) {
                        var t = e.getFixedPriorityListeners(),
                            n = e.getSceneGraphPriorityListeners(),
                            r = this._toRemovedListeners;
                        if (n)
                            for (var o = n.length - 1; o >= 0; o--) {
                                var a = n[o];
                                if (!a._isRegistered()) {
                                    i.js.array.removeAt(n, o);
                                    var s = r.indexOf(a); - 1 !== s && r.splice(s, 1)
                                }
                            }
                        if (t)
                            for (var c = t.length - 1; c >= 0; c--) {
                                var l = t[c];
                                if (!l._isRegistered()) {
                                    i.js.array.removeAt(t, c);
                                    var u = r.indexOf(l); - 1 !== u && r.splice(u, 1)
                                }
                            }
                        n && 0 === n.length && e.clearSceneGraphListeners(), t && 0 === t.length && e.clearFixedListeners()
                    }, t._updateTouchListeners = function() {
                        var e = this._inDispatch;
                        if (I(e > 0, 3508), !(e > 1)) {
                            var t;
                            (t = this._listenersMap[Gm.TOUCH_ONE_BY_ONE]) && this._onUpdateListeners(t), (t = this._listenersMap[Gm.TOUCH_ALL_AT_ONCE]) && this._onUpdateListeners(t), I(1 === e, 3509);
                            var n = this._toAddedListeners;
                            if (0 !== n.length) {
                                for (var i = 0, r = n.length; i < r; i++) this._forceAddEventListener(n[i]);
                                this._toAddedListeners.length = 0
                            }
                            0 !== this._toRemovedListeners.length && this._cleanToRemovedListeners()
                        }
                    }, t._cleanToRemovedListeners = function() {
                        for (var e = this._toRemovedListeners, t = 0; t < e.length; ++t) {
                            var n = e[t],
                                i = this._listenersMap[n._getListenerID()];
                            if (i) {
                                var r = i.getFixedPriorityListeners(),
                                    o = i.getSceneGraphPriorityListeners();
                                if (o) {
                                    var a = o.indexOf(n); - 1 !== a && o.splice(a, 1)
                                }
                                if (r) {
                                    var s = r.indexOf(n); - 1 !== s && r.splice(s, 1)
                                }
                            }
                        }
                        e.length = 0
                    }, t._onTouchEventCallback = function(e, t) {
                        if (!e._isRegistered()) return !1;
                        var n = t.event,
                            i = n.touch;
                        n.currentTarget = e._getSceneGraphPriority();
                        var r = !1,
                            o = -1,
                            a = n.getEventCode();
                        if (a === Om.TOUCH_START) {
                            if (!rt.ENABLE_MULTI_TOUCH && Vm._currentTouch) {
                                var s = Vm._currentTouchListener._node;
                                if (!s || s.activeInHierarchy) return !1
                            }
                            e.onTouchBegan && (r = e.onTouchBegan(i, n)) && e._isRegistered() && !e._isPaused() && (e._claimedTouches.push(i), !rt.ENABLE_MULTI_TOUCH && Vm._currentTouch || (Vm._currentTouch = i), Vm._currentTouchListener = e)
                        } else if (e._claimedTouches.length > 0 && -1 !== (o = e._claimedTouches.indexOf(i))) {
                            if (r = !0, !rt.ENABLE_MULTI_TOUCH && Vm._currentTouch && Vm._currentTouch !== i) return !1;
                            a === Om.TOUCH_MOVE && e.onTouchMoved ? e.onTouchMoved(i, n) : a === Om.TOUCH_END ? (e.onTouchEnded && e.onTouchEnded(i, n), e._isRegistered() && e._claimedTouches.splice(o, 1), (rt.ENABLE_MULTI_TOUCH || Vm._currentTouch === i) && (Vm._currentTouch = null), Vm._currentTouchListener = null) : a === Om.TOUCH_CANCEL && (e.onTouchCancelled && e.onTouchCancelled(i, n), e._isRegistered() && e._claimedTouches.splice(o, 1), (rt.ENABLE_MULTI_TOUCH || Vm._currentTouch === i) && (Vm._currentTouch = null), Vm._currentTouchListener = null)
                        }
                        return n.isStopped() ? (Vm._updateTouchListeners(n), !0) : !!(r && e._isRegistered() && e.swallowTouches) && (t.needsMutableSet && t.touches.splice(i, 1), !0)
                    }, t._dispatchTouchEvent = function(e) {
                        this._sortEventListeners(Gm.TOUCH_ONE_BY_ONE), this._sortEventListeners(Gm.TOUCH_ALL_AT_ONCE);
                        var t = this._getListeners(Gm.TOUCH_ONE_BY_ONE),
                            n = this._getListeners(Gm.TOUCH_ALL_AT_ONCE);
                        if (null !== t || null !== n) {
                            var r = e.getTouches(),
                                o = i.js.array.copy(r),
                                a = {
                                    event: e,
                                    needsMutableSet: t && n,
                                    touches: o,
                                    selTouch: null
                                };
                            if (t)
                                for (var s = 0; s < r.length; ++s) {
                                    var c = r[s];
                                    e.touch = c, e.propagationStopped = e.propagationImmediateStopped = !1, this._dispatchEventToListeners(t, this._onTouchEventCallback, a)
                                }
                            n && o.length > 0 && (this._dispatchEventToListeners(n, this._onTouchesEventCallback, {
                                event: e,
                                touches: o
                            }), e.isStopped()) || this._updateTouchListeners(e)
                        }
                    }, t._onTouchesEventCallback = function(e, t) {
                        if (!e._isRegistered()) return !1;
                        var n = t.event,
                            i = t.touches,
                            r = n.getEventCode();
                        return n.currentTarget = e._getSceneGraphPriority(), r === Om.TOUCH_START && e.onTouchesBegan ? e.onTouchesBegan(i, n) : r === Om.TOUCH_MOVE && e.onTouchesMoved ? e.onTouchesMoved(i, n) : r === Om.TOUCH_END && e.onTouchesEnded ? e.onTouchesEnded(i, n) : r === Om.TOUCH_CANCEL && e.onTouchesCancelled && e.onTouchesCancelled(i, n), !!n.isStopped() && (Vm._updateTouchListeners(n), !0)
                    }, t._associateNodeAndEventListener = function(e, t) {
                        var n = this._nodeListenersMap[e.uuid];
                        n || (n = [], this._nodeListenersMap[e.uuid] = n), n.push(t)
                    }, t._dissociateNodeAndEventListener = function(e, t) {
                        var n = this._nodeListenersMap[e.uuid];
                        n && (i.js.array.remove(n, t), 0 === n.length && delete this._nodeListenersMap[e.uuid])
                    }, t._dispatchEventToListeners = function(e, t, n) {
                        var i = !1,
                            r = e.getFixedPriorityListeners(),
                            o = e.getSceneGraphPriorityListeners(),
                            a = 0;
                        if (r && 0 !== r.length)
                            for (; a < e.gt0Index; ++a) {
                                var s = r[a];
                                if (s.isEnabled() && !s._isPaused() && s._isRegistered() && t(s, n)) {
                                    i = !0;
                                    break
                                }
                            }
                        if (o && !i)
                            for (var c = 0; c < o.length; ++c) {
                                var l = o[c];
                                if (l.isEnabled() && !l._isPaused() && l._isRegistered() && t(l, n)) {
                                    i = !0;
                                    break
                                }
                            }
                        if (r && !i)
                            for (; a < r.length; ++a) {
                                var u = r[a];
                                if (u.isEnabled() && !u._isPaused() && u._isRegistered() && t(u, n)) {
                                    i = !0;
                                    break
                                }
                            }
                    }, t._setDirty = function(e, t) {
                        var n = this._priorityDirtyFlagMap;
                        null == n[e] ? n[e] = t : n[e] |= t
                    }, t._sortNumberAsc = function(e, t) {
                        return e - t
                    }, t._removeListenerInCallback = function(e, t) {
                        if (null == e) return !1;
                        for (var n = e.length - 1; n >= 0; n--) {
                            var r = e[n];
                            if (r._onCustomEvent === t || r.onEvent === t) return r._setRegistered(!1), null != r._getSceneGraphPriority() && (this._dissociateNodeAndEventListener(r._getSceneGraphPriority(), r), r._setSceneGraphPriority(null)), 0 === this._inDispatch ? i.js.array.removeAt(e, n) : this._toRemovedListeners.push(r), !0
                        }
                        return !1
                    }, t._removeListenerInVector = function(e, t) {
                        if (null == e) return !1;
                        for (var n = e.length - 1; n >= 0; n--) {
                            var r = e[n];
                            if (r === t) return r._setRegistered(!1), null != r._getSceneGraphPriority() && (this._dissociateNodeAndEventListener(r._getSceneGraphPriority(), r), r._setSceneGraphPriority(null)), 0 === this._inDispatch ? i.js.array.removeAt(e, n) : this._toRemovedListeners.push(r), !0
                        }
                        return !1
                    }, e
                }(),
                Vm = e("eventManager", new km);
            i.eventManager = Vm, ni.Flags.Destroying;
            var Wm, jm, qm, Xm, Ym, Km, Zm, Qm, Jm, $m = ni.Flags.Destroying,
                eg = ni.Flags.DontDestroy,
                tg = ni.Flags.Deactivating,
                ng = new ue("Node");

            function ig(e) {
                return e ? "string" == typeof e ? Xe(e) : e : (b(3804), null)
            }
            var rg, og, ag, sg, cg, lg, ug, hg, _g, fg, dg, pg = e("BaseNode", A_("cc.BaseNode")((Jm = Qm = function(e) {
                Q(n, e), n._setScene = function(e) {
                    e._updateScene()
                }, n._findComponent = function(e, t) {
                    var n = t,
                        i = e._components;
                    if (n._sealed)
                        for (var r = 0; r < i.length; ++r) {
                            var o = i[r];
                            if (o.constructor === t) return o
                        } else
                            for (var a = 0; a < i.length; ++a) {
                                var s = i[a];
                                if (s instanceof t) return s
                            }
                    return null
                }, n._findComponents = function(e, t, n) {
                    var i = t,
                        r = e._components;
                    if (i._sealed)
                        for (var o = 0; o < r.length; ++o) {
                            var a = r[o];
                            a.constructor === t && n.push(a)
                        } else
                            for (var s = 0; s < r.length; ++s) {
                                var c = r[s];
                                c instanceof t && n.push(c)
                            }
                }, n._findChildComponent = function(e, t) {
                    for (var i = 0; i < e.length; ++i) {
                        var r = e[i],
                            o = n._findComponent(r, t);
                        if (o) return o;
                        if (r._children.length > 0 && (o = n._findChildComponent(r._children, t))) return o
                    }
                    return null
                }, n._findChildComponents = function(e, t, i) {
                    for (var r = 0; r < e.length; ++r) {
                        var o = e[r];
                        n._findComponents(o, t, i), o._children.length > 0 && n._findChildComponents(o._children, t, i)
                    }
                };
                var t = n.prototype;

                function n(t) {
                    var n;
                    return ne(n = e.call(this, t) || this, "_parent", qm, $(n)), ne(n, "_children", Xm, $(n)), ne(n, "_active", Ym, $(n)), ne(n, "_components", Km, $(n)), ne(n, "_prefab", Zm, $(n)), n._scene = null, n._activeInHierarchy = !1, n._id = ng.getNewId(), n._name = void 0, n._eventProcessor = new i.NodeEventProcessor($(n)), n._eventMask = 0, n._siblingIndex = 0, n._originalSceneId = "", n._registerIfAttached = void 0, n._name = void 0 !== t ? t : "New Node", n
                }
                return t._updateScene = function() {
                    null == this._parent ? p("Node %s(%s) has not attached to a scene.", this.name, this.uuid) : this._scene = this._parent._scene
                }, t.attr = function(e) {
                    Ne(this, e)
                }, t.getParent = function() {
                    return this._parent
                }, t.setParent = function(e, t) {
                    if (void 0 === t && (t = !1), this._parent !== e) {
                        var n = this._parent,
                            i = e;
                        if (this._parent = i, this._siblingIndex = 0, this._onSetParent(n, t), this.emit && this.emit(Om.PARENT_CHANGED, n), n && !(n._objFlags & $m)) {
                            var r = n._children.indexOf(this);
                            n._children.splice(r, 1), n._updateSiblingIndex(), n.emit && n.emit(Om.CHILD_REMOVED, this)
                        }
                        i && (i._children.push(this), this._siblingIndex = i._children.length - 1, i.emit && i.emit(Om.CHILD_ADDED, this)), this._onHierarchyChanged(n)
                    }
                }, t.getChildByUuid = function(e) {
                    if (!e) return f("Invalid uuid"), null;
                    for (var t = this._children, n = 0, i = t.length; n < i; n++)
                        if (t[n]._id === e) return t[n];
                    return null
                }, t.getChildByName = function(e) {
                    if (!e) return f("Invalid name"), null;
                    for (var t = this._children, n = 0, i = t.length; n < i; n++)
                        if (t[n]._name === e) return t[n];
                    return null
                }, t.getChildByPath = function(e) {
                    for (var t = e.split("/"), n = this, i = function(e) {
                            var i = t[e];
                            if (0 === i.length) return "continue";
                            var r = n.children.find((function(e) {
                                return e.name === i
                            }));
                            if (!r) return {
                                v: null
                            };
                            n = r
                        }, r = 0; r < t.length; ++r) {
                        var o = i(r);
                        if ("continue" !== o && "object" == typeof o) return o.v
                    }
                    return n
                }, t.addChild = function(e) {
                    e.setParent(this)
                }, t.insertChild = function(e, t) {
                    e.parent = this, e.setSiblingIndex(t)
                }, t.getSiblingIndex = function() {
                    return this._siblingIndex
                }, t.setSiblingIndex = function(e) {
                    if (this._parent)
                        if (this._parent._objFlags & tg) b(3821);
                        else {
                            var t = this._parent._children;
                            e = -1 !== e ? e : t.length - 1;
                            var n = t.indexOf(this);
                            e !== n && (t.splice(n, 1), e < t.length ? t.splice(e, 0, this) : t.push(this), this._parent._updateSiblingIndex(), this._onSiblingIndexChanged && this._onSiblingIndexChanged(e))
                        }
                }, t.walk = function(e, t) {
                    var i = 1,
                        r = null,
                        o = null,
                        a = 0,
                        s = n._stacks[n._stackId];
                    s || (s = [], n._stacks.push(s)), n._stackId++, s.length = 0, s[0] = this;
                    for (var c = null, l = !1; i;)
                        if (o = s[--i])
                            if (!l && e ? e(o) : l && t && t(o), s[i] = null, l) {
                                if (c === this._parent) break;
                                if (l = !1, r)
                                    if (r[++a]) s[i] = r[a], i++;
                                    else if (c && (s[i] = c, i++, l = !0, c._parent ? (a = (r = c._parent._children).indexOf(c), c = c._parent) : (c = null, r = null), a < 0)) break
                            } else o._children.length > 0 ? (c = o, r = o._children, a = 0, s[i] = r[a], i++) : (s[i] = o, i++, l = !0);
                    s.length = 0, n._stackId--
                }, t.removeFromParent = function() {
                    this._parent && this._parent.removeChild(this)
                }, t.removeChild = function(e) {
                    this._children.indexOf(e) > -1 && (e.parent = null)
                }, t.removeAllChildren = function() {
                    for (var e = this._children, t = e.length - 1; t >= 0; t--) {
                        var n = e[t];
                        n && (n.parent = null)
                    }
                    this._children.length = 0
                }, t.isChildOf = function(e) {
                    var t = this;
                    do {
                        if (t === e) return !0;
                        t = t._parent
                    } while (t);
                    return !1
                }, t.getComponent = function(e) {
                    var t = ig(e);
                    return t ? n._findComponent(this, t) : null
                }, t.getComponents = function(e) {
                    var t = ig(e),
                        i = [];
                    return t && n._findComponents(this, t, i), i
                }, t.getComponentInChildren = function(e) {
                    var t = ig(e);
                    return t ? n._findChildComponent(this._children, t) : null
                }, t.getComponentsInChildren = function(e) {
                    var t = ig(e),
                        i = [];
                    return t && (n._findComponents(this, t, i), n._findChildComponents(this._children, t, i)), i
                }, t.addComponent = function(e) {
                    var t;
                    if ("string" == typeof e) {
                        if (!(t = Xe(e))) throw i._RF.peek() && b(3808, e), TypeError(P(3807, e))
                    } else {
                        if (!e) throw TypeError(P(3804));
                        t = e
                    }
                    if ("function" != typeof t) throw TypeError(P(3809));
                    if (!Be(t, i.Component)) throw TypeError(P(3810));
                    var n = t._requireComponent;
                    n && !this.getComponent(n) && this.addComponent(n);
                    var r = new t;
                    return r.node = this, this._components.push(r), this._activeInHierarchy && i.director._nodeActivator.activateComp(r), r
                }, t.removeComponent = function(e) {
                    if (e) {
                        var t = null;
                        (t = e instanceof Jd ? e : this.getComponent(e)) && t.destroy()
                    } else b(3813)
                }, t.on = function(e, t, n, i) {
                    switch (void 0 === i && (i = !1), e) {
                        case Om.TRANSFORM_CHANGED:
                            this._eventMask |= 1
                    }
                    this._eventProcessor.on(e, t, n, i)
                }, t.off = function(e, t, n, i) {
                    if (void 0 === i && (i = !1), this._eventProcessor.off(e, t, n, i), !this._eventProcessor.hasEventListener(e)) switch (e) {
                        case Om.TRANSFORM_CHANGED:
                            this._eventMask &= -2
                    }
                }, t.once = function(e, t, n, i) {
                    this._eventProcessor.once(e, t, n, i)
                }, t.emit = function(e, t, n, i, r, o) {
                    this._eventProcessor.emit(e, t, n, i, r, o)
                }, t.dispatchEvent = function(e) {
                    this._eventProcessor.dispatchEvent(e)
                }, t.hasEventListener = function(e, t, n) {
                    return this._eventProcessor.hasEventListener(e, t, n)
                }, t.targetOff = function(e) {
                    this._eventProcessor.targetOff(e), 1 & this._eventMask && !this._eventProcessor.hasEventListener(Om.TRANSFORM_CHANGED) && (this._eventMask &= -2)
                }, t.destroy = function() {
                    return !!e.prototype.destroy.call(this) && (this.active = !1, !0)
                }, t.destroyAllChildren = function() {
                    for (var e = this._children, t = 0; t < e.length; ++t) e[t].destroy()
                }, t._removeComponent = function(e) {
                    if (e) {
                        if (!(this._objFlags & $m)) {
                            var t = this._components.indexOf(e); - 1 !== t ? this._components.splice(t, 1) : e.node !== this && b(3815)
                        }
                    } else b(3814)
                }, t._updateSiblingIndex = function() {
                    for (var e = 0; e < this._children.length; ++e) this._children[e]._siblingIndex = e;
                    this.emit(Om.SIBLING_ORDER_CHANGED)
                }, t._onSetParent = function(e) {
                    this._parent && (null != e && e._scene === this._parent._scene || null == this._parent._scene || this.walk(n._setScene))
                }, t._onPostActivated = function() {}, t._onBatchCreated = function() {
                    this._parent && (this._siblingIndex = this._parent.children.indexOf(this))
                }, t._onPreDestroy = function() {
                    this._onPreDestroyBase()
                }, t._onHierarchyChanged = function(e) {
                    return this._onHierarchyChangedBase(e)
                }, t._instantiate = function(e, t) {
                    return e || (e = i.instantiate._clone(this, this)), e._prefab, e._parent = null, e._onBatchCreated(t), e
                }, t._onHierarchyChangedBase = function() {
                    var e = this._parent;
                    !this._persistNode || e instanceof i.Scene || i.game.removePersistRootNode(this);
                    var t = this._active && !(!e || !e._activeInHierarchy);
                    this._activeInHierarchy !== t && i.director._nodeActivator.activateNode(this, t)
                }, t._onPreDestroyBase = function() {
                    this._objFlags |= $m;
                    var e = this._parent,
                        t = !!e && 0 != (e._objFlags & $m);
                    if (this._persistNode && i.game.removePersistRootNode(this), !t && e) {
                        this.emit(Om.PARENT_CHANGED, this);
                        var n = e._children.indexOf(this);
                        e._children.splice(n, 1), this._siblingIndex = 0, e._updateSiblingIndex(), e.emit && e.emit(Om.CHILD_REMOVED, this)
                    }
                    this.emit(Om.NODE_DESTROYED, this), this._eventProcessor.destroy();
                    for (var r = this._children, o = 0; o < r.length; ++o) r[o]._destroyImmediate();
                    for (var a = this._components, s = 0; s < a.length; ++s) a[s]._destroyImmediate();
                    return t
                }, K(n, [{
                    key: "components",
                    get: function() {
                        return this._components
                    }
                }, {
                    key: "_persistNode",
                    get: function() {
                        return (this._objFlags & eg) > 0
                    },
                    set: function(e) {
                        e ? this._objFlags |= eg : this._objFlags &= ~eg
                    }
                }, {
                    key: "name",
                    get: function() {
                        return this._name
                    },
                    set: function(e) {
                        this._name = e
                    }
                }, {
                    key: "uuid",
                    get: function() {
                        return this._id
                    }
                }, {
                    key: "children",
                    get: function() {
                        return this._children
                    }
                }, {
                    key: "active",
                    get: function() {
                        return this._active
                    },
                    set: function(e) {
                        if (this._active !== e) {
                            this._active = e;
                            var t = this._parent;
                            t && t._activeInHierarchy && i.director._nodeActivator.activateNode(this, e)
                        }
                    }
                }, {
                    key: "activeInHierarchy",
                    get: function() {
                        return this._activeInHierarchy
                    }
                }, {
                    key: "parent",
                    get: function() {
                        return this._parent
                    },
                    set: function(e) {
                        this.setParent(e)
                    }
                }, {
                    key: "scene",
                    get: function() {
                        return this._scene
                    }
                }, {
                    key: "eventProcessor",
                    get: function() {
                        return this._eventProcessor
                    }
                }]), n
            }(ni), Qm.idGenerator = ng, Qm._stacks = [
                []
            ], Qm._stackId = 0, ie((jm = Jm).prototype, "_persistNode", [R_], Object.getOwnPropertyDescriptor(jm.prototype, "_persistNode"), jm.prototype), ie(jm.prototype, "name", [F_], Object.getOwnPropertyDescriptor(jm.prototype, "name"), jm.prototype), ie(jm.prototype, "children", [F_], Object.getOwnPropertyDescriptor(jm.prototype, "children"), jm.prototype), ie(jm.prototype, "active", [F_], Object.getOwnPropertyDescriptor(jm.prototype, "active"), jm.prototype), ie(jm.prototype, "activeInHierarchy", [F_], Object.getOwnPropertyDescriptor(jm.prototype, "activeInHierarchy"), jm.prototype), ie(jm.prototype, "parent", [F_], Object.getOwnPropertyDescriptor(jm.prototype, "parent"), jm.prototype), qm = ie(jm.prototype, "_parent", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return null
                }
            }), Xm = ie(jm.prototype, "_children", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return []
                }
            }), Ym = ie(jm.prototype, "_active", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return !0
                }
            }), Km = ie(jm.prototype, "_components", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return []
                }
            }), Zm = ie(jm.prototype, "_prefab", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return null
                }
            }), Wm = jm)) || Wm);

            function mg(e) {
                var t = e._prefab;
                if (t && t.instance) {
                    if (!t.asset) return b(3701, e.name), void(t.instance = void 0);
                    var n = e._objFlags,
                        r = e._parent,
                        o = e._id,
                        a = e._prefab;
                    i.game._isCloning = !0, t.asset._doInstantiate(e), i.game._isCloning = !1, e._objFlags = n, e._parent = r, e._id = o, e._prefab && (e._prefab.instance = null == a ? void 0 : a.instance)
                }
            }

            function gg(e, t, n) {
                var i;
                if (t) {
                    var r = t,
                        o = null === (i = e._prefab) || void 0 === i ? void 0 : i.instance;
                    !n && o && (t[o.fileId] = {}, r = t[o.fileId]);
                    var a = e._prefab;
                    a && (r[a.fileId] = e);
                    for (var s = e.components, c = 0; c < s.length; c++) {
                        var l = s[c];
                        l.__prefab && (r[l.__prefab.fileId] = l)
                    }
                    for (var u = 0; u < e.children.length; u++) gg(e.children[u], r, !1)
                }
            }

            function vg(e, t) {
                if (!e) return null;
                for (var n = t, i = 0; i < e.length; i++) {
                    if (!n) return null;
                    n = n[e[i]]
                }
                return n
            }

            function yg(e, t, n) {
                if (t)
                    for (var i = 0; i < t.length; i++) {
                        var r = t[i];
                        if (r && r.targetInfo) {
                            var o = vg(r.targetInfo.localID, n);
                            if (!o) continue;
                            var a = n,
                                s = r.targetInfo.localID;
                            if (s.length > 0)
                                for (var c = 0; c < s.length - 1; c++) a = a[s[c]];
                            if (r.nodes)
                                for (var l = 0; l < r.nodes.length; l++) {
                                    var u = r.nodes[l];
                                    u && (o._children.push(u), u._parent = o, gg(u, a, !1), u._siblingIndex = o._children.length - 1, u._onBatchCreated(!1))
                                }
                        }
                    }
            }

            function Sg(e, t, n) {
                if (t)
                    for (var i = 0; i < t.length; i++) {
                        var r = t[i];
                        if (r && r.targetInfo) {
                            var o = vg(r.targetInfo.localID, n);
                            if (!o) continue;
                            if (r.components)
                                for (var a = 0; a < r.components.length; a++) {
                                    var s = r.components[a];
                                    s && (s.node = o, o._components.push(s))
                                }
                        }
                    }
            }

            function Eg(e, t, n) {
                if (t)
                    for (var i = 0; i < t.length; i++) {
                        var r = t[i];
                        if (r) {
                            var o = vg(r.localID, n);
                            if (!o || !o.node) continue;
                            var a = o.node.components.indexOf(o);
                            a >= 0 && o.node._components.splice(a, 1)
                        }
                    }
            }

            function Tg(e, t, n) {
                if (!(t.length <= 0))
                    for (var i = null, r = 0; r < t.length; r++) {
                        var o = t[r];
                        if (o && o.targetInfo) {
                            if (!(i = vg(o.targetInfo.localID, n))) continue;
                            var a = i,
                                s = o.propertyPath.slice();
                            if (s.length > 0) {
                                var c = s.pop();
                                if (!c) continue;
                                for (var l = 0; l < s.length && (a = a[s[l]]); l++);
                                if (!a) continue;
                                if (Array.isArray(a))
                                    if ("length" === c) a[c] = o.value;
                                    else {
                                        var u = Number.parseInt(c);
                                        Number.isInteger(u) && u < a.length && (a[c] = o.value)
                                    }
                                else a[c] = o.value
                            }
                        }
                    }
            }

            function Ag(e) {
                var t, n = null === (t = e._prefab) || void 0 === t ? void 0 : t.targetOverrides;
                if (n)
                    for (var i = 0; i < n.length; i++) {
                        var r, o, a = n[i],
                            s = a.source,
                            c = a.sourceInfo;
                        if (c) {
                            var l, u, h = null === (l = a.source) || void 0 === l || null === (u = l._prefab) || void 0 === u ? void 0 : u.instance;
                            h && h.targetMap && (s = vg(c.localID, h.targetMap))
                        }
                        if (s) {
                            var _, f = a.targetInfo;
                            if (f) {
                                var d = null === (r = a.target) || void 0 === r || null === (o = r._prefab) || void 0 === o ? void 0 : o.instance;
                                if (d && d.targetMap && (_ = vg(f.localID, d.targetMap))) {
                                    var p = a.propertyPath.slice(),
                                        m = s;
                                    if (p.length > 0) {
                                        var g = p.pop();
                                        if (!g) return;
                                        for (var v = 0; v < p.length && (m = m[p[v]]); v++);
                                        if (!m) continue;
                                        m[g] = _
                                    }
                                }
                            }
                        }
                    }
            }
            i._BaseNode = pg;
            var xg, Cg, bg, Rg, wg, Ig, Pg, Og, Dg, Ng, Mg, Lg, Bg, Fg, zg, Ug, Gg, Hg, kg, Vg, Wg, jg, qg, Xg, Yg, Kg, Zg, Qg, Jg, $g, ev, tv, nv, iv, rv, ov, av, sv, cv, lv, uv, hv, _v, fv, dv, pv, mv, gv, vv, yv, Sv, Ev, Tv, Av, xv, Cv, bv, Rv, wv, Iv, Pv, Ov, Dv, Nv, Mv, Lv, Bv, Fv, zv, Uv = new En,
                Gv = new wn,
                Hv = new wn,
                kv = new Array(10),
                Vv = new wn,
                Wv = new Cn,
                jv = new Cn,
                qv = new Bn,
                Xv = new Map,
                Yv = e("Node", (rg = A_("cc.Node"), og = ef(En), rg((dg = fg = function(e) {
                    function t(t) {
                        var n;
                        return (n = e.call(this, t) || this)._uiProps = new Dm($(n)), n._static = !1, n._pos = new En, n._rot = new wn, n._scale = new En(1, 1, 1), n._mat = new Bn, ne(n, "_lpos", cg, $(n)), ne(n, "_lrot", lg, $(n)), ne(n, "_lscale", ug, $(n)), ne(n, "_layer", hg, $(n)), ne(n, "_euler", _g, $(n)), n._dirtyFlags = r_.NONE, n._eulerDirty = !1, n._poolHandle = 0, n._poolHandle = to.alloc(), to.set(n._poolHandle, Zr.LAYER, n._layer), n
                    }
                    Q(t, e), t.isNode = function(e) {
                        return e instanceof t && (e.constructor === t || !(e instanceof i.Scene))
                    };
                    var n = t.prototype;
                    return n.destroy = function() {
                        return this._poolHandle && (to.free(this._poolHandle), this._poolHandle = 0), e.prototype.destroy.call(this)
                    }, n.setParent = function(t, n) {
                        void 0 === n && (n = !1), n && this.updateWorldTransform(), e.prototype.setParent.call(this, t, n)
                    }, n._onSetParent = function(t, n) {
                        if (e.prototype._onSetParent.call(this, t, n), n) {
                            var i = this._parent;
                            i ? (i.updateWorldTransform(), Bn.multiply(qv, Bn.invert(qv, i._mat), this._mat), Bn.toRTS(qv, this._lrot, this._lpos, this._lscale)) : (En.copy(this._lpos, this._pos), wn.copy(this._lrot, this._rot), En.copy(this._lscale, this._scale)), this._eulerDirty = !0
                        }
                        this.invalidateChildren(r_.TRS)
                    }, n._onHierarchyChanged = function(t) {
                        this.eventProcessor.reattach(), e.prototype._onHierarchyChangedBase.call(this, t)
                    }, n._onBatchCreated = function(e) {
                        var t;
                        to.set(this._poolHandle, Zr.LAYER, this._layer), to.setVec3(this._poolHandle, Zr.WORLD_SCALE, this._scale);
                        var n = null === (t = this._prefab) || void 0 === t ? void 0 : t.instance;
                        !e && n && mg(this), this.hasChangedFlags = r_.TRS, this._dirtyFlags = r_.TRS;
                        for (var i = this._children.length, r = 0; r < i; ++r) this._children[r]._siblingIndex = r, this._children[r]._onBatchCreated(e);
                        if (!e && n) {
                            var o = {};
                            n.targetMap = o, gg(this, o, !0), yg(0, n.mountedChildren, o), Eg(0, n.removedComponents, o), Sg(0, n.mountedComponents, o), Tg(0, n.propertyOverrides, o)
                        }
                        Ag(this)
                    }, n._onBeforeSerialize = function() {
                        this.eulerAngles
                    }, n._onPostActivated = function(e) {
                        e ? (Vm.resumeTarget(this), this.invalidateChildren(r_.TRS)) : Vm.pauseTarget(this)
                    }, n.translate = function(e, t) {
                        var n = t || i_.LOCAL;
                        if (n === i_.LOCAL) En.transformQuat(Uv, e, this._lrot), this._lpos.x += Uv.x, this._lpos.y += Uv.y, this._lpos.z += Uv.z;
                        else if (n === i_.WORLD)
                            if (this._parent) {
                                wn.invert(Gv, this._parent.worldRotation), En.transformQuat(Uv, e, Gv);
                                var i = this.worldScale;
                                this._lpos.x += Uv.x / i.x, this._lpos.y += Uv.y / i.y, this._lpos.z += Uv.z / i.z
                            } else this._lpos.x += e.x, this._lpos.y += e.y, this._lpos.z += e.z;
                        this.invalidateChildren(r_.POSITION), 1 & this._eventMask && this.emit(Om.TRANSFORM_CHANGED, r_.POSITION), to.setVec3(this._poolHandle, Zr.WORLD_POSITION, this.worldPosition)
                    }, n.rotate = function(e, t) {
                        var n = t || i_.LOCAL;
                        if (wn.normalize(Gv, e), n === i_.LOCAL) wn.multiply(this._lrot, this._lrot, Gv);
                        else if (n === i_.WORLD) {
                            var i = this.worldRotation;
                            wn.multiply(Hv, Gv, i), wn.invert(Gv, i), wn.multiply(Hv, Gv, Hv), wn.multiply(this._lrot, this._lrot, Hv)
                        }
                        this._eulerDirty = !0, this.invalidateChildren(r_.ROTATION), 1 & this._eventMask && this.emit(Om.TRANSFORM_CHANGED, r_.ROTATION), to.setVec4(this._poolHandle, Zr.WORLD_ROTATION, this.worldRotation)
                    }, n.lookAt = function(e, t) {
                        this.getWorldPosition(Uv), En.subtract(Uv, Uv, e), En.normalize(Uv, Uv), wn.fromViewUp(Gv, Uv, t), this.setWorldRotation(Gv)
                    }, n.invalidateChildren = function(e) {
                        var t = this.hasChangedFlags;
                        if ((this._dirtyFlags & t & e) !== e) {
                            this._dirtyFlags |= e, this.hasChangedFlags = t | e;
                            for (var n = e | r_.POSITION, i = this._children.length, r = 0; r < i; ++r) {
                                var o = this._children[r];
                                o.isValid && o.invalidateChildren(n)
                            }
                        }
                    }, n.updateWorldTransform = function() {
                        if (this._dirtyFlags) {
                            for (var e, t = this, n = 0; t && t._dirtyFlags;) kv[n++] = t, t = t._parent;
                            for (var i = 0; n;) i |= (e = kv[--n])._dirtyFlags, t ? (i & r_.POSITION && (En.transformMat4(e._pos, e._lpos, t._mat), e._mat.m12 = e._pos.x, e._mat.m13 = e._pos.y, e._mat.m14 = e._pos.z, to.setVec3(e._poolHandle, Zr.WORLD_POSITION, e._pos)), i & r_.RS && (Bn.fromRTS(e._mat, e._lrot, e._lpos, e._lscale), Bn.multiply(e._mat, t._mat, e._mat), i & r_.ROTATION && (wn.multiply(e._rot, t._rot, e._lrot), to.setVec4(e._poolHandle, Zr.WORLD_ROTATION, e._rot)), Cn.fromQuat(Wv, wn.conjugate(Vv, e._rot)), Cn.multiplyMat4(Wv, Wv, e._mat), e._scale.x = Wv.m00, e._scale.y = Wv.m04, e._scale.z = Wv.m08, to.setVec3(e._poolHandle, Zr.WORLD_SCALE, e._scale))) : (i & r_.POSITION && (En.copy(e._pos, e._lpos), e._mat.m12 = e._pos.x, e._mat.m13 = e._pos.y, e._mat.m14 = e._pos.z, to.setVec3(e._poolHandle, Zr.WORLD_POSITION, e._pos)), i & r_.RS && (i & r_.ROTATION && (wn.copy(e._rot, e._lrot), to.setVec4(e._poolHandle, Zr.WORLD_ROTATION, e._rot)), i & r_.SCALE && (En.copy(e._scale, e._lscale), to.setVec3(e._poolHandle, Zr.WORLD_SCALE, e._scale), Bn.fromRTS(e._mat, e._rot, e._pos, e._scale)))), i !== r_.NONE && to.setMat4(e._poolHandle, Zr.WORLD_MATRIX, e._mat), e._dirtyFlags = r_.NONE, t = e
                        }
                    }, n.setPosition = function(e, t, n) {
                        void 0 === t && void 0 === n ? En.copy(this._lpos, e) : void 0 === n ? En.set(this._lpos, e, t, this._lpos.z) : En.set(this._lpos, e, t, n), this.invalidateChildren(r_.POSITION), 1 & this._eventMask && this.emit(Om.TRANSFORM_CHANGED, r_.POSITION)
                    }, n.getPosition = function(e) {
                        return e ? En.set(e, this._lpos.x, this._lpos.y, this._lpos.z) : En.copy(new En, this._lpos)
                    }, n.setRotation = function(e, t, n, i) {
                        void 0 === t || void 0 === n || void 0 === i ? wn.copy(this._lrot, e) : wn.set(this._lrot, e, t, n, i), this._eulerDirty = !0, this.invalidateChildren(r_.ROTATION), 1 & this._eventMask && this.emit(Om.TRANSFORM_CHANGED, r_.ROTATION)
                    }, n.setRotationFromEuler = function(e, t, n) {
                        var i = void 0 === n ? this._euler.z : n;
                        void 0 === t ? (En.copy(this._euler, e), wn.fromEuler(this._lrot, e.x, e.y, e.z)) : (En.set(this._euler, e, t, i), wn.fromEuler(this._lrot, e, t, i)), this._eulerDirty = !1, this.invalidateChildren(r_.ROTATION), 1 & this._eventMask && this.emit(Om.TRANSFORM_CHANGED, r_.ROTATION)
                    }, n.getRotation = function(e) {
                        return e ? wn.set(e, this._lrot.x, this._lrot.y, this._lrot.z, this._lrot.w) : wn.copy(new wn, this._lrot)
                    }, n.setScale = function(e, t, n) {
                        void 0 === t && void 0 === n ? En.copy(this._lscale, e) : void 0 === n ? En.set(this._lscale, e, t, this._lscale.z) : En.set(this._lscale, e, t, n), this.invalidateChildren(r_.SCALE), 1 & this._eventMask && this.emit(Om.TRANSFORM_CHANGED, r_.SCALE)
                    }, n.getScale = function(e) {
                        return e ? En.set(e, this._lscale.x, this._lscale.y, this._lscale.z) : En.copy(new En, this._lscale)
                    }, n.inverseTransformPoint = function(e, t) {
                        En.copy(e, t);
                        for (var n = this, i = 0; n._parent;) kv[i++] = n, n = n._parent;
                        for (; i >= 0;) En.transformInverseRTS(e, e, n._lrot, n._lpos, n._lscale), n = kv[--i];
                        return e
                    }, n.setWorldPosition = function(e, t, n) {
                        void 0 === t || void 0 === n ? En.copy(this._pos, e) : En.set(this._pos, e, t, n), to.setVec3(this._poolHandle, Zr.WORLD_POSITION, this._pos);
                        var i = this._parent,
                            r = this._lpos;
                        i ? (i.updateWorldTransform(), En.transformMat4(r, this._pos, Bn.invert(qv, i._mat))) : En.copy(r, this._pos), this.invalidateChildren(r_.POSITION), 1 & this._eventMask && this.emit(Om.TRANSFORM_CHANGED, r_.POSITION)
                    }, n.getWorldPosition = function(e) {
                        return this.updateWorldTransform(), e ? En.copy(e, this._pos) : En.copy(new En, this._pos)
                    }, n.setWorldRotation = function(e, t, n, i) {
                        void 0 === t || void 0 === n || void 0 === i ? wn.copy(this._rot, e) : wn.set(this._rot, e, t, n, i), to.setVec4(this._poolHandle, Zr.WORLD_ROTATION, this._rot), this._parent ? (this._parent.updateWorldTransform(), wn.multiply(this._lrot, wn.conjugate(this._lrot, this._parent._rot), this._rot)) : wn.copy(this._lrot, this._rot), this._eulerDirty = !0, this.invalidateChildren(r_.ROTATION), 1 & this._eventMask && this.emit(Om.TRANSFORM_CHANGED, r_.ROTATION)
                    }, n.setWorldRotationFromEuler = function(e, t, n) {
                        wn.fromEuler(this._rot, e, t, n), this._parent ? (this._parent.updateWorldTransform(), wn.multiply(this._lrot, wn.conjugate(this._lrot, this._parent._rot), this._rot)) : wn.copy(this._lrot, this._rot), this._eulerDirty = !0, this.invalidateChildren(r_.ROTATION), 1 & this._eventMask && this.emit(Om.TRANSFORM_CHANGED, r_.ROTATION)
                    }, n.getWorldRotation = function(e) {
                        return this.updateWorldTransform(), e ? wn.copy(e, this._rot) : wn.copy(new wn, this._rot)
                    }, n.setWorldScale = function(e, t, n) {
                        void 0 === t || void 0 === n ? En.copy(this._scale, e) : En.set(this._scale, e, t, n), to.setVec3(this._poolHandle, Zr.WORLD_SCALE, this._scale);
                        var i = this._parent;
                        i ? (i.updateWorldTransform(), Cn.fromQuat(Wv, wn.conjugate(Vv, i._rot)), Cn.multiplyMat4(Wv, Wv, i._mat), jv.m00 = this._scale.x, jv.m04 = this._scale.y, jv.m08 = this._scale.z, Cn.multiply(Wv, jv, Cn.invert(Wv, Wv)), this._lscale.x = En.set(Uv, Wv.m00, Wv.m01, Wv.m02).length(), this._lscale.y = En.set(Uv, Wv.m03, Wv.m04, Wv.m05).length(), this._lscale.z = En.set(Uv, Wv.m06, Wv.m07, Wv.m08).length()) : En.copy(this._lscale, this._scale), this.invalidateChildren(r_.SCALE), 1 & this._eventMask && this.emit(Om.TRANSFORM_CHANGED, r_.SCALE)
                    }, n.getWorldScale = function(e) {
                        return this.updateWorldTransform(), e ? En.copy(e, this._scale) : En.copy(new En, this._scale)
                    }, n.getWorldMatrix = function(e) {
                        this.updateWorldTransform();
                        var t = e || new Bn;
                        return Bn.copy(t, this._mat)
                    }, n.getWorldRS = function(e) {
                        this.updateWorldTransform();
                        var t = e || new Bn;
                        return Bn.copy(t, this._mat), t.m12 = 0, t.m13 = 0, t.m14 = 0, t
                    }, n.getWorldRT = function(e) {
                        this.updateWorldTransform();
                        var t = e || new Bn;
                        return Bn.fromRT(t, this._rot, this._pos)
                    }, n.setRTS = function(e, t, n) {
                        var i = 0;
                        e && (i |= r_.ROTATION, void 0 !== e.w ? (wn.copy(this._lrot, e), this._eulerDirty = !0) : (En.copy(this._euler, e), wn.fromEuler(this._lrot, e.x, e.y, e.z), this._eulerDirty = !1)), t && (En.copy(this._lpos, t), i |= r_.POSITION), n && (En.copy(this._lscale, n), i |= r_.SCALE), i && (this.invalidateChildren(i), 1 & this._eventMask && this.emit(Om.TRANSFORM_CHANGED, i))
                    }, n.pauseSystemEvents = function(e) {
                        Vm.pauseTarget(this, e)
                    }, n.resumeSystemEvents = function(e) {
                        Vm.resumeTarget(this, e)
                    }, t.clearBooks = function() {
                        Xv.clear()
                    }, n.syncToNativeTransform = function() {
                        var e = this.hasChangedFlags;
                        e && (e & r_.POSITION && to.setVec3(this._poolHandle, Zr.WORLD_POSITION, this.worldPosition), e & r_.ROTATION && to.setVec3(this._poolHandle, Zr.WORLD_ROTATION, this.worldRotation), e & r_.SCALE && to.setVec3(this._poolHandle, Zr.WORLD_SCALE, this.worldScale))
                    }, n.syncFromNativeTransform = function() {
                        var e = to.get(this._poolHandle, Zr.FLAGS_CHANGED);
                        e && (e & r_.POSITION && (to.getVec3(this._poolHandle, Zr.WORLD_POSITION, Uv), this.setWorldPosition(Uv)), e & r_.ROTATION && (to.getVec4(this._poolHandle, Zr.WORLD_ROTATION, Gv), this.setWorldRotation(Gv)), e & r_.SCALE && (to.getVec3(this._poolHandle, Zr.WORLD_SCALE, Uv), this.setWorldScale(Uv)))
                    }, K(t, [{
                        key: "handle",
                        get: function() {
                            return this._poolHandle
                        }
                    }, {
                        key: "position",
                        get: function() {
                            return this._lpos
                        },
                        set: function(e) {
                            this.setPosition(e)
                        }
                    }, {
                        key: "worldPosition",
                        get: function() {
                            return this.updateWorldTransform(), this._pos
                        },
                        set: function(e) {
                            this.setWorldPosition(e)
                        }
                    }, {
                        key: "rotation",
                        get: function() {
                            return this._lrot
                        },
                        set: function(e) {
                            this.setRotation(e)
                        }
                    }, {
                        key: "eulerAngles",
                        get: function() {
                            return this._eulerDirty && (wn.toEuler(this._euler, this._lrot), this._eulerDirty = !1), this._euler
                        },
                        set: function(e) {
                            this.setRotationFromEuler(e.x, e.y, e.z)
                        }
                    }, {
                        key: "angle",
                        get: function() {
                            return this._euler.z
                        },
                        set: function(e) {
                            En.set(this._euler, 0, 0, e), wn.fromAngleZ(this._lrot, e), this._eulerDirty = !1, this.invalidateChildren(r_.ROTATION), 1 & this._eventMask && this.emit(Om.TRANSFORM_CHANGED, r_.ROTATION)
                        }
                    }, {
                        key: "worldRotation",
                        get: function() {
                            return this.updateWorldTransform(), this._rot
                        },
                        set: function(e) {
                            this.setWorldRotation(e)
                        }
                    }, {
                        key: "scale",
                        get: function() {
                            return this._lscale
                        },
                        set: function(e) {
                            this.setScale(e)
                        }
                    }, {
                        key: "worldScale",
                        get: function() {
                            return this.updateWorldTransform(), this._scale
                        },
                        set: function(e) {
                            this.setWorldScale(e)
                        }
                    }, {
                        key: "matrix",
                        set: function(e) {
                            Bn.toRTS(e, this._lrot, this._lpos, this._lscale), this.invalidateChildren(r_.TRS), this._eulerDirty = !0, 1 & this._eventMask && this.emit(Om.TRANSFORM_CHANGED, r_.TRS)
                        }
                    }, {
                        key: "worldMatrix",
                        get: function() {
                            return this.updateWorldTransform(), this._mat
                        }
                    }, {
                        key: "forward",
                        get: function() {
                            return En.transformQuat(new En, En.FORWARD, this.worldRotation)
                        },
                        set: function(e) {
                            var t = e.length();
                            En.multiplyScalar(Uv, e, -1 / t), wn.fromViewUp(Gv, Uv), this.setWorldRotation(Gv)
                        }
                    }, {
                        key: "layer",
                        get: function() {
                            return this._layer
                        },
                        set: function(e) {
                            this._layer = e, to.set(this._poolHandle, Zr.LAYER, this._layer), this.emit(Om.LAYER_CHANGED, this._layer)
                        }
                    }, {
                        key: "hasChangedFlags",
                        get: function() {
                            return Xv.get(this) || 0
                        },
                        set: function(e) {
                            Xv.set(this, e), to.set(this._poolHandle, Zr.FLAGS_CHANGED, e)
                        }
                    }]), t
                }(pg), fg.bookOfChange = Xv, fg.EventType = Om, fg.NodeSpace = i_, fg.TransformDirtyBit = r_, fg.TransformBit = r_, cg = ie((sg = dg).prototype, "_lpos", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return new En
                    }
                }), lg = ie(sg.prototype, "_lrot", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return new wn
                    }
                }), ug = ie(sg.prototype, "_lscale", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return new En(1, 1, 1)
                    }
                }), hg = ie(sg.prototype, "_layer", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return Pu.Enum.DEFAULT
                    }
                }), _g = ie(sg.prototype, "_euler", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return new En
                    }
                }), ie(sg.prototype, "eulerAngles", [og], Object.getOwnPropertyDescriptor(sg.prototype, "eulerAngles"), sg.prototype), ie(sg.prototype, "angle", [F_], Object.getOwnPropertyDescriptor(sg.prototype, "angle"), sg.prototype), ie(sg.prototype, "layer", [F_], Object.getOwnPropertyDescriptor(sg.prototype, "layer"), sg.prototype), ag = sg)) || ag));
            i.Node = Yv;
            var Kv = A_("cc.TargetInfo")((bg = ie((Cg = function() {
                    ne(this, "localID", bg, this)
                }).prototype, "localID", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return []
                    }
                }), xg = Cg)) || xg,
                Zv = (Rg = A_("cc.TargetOverrideInfo"), wg = ef(ni), Ig = ef(Kv), Pg = ef(Yv), Og = ef(Kv), Rg((Mg = ie((Ng = function() {
                    ne(this, "source", Mg, this), ne(this, "sourceInfo", Lg, this), ne(this, "propertyPath", Bg, this), ne(this, "target", Fg, this), ne(this, "targetInfo", zg, this)
                }).prototype, "source", [w_, wg], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return null
                    }
                }), Lg = ie(Ng.prototype, "sourceInfo", [w_, Ig], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return null
                    }
                }), Bg = ie(Ng.prototype, "propertyPath", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return []
                    }
                }), Fg = ie(Ng.prototype, "target", [w_, Pg], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return null
                    }
                }), zg = ie(Ng.prototype, "targetInfo", [w_, Og], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return null
                    }
                }), Dg = Ng)) || Dg),
                Qv = A_("cc.CompPrefabInfo")((Hg = ie((Gg = function() {
                    ne(this, "fileId", Hg, this)
                }).prototype, "fileId", [w_, F_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return ""
                    }
                }), Ug = Gg)) || Ug,
                Jv = (kg = A_("CCPropertyOverrideInfo"), Vg = ef(Kv), kg((Kg = function() {
                    function e() {
                        ne(this, "targetInfo", qg, this), ne(this, "propertyPath", Xg, this), ne(this, "value", Yg, this)
                    }
                    return e.prototype.isTarget = function() {}, e
                }(), qg = ie((jg = Kg).prototype, "targetInfo", [w_, Vg], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return null
                    }
                }), Xg = ie(jg.prototype, "propertyPath", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return []
                    }
                }), Yg = ie(jg.prototype, "value", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: null
                }), Wg = jg)) || Wg),
                $v = (Zg = A_("cc.MountedChildrenInfo"), Qg = ef(Kv), Jg = ef([Yv]), Zg((iv = function() {
                    function e() {
                        ne(this, "targetInfo", tv, this), ne(this, "nodes", nv, this)
                    }
                    return e.prototype.isTarget = function() {}, e
                }(), tv = ie((ev = iv).prototype, "targetInfo", [w_, Qg], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return null
                    }
                }), nv = ie(ev.prototype, "nodes", [w_, Jg], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return []
                    }
                }), $g = ev)) || $g),
                ey = (rv = A_("cc.MountedComponentsInfo"), ov = ef(Kv), av = ef([Jd]), rv((hv = function() {
                    function e() {
                        ne(this, "targetInfo", lv, this), ne(this, "components", uv, this)
                    }
                    return e.prototype.isTarget = function() {}, e
                }(), lv = ie((cv = hv).prototype, "targetInfo", [w_, ov], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return null
                    }
                }), uv = ie(cv.prototype, "components", [w_, av], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return []
                    }
                }), sv = cv)) || sv),
                ty = (_v = A_("cc.PrefabInstance"), fv = ef(Yv), dv = ef([$v]), pv = ef([ey]), mv = ef([Jv]), gv = ef([Kv]), _v((bv = function() {
                    function e() {
                        ne(this, "fileId", Sv, this), ne(this, "prefabRootNode", Ev, this), ne(this, "mountedChildren", Tv, this), ne(this, "mountedComponents", Av, this), ne(this, "propertyOverrides", xv, this), ne(this, "removedComponents", Cv, this), this.targetMap = {}
                    }
                    var t = e.prototype;
                    return t.findPropertyOverride = function() {}, t.removePropertyOverride = function() {}, e
                }(), Sv = ie((yv = bv).prototype, "fileId", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return ""
                    }
                }), Ev = ie(yv.prototype, "prefabRootNode", [w_, fv], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: null
                }), Tv = ie(yv.prototype, "mountedChildren", [w_, dv], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return []
                    }
                }), Av = ie(yv.prototype, "mountedComponents", [w_, pv], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return []
                    }
                }), xv = ie(yv.prototype, "propertyOverrides", [w_, mv], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return []
                    }
                }), Cv = ie(yv.prototype, "removedComponents", [w_, gv], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return []
                    }
                }), vv = yv)) || vv),
                ny = (Rv = A_("cc.PrefabInfo"), wv = ef(Yv), Iv = ef(i.Prefab), Pv = ef(ty), Ov = ef([Zv]), Rv((Mv = ie((Nv = function() {
                    ne(this, "root", Mv, this), ne(this, "asset", Lv, this), ne(this, "fileId", Bv, this), ne(this, "instance", Fv, this), ne(this, "targetOverrides", zv, this)
                }).prototype, "root", [w_, wv], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: null
                }), Lv = ie(Nv.prototype, "asset", [w_, Iv], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: null
                }), Bv = ie(Nv.prototype, "fileId", [w_, F_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return ""
                    }
                }), Fv = ie(Nv.prototype, "instance", [w_, Pv], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: null
                }), zv = ie(Nv.prototype, "targetOverrides", [w_, Ov], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: null
                }), Dv = Nv)) || Dv);
            i._PrefabInfo = ny;
            var iy, ry, oy, ay, sy, cy, ly, uy, hy, _y, fy, dy, py, my = Object.freeze({
                    __proto__: null,
                    TargetInfo: Kv,
                    TargetOverrideInfo: Zv,
                    CompPrefabInfo: Qv,
                    PropertyOverrideInfo: Jv,
                    MountedChildrenInfo: $v,
                    MountedComponentsInfo: ey,
                    PrefabInstance: ty,
                    PrefabInfo: ny,
                    createNodeWithPrefab: mg,
                    generateTargetMap: gg,
                    getTarget: vg,
                    applyMountedChildren: yg,
                    applyMountedComponents: Sg,
                    applyRemovedComponents: Eg,
                    applyPropertyOverrides: Tg,
                    applyTargetOverrides: Ag
                }),
                gy = $e({
                    AUTO: 0,
                    SINGLE_INSTANCE: 1,
                    MULTI_INSTANCE: 2
                }),
                vy = e("Prefab", A_("cc.Prefab")((cy = sy = function(e) {
                    function t() {
                        var t;
                        return ne(t = e.call(this) || this, "data", oy, $(t)), ne(t, "optimizationPolicy", ay, $(t)), t._createFunction = void 0, t._instantiatedTimes = void 0, t._createFunction = null, t._instantiatedTimes = 0, t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.createNode = function(e) {
                        var t = i.instantiate(this);
                        t.name = this.name, e(null, t)
                    }, n.compileCreateFunction = function() {
                        var e, t;
                        this._createFunction = (t = (e = this.data) instanceof i._BaseNode && e, new Im(e, t).result)
                    }, n._doInstantiate = function(e) {
                        return this.data._prefab || x(3700), this._createFunction || this.compileCreateFunction(), this._createFunction(e)
                    }, n._instantiate = function() {
                        var e;
                        return this.optimizationPolicy !== gy.SINGLE_INSTANCE && (this.optimizationPolicy === gy.MULTI_INSTANCE || this._instantiatedTimes + 1 >= t.OptimizationPolicyThreshold) ? (e = this._doInstantiate(), this.data._instantiate(e)) : e = this.data._instantiate(), ++this._instantiatedTimes, e
                    }, n.initDefault = function(t) {
                        e.prototype.initDefault.call(this, t), this.data = new Yv, this.data.name = "(Missing Node)";
                        var n = new ny;
                        n.asset = this, n.root = this.data, this.data._prefab = n
                    }, n.validate = function() {
                        return !!this.data
                    }, t
                }(Nf), sy.OptimizationPolicy = gy, sy.OptimizationPolicyThreshold = 3, oy = ie((ry = cy).prototype, "data", [w_, F_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return null
                    }
                }), ay = ie(ry.prototype, "optimizationPolicy", [w_, F_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return gy.AUTO
                    }
                }), iy = ry)) || iy);
            Qe.value(vy, "_utils", my), i.Prefab = vy, xe(i, "cc._Prefab", "Prefab"), e("PrefabLink", (ly = A_("cc.PrefabLink"), uy = ef(vy), hy = z_(), ly((py = function(e) {
                function t() {
                    for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                    return ne(t = e.call.apply(e, [this].concat(i)) || this, "prefab", dy, $(t)), t
                }
                return Q(t, e), t
            }(Jd), dy = ie((fy = py).prototype, "prefab", [uy, w_, hy], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return null
                }
            }), _y = fy)) || _y));
            var yy = new En;

            function Sy(e, t, n, i) {
                i || (i = new En), e.convertToUINode(t, n, i);
                var r = n.position;
                return i.add(r), i
            }

            function Ey(e, t, n) {
                return n || (n = new En), e.worldToScreen(t, n), n.x /= i.view.getScaleX(), n.y /= i.view.getScaleY(), n
            }
            var Ty = e("convertUtils", {
                WorldNode3DToLocalNodeUI: Sy,
                WorldNode3DToWorldNodeUI: Ey
            });
            i.pipelineUtils = Ty, U(i.pipelineUtils, "cc.pipelineUtils", [{
                name: "WorldNode3DToLocalNodeUI",
                newName: "convertToUINode",
                targetName: "cc.Camera.prototype",
                customFunction: function() {
                    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
                    var i = t[0],
                        r = t[3] || yy;
                    return i.convertToUINode(t[1], t[2], r), r.add(t[2].position), t[3] || r.clone()
                }
            }]), U(Om, "Node.EventType", [{
                name: "POSITION_PART",
                newName: "TRANSFORM_CHANGED"
            }, {
                name: "ROTATION_PART",
                newName: "TRANSFORM_CHANGED"
            }, {
                name: "SCALE_PART",
                newName: "TRANSFORM_CHANGED"
            }]);
            var Ay = function() {
                    function e() {
                        this.support = void 0, this._intervalInMileseconds = 200, this._accelTimer = 0, this._eventTarget = new Si, this._deviceEventName = void 0, this._globalEventClass = void 0, this._didAccelerateFunc = void 0, this.support = !0, this._globalEventClass = window.DeviceMotionEvent || window.DeviceOrientationEvent, Ei.browserType === fi.QQ && (this._globalEventClass = window.DeviceOrientationEvent), this._deviceEventName = this._globalEventClass === window.DeviceMotionEvent ? "devicemotion" : "deviceorientation", this._didAccelerateFunc = this._didAccelerate.bind(this)
                    }
                    var t = e.prototype;
                    return t._registerEvent = function() {
                        this._accelTimer = performance.now(), window.addEventListener(this._deviceEventName, this._didAccelerateFunc, !1)
                    }, t._unregisterEvent = function() {
                        this._accelTimer = 0, window.removeEventListener(this._deviceEventName, this._didAccelerateFunc, !1)
                    }, t._didAccelerate = function(e) {
                        var t = performance.now();
                        if (!(t - this._accelTimer < this._intervalInMileseconds)) {
                            this._accelTimer = t;
                            var n = 0,
                                r = 0,
                                o = 0;
                            if (this._globalEventClass === window.DeviceMotionEvent) {
                                var a = e.accelerationIncludingGravity;
                                n = .1 * ((null == a ? void 0 : a.x) || 0), r = .1 * ((null == a ? void 0 : a.y) || 0), o = .1 * ((null == a ? void 0 : a.z) || 0)
                            } else {
                                var s = e;
                                n = (s.gamma || 0) / 90 * .981, r = -(s.beta || 0) / 90 * .981, o = (s.alpha || 0) / 90 * .981
                            }
                            if (i.view._isRotated) {
                                var c = n;
                                n = -r, r = c
                            }
                            var l = n;
                            90 === window.orientation ? (n = -r, r = l) : -90 === window.orientation ? (n = r, r = -l) : 180 === window.orientation && (n = -n, r = -r), Ei.os === gi.ANDROID && Ei.browserType !== fi.MOBILE_QQ && (n = -n, r = -r);
                            var u = {
                                type: Om.DEVICEMOTION,
                                x: n,
                                y: r,
                                z: o,
                                timestamp: performance.now()
                            };
                            this._eventTarget.emit(Om.DEVICEMOTION, u)
                        }
                    }, t.start = function() {
                        this._registerEvent()
                    }, t.stop = function() {
                        this._unregisterEvent()
                    }, t.setInterval = function(e) {
                        this._intervalInMileseconds = e
                    }, t.onChange = function(e) {
                        this._eventTarget.on(Om.DEVICEMOTION, e)
                    }, e
                }(),
                xy = function() {
                    function e() {
                        this.support = void 0, this.support = !0
                    }
                    var t = e.prototype;
                    return t.show = function() {
                        throw new Error("Method not implemented.")
                    }, t.hide = function() {
                        throw new Error("Method not implemented.")
                    }, t.onChange = function() {
                        throw new Error("Method not implemented.")
                    }, t.onComplete = function() {
                        throw new Error("Method not implemented.")
                    }, t.offChange = function() {
                        throw new Error("Method not implemented.")
                    }, t.offComplete = function() {
                        throw new Error("Method not implemented.")
                    }, e
                }(),
                Cy = function() {
                    function e() {
                        this.support = void 0, this._eventTarget = new Si, this.support = !Ei.isMobile, this._registerEvent()
                    }
                    var t = e.prototype;
                    return t._registerEvent = function() {
                        var e = document.getElementById("GameCanvas");
                        null == e || e.addEventListener("keydown", this._createCallback(Om.KEY_DOWN)), null == e || e.addEventListener("keyup", this._createCallback(Om.KEY_UP))
                    }, t._createCallback = function(e) {
                        var t = this;
                        return function(n) {
                            var i = {
                                type: e,
                                code: n.keyCode,
                                timestamp: performance.now()
                            };
                            n.stopPropagation(), n.preventDefault(), t._eventTarget.emit(e, i)
                        }
                    }, t.onDown = function(e) {
                        this._eventTarget.on(Om.KEY_DOWN, e)
                    }, t.onUp = function(e) {
                        this._eventTarget.on(Om.KEY_UP, e)
                    }, e
                }(),
                by = function() {
                    function e() {
                        this.support = void 0, this._canvas = void 0, this._eventTarget = new Si, this._pointLocked = !1, this._isPressed = !1, this._preMousePos = new Gn, this.support = !Ei.isMobile && !0, this.support && (this._canvas = document.getElementById("GameCanvas"), this._canvas, this._registerEvent())
                    }
                    var t = e.prototype;
                    return t._getCanvasRect = function() {
                        var e = this._canvas,
                            t = null == e ? void 0 : e.getBoundingClientRect();
                        return t ? new Kn(t.x, t.y, t.width, t.height) : new Kn(0, 0, 0, 0)
                    }, t._getLocation = function(e) {
                        return new Gn(e.clientX, e.clientY)
                    }, t._registerEvent = function() {
                        var e, t, n, i, r = this;
                        window.addEventListener("mousedown", (function() {
                            r._isPressed = !0
                        })), null === (e = this._canvas) || void 0 === e || e.addEventListener("mousedown", this._createCallback(Om.MOUSE_DOWN)), null === (t = this._canvas) || void 0 === t || t.addEventListener("mousemove", this._createCallback(Om.MOUSE_MOVE)), window.addEventListener("mouseup", this._createCallback(Om.MOUSE_UP)), null === (n = this._canvas) || void 0 === n || n.addEventListener("mouseup", this._createCallback(Om.MOUSE_UP)), null === (i = this._canvas) || void 0 === i || i.addEventListener("wheel", (function(e) {
                            var t = r._getCanvasRect(),
                                n = r._getLocation(e),
                                i = {
                                    type: Om.MOUSE_WHEEL,
                                    x: n.x - t.x,
                                    y: t.y + t.height - n.y,
                                    button: e.button,
                                    deltaX: 5 * e.deltaX,
                                    deltaY: 5 * -e.deltaY,
                                    timestamp: performance.now(),
                                    movementX: e.movementX,
                                    movementY: e.movementY
                                };
                            e.stopPropagation(), e.preventDefault(), r._eventTarget.emit(Om.MOUSE_WHEEL, i)
                        })), this._registerPointerLockEvent()
                    }, t._registerPointerLockEvent = function() {
                        var e = this,
                            t = function() {
                                var t = e._canvas;
                                document.pointerLockElement === t || document.mozPointerLockElement === t ? e._pointLocked = !0 : e._pointLocked = !1
                            };
                        "onpointerlockchange" in document ? document.addEventListener("pointerlockchange", t, !1) : "onmozpointerlockchange" in document && document.addEventListener("mozpointerlockchange", t, !1)
                    }, t._createCallback = function(e) {
                        var t = this;
                        return function(n) {
                            var i, r = t._getCanvasRect(),
                                o = t._getLocation(n),
                                a = n.button;
                            switch (n.type) {
                                case "mousedown":
                                    null === (i = t._canvas) || void 0 === i || i.focus(), t._isPressed = !0;
                                    break;
                                case "mouseup":
                                    t._isPressed = !1;
                                    break;
                                case "mousemove":
                                    t._isPressed || (a = -1)
                            }
                            var s = {
                                type: e,
                                x: t._pointLocked ? t._preMousePos.x + n.movementX : o.x - r.x,
                                y: t._pointLocked ? t._preMousePos.y - n.movementY : r.y + r.height - o.y,
                                button: a,
                                timestamp: performance.now(),
                                movementX: n.movementX,
                                movementY: n.movementY
                            };
                            t._preMousePos.set(s.x, s.y), n.stopPropagation(), n.target === t._canvas && n.preventDefault(), t._eventTarget.emit(e, s)
                        }
                    }, t.onDown = function(e) {
                        this._eventTarget.on(Om.MOUSE_DOWN, e)
                    }, t.onMove = function(e) {
                        this._eventTarget.on(Om.MOUSE_MOVE, e)
                    }, t.onUp = function(e) {
                        this._eventTarget.on(Om.MOUSE_UP, e)
                    }, t.onWheel = function(e) {
                        this._eventTarget.on(Om.MOUSE_WHEEL, e)
                    }, e
                }(),
                Ry = function() {
                    function e() {
                        this.support = void 0, this._canvas = void 0, this._eventTarget = new Si, this.support = Ei.isMobile, this.support && (this._canvas = document.getElementById("GameCanvas"), this._canvas, this._registerEvent())
                    }
                    var t = e.prototype;
                    return t._registerEvent = function() {
                        var e, t, n, i;
                        null === (e = this._canvas) || void 0 === e || e.addEventListener("touchstart", this._createCallback(Om.TOUCH_START)), null === (t = this._canvas) || void 0 === t || t.addEventListener("touchmove", this._createCallback(Om.TOUCH_MOVE)), null === (n = this._canvas) || void 0 === n || n.addEventListener("touchend", this._createCallback(Om.TOUCH_END)), null === (i = this._canvas) || void 0 === i || i.addEventListener("touchcancel", this._createCallback(Om.TOUCH_CANCEL))
                    }, t._createCallback = function(e) {
                        var t = this;
                        return function(n) {
                            for (var r = t._getCanvasRect(), o = [], a = n.changedTouches.length, s = 0; s < a; ++s) {
                                var c = n.changedTouches[s],
                                    l = t._getLocation(c),
                                    u = l.x - r.x,
                                    h = r.y + r.height - l.y;
                                if (i.view._isRotated) {
                                    var _ = u;
                                    u = r.height - h, h = _
                                }
                                var f = {
                                    identifier: c.identifier,
                                    x: u,
                                    y: h,
                                    force: c.force
                                };
                                o.push(f)
                            }
                            var d, p = {
                                type: e,
                                changedTouches: o,
                                timestamp: performance.now()
                            };
                            n.stopPropagation(), n.target === t._canvas && n.preventDefault(), "touchstart" === n.type && (null === (d = t._canvas) || void 0 === d || d.focus()), t._eventTarget.emit(e, p)
                        }
                    }, t._getCanvasRect = function() {
                        var e = this._canvas,
                            t = null == e ? void 0 : e.getBoundingClientRect();
                        return t ? new Kn(t.x, t.y, t.width, t.height) : new Kn(0, 0, 0, 0)
                    }, t._getLocation = function(e) {
                        return new Gn(e.clientX, e.clientY)
                    }, t.onStart = function(e) {
                        this._eventTarget.on(Om.TOUCH_START, e)
                    }, t.onMove = function(e) {
                        this._eventTarget.on(Om.TOUCH_MOVE, e)
                    }, t.onEnd = function(e) {
                        this._eventTarget.on(Om.TOUCH_END, e)
                    }, t.onCancel = function(e) {
                        this._eventTarget.on(Om.TOUCH_CANCEL, e)
                    }, e
                }(),
                wy = new(function() {
                    function e() {
                        this._touch = new Ry, this._mouse = new by, this._keyboard = new Cy, this._accelerometer = new Ay, this._inputBox = new xy, this._inputEventList = [], this._registerEvent()
                    }
                    var t = e.prototype;
                    return t._registerEvent = function() {}, t._pushEvent = function(e) {
                        this._inputEventList.push(e)
                    }, t.pollEvent = function() {
                        return this._inputEventList.shift()
                    }, e
                }()),
                Iy = new Gn,
                Py = e("EventMouse", function(e) {
                    function t(n, i, r) {
                        var o;
                        return (o = e.call(this, Df.MOUSE, i) || this).movementX = 0, o.movementY = 0, o.eventType = void 0, o._button = t.BUTTON_MISSING, o._x = 0, o._y = 0, o._prevX = 0, o._prevY = 0, o._scrollX = 0, o._scrollY = 0, o.eventType = n, r && (o._prevX = r.x, o._prevY = r.y), o
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.setScrollData = function(e, t) {
                        this._scrollX = e, this._scrollY = t
                    }, n.getScrollX = function() {
                        return this._scrollX
                    }, n.getScrollY = function() {
                        return this._scrollY
                    }, n.setLocation = function(e, t) {
                        this._x = e, this._y = t
                    }, n.getLocation = function(e) {
                        return e || (e = new Gn), Gn.set(e, this._x, this._y), e
                    }, n.getLocationInView = function(e) {
                        return e || (e = new Gn), Gn.set(e, this._x, i.view._designResolutionSize.height - this._y), e
                    }, n.getUILocation = function(e) {
                        return e || (e = new Gn), Gn.set(e, this._x, this._y), i.view._convertPointWithScale(e), e
                    }, n.getPreviousLocation = function(e) {
                        return e || (e = new Gn), Gn.set(e, this._prevX, this._prevY), e
                    }, n.getUIPreviousLocation = function(e) {
                        return e || (e = new Gn), Gn.set(e, this._prevX, this._prevY), i.view._convertPointWithScale(e), e
                    }, n.getDelta = function(e) {
                        return e || (e = new Gn), Gn.set(e, this._x - this._prevX, this._y - this._prevY), e
                    }, n.getDeltaX = function() {
                        return this._x - this._prevX
                    }, n.getDeltaY = function() {
                        return this._y - this._prevY
                    }, n.getUIDelta = function(e) {
                        return e || (e = new Gn), Gn.set(e, (this._x - this._prevX) / i.view.getScaleX(), (this._y - this._prevY) / i.view.getScaleY()), e
                    }, n.getUIDeltaX = function() {
                        return (this._x - this._prevX) / i.view.getScaleX()
                    }, n.getUIDeltaY = function() {
                        return (this._y - this._prevY) / i.view.getScaleY()
                    }, n.setButton = function(e) {
                        this._button = e
                    }, n.getButton = function() {
                        return this._button
                    }, n.getLocationX = function() {
                        return this._x
                    }, n.getLocationY = function() {
                        return this._y
                    }, n.getUILocationX = function() {
                        var e = i.view.getViewportRect();
                        return (this._x - e.x) / i.view.getScaleX()
                    }, n.getUILocationY = function() {
                        var e = i.view.getViewportRect();
                        return (this._y - e.y) / i.view.getScaleY()
                    }, t
                }(Df));
            Py.BUTTON_MISSING = -1, Py.BUTTON_LEFT = 0, Py.BUTTON_RIGHT = 2, Py.BUTTON_MIDDLE = 1, Py.BUTTON_4 = 3, Py.BUTTON_5 = 4, Py.BUTTON_6 = 5, Py.BUTTON_7 = 6, Py.BUTTON_8 = 7;
            var Oy = e("EventTouch", function(e) {
                function t(t, n, i, r) {
                    var o;
                    return (o = e.call(this, Df.TOUCH, n) || this).touch = null, o.simulate = !1, o._eventCode = void 0, o._touches = void 0, o._allTouches = void 0, o._eventCode = i || "", o._touches = t || [], o._allTouches = r || [], o
                }
                Q(t, e);
                var n = t.prototype;
                return n.getEventCode = function() {
                    return this._eventCode
                }, n.getTouches = function() {
                    return this._touches
                }, n.getAllTouches = function() {
                    return this._allTouches
                }, n.setLocation = function(e, t) {
                    this.touch && this.touch.setTouchInfo(this.touch.getID(), e, t)
                }, n.getLocation = function(e) {
                    return this.touch ? this.touch.getLocation(e) : new Gn
                }, n.getUILocation = function(e) {
                    return this.touch ? this.touch.getUILocation(e) : new Gn
                }, n.getLocationInView = function(e) {
                    return this.touch ? this.touch.getLocationInView(e) : new Gn
                }, n.getPreviousLocation = function(e) {
                    return this.touch ? this.touch.getPreviousLocation(e) : new Gn
                }, n.getStartLocation = function(e) {
                    return this.touch ? this.touch.getStartLocation(e) : new Gn
                }, n.getUIStartLocation = function(e) {
                    return this.touch ? this.touch.getUIStartLocation(e) : new Gn
                }, n.getID = function() {
                    return this.touch ? this.touch.getID() : null
                }, n.getDelta = function(e) {
                    return this.touch ? this.touch.getDelta(e) : new Gn
                }, n.getUIDelta = function(e) {
                    return this.touch ? this.touch.getUIDelta(e) : new Gn
                }, n.getDeltaX = function() {
                    return this.touch ? this.touch.getDelta(Iy).x : 0
                }, n.getDeltaY = function() {
                    return this.touch ? this.touch.getDelta(Iy).y : 0
                }, n.getLocationX = function() {
                    return this.touch ? this.touch.getLocationX() : 0
                }, n.getLocationY = function() {
                    return this.touch ? this.touch.getLocationY() : 0
                }, t
            }(Df));
            Oy.MAX_TOUCHES = 5;
            var Dy = e("EventAcceleration", function(e) {
                    function t(t, n) {
                        var i;
                        return (i = e.call(this, Df.ACCELERATION, n) || this).acc = void 0, i.acc = t, i
                    }
                    return Q(t, e), t
                }(Df)),
                Ny = e("EventKeyboard", function(e) {
                    function t(t, n, i) {
                        var r;
                        return (r = e.call(this, Df.KEYBOARD, i) || this).keyCode = void 0, r.rawEvent = void 0, r.isPressed = void 0, "number" == typeof t ? r.keyCode = t : (r.keyCode = t.keyCode, r.rawEvent = t), r.isPressed = n, r
                    }
                    return Q(t, e), t
                }(Df));
            Df.EventMouse = Py, Df.EventTouch = Oy, Df.EventAcceleration = Dy, Df.EventKeyboard = Ny;
            var My = new Gn,
                Ly = e("Touch", function() {
                    function e(e, t, n) {
                        void 0 === n && (n = 0), this._point = new Gn, this._prevPoint = new Gn, this._lastModified = 0, this._id = 0, this._startPoint = new Gn, this._startPointCaptured = !1, this.setTouchInfo(n, e, t)
                    }
                    var t = e.prototype;
                    return t.getLocation = function(e) {
                        return e || (e = new Gn), e.set(this._point.x, this._point.y), e
                    }, t.getLocationX = function() {
                        return this._point.x
                    }, t.getLocationY = function() {
                        return this._point.y
                    }, t.getUILocation = function(e) {
                        return e || (e = new Gn), e.set(this._point.x, this._point.y), i.view._convertPointWithScale(e), e
                    }, t.getUILocationX = function() {
                        var e = i.view.getViewportRect();
                        return (this._point.x - e.x) / i.view.getScaleX()
                    }, t.getUILocationY = function() {
                        var e = i.view.getViewportRect();
                        return (this._point.y - e.y) / i.view.getScaleY()
                    }, t.getPreviousLocation = function(e) {
                        return e || (e = new Gn), e.set(this._prevPoint.x, this._prevPoint.y), e
                    }, t.getUIPreviousLocation = function(e) {
                        return e || (e = new Gn), e.set(this._prevPoint.x, this._prevPoint.y), i.view._convertPointWithScale(e), e
                    }, t.getStartLocation = function(e) {
                        return e || (e = new Gn), e.set(this._startPoint.x, this._startPoint.y), e
                    }, t.getUIStartLocation = function(e) {
                        return e || (e = new Gn), e.set(this._startPoint.x, this._startPoint.y), i.view._convertPointWithScale(e), e
                    }, t.getDelta = function(e) {
                        return e || (e = new Gn), e.set(this._point), e.subtract(this._prevPoint), e
                    }, t.getUIDelta = function(e) {
                        return e || (e = new Gn), My.set(this._point), My.subtract(this._prevPoint), e.set(i.view.getScaleX(), i.view.getScaleY()), Gn.divide(e, My, e), e
                    }, t.getLocationInView = function(e) {
                        return e || (e = new Gn), e.set(this._point.x, i.view._designResolutionSize.height - this._point.y), e
                    }, t.getPreviousLocationInView = function(e) {
                        return e || (e = new Gn), e.set(this._prevPoint.x, i.view._designResolutionSize.height - this._prevPoint.y), e
                    }, t.getStartLocationInView = function(e) {
                        return e || (e = new Gn), e.set(this._startPoint.x, i.view._designResolutionSize.height - this._startPoint.y), e
                    }, t.getID = function() {
                        return this._id
                    }, t.setTouchInfo = function(e, t, n) {
                        void 0 === e && (e = 0), this._prevPoint = this._point, this._point = new Gn(t || 0, n || 0), this._id = e, this._startPointCaptured || (this._startPoint = new Gn(this._point), this._startPointCaptured = !0)
                    }, t.setPoint = function(e, t) {
                        "object" == typeof e ? (this._point.x = e.x, this._point.y = e.y) : (this._point.x = e || 0, this._point.y = t || 0), this._lastModified = i.director.getCurrentTime()
                    }, t.setPrevPoint = function(e, t) {
                        this._prevPoint = "object" == typeof e ? new Gn(e.x, e.y) : new Gn(e || 0, t || 0), this._lastModified = i.director.getCurrentTime()
                    }, K(e, [{
                        key: "lastModified",
                        get: function() {
                            return this._lastModified
                        }
                    }]), e
                }());
            i.Touch = Ly;
            var By = function(e, t, n, i) {
                    void 0 === e && (e = 0), void 0 === t && (t = 0), void 0 === n && (n = 0), void 0 === i && (i = 0), this.x = void 0, this.y = void 0, this.z = void 0, this.timestamp = void 0, this.x = e, this.y = t, this.z = n, this.timestamp = i
                },
                Fy = rt.TOUCH_TIMEOUT,
                zy = new Gn,
                Uy = new Gn,
                Gy = new(function() {
                    function e() {
                        this._isRegisterEvent = !1, this._preTouchPoint = new Gn, this._prevMousePoint = new Gn, this._preTouchPool = [], this._preTouchPoolPointer = 0, this._touches = [], this._touchesIntegerDict = {}, this._indexBitsUsed = 0, this._maxTouches = 8, this._glView = null
                    }
                    var t = e.prototype;
                    return t.handleTouchesBegin = function(e) {
                        for (var t = [], n = this._touchesIntegerDict, i = 0; i < e.length; ++i) {
                            var r = e[i],
                                o = r.getID();
                            if (null !== o && void 0 === n[o]) {
                                var a = this._getUnUsedIndex();
                                if (-1 === a) {
                                    T(2300, a);
                                    continue
                                }
                                r.getLocation(zy);
                                var s = new Ly(zy.x, zy.y, o);
                                this._touches[a] = s, r.getPreviousLocation(zy), s.setPrevPoint(zy), n[o] = a, t.push(s)
                            }
                        }
                        if (t.length > 0) {
                            var c = new Oy(t, !1, Om.TOUCH_START, rt.ENABLE_MULTI_TOUCH ? this._getUsefulTouches() : t);
                            Vm.dispatchEvent(c)
                        }
                    }, t.handleTouchesMove = function(e) {
                        for (var t = [], n = this._touches, i = 0; i < e.length; ++i) {
                            var r = e[i],
                                o = r.getID();
                            if (null !== o) {
                                var a = this._touchesIntegerDict[o];
                                void 0 !== a && n[a] && (r.getLocation(zy), n[a].setPoint(zy), r.getPreviousLocation(zy), n[a].setPrevPoint(zy), t.push(n[a]))
                            }
                        }
                        if (t.length > 0) {
                            var s = new Oy(t, !1, Om.TOUCH_MOVE, rt.ENABLE_MULTI_TOUCH ? this._getUsefulTouches() : t);
                            Vm.dispatchEvent(s)
                        }
                    }, t.handleTouchesEnd = function(e) {
                        var t = this.getSetOfTouchesEndOrCancel(e);
                        if (t.length > 0) {
                            var n = new Oy(t, !1, Om.TOUCH_END, rt.ENABLE_MULTI_TOUCH ? this._getUsefulTouches() : t);
                            Vm.dispatchEvent(n)
                        }
                        this._preTouchPool.length = 0
                    }, t.handleTouchesCancel = function(e) {
                        var t = this.getSetOfTouchesEndOrCancel(e);
                        if (t.length > 0) {
                            var n = new Oy(t, !1, Om.TOUCH_CANCEL, rt.ENABLE_MULTI_TOUCH ? this._getUsefulTouches() : t);
                            Vm.dispatchEvent(n)
                        }
                        this._preTouchPool.length = 0
                    }, t.getSetOfTouchesEndOrCancel = function(e) {
                        for (var t = [], n = this._touches, i = this._touchesIntegerDict, r = 0; r < e.length; ++r) {
                            var o = e[r],
                                a = o.getID();
                            if (null !== a) {
                                var s = i[a];
                                void 0 !== s && n[s] && (o.getLocation(zy), n[s].setPoint(zy), o.getPreviousLocation(zy), n[s].setPrevPoint(zy), t.push(n[s]), this._removeUsedIndexBit(s), delete i[a])
                            }
                        }
                        return t
                    }, t._getPreTouch = function(e) {
                        for (var t = null, n = this._preTouchPool, i = e.getID(), r = n.length - 1; r >= 0; r--)
                            if (n[r].getID() === i) {
                                t = n[r];
                                break
                            }
                        return t || (t = e), t
                    }, t._setPreTouch = function(e) {
                        for (var t = !1, n = this._preTouchPool, i = e.getID(), r = n.length - 1; r >= 0; r--)
                            if (n[r].getID() === i) {
                                n[r] = e, t = !0;
                                break
                            }
                        t || (n.length <= 50 ? n.push(e) : (n[this._preTouchPoolPointer] = e, this._preTouchPoolPointer = (this._preTouchPoolPointer + 1) % 50))
                    }, t._getViewPixelRatio = function() {
                        return this._glView ? this._glView._devicePixelRatio : 1
                    }, t._getTouch = function(e) {
                        var t = this._preTouchPoint,
                            n = this._getViewPixelRatio(),
                            i = e.x * n,
                            r = e.y * n,
                            o = new Ly(i, r, 0);
                        return o.setPrevPoint(t.x, t.y), t.x = i, t.y = r, o
                    }, t._getMouseEvent = function(e) {
                        var t = this._prevMousePoint,
                            n = new Py(e.type, !1, t),
                            r = this._getViewPixelRatio();
                        return t.x = e.x * r, t.y = e.y * r, i.GAME_VIEW && (t.x /= i.gameView.canvas.width / i.game.canvas.width, t.y /= i.gameView.canvas.height / i.game.canvas.height), n.setLocation(t.x, t.y), n.setButton(e.button), e.movementX && (n.movementX = e.movementX), e.movementY && (n.movementY = e.movementY), n
                    }, t._getTouchList = function(e) {
                        for (var t = [], n = this._preTouchPoint, i = e.changedTouches.length, r = this._getViewPixelRatio(), o = 0; o < i; o++) {
                            var a = e.changedTouches[o],
                                s = a.x * r,
                                c = a.y * r,
                                l = new Ly(s, c, a.identifier);
                            if (this._getPreTouch(l).getLocation(Uy), l.setPrevPoint(Uy.x, Uy.y), this._setPreTouch(l), n.x = s, n.y = c, t.push(l), !rt.ENABLE_MULTI_TOUCH) break
                        }
                        return t
                    }, t._getUnUsedIndex = function() {
                        for (var e = this._indexBitsUsed, t = i.director.getCurrentTime(), n = 0; n < this._maxTouches; n++) {
                            if (!(1 & e)) return this._indexBitsUsed |= 1 << n, n;
                            var r = this._touches[n];
                            if (t - r.lastModified > Fy) {
                                this._removeUsedIndexBit(n);
                                var o = r.getID();
                                return null !== o && delete this._touchesIntegerDict[o], n
                            }
                            e >>= 1
                        }
                        return -1
                    }, t._removeUsedIndexBit = function(e) {
                        if (!(e < 0 || e >= this._maxTouches)) {
                            var t = 1 << e;
                            t = ~t, this._indexBitsUsed &= t
                        }
                    }, t._getUsefulTouches = function() {
                        var e = [],
                            t = this._touchesIntegerDict;
                        for (var n in t) {
                            var i = t[parseInt(n)];
                            if (null != i) {
                                var r = this._touches[i];
                                e.push(r)
                            }
                        }
                        return e
                    }, t.setAccelerometerEnabled = function(e) {
                        e ? wy._accelerometer.start() : wy._accelerometer.stop()
                    }, t.setAccelerometerInterval = function(e) {
                        wy._accelerometer.setInterval(e)
                    }, t.registerSystemEvent = function() {
                        this._isRegisterEvent || (this._glView = i.view, wy._mouse.support && this._registerMouseEvents(), wy._touch.support && this._registerTouchEvents(), wy._keyboard.support && this._registerKeyboardEvent(), wy._accelerometer.support && this._registerAccelerometerEvent(), this._isRegisterEvent = !0)
                    }, t._registerMouseEvents = function() {
                        var e = this;
                        wy._mouse.onDown((function(t) {
                            var n = e._getMouseEvent(t),
                                i = e._getTouch(t);
                            e.handleTouchesBegin([i]), Vm.dispatchEvent(n)
                        })), wy._mouse.onMove((function(t) {
                            var n = e._getMouseEvent(t),
                                i = e._getTouch(t);
                            e.handleTouchesMove([i]), Vm.dispatchEvent(n)
                        })), wy._mouse.onUp((function(t) {
                            var n = e._getMouseEvent(t),
                                i = e._getTouch(t);
                            e.handleTouchesEnd([i]), Vm.dispatchEvent(n)
                        })), wy._mouse.onWheel((function(t) {
                            var n = e._getMouseEvent(t);
                            n.setScrollData(t.deltaX, t.deltaY), Vm.dispatchEvent(n)
                        }))
                    }, t._registerTouchEvents = function() {
                        var e = this;
                        wy._touch.onStart((function(t) {
                            var n = e._getTouchList(t);
                            e.handleTouchesBegin(n)
                        })), wy._touch.onMove((function(t) {
                            var n = e._getTouchList(t);
                            e.handleTouchesMove(n)
                        })), wy._touch.onEnd((function(t) {
                            var n = e._getTouchList(t);
                            e.handleTouchesEnd(n)
                        })), wy._touch.onCancel((function(t) {
                            var n = e._getTouchList(t);
                            e.handleTouchesCancel(n)
                        }))
                    }, t._registerKeyboardEvent = function() {
                        wy._keyboard.onDown((function(e) {
                            Vm.dispatchEvent(new Ny(e.code, !0))
                        })), wy._keyboard.onUp((function(e) {
                            Vm.dispatchEvent(new Ny(e.code, !1))
                        }))
                    }, t._registerAccelerometerEvent = function() {
                        wy._accelerometer.onChange((function(e) {
                            var t = e.x,
                                n = e.y,
                                i = e.z,
                                r = e.timestamp;
                            Vm.dispatchEvent(new Dy(new By(t, n, i, r)))
                        }))
                    }, e
                }());
            i.internal.inputManager = Gy;
            var Hy = null,
                ky = null,
                Vy = null,
                Wy = null,
                jy = e("SystemEvent", function(e) {
                    function t() {
                        return e.call(this) || this
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.setAccelerometerEnabled = function(e) {
                        e && window.DeviceMotionEvent && "function" == typeof DeviceMotionEvent.requestPermission ? DeviceMotionEvent.requestPermission().then((function(e) {
                            T(3520, e), Gy.setAccelerometerEnabled("granted" === e)
                        })).catch((function(e) {
                            x(3521, e.message), Gy.setAccelerometerEnabled(!1)
                        })) : Gy.setAccelerometerEnabled(e)
                    }, n.setAccelerometerInterval = function(e) {
                        Gy.setAccelerometerInterval(e)
                    }, n.on = function(t, n, r, o) {
                        return e.prototype.on.call(this, t, n, r, o), t !== Om.KEY_DOWN && t !== Om.KEY_UP || Hy || (Hy = Nm.create({
                            event: Nm.KEYBOARD,
                            onKeyPressed: function(e, t) {
                                t.type = Om.KEY_DOWN, qy.emit(t.type, t)
                            },
                            onKeyReleased: function(e, t) {
                                t.type = Om.KEY_UP, qy.emit(t.type, t)
                            }
                        }), Vm.addListener(Hy, 256)), t === Om.DEVICEMOTION && (ky || (ky = Nm.create({
                            event: Nm.ACCELERATION,
                            callback: function(e, t) {
                                t.type = Om.DEVICEMOTION, i.systemEvent.emit(t.type, t)
                            }
                        }), Vm.addListener(ky, 256))), t !== Om.TOUCH_START && t !== Om.TOUCH_MOVE && t !== Om.TOUCH_END && t !== Om.TOUCH_CANCEL || Vy || (Vy = Nm.create({
                            event: Nm.TOUCH_ONE_BY_ONE,
                            onTouchBegan: function(e, t) {
                                return t.type = Om.TOUCH_START, i.systemEvent.emit(t.type, e, t), !0
                            },
                            onTouchMoved: function(e, t) {
                                t.type = Om.TOUCH_MOVE, i.systemEvent.emit(t.type, e, t)
                            },
                            onTouchEnded: function(e, t) {
                                t.type = Om.TOUCH_END, i.systemEvent.emit(t.type, e, t)
                            },
                            onTouchCancelled: function(e, t) {
                                t.type = Om.TOUCH_CANCEL, i.systemEvent.emit(t.type, e, t)
                            }
                        }), Vm.addListener(Vy, 256)), t !== Om.MOUSE_DOWN && t !== Om.MOUSE_MOVE && t !== Om.MOUSE_UP && t !== Om.MOUSE_WHEEL || Wy || (Wy = Nm.create({
                            event: Nm.MOUSE,
                            onMouseDown: function(e) {
                                e.type = Om.MOUSE_DOWN, i.systemEvent.emit(e.type, e)
                            },
                            onMouseMove: function(e) {
                                e.type = Om.MOUSE_MOVE, i.systemEvent.emit(e.type, e)
                            },
                            onMouseUp: function(e) {
                                e.type = Om.MOUSE_UP, i.systemEvent.emit(e.type, e)
                            },
                            onMouseScroll: function(e) {
                                e.type = Om.MOUSE_WHEEL, i.systemEvent.emit(e.type, e)
                            }
                        }), Vm.addListener(Wy, 256)), n
                    }, n.off = function(t, n, i) {
                        if (e.prototype.off.call(this, t, n, i), Hy && (t === Om.KEY_DOWN || t === Om.KEY_UP)) {
                            var r = this.hasEventListener(Om.KEY_DOWN),
                                o = this.hasEventListener(Om.KEY_UP);
                            r || o || (Vm.removeListener(Hy), Hy = null)
                        }
                        if (ky && t === Om.DEVICEMOTION && (Vm.removeListener(ky), ky = null), Vy && (t === Om.TOUCH_START || t === Om.TOUCH_MOVE || t === Om.TOUCH_END || t === Om.TOUCH_CANCEL)) {
                            var a = this.hasEventListener(Om.TOUCH_START),
                                s = this.hasEventListener(Om.TOUCH_MOVE),
                                c = this.hasEventListener(Om.TOUCH_END),
                                l = this.hasEventListener(Om.TOUCH_CANCEL);
                            a || s || c || l || (Vm.removeListener(Vy), Vy = null)
                        }
                        if (Wy && (t === Om.MOUSE_DOWN || t === Om.MOUSE_MOVE || t === Om.MOUSE_UP || t === Om.MOUSE_WHEEL)) {
                            var u = this.hasEventListener(Om.MOUSE_DOWN),
                                h = this.hasEventListener(Om.MOUSE_MOVE),
                                _ = this.hasEventListener(Om.MOUSE_UP),
                                f = this.hasEventListener(Om.MOUSE_WHEEL);
                            u || h || _ || f || (Vm.removeListener(Wy), Wy = null)
                        }
                    }, t
                }(Si));
            jy.EventType = Om, i.SystemEvent = jy;
            var qy = e("systemEvent", new jy);
            i.systemEvent = qy;
            var Xy, Yy, Ky, Zy, Qy, Jy, $y, eS, tS, nS, iS = Ei.getViewSize(),
                rS = Ei.pixelRatio,
                oS = e("sys", {
                    NetworkType: mi,
                    Language: pi,
                    OS: gi,
                    Platform: yi,
                    BrowserType: fi,
                    isNative: Ei.isNative,
                    isBrowser: Ei.isBrowser,
                    isMobile: Ei.isMobile,
                    isLittleEndian: Ei.isLittleEndian,
                    platform: Ei.platform,
                    language: Ei.language,
                    languageCode: Ei.nativeLanguage,
                    os: Ei.os,
                    osVersion: Ei.osVersion,
                    osMainVersion: Ei.osMainVersion,
                    browserType: Ei.browserType,
                    browserVersion: Ei.browserVersion,
                    windowPixelResolution: {
                        width: iS.width * rS,
                        height: iS.height * rS
                    },
                    capabilities: {
                        canvas: Ei.supportCapability.canvas,
                        opengl: Ei.supportCapability.gl,
                        webp: Ei.supportCapability.webp,
                        imageBitmap: Ei.supportCapability.imageBitmap,
                        touches: !1,
                        mouse: !1,
                        keyboard: !1,
                        accelerometer: !1
                    },
                    localStorage: null,
                    getNetworkType: function() {
                        return Ei.networkType
                    },
                    getBatteryLevel: function() {
                        return Ei.getBatteryLevel()
                    },
                    garbageCollect: function() {
                        Ei.triggerGC()
                    },
                    isObjectValid: function(e) {
                        return null != e
                    },
                    dump: function() {
                        var e = "";
                        e += "isMobile : " + this.isMobile + "\r\n", e += "language : " + this.language + "\r\n", e += "browserType : " + this.browserType + "\r\n", e += "browserVersion : " + this.browserVersion + "\r\n", e += "capabilities : " + JSON.stringify(this.capabilities) + "\r\n", e += "os : " + this.os + "\r\n", e += "osVersion : " + this.osVersion + "\r\n", e += "platform : " + this.platform + "\r\n", f(e += "Using " + (i.game.renderType === i.game.RENDER_TYPE_WEBGL ? "WEBGL" : "CANVAS") + " renderer.\r\n")
                    },
                    openURL: function(e) {
                        Ei.openURL(e)
                    },
                    now: function() {
                        return Ei.now()
                    },
                    restartVM: function() {
                        Ei.restartJSVM()
                    },
                    getSafeAreaRect: function() {
                        var e = i.view.getVisibleSize();
                        return i.rect(0, 0, e.width, e.height)
                    },
                    __init: function() {
                        try {
                            var e = oS.localStorage = window.localStorage;
                            e.setItem("storage", ""), e.removeItem("storage"), e = null
                        } catch (e) {
                            var t = function() {
                                x(5200)
                            };
                            oS.localStorage = {
                                getItem: t,
                                setItem: t,
                                removeItem: t,
                                clear: t
                            }
                        }
                        var n = window,
                            i = n.navigator,
                            r = document,
                            o = r.documentElement,
                            a = oS.capabilities;
                        (void 0 !== o.ontouchstart || void 0 !== r.ontouchstart || i.msPointerEnabled) && (a.touches = !0), void 0 !== o.onmouseup && (a.mouse = !0), void 0 !== o.onkeyup && (a.keyboard = !0), (n.DeviceMotionEvent || n.DeviceOrientationEvent) && (a.accelerometer = !0), oS.__isWebIOS14OrIPadOS14Env = (oS.os === gi.IOS || oS.os === gi.OSX) && Ei.isBrowser && /(OS 1[4-9])|(Version\/1[4-9])/.test(window.navigator.userAgent), Ei.onViewResize((function() {
                            var e = Ei.getViewSize();
                            oS.windowPixelResolution = {
                                width: Math.round(e.width * rS),
                                height: Math.round(e.height * rS)
                            }
                        }))
                    }
                });
            oS.__init(), i.sys = oS;
            var aS, sS, cS, lS, uS, hS, _S, fS, dS, pS, mS, gS, vS, yS = e("RenderStage", (Xy = A_("RenderStage"), Yy = q_(), Ky = q_(), Zy = q_(), Xy((nS = function() {
                function e() {
                    ne(this, "_name", $y, this), ne(this, "_priority", eS, this), ne(this, "_tag", tS, this)
                }
                var t = e.prototype;
                return t.initialize = function(e) {
                    return this._name = e.name, this._priority = e.priority, e.tag && (this._tag = e.tag), !0
                }, t.activate = function(e, t) {
                    this._pipeline = e, this._flow = t
                }, K(e, [{
                    key: "name",
                    get: function() {
                        return this._name
                    }
                }, {
                    key: "priority",
                    get: function() {
                        return this._priority
                    }
                }, {
                    key: "tag",
                    get: function() {
                        return this._tag
                    }
                }]), e
            }(), $y = ie((Jy = nS).prototype, "_name", [Yy, w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return ""
                }
            }), eS = ie(Jy.prototype, "_priority", [Ky, w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return 0
                }
            }), tS = ie(Jy.prototype, "_tag", [Zy, w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return 0
                }
            }), Qy = Jy)) || Qy));
            i.RenderStage = yS;
            var SS, ES, TS, AS, xS, CS, bS, RS, wS = e("RenderFlow", (aS = A_("RenderFlow"), sS = q_(), cS = q_(), lS = q_(), uS = q_(), hS = ef([yS]), aS((vS = function() {
                function e() {
                    ne(this, "_name", dS, this), ne(this, "_priority", pS, this), ne(this, "_tag", mS, this), ne(this, "_stages", gS, this)
                }
                var t = e.prototype;
                return t.initialize = function(e) {
                    return this._name = e.name, this._priority = e.priority, this._stages = e.stages, e.tag && (this._tag = e.tag), !0
                }, t.activate = function(e) {
                    this._pipeline = e, this._stages.sort((function(e, t) {
                        return e.priority - t.priority
                    }));
                    for (var t = 0, n = this._stages.length; t < n; t++) this._stages[t].activate(e, this)
                }, t.render = function(e) {
                    for (var t = 0, n = this._stages.length; t < n; t++) this._stages[t].render(e)
                }, t.destroy = function() {
                    for (var e = 0, t = this._stages.length; e < t; e++) this._stages[e].destroy();
                    this._stages.length = 0
                }, K(e, [{
                    key: "name",
                    get: function() {
                        return this._name
                    }
                }, {
                    key: "priority",
                    get: function() {
                        return this._priority
                    }
                }, {
                    key: "tag",
                    get: function() {
                        return this._tag
                    }
                }, {
                    key: "stages",
                    get: function() {
                        return this._stages
                    }
                }, {
                    key: "pipeline",
                    get: function() {
                        return this._pipeline
                    }
                }]), e
            }(), dS = ie((fS = vS).prototype, "_name", [sS, w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return ""
                }
            }), pS = ie(fS.prototype, "_priority", [cS, w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return 0
                }
            }), mS = ie(fS.prototype, "_tag", [lS, w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return 0
                }
            }), gS = ie(fS.prototype, "_stages", [uS, hS, w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return []
                }
            }), _S = fS)) || _S));
            i.RenderFlow = wS;
            var IS, PS, OS, DS, NS, MS, LS, BS, FS, zS, US = e("EffectAsset", A_("cc.EffectAsset")((RS = bS = function(e) {
                function t() {
                    for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                    return ne(t = e.call.apply(e, [this].concat(i)) || this, "techniques", TS, $(t)), ne(t, "shaders", AS, $(t)), ne(t, "combinations", xS, $(t)), ne(t, "hideInEditor", CS, $(t)), t
                }
                Q(t, e), t.register = function(e) {
                    t._effects[e.name] = e
                }, t.remove = function(e) {
                    if (t._effects[e]) delete t._effects[e];
                    else
                        for (var n in t._effects)
                            if (t._effects[n]._uuid === e) return void delete t._effects[n]
                }, t.get = function(e) {
                    if (t._effects[e]) return t._effects[e];
                    for (var n in t._effects)
                        if (t._effects[n]._uuid === e) return t._effects[n];
                    return null
                }, t.getAll = function() {
                    return t._effects
                };
                var n = t.prototype;
                return n.onLoaded = function() {
                    Yp.register(this), t.register(this), i.game.once(i.Game.EVENT_ENGINE_INITED, this._precompile, this)
                }, n._precompile = function() {
                    for (var e = this, t = i.director.root, n = function(n) {
                            var i = e.shaders[n],
                                r = e.combinations[n];
                            if (!r) return "continue";
                            Object.keys(r).reduce((function(e, t) {
                                return e.reduce((function(e, n) {
                                    for (var i = r[t], o = 0; o < i.length; ++o) {
                                        var a = Z({}, n);
                                        a[t] = i[o], e.push(a)
                                    }
                                    return e
                                }), [])
                            }), [{}]).forEach((function(e) {
                                return Yp.getGFXShader(t.device, i.name, e, t.pipeline)
                            }))
                        }, r = 0; r < this.shaders.length; r++) n(r)
                }, n.destroy = function() {
                    return t.remove(this.name), e.prototype.destroy.call(this)
                }, n.initDefault = function(n) {
                    e.prototype.initDefault.call(this, n);
                    var i = t.get("unlit");
                    this.name = "unlit", this.shaders = i.shaders, this.combinations = i.combinations, this.techniques = i.techniques
                }, n.validate = function() {
                    return this.techniques.length > 0 && this.shaders.length > 0
                }, t
            }(Nf), bS._effects = {}, TS = ie((ES = RS).prototype, "techniques", [w_, F_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return []
                }
            }), AS = ie(ES.prototype, "shaders", [w_, F_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return []
                }
            }), xS = ie(ES.prototype, "combinations", [w_, F_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return []
                }
            }), CS = ie(ES.prototype, "hideInEditor", [w_, I_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return !1
                }
            }), SS = ES)) || SS);
            i.EffectAsset = US;
            var GS = new ue("RenderTex"),
                HS = new Fs;
            HS.endAccesses = [ka.FRAGMENT_SHADER_READ_TEXTURE];
            var kS, VS, WS, jS, qS, XS, YS, KS, ZS, QS, JS = new zs,
                $S = new Gs([HS], JS),
                eE = {
                    width: 1,
                    height: 1,
                    renderPassInfo: $S
                },
                tE = e("RenderTexture", (IS = A_("cc.RenderTexture"), PS = k_(), OS = V_(), DS = k_(), NS = V_(), IS((zS = function(e) {
                    function t() {
                        var t;
                        return ne(t = e.call(this) || this, "_width", BS, $(t)), ne(t, "_height", FS, $(t)), t._textureHash = 0, t._id = void 0, t._window = null, t._id = GS.getNewId(), t._textureHash = vc(t._id, 666), t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.getHash = function() {
                        return this._textureHash
                    }, n.initialize = function(e) {
                        this._name = e.name || "", this._width = e.width, this._height = e.height, this._initWindow(e)
                    }, n.reset = function(e) {
                        this.initialize(e)
                    }, n.destroy = function() {
                        return this._window && (i.director.root.destroyWindow(this._window), this._window = null), e.prototype.destroy.call(this)
                    }, n.resize = function(e, t) {
                        this._width = e, this._height = t, this._window && this._window.resize(e, t), this.emit("resize", this._window)
                    }, n.getGFXTexture = function() {
                        return this._window && this._window.framebuffer.colorTextures[0]
                    }, n.getGFXSampler = function() {
                        var e = i.director.root;
                        return cd.getSampler(e.device, qf)
                    }, n.getSamplerHash = function() {
                        return qf
                    }, n.onLoaded = function() {
                        this._initWindow(), this.loaded = !0, this.emit("load")
                    }, n._initWindow = function(e) {
                        var t = i.director.root;
                        eE.title = this._name, eE.width = this._width, eE.height = this._height, eE.renderPassInfo = e && e.passInfo ? e.passInfo : $S, this._window ? (this._window.destroy(), this._window.initialize(t.device, eE)) : this._window = t.createWindow(eE)
                    }, n.initDefault = function(t) {
                        e.prototype.initDefault.call(this, t), this._width = this._height = 1, this._initWindow()
                    }, n.validate = function() {
                        return this.width >= 1 && this.width <= 2048 && this.height >= 1 && this.height <= 2048
                    }, K(t, [{
                        key: "width",
                        get: function() {
                            return this._width
                        }
                    }, {
                        key: "height",
                        get: function() {
                            return this._height
                        }
                    }, {
                        key: "window",
                        get: function() {
                            return this._window
                        }
                    }]), t
                }(Nf), BS = ie((LS = zS).prototype, "_width", [w_, PS, OS], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 1
                    }
                }), FS = ie(LS.prototype, "_height", [w_, DS, NS], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 1
                    }
                }), MS = LS)) || MS));
            i.RenderTexture = tE;
            var nE = e("Material", (kS = A_("cc.Material"), VS = ef(US), kS((QS = function(e) {
                function t() {
                    var t;
                    return ne(t = e.call(this) || this, "_effectAsset", qS, $(t)), ne(t, "_techIdx", XS, $(t)), ne(t, "_defines", YS, $(t)), ne(t, "_states", KS, $(t)), ne(t, "_props", ZS, $(t)), t._passes = [], t._hash = 0, t.loaded = !1, t
                }
                Q(t, e), t.getHash = function(e) {
                    for (var t, n = 0, i = te(e.passes); !(t = i()).done;) n ^= t.value.hash;
                    return n
                };
                var n = t.prototype;
                return n.initialize = function(e) {
                    this._defines || (this._defines = []), this._states || (this._states = []), this._props || (this._props = []), void 0 !== e.technique && (this._techIdx = e.technique), e.effectAsset ? this._effectAsset = e.effectAsset : e.effectName && (this._effectAsset = US.get(e.effectName)), e.defines && this._prepareInfo(e.defines, this._defines), e.states && this._prepareInfo(e.states, this._states), this._update()
                }, n.reset = function(e) {
                    this.initialize(e)
                }, n.destroy = function() {
                    return this._doDestroy(), e.prototype.destroy.call(this)
                }, n.recompileShaders = function() {
                    console.warn("Shaders in material asset '" + this.name + "' cannot be modified at runtime, please instantiate the material first.")
                }, n.overridePipelineStates = function() {
                    console.warn("Pipeline states in material asset '" + this.name + "' cannot be modified at runtime, please instantiate the material first.")
                }, n.onLoaded = function() {
                    this._update(), this.loaded = !0, this.emit("load")
                }, n.resetUniforms = function(e) {
                    void 0 === e && (e = !0), this._props.length = this._passes.length;
                    for (var t = 0; t < this._props.length; t++) this._props[t] = {};
                    if (e)
                        for (var n, i = te(this._passes); !(n = i()).done;) {
                            var r = n.value;
                            r.resetUBOs(), r.resetTextures()
                        }
                }, n.setProperty = function(e, t, n) {
                    var i = !1;
                    if (void 0 === n)
                        for (var r = this._passes, o = r.length, a = 0; a < o; a++) {
                            var s = r[a];
                            this._uploadProperty(s, e, t) && (this._props[s.propertyIndex][e] = t, i = !0)
                        } else {
                            if (n >= this._passes.length) return void console.warn("illegal pass index: " + n + ".");
                            var c = this._passes[n];
                            this._uploadProperty(c, e, t) && (this._props[c.propertyIndex][e] = t, i = !0)
                        }
                    i || console.warn("illegal property name: " + e + ".")
                }, n.getProperty = function(e, t) {
                    if (void 0 === t)
                        for (var n = this._props, i = n.length, r = 0; r < i; r++) {
                            var o = n[r];
                            if (e in o) return o[e]
                        } else {
                            if (t >= this._props.length) return console.warn("illegal pass index: " + t + "."), null;
                            var a = this._props[this._passes[t].propertyIndex];
                            if (e in a) return a[e]
                        }
                    return null
                }, n.copy = function(e) {
                    this._techIdx = e._techIdx, this._props.length = e._props.length;
                    for (var t = 0; t < e._props.length; t++) this._props[t] = Z({}, e._props[t]);
                    this._defines.length = e._defines.length;
                    for (var n = 0; n < e._defines.length; n++) this._defines[n] = Z({}, e._defines[n]);
                    this._states.length = e._states.length;
                    for (var i = 0; i < e._states.length; i++) this._states[i] = Z({}, e._states[i]);
                    this._effectAsset = e._effectAsset, this._update()
                }, n._prepareInfo = function(e, t) {
                    var n = e;
                    if (!Array.isArray(n)) {
                        var i = this._effectAsset ? this._effectAsset.techniques[this._techIdx].passes.length : 1;
                        n = Array(i).fill(n)
                    }
                    for (var r = 0; r < n.length; ++r) Object.assign(t[r] || (t[r] = {}), n[r])
                }, n._createPasses = function() {
                    var e = this._effectAsset.techniques[this._techIdx || 0];
                    if (!e) return [];
                    for (var t = e.passes.length, n = [], r = 0; r < t; ++r) {
                        var o = e.passes[r],
                            a = o.passIndex = r,
                            s = o.defines = this._defines[a] || (this._defines[a] = {}),
                            c = o.stateOverrides = this._states[a] || (this._states[a] = {});
                        if (void 0 !== o.propertyIndex && (Object.assign(s, this._defines[o.propertyIndex]), Object.assign(c, this._states[o.propertyIndex])), void 0 !== o.embeddedMacros && Object.assign(s, o.embeddedMacros), !o.switch || s[o.switch]) {
                            var l = new om(i.director.root);
                            l.initialize(o), n.push(l)
                        }
                    }
                    return n
                }, n._update = function(e) {
                    var n = this;
                    if (void 0 === e && (e = !0), this._effectAsset) {
                        if (this._passes && this._passes.length)
                            for (var i, r = te(this._passes); !(i = r()).done;) i.value.destroy();
                        this._passes = this._createPasses();
                        var o = this._effectAsset.techniques[this._techIdx].passes.length;
                        if (this._props.length = o, e) this._passes.forEach((function(e, t) {
                            var i = n._props[t];
                            for (var r in i || (i = n._props[t] = {}), void 0 !== e.propertyIndex && Object.assign(i, n._props[e.propertyIndex]), i) n._uploadProperty(e, r, i[r])
                        }));
                        else
                            for (var a = 0; a < this._props.length; a++) this._props[a] = {}
                    }
                    this._hash = t.getHash(this)
                }, n._uploadProperty = function(e, t, n) {
                    var i = e.getHandle(t);
                    if (!i) return !1;
                    var r = om.getPropertyTypeFromHandle(i);
                    if (r === xp.BUFFER) Array.isArray(n) ? e.setUniformArray(i, n) : null !== n ? e.setUniform(i, n) : e.resetUniform(t);
                    else if (r === xp.TEXTURE)
                        if (Array.isArray(n))
                            for (var o = 0; o < n.length; o++) this._bindTexture(e, i, n[o], o);
                        else n ? this._bindTexture(e, i, n) : e.resetTexture(t);
                    return !0
                }, n._bindTexture = function(e, t, n, i) {
                    var r = om.getBindingFromHandle(t);
                    if (n instanceof Nc) e.bindTexture(r, n, i);
                    else if (n instanceof ud || n instanceof tE) {
                        var o = n.getGFXTexture();
                        if (!o || !o.width || !o.height) return;
                        e.bindTexture(r, o, i), e.bindSampler(r, n.getGFXSampler(), i)
                    }
                }, n._doDestroy = function() {
                    if (this._passes && this._passes.length)
                        for (var e, t = te(this._passes); !(e = t()).done;) e.value.destroy();
                    this._effectAsset = null, this._passes.length = 0, this._props.length = 0, this._defines.length = 0, this._states.length = 0
                }, n.initDefault = function(t) {
                    e.prototype.initDefault.call(this, t), this.initialize({
                        effectName: "unlit",
                        defines: {
                            USE_COLOR: !0
                        }
                    }), this.setProperty("mainColor", new yn("#ff00ff"))
                }, n.validate = function() {
                    return !!this._effectAsset && !this._effectAsset.isDefault && this.passes.length > 0
                }, K(t, [{
                    key: "effectAsset",
                    get: function() {
                        return this._effectAsset
                    }
                }, {
                    key: "effectName",
                    get: function() {
                        return this._effectAsset ? this._effectAsset.name : ""
                    }
                }, {
                    key: "technique",
                    get: function() {
                        return this._techIdx
                    }
                }, {
                    key: "passes",
                    get: function() {
                        return this._passes
                    }
                }, {
                    key: "hash",
                    get: function() {
                        return this._hash
                    }
                }, {
                    key: "parent",
                    get: function() {
                        return null
                    }
                }, {
                    key: "owner",
                    get: function() {
                        return null
                    }
                }]), t
            }(Nf), qS = ie((jS = QS).prototype, "_effectAsset", [VS], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return null
                }
            }), XS = ie(jS.prototype, "_techIdx", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return 0
                }
            }), YS = ie(jS.prototype, "_defines", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return []
                }
            }), KS = ie(jS.prototype, "_states", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return []
                }
            }), ZS = ie(jS.prototype, "_props", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return []
                }
            }), WS = jS)) || WS));
            i.Material = nE;
            var iE = $e({
                    Planar: 0,
                    ShadowMap: 1
                }),
                rE = $e({
                    HARD: 0,
                    FILTER_X5: 1,
                    FILTER_X9: 2,
                    FILTER_X25: 3
                }),
                oE = iE.ShadowMap + 1,
                aE = function() {
                    function e() {
                        this.sphere = new es(0, 0, 0, .01), this.maxReceived = 4, this._normal = new En(0, 1, 0), this._shadowColor = new yn(0, 0, 0, 76), this._matLight = new Bn, this._material = null, this._instancingMaterial = null, this._size = new Gn(512, 512), this._handle = 0, this._handle = Ao.alloc()
                    }
                    var t = e.prototype;
                    return t.getPlanarShader = function(e) {
                        return this._material || (this._material = new nE, this._material.initialize({
                            effectName: "planar-shadow"
                        }), Ao.set(this._handle, yo.PLANAR_PASS, this._material.passes[0].handle)), this._material.passes[0].getShaderVariant(e)
                    }, t.getPlanarInstanceShader = function(e) {
                        return this._instancingMaterial || (this._instancingMaterial = new nE, this._instancingMaterial.initialize({
                            effectName: "planar-shadow",
                            defines: {
                                USE_INSTANCING: !0
                            }
                        }), Ao.set(this._handle, yo.INSTANCE_PASS, this._instancingMaterial.passes[0].handle)), this._instancingMaterial.passes[0].getShaderVariant(e)
                    }, t.initialize = function(e) {
                        Ao.set(this._handle, yo.TYPE, e.enabled ? e.type : oE), Ao.set(this._handle, yo.NEAR, e.near), Ao.set(this._handle, yo.FAR, e.far), Ao.set(this._handle, yo.ASPECT, e.aspect), Ao.set(this._handle, yo.ORTHO_SIZE, e.orthoSize), this._size = e.shadowMapSize, Ao.setVec2(this._handle, yo.SIZE, this._size), Ao.set(this._handle, yo.PCF_TYPE, e.pcf), En.copy(this._normal, e.normal), Ao.setVec3(this._handle, yo.NORMAL, this._normal), Ao.set(this._handle, yo.DISTANCE, e.distance), this._shadowColor.set(e.shadowColor), Ao.setVec4(this._handle, yo.COLOR, this._shadowColor), Ao.set(this._handle, yo.BIAS, e.bias), Ao.set(this._handle, yo.PACKING, e.packing ? 1 : 0), Ao.set(this._handle, yo.LINEAR, e.linear ? 1 : 0), Ao.set(this._handle, yo.SELF_SHADOW, e.selfShadow ? 1 : 0), Ao.set(this._handle, yo.NORMAL_BIAS, e.normalBias), Ao.set(this._handle, yo.ENABLE, e.enabled ? 1 : 0), this.maxReceived = e.maxReceived, Ao.set(this._handle, yo.AUTO_ADAPT, e.autoAdapt ? 1 : 0)
                    }, t.activate = function() {
                        if (this.enabled) this.type === iE.ShadowMap ? this._updatePipeline() : this._updatePlanarInfo();
                        else {
                            var e = i.director.root;
                            e.pipeline.macros.CC_RECEIVE_SHADOW = 0, e.onGlobalPipelineStateChanged()
                        }
                    }, t._updatePlanarInfo = function() {
                        this._material || (this._material = new nE, this._material.initialize({
                            effectName: "planar-shadow"
                        }), Ao.set(this._handle, yo.PLANAR_PASS, this._material.passes[0].handle)), this._instancingMaterial || (this._instancingMaterial = new nE, this._instancingMaterial.initialize({
                            effectName: "planar-shadow",
                            defines: {
                                USE_INSTANCING: !0
                            }
                        }), Ao.set(this._handle, yo.INSTANCE_PASS, this._instancingMaterial.passes[0].handle));
                        var e = i.director.root;
                        e.pipeline.macros.CC_RECEIVE_SHADOW = 0, e.onGlobalPipelineStateChanged()
                    }, t._updatePipeline = function() {
                        var e = i.director.root;
                        e.pipeline.macros.CC_RECEIVE_SHADOW = 1, e.onGlobalPipelineStateChanged()
                    }, t.destroy = function() {
                        this._material && this._material.destroy(), this._instancingMaterial && this._instancingMaterial.destroy(), this._handle && (Ao.free(this._handle), this._handle = 0), this.sphere.destroy()
                    }, K(e, [{
                        key: "enabled",
                        get: function() {
                            return !!Ao.get(this._handle, yo.ENABLE)
                        },
                        set: function(e) {
                            Ao.set(this._handle, yo.ENABLE, e ? 1 : 0), e || Ao.set(this._handle, yo.TYPE, oE), this.activate()
                        }
                    }, {
                        key: "normal",
                        get: function() {
                            return this._normal
                        },
                        set: function(e) {
                            En.copy(this._normal, e), Ao.setVec3(this._handle, yo.NORMAL, this._normal)
                        }
                    }, {
                        key: "distance",
                        get: function() {
                            return Ao.get(this._handle, yo.DISTANCE)
                        },
                        set: function(e) {
                            Ao.set(this._handle, yo.DISTANCE, e)
                        }
                    }, {
                        key: "shadowColor",
                        get: function() {
                            return this._shadowColor
                        },
                        set: function(e) {
                            this._shadowColor = e, Ao.setVec4(this._handle, yo.COLOR, e)
                        }
                    }, {
                        key: "type",
                        get: function() {
                            return Ao.get(this._handle, yo.TYPE)
                        },
                        set: function(e) {
                            Ao.set(this._handle, yo.TYPE, this.enabled ? e : oE), this.activate()
                        }
                    }, {
                        key: "near",
                        get: function() {
                            return Ao.get(this._handle, yo.NEAR)
                        },
                        set: function(e) {
                            Ao.set(this._handle, yo.NEAR, e)
                        }
                    }, {
                        key: "far",
                        get: function() {
                            return Ao.get(this._handle, yo.FAR)
                        },
                        set: function(e) {
                            Ao.set(this._handle, yo.FAR, e)
                        }
                    }, {
                        key: "aspect",
                        get: function() {
                            return Ao.get(this._handle, yo.ASPECT)
                        },
                        set: function(e) {
                            Ao.set(this._handle, yo.ASPECT, e)
                        }
                    }, {
                        key: "orthoSize",
                        get: function() {
                            return Ao.get(this._handle, yo.ORTHO_SIZE)
                        },
                        set: function(e) {
                            Ao.set(this._handle, yo.ORTHO_SIZE, e)
                        }
                    }, {
                        key: "size",
                        get: function() {
                            return this._size
                        },
                        set: function(e) {
                            this._size = e, Ao.setVec2(this._handle, yo.SIZE, this._size)
                        }
                    }, {
                        key: "pcf",
                        get: function() {
                            return Ao.get(this._handle, yo.PCF_TYPE)
                        },
                        set: function(e) {
                            Ao.set(this._handle, yo.PCF_TYPE, e)
                        }
                    }, {
                        key: "shadowMapDirty",
                        get: function() {
                            return !!Ao.get(this._handle, yo.SHADOW_MAP_DIRTY)
                        },
                        set: function(e) {
                            Ao.set(this._handle, yo.SHADOW_MAP_DIRTY, e ? 1 : 0)
                        }
                    }, {
                        key: "bias",
                        get: function() {
                            return Ao.get(this._handle, yo.BIAS)
                        },
                        set: function(e) {
                            Ao.set(this._handle, yo.BIAS, e)
                        }
                    }, {
                        key: "packing",
                        get: function() {
                            return !!Ao.get(this._handle, yo.PACKING)
                        },
                        set: function(e) {
                            Ao.set(this._handle, yo.PACKING, e ? 1 : 0)
                        }
                    }, {
                        key: "linear",
                        get: function() {
                            return !!Ao.get(this._handle, yo.LINEAR)
                        },
                        set: function(e) {
                            Ao.set(this._handle, yo.LINEAR, e ? 1 : 0)
                        }
                    }, {
                        key: "selfShadow",
                        get: function() {
                            return !!Ao.get(this._handle, yo.SELF_SHADOW)
                        },
                        set: function(e) {
                            Ao.set(this._handle, yo.SELF_SHADOW, e ? 1 : 0)
                        }
                    }, {
                        key: "normalBias",
                        get: function() {
                            return Ao.get(this._handle, yo.NORMAL_BIAS)
                        },
                        set: function(e) {
                            Ao.set(this._handle, yo.NORMAL_BIAS, e)
                        }
                    }, {
                        key: "autoAdapt",
                        get: function() {
                            return !!Ao.get(this._handle, yo.AUTO_ADAPT)
                        },
                        set: function(e) {
                            Ao.set(this._handle, yo.AUTO_ADAPT, e ? 1 : 0)
                        }
                    }, {
                        key: "matLight",
                        get: function() {
                            return this._matLight
                        }
                    }, {
                        key: "material",
                        get: function() {
                            return this._material
                        }
                    }, {
                        key: "instancingMaterial",
                        get: function() {
                            return this._instancingMaterial
                        }
                    }, {
                        key: "handle",
                        get: function() {
                            return this._handle
                        }
                    }]), e
                }();
            aE.MAX_FAR = 2e3, aE.COEFFICIENT_OF_EXPANSION = 2 * Math.sqrt(3), i.Shadows = aE;
            var sE = new En,
                cE = new En,
                lE = new En,
                uE = new Bn,
                hE = new tu,
                _E = !1,
                fE = [],
                dE = es.create(0, 0, 0, 1),
                pE = new Jn((function() {
                    return {
                        model: null,
                        depth: 0
                    }
                }), 128),
                mE = new Jn((function() {
                    return {
                        model: null,
                        depth: 0
                    }
                }), 128);

            function gE(e, t) {
                var n = 0;
                e.node && (En.subtract(sE, e.node.worldPosition, t.position), n = En.dot(sE, t.forward));
                var i = pE.alloc();
                return i.model = e, i.depth = n, i
            }

            function vE(e, t) {
                var n = 0;
                e.node && (En.subtract(sE, e.node.worldPosition, t.position), n = En.dot(sE, t.forward));
                var i = mE.alloc();
                return i.model = e, i.depth = n, i
            }

            function yE(e, t, n, i) {
                var r = e.pipelineSceneData.shadows;
                En.negate(cE, n);
                var o = r.sphere.radius * aE.COEFFICIENT_OF_EXPANSION;
                return En.multiplyScalar(lE, cE, o), En.add(lE, lE, r.sphere.center), i.set(lE), Bn.fromRT(uE, t, lE), uE
            }

            function SE(e, t, n) {
                var i = t.direction,
                    r = e.normal,
                    o = e.distance + .001,
                    a = 1 / En.dot(r, i),
                    s = i.x * a,
                    c = i.y * a,
                    l = i.z * a,
                    u = r.x,
                    h = r.y,
                    _ = r.z,
                    f = e.matLight;
                f.m00 = 1 - u * s, f.m01 = -u * c, f.m02 = -u * l, f.m03 = 0, f.m04 = -h * s, f.m05 = 1 - h * c, f.m06 = -h * l, f.m07 = 0, f.m08 = -_ * s, f.m09 = -_ * c, f.m10 = 1 - _ * l, f.m11 = 0, f.m12 = s * o, f.m13 = c * o, f.m14 = l * o, f.m15 = 1, Bn.toArray(n, f, Ku.MAT_LIGHT_PLANE_PROJ_OFFSET)
            }

            function EE(e, t) {
                var n = t.scene,
                    i = n.mainLight,
                    r = e.pipelineSceneData,
                    o = r.shadows,
                    a = r.skybox,
                    s = r.renderObjects;
                pE.freeArray(s), s.length = 0;
                var c = null;
                _E = !1, o.enabled && (e.pipelineUBO.updateShadowUBORange(Ku.SHADOW_COLOR_OFFSET, o.shadowColor), o.type === iE.ShadowMap && (c = e.pipelineSceneData.shadowObjects, mE.freeArray(c), c.length = 0)), i && o.type === iE.Planar && function(e, t) {
                    var n = e.pipelineSceneData.shadows,
                        i = t.direction,
                        r = n.normal,
                        o = n.distance + .001,
                        a = 1 / En.dot(r, i),
                        s = i.x * a,
                        c = i.y * a,
                        l = i.z * a,
                        u = r.x,
                        h = r.y,
                        _ = r.z,
                        f = n.matLight;
                    f.m00 = 1 - u * s, f.m01 = -u * c, f.m02 = -u * l, f.m03 = 0, f.m04 = -h * s, f.m05 = 1 - h * c, f.m06 = -h * l, f.m07 = 0, f.m08 = -_ * s, f.m09 = -_ * c, f.m10 = 1 - _ * l, f.m11 = 0, f.m12 = s * o, f.m13 = c * o, f.m14 = l * o, f.m15 = 1, e.pipelineUBO.updateShadowUBORange(Ku.MAT_LIGHT_PLANE_PROJ_OFFSET, n.matLight)
                }(e, i), a.enabled && a.model && t.clearFlag & h_ && s.push(gE(a.model, t));
                for (var l = n.models, u = 0; u < l.length; u++) {
                    var h = l[u];
                    if (h.enabled && (h.node && (t.visibility & h.node.layer) === h.node.layer || t.visibility & h.visFlags)) {
                        if (null != c && h.castShadow && h.worldBounds && (_E || (hE.copy(h.worldBounds), _E = !0), tu.merge(hE, hE, h.worldBounds), c.push(vE(h, t))), h.worldBounds && !Vl.aabbFrustum(h.worldBounds, t.frustum)) continue;
                        s.push(gE(h, t))
                    }
                }
                hE && tu.toBoundingSphere(o.sphere, hE)
            }
            var TE = new Bn,
                AE = new Bn,
                xE = new En,
                CE = new Wn,
                bE = function() {
                    function e() {
                        this._globalUBO = new Float32Array(Xu.COUNT), this._cameraUBO = new Float32Array(Yu.COUNT), this._shadowUBO = new Float32Array(Ku.COUNT)
                    }
                    e.updateGlobalUBOView = function(e, t) {
                        var n = e.device,
                            r = i.director.root,
                            o = t,
                            a = Math.floor(n.width),
                            s = Math.floor(n.height);
                        o[Xu.TIME_OFFSET] = r.cumulativeTime, o[Xu.TIME_OFFSET + 1] = r.frameTime, o[Xu.TIME_OFFSET + 2] = i.director.getTotalFrames(), o[Xu.SCREEN_SIZE_OFFSET] = n.width, o[Xu.SCREEN_SIZE_OFFSET + 1] = n.height, o[Xu.SCREEN_SIZE_OFFSET + 2] = 1 / n.width, o[Xu.SCREEN_SIZE_OFFSET + 3] = 1 / n.height, o[Xu.NATIVE_SIZE_OFFSET] = a, o[Xu.NATIVE_SIZE_OFFSET + 1] = s, o[Xu.NATIVE_SIZE_OFFSET + 2] = 1 / o[Xu.NATIVE_SIZE_OFFSET], o[Xu.NATIVE_SIZE_OFFSET + 3] = 1 / o[Xu.NATIVE_SIZE_OFFSET + 1]
                    }, e.updateCameraUBOView = function(e, t, n) {
                        var r = e.device,
                            o = (n.scene ? n.scene : i.director.getScene().renderScene).mainLight,
                            a = e.pipelineSceneData,
                            s = a.ambient,
                            c = a.fog,
                            l = Math.floor(r.width),
                            u = Math.floor(r.height),
                            h = t,
                            _ = n.exposure,
                            f = a.isHDR,
                            d = a.shadingScale,
                            p = a.fpScale;
                        if (h[Yu.SCREEN_SCALE_OFFSET] = n.width / l * d, h[Yu.SCREEN_SCALE_OFFSET + 1] = n.height / u * d, h[Yu.SCREEN_SCALE_OFFSET + 2] = 1 / h[Yu.SCREEN_SCALE_OFFSET], h[Yu.SCREEN_SCALE_OFFSET + 3] = 1 / h[Yu.SCREEN_SCALE_OFFSET + 1], h[Yu.EXPOSURE_OFFSET] = _, h[Yu.EXPOSURE_OFFSET + 1] = 1 / _, h[Yu.EXPOSURE_OFFSET + 2] = f ? 1 : 0, h[Yu.EXPOSURE_OFFSET + 3] = p / _, o) {
                            if (En.toArray(h, o.direction, Yu.MAIN_LIT_DIR_OFFSET), En.toArray(h, o.color, Yu.MAIN_LIT_COLOR_OFFSET), o.useColorTemperature) {
                                var m = o.colorTemperatureRGB;
                                h[Yu.MAIN_LIT_COLOR_OFFSET] *= m.x, h[Yu.MAIN_LIT_COLOR_OFFSET + 1] *= m.y, h[Yu.MAIN_LIT_COLOR_OFFSET + 2] *= m.z
                            }
                            h[Yu.MAIN_LIT_COLOR_OFFSET + 3] = f ? o.illuminance * p : o.illuminance * _
                        } else En.toArray(h, En.UNIT_Z, Yu.MAIN_LIT_DIR_OFFSET), Wn.toArray(h, Wn.ZERO, Yu.MAIN_LIT_COLOR_OFFSET);
                        var g = s.colorArray;
                        g[3] = f ? s.skyIllum * p : s.skyIllum * _, h.set(g, Yu.AMBIENT_SKY_OFFSET), h.set(s.albedoArray, Yu.AMBIENT_GROUND_OFFSET), Bn.toArray(h, n.matView, Yu.MAT_VIEW_OFFSET), Bn.toArray(h, n.node.worldMatrix, Yu.MAT_VIEW_INV_OFFSET), En.toArray(h, n.position, Yu.CAMERA_POS_OFFSET), Bn.toArray(h, n.matProj, Yu.MAT_PROJ_OFFSET), Bn.toArray(h, n.matProjInv, Yu.MAT_PROJ_INV_OFFSET), Bn.toArray(h, n.matViewProj, Yu.MAT_VIEW_PROJ_OFFSET), Bn.toArray(h, n.matViewProjInv, Yu.MAT_VIEW_PROJ_INV_OFFSET), h[Yu.CAMERA_POS_OFFSET + 3] = this.getCombineSignY(), h.set(c.colorArray, Yu.GLOBAL_FOG_COLOR_OFFSET), h[Yu.GLOBAL_FOG_BASE_OFFSET] = c.fogStart, h[Yu.GLOBAL_FOG_BASE_OFFSET + 1] = c.fogEnd, h[Yu.GLOBAL_FOG_BASE_OFFSET + 2] = c.fogDensity, h[Yu.GLOBAL_FOG_ADD_OFFSET] = c.fogTop, h[Yu.GLOBAL_FOG_ADD_OFFSET + 1] = c.fogRange, h[Yu.GLOBAL_FOG_ADD_OFFSET + 2] = c.fogAtten
                    }, e.updateShadowUBOView = function(e, t, n) {
                        var i = e.device,
                            r = n.scene.mainLight,
                            o = e.pipelineSceneData.shadows,
                            a = t;
                        if (o.enabled) {
                            if (r && o.type === iE.ShadowMap) {
                                var s, c = 0,
                                    l = 0,
                                    u = 0;
                                if (o.autoAdapt) {
                                    s = yE(e, r.node.getWorldRotation(), r.direction, xE);
                                    var h = o.sphere.radius;
                                    c = h * o.aspect, l = h;
                                    var _ = En.distance(o.sphere.center, xE);
                                    u = Math.min(_ * aE.COEFFICIENT_OF_EXPANSION, aE.MAX_FAR)
                                } else s = r.node.getWorldMatrix(), c = o.orthoSize * o.aspect, l = o.orthoSize, u = o.far;
                                Bn.toArray(a, s, Ku.MAT_LIGHT_VIEW_OFFSET), Bn.invert(TE, s), Bn.ortho(AE, -c, c, -l, l, o.near, u, i.capabilities.clipSpaceMinZ, i.capabilities.clipSpaceSignY), Bn.multiply(AE, AE, TE), Bn.toArray(a, AE, Ku.MAT_LIGHT_VIEW_PROJ_OFFSET);
                                var f = n_(i),
                                    d = o.linear && f ? 1 : 0;
                                a[Ku.SHADOW_NEAR_FAR_LINEAR_SELF_INFO_OFFSET + 0] = o.near, a[Ku.SHADOW_NEAR_FAR_LINEAR_SELF_INFO_OFFSET + 1] = u, a[Ku.SHADOW_NEAR_FAR_LINEAR_SELF_INFO_OFFSET + 2] = d, a[Ku.SHADOW_NEAR_FAR_LINEAR_SELF_INFO_OFFSET + 3] = o.selfShadow ? 1 : 0, a[Ku.SHADOW_WIDTH_HEIGHT_PCF_BIAS_INFO_OFFSET + 0] = o.size.x, a[Ku.SHADOW_WIDTH_HEIGHT_PCF_BIAS_INFO_OFFSET + 1] = o.size.y, a[Ku.SHADOW_WIDTH_HEIGHT_PCF_BIAS_INFO_OFFSET + 2] = o.pcf, a[Ku.SHADOW_WIDTH_HEIGHT_PCF_BIAS_INFO_OFFSET + 3] = o.bias;
                                var p = o.packing ? 1 : f ? 0 : 1;
                                a[Ku.SHADOW_LIGHT_PACKING_NBIAS_NULL_INFO_OFFSET + 0] = 0, a[Ku.SHADOW_LIGHT_PACKING_NBIAS_NULL_INFO_OFFSET + 1] = p, a[Ku.SHADOW_LIGHT_PACKING_NBIAS_NULL_INFO_OFFSET + 2] = o.normalBias, a[Ku.SHADOW_LIGHT_PACKING_NBIAS_NULL_INFO_OFFSET + 3] = 0
                            } else r && o.type === iE.Planar && SE(o, r, a);
                            yn.toArray(a, o.shadowColor, Ku.SHADOW_COLOR_OFFSET)
                        }
                    }, e.updateShadowUBOLightView = function(e, t, n) {
                        var i, r = e.device,
                            o = e.pipelineSceneData.shadows,
                            a = t,
                            s = n_(r),
                            c = o.linear && s ? 1 : 0,
                            l = o.packing ? 1 : s ? 0 : 1,
                            u = 0,
                            h = 0,
                            _ = 0;
                        switch (n.type) {
                            case sm.DIRECTIONAL:
                                if (n.update(), o.autoAdapt) {
                                    var f = n.node;
                                    f && (i = yE(e, f.getWorldRotation(), n.direction, xE));
                                    var d = o.sphere.radius;
                                    u = d * o.aspect, h = d;
                                    var p = En.distance(o.sphere.center, xE);
                                    _ = Math.min(p * aE.COEFFICIENT_OF_EXPANSION, aE.MAX_FAR)
                                } else i = n.node.getWorldMatrix(), u = o.orthoSize * o.aspect, h = o.orthoSize, _ = o.far;
                                Bn.toArray(a, i, Ku.MAT_LIGHT_VIEW_OFFSET), Bn.invert(TE, i), CE.set(o.near, _, c, o.selfShadow ? 1 : 0), Wn.toArray(a, CE, Ku.SHADOW_NEAR_FAR_LINEAR_SELF_INFO_OFFSET), CE.set(0, l, o.normalBias, 0), Wn.toArray(a, CE, Ku.SHADOW_LIGHT_PACKING_NBIAS_NULL_INFO_OFFSET), Bn.ortho(AE, -u, u, -h, h, o.near, _, r.capabilities.clipSpaceMinZ, r.capabilities.clipSpaceSignY);
                                break;
                            case sm.SPOT:
                                Bn.toArray(a, n.node.getWorldMatrix(), Ku.MAT_LIGHT_VIEW_OFFSET), Bn.invert(TE, n.node.getWorldMatrix()), CE.set(.01, n.range, c, o.selfShadow ? 1 : 0), Wn.toArray(a, CE, Ku.SHADOW_NEAR_FAR_LINEAR_SELF_INFO_OFFSET), CE.set(1, l, o.normalBias, 0), Wn.toArray(a, CE, Ku.SHADOW_LIGHT_PACKING_NBIAS_NULL_INFO_OFFSET), Bn.perspective(AE, n.spotAngle, n.aspect, .001, n.range)
                        }
                        Bn.multiply(AE, AE, TE), Bn.toArray(a, AE, Ku.MAT_LIGHT_VIEW_PROJ_OFFSET), CE.set(o.size.x, o.size.y, o.pcf, o.bias), Wn.toArray(a, CE, Ku.SHADOW_WIDTH_HEIGHT_PCF_BIAS_INFO_OFFSET), yn.toArray(a, o.shadowColor, Ku.SHADOW_COLOR_OFFSET)
                    }, e.getCombineSignY = function() {
                        return e._combineSignY
                    };
                    var t = e.prototype;
                    return t._initCombineSignY = function() {
                        var t = this._device;
                        e._combineSignY = .5 * t.capabilities.screenSpaceSignY + .5 << 1 | .5 * t.capabilities.clipSpaceSignY + .5
                    }, t.activate = function(e, t) {
                        this._device = e, this._pipeline = t;
                        var n = this._pipeline.descriptorSet;
                        this._initCombineSignY();
                        var i = e.createBuffer(new gs(xa.UNIFORM | xa.TRANSFER_DST, Ra.HOST | Ra.DEVICE, Xu.SIZE, Xu.SIZE));
                        n.bindBuffer(Xu.BINDING, i);
                        var r = e.createBuffer(new gs(xa.UNIFORM | xa.TRANSFER_DST, Ra.HOST | Ra.DEVICE, Yu.SIZE, Yu.SIZE));
                        n.bindBuffer(Yu.BINDING, r);
                        var o = e.createBuffer(new gs(xa.UNIFORM | xa.TRANSFER_DST, Ra.HOST | Ra.DEVICE, Ku.SIZE, Ku.SIZE));
                        n.bindBuffer(Ku.BINDING, o)
                    }, t.updateGlobalUBO = function() {
                        var t = this._pipeline.descriptorSet,
                            n = this._pipeline.commandBuffers;
                        t.update(), e.updateGlobalUBOView(this._pipeline, this._globalUBO), n[0].updateBuffer(t.getBuffer(Xu.BINDING), this._globalUBO)
                    }, t.updateCameraUBO = function(t) {
                        var n = this._pipeline.descriptorSet,
                            i = this._pipeline.commandBuffers;
                        e.updateCameraUBOView(this._pipeline, this._cameraUBO, t), i[0].updateBuffer(n.getBuffer(Yu.BINDING), this._cameraUBO)
                    }, t.updateShadowUBO = function(t) {
                        var n = this._pipeline.pipelineSceneData;
                        if (n.shadows.enabled) {
                            var i = this._pipeline.descriptorSet,
                                r = this._pipeline.commandBuffers,
                                o = n.shadowFrameBufferMap,
                                a = t.scene.mainLight;
                            i.update(), a && o.has(a) && i.bindTexture(Zu, o.get(a).colorTextures[0]), e.updateShadowUBOView(this._pipeline, this._shadowUBO, t), r[0].updateBuffer(i.getBuffer(Ku.BINDING), this._shadowUBO)
                        }
                    }, t.updateShadowUBOLight = function(t) {
                        var n = this._pipeline.descriptorSet;
                        e.updateShadowUBOLightView(this._pipeline, this._shadowUBO, t), n.getBuffer(Ku.BINDING).update(this._shadowUBO)
                    }, t.updateShadowUBORange = function(e, t) {
                        t instanceof Bn ? Bn.toArray(this._shadowUBO, t, e) : t instanceof yn && yn.toArray(this._shadowUBO, t, e)
                    }, t.destroy = function() {}, e
                }();
            bE._combineSignY = 0;
            var RE = $e({
                    LINEAR: 0,
                    EXP: 1,
                    EXP_SQUARED: 2,
                    LAYERED: 3
                }),
                wE = RE.LAYERED + 1,
                IE = function() {
                    function e() {
                        this._fogColor = new yn("#C8C8C8"), this._colorArray = new Float32Array([.2, .2, .2, 1]), this._handle = 0, this._handle = So.alloc()
                    }
                    var t = e.prototype;
                    return t.initialize = function(e) {
                        So.set(this._handle, po.ENABLE, e.enabled ? 1 : 0), So.set(this._handle, po.TYPE, e.enabled ? e.type : wE), this._fogColor.set(e.fogColor), yn.toArray(this._colorArray, this._fogColor), So.setVec4(this._handle, po.COLOR, this._fogColor), So.set(this._handle, po.DENSITY, e.fogDensity), So.set(this._handle, po.START, e.fogStart), So.set(this._handle, po.END, e.fogEnd), So.set(this._handle, po.ATTEN, e.fogAtten), So.set(this._handle, po.TOP, e.fogTop), So.set(this._handle, po.RANGE, e.fogRange)
                    }, t.activate = function() {
                        this._updatePipeline()
                    }, t._updatePipeline = function() {
                        var e = i.director.root,
                            t = this.enabled ? this.type : wE,
                            n = e.pipeline;
                        n.macros.CC_USE_FOG !== t && (n.macros.CC_USE_FOG = t, e.onGlobalPipelineStateChanged())
                    }, t.destroy = function() {
                        this._handle && (So.free(this._handle), this._handle = 0)
                    }, K(e, [{
                        key: "enabled",
                        get: function() {
                            return So.get(this._handle, po.ENABLE)
                        },
                        set: function(e) {
                            So.set(this._handle, po.ENABLE, e ? 1 : 0), e || So.set(this._handle, po.TYPE, wE), e ? this.activate() : this._updatePipeline()
                        }
                    }, {
                        key: "fogColor",
                        get: function() {
                            return this._fogColor
                        },
                        set: function(e) {
                            this._fogColor.set(e), yn.toArray(this._colorArray, this._fogColor), So.setVec4(this._handle, po.COLOR, this._fogColor)
                        }
                    }, {
                        key: "type",
                        get: function() {
                            return So.get(this._handle, po.TYPE)
                        },
                        set: function(e) {
                            So.set(this._handle, po.TYPE, this.enabled ? e : wE), this.enabled && this._updatePipeline()
                        }
                    }, {
                        key: "fogDensity",
                        get: function() {
                            return So.get(this._handle, po.DENSITY)
                        },
                        set: function(e) {
                            So.set(this._handle, po.DENSITY, e)
                        }
                    }, {
                        key: "fogStart",
                        get: function() {
                            return So.get(this._handle, po.START)
                        },
                        set: function(e) {
                            So.set(this._handle, po.START, e)
                        }
                    }, {
                        key: "fogEnd",
                        get: function() {
                            return So.get(this._handle, po.END)
                        },
                        set: function(e) {
                            So.set(this._handle, po.END, e)
                        }
                    }, {
                        key: "fogAtten",
                        get: function() {
                            return So.get(this._handle, po.ATTEN)
                        },
                        set: function(e) {
                            So.set(this._handle, po.ATTEN, e)
                        }
                    }, {
                        key: "fogTop",
                        get: function() {
                            return So.get(this._handle, po.TOP)
                        },
                        set: function(e) {
                            So.set(this._handle, po.TOP, e)
                        }
                    }, {
                        key: "fogRange",
                        get: function() {
                            return So.get(this._handle, po.RANGE)
                        },
                        set: function(e) {
                            So.set(this._handle, po.RANGE, e)
                        }
                    }, {
                        key: "colorArray",
                        get: function() {
                            return this._colorArray
                        }
                    }, {
                        key: "handle",
                        get: function() {
                            return this._handle
                        }
                    }]), e
                }();
            i.Fog = IE;
            var PE = function(e) {
                    function t(t, n) {
                        var i;
                        (i = e.call(this, t.root) || this)._parent = void 0, i._owner = void 0, i._dontNotify = !1, i._parent = t, i._owner = n, i._doInit(i._parent, !0);
                        for (var r = 0; r < i._shaderInfo.blocks.length; r++) {
                            var o = i._shaderInfo.blocks[r],
                                a = i._blocks[o.binding],
                                s = i._parent.blocks[o.binding];
                            a.set(s)
                        }
                        i._rootBufferDirty = !0;
                        for (var c = i._parent, l = 0; l < i._shaderInfo.samplerTextures.length; l++)
                            for (var u = i._shaderInfo.samplerTextures[l], h = 0; h < u.count; h++) {
                                var _ = c._descriptorSet.getSampler(u.binding, h),
                                    f = c._descriptorSet.getTexture(u.binding, h);
                                i._descriptorSet.bindSampler(u.binding, _, h), i._descriptorSet.bindTexture(u.binding, f, h)
                            }
                        return e.prototype.tryCompile.call($(i)), i
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.overridePipelineStates = function(e, t) {
                        this._bs.reset(), this._rs.reset(), this._dss.reset(), om.fillPipelineInfo(this, e), om.fillPipelineInfo(this, t), this._onStateChange()
                    }, n.tryCompile = function(t) {
                        if (t && !Gp(this._defines, t)) return !1;
                        var n = e.prototype.tryCompile.call(this);
                        return this._onStateChange(), n
                    }, n.beginChangeStatesSilently = function() {
                        this._dontNotify = !0
                    }, n.endChangeStatesSilently = function() {
                        this._dontNotify = !1
                    }, n._syncBatchingScheme = function() {
                        this._defines.USE_BATCHING = this._defines.USE_INSTANCING = !1, Mr.set(this._handle, gr.BATCHING_SCHEME, 0)
                    }, n._onStateChange = function() {
                        Mr.set(this._handle, gr.HASH, om.getPassHash(this, this._hShaderDefault)), this._owner.onPassStateChange(this._dontNotify)
                    }, K(t, [{
                        key: "parent",
                        get: function() {
                            return this._parent
                        }
                    }]), t
                }(om),
                OE = function(e) {
                    function t(t) {
                        var n;
                        return (n = e.call(this) || this)._passes = [], n._parent = void 0, n._owner = void 0, n._subModelIdx = 0, n._parent = t.parent, n._owner = t.owner || null, n._subModelIdx = t.subModelIdx || 0, n.copy(n._parent), n
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.recompileShaders = function(e, t) {
                        if (this._passes && this.effectAsset)
                            if (void 0 === t)
                                for (var n, i = te(this._passes); !(n = i()).done;) n.value.tryCompile(e);
                            else this._passes[t].tryCompile(e)
                    }, n.overridePipelineStates = function(e, t) {
                        if (this._passes && this.effectAsset) {
                            var n = this.effectAsset.techniques[this.technique].passes;
                            if (void 0 === t)
                                for (var i = 0; i < this._passes.length; i++) {
                                    var r = this._passes[i],
                                        o = this._states[i] || (this._states[i] = {});
                                    for (var a in e) o[a] = e[a];
                                    r.overridePipelineStates(n[r.passIndex], o)
                                } else {
                                    var s = this._states[t] || (this._states[t] = {});
                                    for (var c in e) s[c] = e[c];
                                    this._passes[t].overridePipelineStates(n[t], s)
                                }
                        }
                    }, n.destroy = function() {
                        return this._doDestroy(), !0
                    }, n.onPassStateChange = function(e) {
                        this._hash = nE.getHash(this), !e && this._owner && this._owner._onRebuildPSO(this._subModelIdx, this)
                    }, n._createPasses = function() {
                        var e = [],
                            t = this._parent.passes;
                        if (!t) return e;
                        for (var n = 0; n < t.length; ++n) e.push(new PE(t[n], this));
                        return e
                    }, K(t, [{
                        key: "parent",
                        get: function() {
                            return this._parent
                        }
                    }, {
                        key: "owner",
                        get: function() {
                            return this._owner
                        }
                    }]), t
                }(nE),
                DE = null,
                NE = null,
                ME = function() {
                    function e() {
                        this._envmap = null, this._globalDescriptorSet = null, this._model = null, this._default = null, this._handle = 0, this._handle = go.alloc()
                    }
                    var t = e.prototype;
                    return t.initialize = function(e) {
                        go.set(this._handle, _o.ENABLE, e.enabled ? 1 : 0), go.set(this._handle, _o.USE_IBL, e.useIBL ? 1 : 0), go.set(this._handle, _o.IS_RGBE, e.isRGBE ? 1 : 0), this._envmap = e.envmap
                    }, t.activate = function() {
                        var e = i.director.root.pipeline,
                            t = e.pipelineSceneData.ambient;
                        if (this._globalDescriptorSet = e.descriptorSet, this._default = em.get("default-cube-texture"), this._model || (this._model = i.director.root.createModel(i.renderer.scene.Model), this._model._initLocalDescriptors = function() {}), go.set(this._handle, _o.MODEL, this._model.handle), this._envmap || (this._envmap = this._default), t.albedoArray[3] = this._envmap.mipmapLevel, NE) NE.recompileShaders({
                            USE_RGBE_CUBEMAP: this.isRGBE
                        });
                        else {
                            var n = new nE;
                            n.initialize({
                                effectName: "skybox",
                                defines: {
                                    USE_RGBE_CUBEMAP: this.isRGBE
                                }
                            }), NE = new OE({
                                parent: n
                            })
                        }
                        this.enabled && (DE || (DE = i.utils.createMesh(i.primitives.box({
                            width: 2,
                            height: 2,
                            length: 2
                        }))), this._model.initSubModel(0, DE.renderingSubMeshes[0], NE)), this._updateGlobalBinding(), this._updatePipeline()
                    }, t._updatePipeline = function() {
                        var e = this.useIBL ? this.isRGBE ? 2 : 1 : 0,
                            t = i.director.root,
                            n = t.pipeline;
                        n.macros.CC_USE_IBL !== e && (n.macros.CC_USE_IBL = e, t.onGlobalPipelineStateChanged())
                    }, t._updateGlobalBinding = function() {
                        var e = this.envmap.getGFXTexture(),
                            t = cd.getSampler(i.director._device, this.envmap.getSamplerHash());
                        this._globalDescriptorSet.bindSampler(dh, t), this._globalDescriptorSet.bindTexture(dh, e)
                    }, t.destroy = function() {
                        this._handle && (go.free(this._handle), this._handle = 0)
                    }, K(e, [{
                        key: "model",
                        get: function() {
                            return this._model
                        }
                    }, {
                        key: "enabled",
                        get: function() {
                            return go.get(this._handle, _o.ENABLE)
                        },
                        set: function(e) {
                            e ? this.activate() : this._updatePipeline(), go.set(this._handle, _o.ENABLE, e ? 1 : 0)
                        }
                    }, {
                        key: "useIBL",
                        get: function() {
                            return go.get(this._handle, _o.USE_IBL)
                        },
                        set: function(e) {
                            go.set(this._handle, _o.USE_IBL, e ? 1 : 0), this._updatePipeline()
                        }
                    }, {
                        key: "isRGBE",
                        get: function() {
                            return go.get(this._handle, _o.IS_RGBE)
                        },
                        set: function(e) {
                            e && (NE && NE.recompileShaders({
                                USE_RGBE_CUBEMAP: e
                            }), this._model && this._model.setSubModelMaterial(0, NE)), go.set(this._handle, _o.IS_RGBE, e ? 1 : 0), this._updatePipeline()
                        }
                    }, {
                        key: "envmap",
                        get: function() {
                            return this._envmap
                        },
                        set: function(e) {
                            this._envmap = e || this._default, this._envmap && (i.director.root.pipeline.pipelineSceneData.ambient.albedoArray[3] = this._envmap.mipmapLevel, this._updateGlobalBinding())
                        }
                    }, {
                        key: "handle",
                        get: function() {
                            return this._handle
                        }
                    }]), e
                }();
            i.Skybox = ME;
            var LE, BE, FE, zE, UE, GE, HE, kE, VE, WE, jE, qE = function() {
                    function e() {
                        this.fog = new IE, this.ambient = new Ko, this.skybox = new ME, this.shadows = new aE, this.renderObjects = [], this.shadowObjects = [], this.shadowFrameBufferMap = new Map, this._handle = bo.alloc(), bo.set(this._handle, To.AMBIENT, this.ambient.handle), bo.set(this._handle, To.SKYBOX, this.skybox.handle), bo.set(this._handle, To.FOG, this.fog.handle), bo.set(this._handle, To.SHADOW, this.shadows.handle), bo.set(this._handle, To.IS_HDR, 0), bo.set(this._handle, To.SHADING_SCALE, 1), bo.set(this._handle, To.FP_SCALE, 1 / 1024)
                    }
                    var t = e.prototype;
                    return t.initDeferredPassInfo = function() {
                        var e = em.get("builtin-deferred-material");
                        if (e) {
                            var t = e.passes[0];
                            t.beginChangeStatesSilently(), t.tryCompile(), t.endChangeStatesSilently()
                        }
                        var n = em.get("builtin-post-process-material");
                        if (n) {
                            var i = n.passes[0];
                            i.beginChangeStatesSilently(), i.tryCompile(), i.endChangeStatesSilently()
                        }
                        if (e) {
                            var r = e.passes[0];
                            bo.set(this._handle, To.DEFERRED_LIGHT_PASS, r.handle), bo.set(this._handle, To.DEFERRED_LIGHT_PASS_SHADER, r.getShaderVariant())
                        }
                        if (n) {
                            var o = n.passes[0];
                            bo.set(this._handle, To.DEFERRED_POST_PASS, o.handle), bo.set(this._handle, To.DEFERRED_POST_PASS_SHADER, o.getShaderVariant())
                        }
                    }, t.activate = function(e, t) {
                        return this._device = e, this._pipeline = t, this.initDeferredPassInfo(), !0
                    }, t.destroy = function() {
                        this.ambient.destroy(), this.skybox.destroy(), this.fog.destroy(), this.shadows.destroy(), this._handle && bo.free(this._handle)
                    }, K(e, [{
                        key: "handle",
                        get: function() {
                            return this._handle
                        }
                    }, {
                        key: "isHDR",
                        get: function() {
                            return bo.get(this._handle, To.IS_HDR)
                        },
                        set: function(e) {
                            bo.set(this._handle, To.IS_HDR, e ? 1 : 0)
                        }
                    }, {
                        key: "shadingScale",
                        get: function() {
                            return bo.get(this._handle, To.SHADING_SCALE)
                        },
                        set: function(e) {
                            bo.set(this._handle, To.SHADING_SCALE, e)
                        }
                    }, {
                        key: "fpScale",
                        get: function() {
                            return bo.get(this._handle, To.FP_SCALE)
                        },
                        set: function(e) {
                            bo.set(this._handle, To.FP_SCALE, e)
                        }
                    }, {
                        key: "deferredLightPassHandle",
                        get: function() {
                            return bo.get(this._handle, To.DEFERRED_LIGHT_PASS)
                        }
                    }, {
                        key: "deferredLightPassShaderHandle",
                        get: function() {
                            return bo.get(this._handle, To.DEFERRED_LIGHT_PASS_SHADER)
                        }
                    }, {
                        key: "deferredPostPassHandle",
                        get: function() {
                            return bo.get(this._handle, To.DEFERRED_POST_PASS)
                        }
                    }, {
                        key: "deferredPostPassShaderHandle",
                        get: function() {
                            return bo.get(this._handle, To.DEFERRED_POST_PASS_SHADER)
                        }
                    }]), e
                }(),
                XE = e("RenderPipeline", (LE = A_("cc.RenderPipeline"), BE = q_(), FE = q_(), zE = ef([wS]), LE((VE = function(e) {
                    function t() {
                        for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                        return ne(t = e.call.apply(e, [this].concat(i)) || this, "_tag", HE, $(t)), ne(t, "_flows", kE, $(t)), t._commandBuffers = [], t._pipelineUBO = new bE, t._pipelineSceneData = new qE, t._macros = {}, t._constantMacros = "", t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.initialize = function(e) {
                        return this._flows = e.flows, e.tag && (this._tag = e.tag), !0
                    }, n.generateRenderArea = function(e) {
                        var t = new ss,
                            n = e.viewport,
                            i = this.pipelineSceneData,
                            r = e.window.hasOnScreenAttachments && this.device.surfaceTransform % 2 ? e.height : e.width,
                            o = e.window.hasOnScreenAttachments && this.device.surfaceTransform % 2 ? e.width : e.height;
                        return t.x = n.x * r, t.y = n.y * o, t.width = n.width * r * i.shadingScale, t.height = n.height * o * i.shadingScale, t
                    }, n.activate = function() {
                        this._device = i.director.root.device;
                        var e = new js(zu.bindings);
                        this._descriptorSetLayout = this._device.createDescriptorSetLayout(e), this._descriptorSet = this._device.createDescriptorSet(new qs(this._descriptorSetLayout)), this._pipelineUBO.activate(this._device, this), this._pipelineSceneData.activate(this._device, this);
                        for (var t = 0; t < this._flows.length; t++) this._flows[t].activate(this);
                        return this._macros.CC_USE_HDR = this._pipelineSceneData.isHDR, this._generateConstantMacros(), !0
                    }, n.render = function(e) {
                        for (var t = 0; t < this.flows.length; t++)
                            for (var n = 0; n < e.length; n++) {
                                var i = e[n];
                                this.flows[t].render(i)
                            }
                    }, n.destroy = function() {
                        for (var t = 0; t < this._flows.length; t++) this._flows[t].destroy();
                        this._flows.length = 0, this._descriptorSet && (this._descriptorSet.destroy(), this._descriptorSet = null);
                        for (var n = 0; n < this._commandBuffers.length; n++) this._commandBuffers[n].destroy();
                        return this._commandBuffers.length = 0, this._pipelineUBO.destroy(), this._pipelineSceneData.destroy(), e.prototype.destroy.call(this)
                    }, n.resize = function() {}, n._generateConstantMacros = function() {
                        var e = "";
                        e += "#define CC_DEVICE_SUPPORT_FLOAT_TEXTURE " + (this.device.hasFeature(Sa.TEXTURE_FLOAT) ? 1 : 0) + "\n", e += "#define CC_DEVICE_MAX_VERTEX_UNIFORM_VECTORS " + this.device.capabilities.maxVertexUniformVectors + "\n", e += "#define CC_DEVICE_MAX_FRAGMENT_UNIFORM_VECTORS " + this.device.capabilities.maxFragmentUniformVectors + "\n", this._constantMacros = e
                    }, K(t, [{
                        key: "tag",
                        get: function() {
                            return this._tag
                        }
                    }, {
                        key: "flows",
                        get: function() {
                            return this._flows
                        }
                    }, {
                        key: "constantMacros",
                        get: function() {
                            return this._constantMacros
                        }
                    }, {
                        key: "macros",
                        get: function() {
                            return this._macros
                        }
                    }, {
                        key: "device",
                        get: function() {
                            return this._device
                        }
                    }, {
                        key: "descriptorSetLayout",
                        get: function() {
                            return this._descriptorSetLayout
                        }
                    }, {
                        key: "descriptorSet",
                        get: function() {
                            return this._descriptorSet
                        }
                    }, {
                        key: "commandBuffers",
                        get: function() {
                            return this._commandBuffers
                        }
                    }, {
                        key: "pipelineUBO",
                        get: function() {
                            return this._pipelineUBO
                        }
                    }, {
                        key: "pipelineSceneData",
                        get: function() {
                            return this._pipelineSceneData
                        }
                    }]), t
                }(Nf), HE = ie((GE = VE).prototype, "_tag", [BE, w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 0
                    }
                }), kE = ie(GE.prototype, "_flows", [FE, zE, w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return []
                    }
                }), UE = GE)) || UE));
            i.RenderPipeline = XE,
                function(e) {
                    e[e.FORWARD = 10] = "FORWARD", e[e.UI = 20] = "UI"
                }(WE || (WE = {})),
                function(e) {
                    e[e.SHADOW = 0] = "SHADOW", e[e.FORWARD = 1] = "FORWARD", e[e.UI = 10] = "UI"
                }(jE || (jE = {}));
            var YE, KE, ZE, QE, JE, $E, eT, tT, nT, iT, rT, oT, aT, sT, cT, lT, uT, hT, _T, fT, dT, pT, mT, gT, vT, yT, ST, ET, TT, AT, xT, CT, bT, RT, wT, IT, PT, OT, DT, NT, MT, LT, BT, FT, zT, UT, GT, HT, kT, VT, WT, jT, qT, XT, YT, KT, ZT, QT, JT, $T, eA, tA, nA, iA, rA, oA, aA, sA, cA, lA, uA, hA, _A, fA, dA, pA, mA, gA, vA, yA, SA = e("PipelineStateManager", function() {
                function e() {}
                return e.getOrCreatePipelineState = function(e, t, n, i, r) {
                    var o = t.handle,
                        a = Mr.get(o, gr.HASH) ^ i.hash ^ r.attributesHash ^ n.id,
                        s = this._PSOHashMap.get(a);
                    if (!s) {
                        var c = Er.get(Mr.get(o, gr.PIPELINE_LAYOUT)),
                            l = new Ys(r.attributes),
                            u = new Rc(n, c, i, l, t.rasterizerState, t.depthStencilState, t.blendState, Mr.get(o, gr.PRIMITIVE), Mr.get(o, gr.DYNAMIC_STATES));
                        s = e.createPipelineState(u), this._PSOHashMap.set(a, s)
                    }
                    return s
                }, e
            }());
            SA._PSOHashMap = new Map, nt(wa), nt(Ia), nt(Ha), nt(Ga), nt(ka),
                function(e) {
                    e[e.SCENE = 0] = "SCENE", e[e.POSTPROCESS = 1] = "POSTPROCESS", e[e.UI = 2] = "UI"
                }(yA || (yA = {})), nt(yA), YE = A_("RenderTextureDesc"), KE = ef(wa), ZE = ef(Ia), QE = ef(Ea), YE(($E = ie((JE = function() {
                    ne(this, "name", $E, this), ne(this, "type", eT, this), ne(this, "usage", tT, this), ne(this, "format", nT, this), ne(this, "width", iT, this), ne(this, "height", rT, this)
                }).prototype, "name", [w_, F_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return ""
                    }
                }), eT = ie(JE.prototype, "type", [KE], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return wa.TEX2D
                    }
                }), tT = ie(JE.prototype, "usage", [ZE], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return Ia.COLOR_ATTACHMENT
                    }
                }), nT = ie(JE.prototype, "format", [QE], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return Ea.UNKNOWN
                    }
                }), iT = ie(JE.prototype, "width", [w_, F_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return -1
                    }
                }), rT = ie(JE.prototype, "height", [w_, F_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return -1
                    }
                }), JE));
            var EA, TA = (oT = A_("RenderTextureConfig"), aT = ef(tE), oT((lT = ie((cT = function() {
                    ne(this, "name", lT, this), ne(this, "texture", uT, this)
                }).prototype, "name", [w_, F_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return ""
                    }
                }), uT = ie(cT.prototype, "texture", [aT], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return null
                    }
                }), sT = cT)) || sT),
                AA = (hT = A_("MaterialConfig"), _T = ef(nE), hT((pT = ie((dT = function() {
                    ne(this, "name", pT, this), ne(this, "material", mT, this)
                }).prototype, "name", [w_, F_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return ""
                    }
                }), mT = ie(dT.prototype, "material", [_T], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return null
                    }
                }), fT = dT)) || fT),
                xA = (gT = A_("FrameBufferDesc"), vT = ef([It]), yT = ef(tE), gT((ET = ie((ST = function() {
                    ne(this, "name", ET, this), ne(this, "renderPass", TT, this), ne(this, "colorTextures", AT, this), ne(this, "depthStencilTexture", xT, this), ne(this, "texture", CT, this)
                }).prototype, "name", [w_, F_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return ""
                    }
                }), TT = ie(ST.prototype, "renderPass", [w_, F_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 0
                    }
                }), AT = ie(ST.prototype, "colorTextures", [vT], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return []
                    }
                }), xT = ie(ST.prototype, "depthStencilTexture", [w_, F_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return ""
                    }
                }), CT = ie(ST.prototype, "texture", [yT], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return null
                    }
                }), ST)), bT = A_("ColorDesc"), RT = ef(Ea), wT = ef(Ga), IT = ef(Ha), PT = ef([ka]), OT = ef([ka]), bT((MT = ie((NT = function() {
                    ne(this, "format", MT, this), ne(this, "loadOp", LT, this), ne(this, "storeOp", BT, this), ne(this, "sampleCount", FT, this), ne(this, "beginAccesses", zT, this), ne(this, "endAccesses", UT, this)
                }).prototype, "format", [RT], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return Ea.UNKNOWN
                    }
                }), LT = ie(NT.prototype, "loadOp", [wT], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return Ga.CLEAR
                    }
                }), BT = ie(NT.prototype, "storeOp", [IT], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return Ha.STORE
                    }
                }), FT = ie(NT.prototype, "sampleCount", [w_, F_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 1
                    }
                }), zT = ie(NT.prototype, "beginAccesses", [PT], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return []
                    }
                }), UT = ie(NT.prototype, "endAccesses", [OT], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return [ka.PRESENT]
                    }
                }), DT = NT)) || DT),
                CA = (GT = A_("DepthStencilDesc"), HT = ef(Ea), kT = ef(Ga), VT = ef(Ha), WT = ef(Ga), jT = ef(Ha), qT = ef([ka]), XT = ef([ka]), GT((ZT = ie((KT = function() {
                    ne(this, "format", ZT, this), ne(this, "depthLoadOp", QT, this), ne(this, "depthStoreOp", JT, this), ne(this, "stencilLoadOp", $T, this), ne(this, "stencilStoreOp", eA, this), ne(this, "sampleCount", tA, this), ne(this, "beginAccesses", nA, this), ne(this, "endAccesses", iA, this)
                }).prototype, "format", [HT], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return Ea.UNKNOWN
                    }
                }), QT = ie(KT.prototype, "depthLoadOp", [kT], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return Ga.CLEAR
                    }
                }), JT = ie(KT.prototype, "depthStoreOp", [VT], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return Ha.STORE
                    }
                }), $T = ie(KT.prototype, "stencilLoadOp", [WT], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return Ga.CLEAR
                    }
                }), eA = ie(KT.prototype, "stencilStoreOp", [jT], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return Ha.STORE
                    }
                }), tA = ie(KT.prototype, "sampleCount", [w_, F_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 1
                    }
                }), nA = ie(KT.prototype, "beginAccesses", [qT], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return []
                    }
                }), iA = ie(KT.prototype, "endAccesses", [XT], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return [ka.DEPTH_STENCIL_ATTACHMENT_WRITE]
                    }
                }), YT = KT)) || YT);
            rA = A_("RenderPassDesc"), oA = ef([xA]), aA = ef(CA), rA((cA = ie((sA = function() {
                    ne(this, "index", cA, this), ne(this, "colorAttachments", lA, this), ne(this, "depthStencilAttachment", uA, this)
                }).prototype, "index", [w_, F_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return -1
                    }
                }), lA = ie(sA.prototype, "colorAttachments", [oA], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return []
                    }
                }), uA = ie(sA.prototype, "depthStencilAttachment", [aA], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return new CA
                    }
                }), sA)),
                function(e) {
                    e[e.FRONT_TO_BACK = 0] = "FRONT_TO_BACK", e[e.BACK_TO_FRONT = 1] = "BACK_TO_FRONT"
                }(EA || (EA = {})), nt(EA);
            var bA = (hA = A_("RenderQueueDesc"), _A = ef(EA), fA = ef([It]), hA((mA = ie((pA = function() {
                ne(this, "isTransparent", mA, this), ne(this, "sortMode", gA, this), ne(this, "stages", vA, this)
            }).prototype, "isTransparent", [w_, F_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return !1
                }
            }), gA = ie(pA.prototype, "sortMode", [_A], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return EA.FRONT_TO_BACK
                }
            }), vA = ie(pA.prototype, "stages", [fA], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return []
                }
            }), dA = pA)) || dA);

            function RA(e, t) {
                return e.hash - t.hash || e.depth - t.depth || e.shaderId - t.shaderId
            }

            function wA(e, t) {
                return e.hash - t.hash || t.depth - e.depth || e.shaderId - t.shaderId
            }
            var IA = function() {
                function e(e) {
                    this.queue = void 0, this._passDesc = void 0, this._passPool = void 0, this._passDesc = e, this._passPool = new $n((function() {
                        return {
                            hash: 0,
                            depth: 0,
                            shaderId: 0,
                            subModel: null,
                            passIdx: 0
                        }
                    }), 64), this.queue = new ei(64, this._passDesc.sortFunc)
                }
                var t = e.prototype;
                return t.clear = function() {
                    this.queue.clear(), this._passPool.reset()
                }, t.insertRenderPass = function(e, t, n) {
                    var i = e.model.subModels[t],
                        r = Fr.get(i.handle, Dr.PASS_0 + n);
                    if (i.passes[n].blendState.targets[0].blend !== this._passDesc.isTransparent || !(Mr.get(r, gr.PHASE) & this._passDesc.phases)) return !1;
                    var o = 0 | Mr.get(r, gr.PRIORITY) << 16 | i.priority << 8 | n,
                        a = this._passPool.add();
                    return a.hash = o, a.depth = e.depth || 0, a.shaderId = Fr.get(i.handle, Dr.SHADER_0 + n), a.subModel = i, a.passIdx = n, this.queue.push(a), !0
                }, t.sort = function() {
                    this.queue.sort()
                }, t.recordCommandBuffer = function(e, t, n) {
                    for (var i = 0; i < this.queue.length; ++i) {
                        var r = this.queue.array[i],
                            o = r.subModel,
                            a = r.passIdx,
                            s = o.inputAssembler,
                            c = o.handle,
                            l = o.passes[a],
                            u = vr.get(Fr.get(c, Dr.SHADER_0 + a)),
                            h = SA.getOrCreatePipelineState(e, l, u, t, s);
                        n.bindPipelineState(h), n.bindDescriptorSet(Vu.MATERIAL, l.descriptorSet), n.bindDescriptorSet(Vu.LOCAL, o.descriptorSet), n.bindInputAssembler(s), n.draw(s)
                    }
                }, e
            }();

            function PA(e) {
                for (var t = 0, n = 0; n < e.stages.length; n++) t |= tm(e.stages[n]);
                var i = RA;
                switch (e.sortMode) {
                    case EA.BACK_TO_FRONT:
                        i = wA;
                        break;
                    case EA.FRONT_TO_BACK:
                        i = RA
                }
                return new IA({
                    isTransparent: e.isTransparent,
                    phases: t,
                    sortFunc: i
                })
            }

            function OA(e) {
                e.clear()
            }

            function DA(e) {
                e.sort()
            }

            function NA(e, t) {
                e.x = t.x * t.x, e.y = t.y * t.y, e.z = t.z * t.z
            }
            var MA = function() {
                    function e() {
                        this.queue = new Set
                    }
                    var t = e.prototype;
                    return t.clear = function() {
                        for (var e = this.queue.values(), t = e.next(); !t.done;) t.value.clear(), t = e.next();
                        this.queue.clear()
                    }, t.uploadBuffers = function(e) {
                        for (var t = this.queue.values(), n = t.next(); !n.done;) {
                            for (var i = 0; i < n.value.batches.length; ++i) {
                                var r = n.value.batches[i];
                                if (r.mergeCount) {
                                    for (var o = 0; o < r.vbs.length; ++o) r.vbs[o].update(r.vbDatas[o]);
                                    e.updateBuffer(r.vbIdx, r.vbIdxData.buffer), e.updateBuffer(r.ubo, r.uboData)
                                }
                            }
                            n = t.next()
                        }
                    }, t.recordCommandBuffer = function(e, t, n) {
                        for (var i = this.queue.values(), r = i.next(); !r.done;) {
                            for (var o = !1, a = 0; a < r.value.batches.length; ++a) {
                                var s = r.value.batches[a];
                                if (s.mergeCount) {
                                    if (!o) {
                                        var c = vr.get(s.hShader),
                                            l = SA.getOrCreatePipelineState(e, s.pass, c, t, s.ia);
                                        n.bindPipelineState(l), n.bindDescriptorSet(Vu.MATERIAL, s.pass.descriptorSet), o = !0
                                    }
                                    n.bindDescriptorSet(Vu.LOCAL, s.descriptorSet, r.value.dynamicOffsets), n.bindInputAssembler(s.ia), n.draw(s.ia)
                                }
                            }
                            r = i.next()
                        }
                    }, e
                }(),
                LA = function() {
                    function e() {
                        this.queue = new Set
                    }
                    var t = e.prototype;
                    return t.clear = function() {
                        for (var e = this.queue.values(), t = e.next(); !t.done;) t.value.clear(), t = e.next();
                        this.queue.clear()
                    }, t.uploadBuffers = function(e) {
                        for (var t = this.queue.values(), n = t.next(); !n.done;) n.value.hasPendingModels && n.value.uploadBuffers(e), n = t.next()
                    }, t.recordCommandBuffer = function(e, t, n) {
                        for (var i = this.queue.values(), r = i.next(); !r.done;) {
                            var o = r.value,
                                a = o.instances,
                                s = o.pass;
                            if (o.hasPendingModels) {
                                n.bindDescriptorSet(Vu.MATERIAL, s.descriptorSet);
                                for (var c = null, l = 0; l < a.length; ++l) {
                                    var u = a[l];
                                    if (u.count) {
                                        var h = vr.get(u.hShader),
                                            _ = SA.getOrCreatePipelineState(e, s, h, t, u.ia);
                                        c !== _ && (n.bindPipelineState(_), c = _), n.bindDescriptorSet(Vu.LOCAL, yr.get(u.hDescriptorSet), r.value.dynamicOffsets), n.bindInputAssembler(u.ia), n.draw(u.ia)
                                    }
                                }
                            }
                            r = i.next()
                        }
                    }, e
                }(),
                BA = function() {
                    function e(e) {
                        this.batches = [], this.dynamicOffsets = [], this._device = void 0, this._device = e.device
                    }
                    e.get = function(t, n) {
                        void 0 === n && (n = 0);
                        var i = e._buffers;
                        i.has(t) || i.set(t, {});
                        var r = i.get(t);
                        return r[n] || (r[n] = new e(t))
                    };
                    var t = e.prototype;
                    return t.destroy = function() {
                        for (var e = 0; e < this.batches.length; ++e) {
                            for (var t = this.batches[e], n = 0; n < t.vbs.length; ++n) t.vbs[n].destroy();
                            t.vbIdx.destroy(), t.ia.destroy(), t.ubo.destroy()
                        }
                        this.batches.length = 0
                    }, t.merge = function(e, t, n) {
                        var i = e.subMesh.flatBuffers;
                        if (0 !== i.length) {
                            for (var r = 0, o = 0, a = i[0].count, s = e.passes[t], c = Fr.get(e.handle, Dr.SHADER_0 + t), l = e.descriptorSet, u = !1, h = 0; h < this.batches.length; ++h) {
                                var _ = this.batches[h];
                                if (_.vbs.length === i.length && _.mergeCount < Th.BATCHING_COUNT) {
                                    u = !0;
                                    for (var f = 0; f < _.vbs.length; ++f)
                                        if (_.vbs[f].stride !== i[f].stride) {
                                            u = !1;
                                            break
                                        }
                                    if (u) {
                                        for (var d = 0; d < _.vbs.length; ++d) {
                                            var p = i[d],
                                                m = _.vbs[d],
                                                g = _.vbDatas[d];
                                            (r = (a + _.vbCount) * p.stride) > m.size && (m.resize(r), _.vbDatas[d] = new Uint8Array(r), _.vbDatas[d].set(g)), _.vbDatas[d].set(p.buffer, _.vbCount * p.stride)
                                        }
                                        var v = _.vbIdxData;
                                        (o = 4 * (a + _.vbCount)) > _.vbIdx.size && (_.vbIdx.resize(o), _.vbIdxData = new Float32Array(o / Float32Array.BYTES_PER_ELEMENT), _.vbIdxData.set(v), v = _.vbIdxData);
                                        var y = _.vbCount,
                                            S = y + a,
                                            E = _.mergeCount;
                                        if (v[y] !== E || v[S - 1] !== E)
                                            for (var T = y; T < S; T++) v[T] = E + .1;
                                        return Bn.toArray(_.uboData, n.transform.worldMatrix, Th.MAT_WORLDS_OFFSET + 16 * _.mergeCount), _.mergeCount || (l.bindBuffer(Th.BINDING, _.ubo), l.update(), _.pass = s, _.hShader = c, _.descriptorSet = l), ++_.mergeCount, _.vbCount += a, void(_.ia.vertexCount += a)
                                    }
                                }
                            }
                            for (var A = [], x = [], C = [], b = 0; b < i.length; ++b) {
                                var R = i[b],
                                    w = this._device.createBuffer(new gs(xa.VERTEX | xa.TRANSFER_DST, Ra.HOST | Ra.DEVICE, R.count * R.stride, R.stride));
                                w.update(R.buffer.buffer), A.push(w), x.push(new Uint8Array(w.size)), C.push(w)
                            }
                            var I = this._device.createBuffer(new gs(xa.VERTEX | xa.TRANSFER_DST, Ra.HOST | Ra.DEVICE, 4 * a, 4)),
                                P = new Float32Array(a);
                            P.fill(0), I.update(P), C.push(I);
                            for (var O = e.inputAssembler.attributes, D = new Array(O.length + 1), N = 0; N < O.length; ++N) D[N] = O[N];
                            D[O.length] = new Ms("a_dyn_batch_id", Ea.R32F, !1, i.length);
                            var M = new Bs(D, C),
                                L = this._device.createInputAssembler(M),
                                B = this._device.createBuffer(new gs(xa.UNIFORM | xa.TRANSFER_DST, Ra.HOST | Ra.DEVICE, Th.SIZE, Th.SIZE));
                            l.bindBuffer(Th.BINDING, B), l.update();
                            var F = new Float32Array(Th.COUNT);
                            Bn.toArray(F, n.transform.worldMatrix, Th.MAT_WORLDS_OFFSET), this.batches.push({
                                mergeCount: 1,
                                vbs: A,
                                vbDatas: x,
                                vbIdx: I,
                                vbIdxData: P,
                                vbCount: a,
                                ia: L,
                                ubo: B,
                                uboData: F,
                                pass: s,
                                hShader: c,
                                descriptorSet: l
                            })
                        }
                    }, t.clear = function() {
                        for (var e = 0; e < this.batches.length; ++e) {
                            var t = this.batches[e];
                            t.vbCount = 0, t.mergeCount = 0, t.ia.vertexCount = 0
                        }
                    }, e
                }();
            BA._buffers = new Map;
            var FA = e("InstancedBuffer", function() {
                function e(e) {
                    this.instances = [], this.pass = void 0, this.hasPendingModels = !1, this.dynamicOffsets = [], this._device = void 0, this._device = e.device, this.pass = e
                }
                e.get = function(t, n) {
                    void 0 === n && (n = 0);
                    var i = e._buffers;
                    i.has(t) || i.set(t, {});
                    var r = i.get(t);
                    return r[n] || (r[n] = new e(t))
                };
                var t = e.prototype;
                return t.destroy = function() {
                    for (var e = 0; e < this.instances.length; ++e) {
                        var t = this.instances[e];
                        t.vb.destroy(), t.ia.destroy()
                    }
                    this.instances.length = 0
                }, t.merge = function(e, t, n, i) {
                    void 0 === i && (i = null);
                    var r = t.buffer.length;
                    if (r) {
                        var o = e.inputAssembler,
                            a = e.descriptorSet.getTexture(kh),
                            s = i;
                        s || (s = Fr.get(e.handle, Dr.SHADER_0 + n));
                        for (var c = Fr.get(e.handle, Dr.DESCRIPTOR_SET), l = 0; l < this.instances.length; ++l) {
                            var u = this.instances[l];
                            if (!(u.ia.indexBuffer !== o.indexBuffer || u.count >= 1024) && u.lightingMap === a) {
                                if (u.stride !== r) return;
                                if (u.count >= u.capacity) {
                                    u.capacity <<= 1;
                                    var h = u.stride * u.capacity,
                                        _ = u.data;
                                    u.data = new Uint8Array(h), u.data.set(_), u.vb.resize(h)
                                }
                                return u.hShader !== s && (u.hShader = s), u.hDescriptorSet !== c && (u.hDescriptorSet = c), u.data.set(t.buffer, u.stride * u.count++), void(this.hasPendingModels = !0)
                            }
                        }
                        for (var f = this._device.createBuffer(new gs(xa.VERTEX | xa.TRANSFER_DST, Ra.HOST | Ra.DEVICE, 32 * r, r)), d = new Uint8Array(32 * r), p = o.vertexBuffers.slice(), m = o.attributes.slice(), g = o.indexBuffer, v = 0; v < t.attributes.length; v++) {
                            var y = t.attributes[v],
                                S = new Ms(y.name, y.format, y.isNormalized, p.length, !0);
                            m.push(S)
                        }
                        d.set(t.buffer), p.push(f);
                        var E = new Bs(m, p, g),
                            T = this._device.createInputAssembler(E);
                        this.instances.push({
                            count: 1,
                            capacity: 32,
                            vb: f,
                            data: d,
                            ia: T,
                            stride: r,
                            hShader: s,
                            hDescriptorSet: c,
                            lightingMap: a
                        }), this.hasPendingModels = !0
                    }
                }, t.uploadBuffers = function(e) {
                    for (var t = 0; t < this.instances.length; ++t) {
                        var n = this.instances[t];
                        n.count && (n.ia.instanceCount = n.count, e.updateBuffer(n.vb, n.data))
                    }
                }, t.clear = function() {
                    for (var e = 0; e < this.instances.length; ++e) this.instances[e].count = 0;
                    this.hasPendingModels = !1
                }, e
            }());
            FA._buffers = new Map;
            var zA = [Da.LINEAR, Da.LINEAR, Da.NONE, Na.CLAMP, Na.CLAMP, Na.CLAMP],
                UA = new Jn((function() {
                    return {
                        subModel: null,
                        passIdx: -1,
                        dynamicOffsets: [],
                        lights: []
                    }
                }), 16),
                GA = new Float32Array(4),
                HA = es.create(0, 0, 0, 1),
                kA = [],
                VA = [],
                WA = new Bn,
                jA = new Bn;

            function qA(e, t) {
                return !(!t.worldBounds || Vl.aabbWithAABB(t.worldBounds, e.aabb))
            }

            function XA(e, t) {
                return !(!t.worldBounds || Vl.aabbWithAABB(t.worldBounds, e.aabb) && Vl.aabbFrustum(t.worldBounds, e.frustum))
            }
            var YA = tm("forward-add"),
                KA = [];

            function ZA(e, t) {
                t.length = 0;
                for (var n = !1, i = 0; i < e.length; i++) {
                    for (var r = e[i].passes, o = -1, a = 0; a < r.length; a++)
                        if (r[a].phase === YA) {
                            o = a, n = !0;
                            break
                        }
                    t.push(o)
                }
                return n
            }
            var QA, JA, $A, ex, tx, nx, ix, rx, ox, ax, sx, cx = function() {
                    function e(e) {
                        this._pipeline = void 0, this._device = void 0, this._validLights = [], this._lightPasses = [], this._descriptorSetMap = new Map, this._shadowUBO = new Float32Array(Ku.COUNT), this._lightBufferCount = 16, this._lightBufferStride = void 0, this._lightBufferElementCount = void 0, this._lightBuffer = void 0, this._firstLightBufferView = void 0, this._lightBufferData = void 0, this._instancedQueue = void 0, this._batchedQueue = void 0, this._lightMeterScale = 1e4, this._sampler = null, this._pipeline = e, this._device = e.device, this._instancedQueue = new LA, this._batchedQueue = new MA;
                        var t = this._device.capabilities.uboOffsetAlignment;
                        this._lightBufferStride = Math.ceil(Ah.SIZE / t) * t, this._lightBufferElementCount = this._lightBufferStride / Float32Array.BYTES_PER_ELEMENT, this._lightBuffer = this._device.createBuffer(new gs(xa.UNIFORM | xa.TRANSFER_DST, Ra.HOST | Ra.DEVICE, this._lightBufferStride * this._lightBufferCount, this._lightBufferStride)), this._firstLightBufferView = this._device.createBuffer(new vs(this._lightBuffer, 0, Ah.SIZE)), this._lightBufferData = new Float32Array(this._lightBufferElementCount * this._lightBufferCount);
                        var n = Kf(zA);
                        this._sampler = cd.getSampler(this._device, n)
                    }
                    var t = e.prototype;
                    return t.clear = function() {
                        this._instancedQueue.clear(), this._batchedQueue.clear(), this._validLights.length = 0;
                        for (var e = 0; e < this._lightPasses.length; e++) {
                            var t = this._lightPasses[e];
                            t.dynamicOffsets.length = 0, t.lights.length = 0
                        }
                        UA.freeArray(this._lightPasses), this._lightPasses.length = 0
                    }, t.destroy = function() {
                        for (var e = Array.from(this._descriptorSetMap.values()), t = 0; t < e.length; ++t) {
                            var n = e[t];
                            n && (n.getBuffer(Xu.BINDING).destroy(), n.getBuffer(Ku.BINDING).destroy(), n.getSampler(Zu).destroy(), n.getSampler(gh).destroy(), n.getTexture(Zu).destroy(), n.getTexture(gh).destroy(), n.destroy())
                        }
                        this._descriptorSetMap.clear()
                    }, t.gatherLightPasses = function(e, t) {
                        var n = this._validLights;
                        if (this.clear(), this._gatherValidLights(e, n), n.length) {
                            this._updateUBOs(e, t), this._updateLightDescriptorSet(e, t);
                            for (var i = this._pipeline.pipelineSceneData.renderObjects, r = 0; r < i.length; r++) {
                                var o = i[r].model,
                                    a = o.subModels;
                                if (ZA(a, KA) && (VA.length = 0, this._lightCulling(o, n), VA.length))
                                    for (var s = 0; s < a.length; s++) {
                                        var c = KA[s];
                                        if (!(c < 0)) {
                                            var l = a[s],
                                                u = l.passes[c];
                                            l.descriptorSet.bindBuffer(Ah.BINDING, this._firstLightBufferView), l.descriptorSet.update(), this._addRenderQueue(u, l, o, c, n)
                                        }
                                    }
                            }
                            this._instancedQueue.uploadBuffers(t), this._batchedQueue.uploadBuffers(t)
                        }
                    }, t.recordCommandBuffer = function(e, t, n) {
                        this._instancedQueue.recordCommandBuffer(e, t, n), this._batchedQueue.recordCommandBuffer(e, t, n);
                        for (var i = 0; i < this._lightPasses.length; i++) {
                            var r = this._lightPasses[i],
                                o = r.subModel,
                                a = r.passIdx,
                                s = r.dynamicOffsets,
                                c = r.lights,
                                l = vr.get(Fr.get(o.handle, Dr.SHADER_0 + a)),
                                u = o.passes[a],
                                h = o.inputAssembler,
                                _ = SA.getOrCreatePipelineState(e, u, l, t, h),
                                f = yr.get(Mr.get(u.handle, gr.DESCRIPTOR_SET)),
                                d = o.descriptorSet;
                            n.bindPipelineState(_), n.bindDescriptorSet(Vu.MATERIAL, f), n.bindInputAssembler(h);
                            for (var p = 0; p < s.length; ++p) {
                                var m = c[p],
                                    g = this._getOrCreateDescriptorSet(m);
                                kA[0] = s[p], n.bindDescriptorSet(Vu.GLOBAL, g), n.bindDescriptorSet(Vu.LOCAL, d, kA), n.draw(h)
                            }
                        }
                    }, t._gatherValidLights = function(e, t) {
                        for (var n = e.scene.sphereLights, i = 0; i < n.length; i++) {
                            var r = n[i];
                            r.baked || (es.set(HA, r.position.x, r.position.y, r.position.z, r.range), Vl.sphereFrustum(HA, e.frustum) && (t.push(r), this._getOrCreateDescriptorSet(r)))
                        }
                        for (var o = e.scene.spotLights, a = 0; a < o.length; a++) {
                            var s = o[a];
                            s.baked || (es.set(HA, s.position.x, s.position.y, s.position.z, s.range), Vl.sphereFrustum(HA, e.frustum) && (t.push(s), this._getOrCreateDescriptorSet(s)))
                        }
                    }, t._lightCulling = function(e, t) {
                        for (var n = 0; n < t.length; n++) {
                            var i = t[n],
                                r = !1;
                            switch (i.type) {
                                case sm.SPHERE:
                                    r = qA(i, e);
                                    break;
                                case sm.SPOT:
                                    r = XA(i, e)
                            }
                            r || VA.push(n)
                        }
                    }, t._addRenderQueue = function(e, t, n, i, r) {
                        var o = e.batchingScheme;
                        if (o === Qp.INSTANCING)
                            for (var a = 0; a < VA.length; a++) {
                                var s = VA[a],
                                    c = FA.get(e, s);
                                c.merge(t, n.instancedAttributes, i), c.dynamicOffsets[0] = this._lightBufferStride * s, this._instancedQueue.queue.add(c)
                            } else if (o === Qp.VB_MERGING)
                                for (var l = 0; l < VA.length; l++) {
                                    var u = VA[l],
                                        h = BA.get(e, u);
                                    h.merge(t, i, n), h.dynamicOffsets[0] = this._lightBufferStride * u, this._batchedQueue.queue.add(h)
                                } else {
                                    var _ = UA.alloc();
                                    _.subModel = t, _.passIdx = i;
                                    for (var f = 0; f < VA.length; f++) {
                                        var d = VA[f];
                                        _.lights.push(r[d]), _.dynamicOffsets.push(this._lightBufferStride * d)
                                    }
                                    this._lightPasses.push(_)
                                }
                    }, t._updateLightDescriptorSet = function(e, t) {
                        for (var n = this._pipeline.device, i = this._pipeline.pipelineSceneData, r = i.shadows, o = i.shadowFrameBufferMap, a = e.scene.mainLight, s = n_(n), c = r.linear && s ? 1 : 0, l = r.packing ? 1 : s ? 0 : 1, u = 0; u < this._validLights.length; u++) {
                            var h = this._validLights[u],
                                _ = this._getOrCreateDescriptorSet(h);
                            if (_) {
                                switch (h.type) {
                                    case sm.SPHERE:
                                        a && SE(r, a, this._shadowUBO), this._shadowUBO[Ku.SHADOW_WIDTH_HEIGHT_PCF_BIAS_INFO_OFFSET + 0] = r.size.x, this._shadowUBO[Ku.SHADOW_WIDTH_HEIGHT_PCF_BIAS_INFO_OFFSET + 1] = r.size.y, this._shadowUBO[Ku.SHADOW_WIDTH_HEIGHT_PCF_BIAS_INFO_OFFSET + 2] = r.pcf, this._shadowUBO[Ku.SHADOW_WIDTH_HEIGHT_PCF_BIAS_INFO_OFFSET + 3] = r.bias, this._shadowUBO[Ku.SHADOW_LIGHT_PACKING_NBIAS_NULL_INFO_OFFSET + 0] = 2, this._shadowUBO[Ku.SHADOW_LIGHT_PACKING_NBIAS_NULL_INFO_OFFSET + 1] = l, this._shadowUBO[Ku.SHADOW_LIGHT_PACKING_NBIAS_NULL_INFO_OFFSET + 2] = r.normalBias, this._shadowUBO[Ku.SHADOW_LIGHT_PACKING_NBIAS_NULL_INFO_OFFSET + 3] = 0, yn.toArray(this._shadowUBO, r.shadowColor, Ku.SHADOW_COLOR_OFFSET);
                                        break;
                                    case sm.SPOT:
                                        if (a && SE(r, a, this._shadowUBO), Bn.toArray(this._shadowUBO, h.node.getWorldMatrix(), Ku.MAT_LIGHT_VIEW_OFFSET), Bn.invert(WA, h.node.getWorldMatrix()), Bn.perspective(jA, h.spotAngle, h.aspect, .001, h.range), Bn.multiply(jA, jA, WA), Bn.toArray(this._shadowUBO, jA, Ku.MAT_LIGHT_VIEW_PROJ_OFFSET), this._shadowUBO[Ku.SHADOW_NEAR_FAR_LINEAR_SELF_INFO_OFFSET + 0] = .01, this._shadowUBO[Ku.SHADOW_NEAR_FAR_LINEAR_SELF_INFO_OFFSET + 1] = h.range, this._shadowUBO[Ku.SHADOW_NEAR_FAR_LINEAR_SELF_INFO_OFFSET + 2] = c, this._shadowUBO[Ku.SHADOW_NEAR_FAR_LINEAR_SELF_INFO_OFFSET + 3] = r.selfShadow ? 1 : 0, this._shadowUBO[Ku.SHADOW_WIDTH_HEIGHT_PCF_BIAS_INFO_OFFSET + 0] = r.size.x, this._shadowUBO[Ku.SHADOW_WIDTH_HEIGHT_PCF_BIAS_INFO_OFFSET + 1] = r.size.y, this._shadowUBO[Ku.SHADOW_WIDTH_HEIGHT_PCF_BIAS_INFO_OFFSET + 2] = r.pcf, this._shadowUBO[Ku.SHADOW_WIDTH_HEIGHT_PCF_BIAS_INFO_OFFSET + 3] = r.bias, this._shadowUBO[Ku.SHADOW_LIGHT_PACKING_NBIAS_NULL_INFO_OFFSET + 0] = 1, this._shadowUBO[Ku.SHADOW_LIGHT_PACKING_NBIAS_NULL_INFO_OFFSET + 1] = l, this._shadowUBO[Ku.SHADOW_LIGHT_PACKING_NBIAS_NULL_INFO_OFFSET + 2] = r.normalBias, this._shadowUBO[Ku.SHADOW_LIGHT_PACKING_NBIAS_NULL_INFO_OFFSET + 3] = 0, yn.toArray(this._shadowUBO, r.shadowColor, Ku.SHADOW_COLOR_OFFSET), o.has(h) && o.has(h)) {
                                            var f, d = null === (f = o.get(h)) || void 0 === f ? void 0 : f.colorTextures[0];
                                            d && _.bindTexture(gh, d)
                                        }
                                }
                                _.update(), t.updateBuffer(_.getBuffer(Ku.BINDING), this._shadowUBO)
                            }
                        }
                    }, t._updateUBOs = function(e, t) {
                        var n = e.exposure,
                            i = this._pipeline.pipelineSceneData,
                            r = i.isHDR,
                            o = i.fpScale;
                        this._validLights.length > this._lightBufferCount && (this._firstLightBufferView.destroy(), this._lightBufferCount = _n(this._validLights.length), this._lightBuffer.resize(this._lightBufferStride * this._lightBufferCount), this._lightBufferData = new Float32Array(this._lightBufferElementCount * this._lightBufferCount), this._firstLightBufferView.initialize(new vs(this._lightBuffer, 0, Ah.SIZE)));
                        for (var a = 0, s = 0; a < this._validLights.length; a++, s += this._lightBufferElementCount) {
                            var c = this._validLights[a];
                            switch (c.type) {
                                case sm.SPHERE:
                                    if (En.toArray(GA, c.position), GA[3] = 0, this._lightBufferData.set(GA, s + Ah.LIGHT_POS_OFFSET), GA[0] = c.size, GA[1] = c.range, GA[2] = 0, this._lightBufferData.set(GA, s + Ah.LIGHT_SIZE_RANGE_ANGLE_OFFSET), En.toArray(GA, c.color), c.useColorTemperature) {
                                        var l = c.colorTemperatureRGB;
                                        GA[0] *= l.x, GA[1] *= l.y, GA[2] *= l.z
                                    }
                                    GA[3] = r ? c.luminance * o * this._lightMeterScale : c.luminance * n * this._lightMeterScale, this._lightBufferData.set(GA, s + Ah.LIGHT_COLOR_OFFSET);
                                    break;
                                case sm.SPOT:
                                    if (En.toArray(GA, c.position), GA[3] = 1, this._lightBufferData.set(GA, s + Ah.LIGHT_POS_OFFSET), GA[0] = c.size, GA[1] = c.range, GA[2] = c.spotAngle, this._lightBufferData.set(GA, s + Ah.LIGHT_SIZE_RANGE_ANGLE_OFFSET), En.toArray(GA, c.direction), this._lightBufferData.set(GA, s + Ah.LIGHT_DIR_OFFSET), En.toArray(GA, c.color), c.useColorTemperature) {
                                        var u = c.colorTemperatureRGB;
                                        GA[0] *= u.x, GA[1] *= u.y, GA[2] *= u.z
                                    }
                                    GA[3] = r ? c.luminance * o * this._lightMeterScale : c.luminance * n * this._lightMeterScale, this._lightBufferData.set(GA, s + Ah.LIGHT_COLOR_OFFSET)
                            }
                        }
                        t.updateBuffer(this._lightBuffer, this._lightBufferData)
                    }, t._getOrCreateDescriptorSet = function(e) {
                        if (!this._descriptorSetMap.has(e)) {
                            var t = this._device,
                                n = t.createDescriptorSet(new qs(this._pipeline.descriptorSetLayout));
                            n.bindBuffer(Xu.BINDING, this._pipeline.descriptorSet.getBuffer(Xu.BINDING)), n.bindBuffer(Yu.BINDING, this._pipeline.descriptorSet.getBuffer(Yu.BINDING));
                            var i = t.createBuffer(new gs(xa.UNIFORM | xa.TRANSFER_DST, Ra.HOST | Ra.DEVICE, Ku.SIZE, Ku.SIZE));
                            return n.bindBuffer(Ku.BINDING, i), n.bindSampler(Zu, this._sampler), n.bindTexture(Zu, em.get("default-texture").getGFXTexture()), n.bindSampler(gh, this._sampler), n.bindTexture(gh, em.get("default-texture").getGFXTexture()), n.update(), this._descriptorSetMap.set(e, n), n
                        }
                        return this._descriptorSetMap.get(e)
                    }, e
                }(),
                lx = new tu,
                ux = function() {
                    function e(e) {
                        this._pendingModels = [], this._instancedQueue = new LA, this._pipeline = void 0, this._pipeline = e
                    }
                    var t = e.prototype;
                    return t.gatherShadowPasses = function(e, t) {
                        var n = this._pipeline.pipelineSceneData,
                            i = this._pipeline.pipelineUBO,
                            r = n.shadows;
                        if (this._instancedQueue.clear(), this._pendingModels.length = 0, r.enabled && r.type === iE.Planar) {
                            i.updateShadowUBO(e);
                            var o = e.scene,
                                a = e.frustum,
                                s = 0 != (e.visibility & Pu.BitMask.DEFAULT);
                            if (o.mainLight && s) {
                                var c = n.renderObjects,
                                    l = FA.get(r.instancingMaterial.passes[0]);
                                this._instancedQueue.queue.add(l);
                                for (var u = 0; u < c.length; u++) {
                                    var h = c[u].model;
                                    if (h.enabled && h.node && h.castShadow && (!h.worldBounds || (tu.transform(lx, h.worldBounds, r.matLight), Vl.aabbFrustum(lx, a))))
                                        if (h.isInstancingEnabled)
                                            for (var _ = h.subModels, f = 0; f < _.length; f++) {
                                                var d = _[f];
                                                l.merge(d, h.instancedAttributes, 0, d.planarInstanceShaderHandle)
                                            } else this._pendingModels.push(h)
                                }
                                this._instancedQueue.uploadBuffers(t)
                            }
                        }
                    }, t.recordCommandBuffer = function(e, t, n) {
                        var i = this._pipeline.pipelineSceneData.shadows;
                        if (i.enabled && i.type === iE.Planar && (this._instancedQueue.recordCommandBuffer(e, t, n), this._pendingModels.length)) {
                            var r = i.material.passes[0],
                                o = yr.get(Mr.get(r.handle, gr.DESCRIPTOR_SET));
                            n.bindDescriptorSet(Vu.MATERIAL, o);
                            for (var a = this._pendingModels.length, s = 0; s < a; s++)
                                for (var c = this._pendingModels[s], l = 0; l < c.subModels.length; l++) {
                                    var u = c.subModels[l],
                                        h = vr.get(u.planarShaderHandle),
                                        _ = u.inputAssembler,
                                        f = SA.getOrCreatePipelineState(e, r, h, t, _);
                                    n.bindPipelineState(f), n.bindDescriptorSet(Vu.LOCAL, u.descriptorSet), n.bindInputAssembler(_), n.draw(_)
                                }
                        }
                    }, e
                }(),
                hx = function() {
                    function e() {
                        this._phaseID = tm("default")
                    }
                    var t = e.prototype;
                    return t.activate = function(e) {
                        this._pipeline = e
                    }, t.render = function(e, t) {
                        for (var n = this._pipeline, i = n.device, r = n.commandBuffers[0], o = e.scene.batches, a = 0; a < o.length; a++) {
                            var s = o[a],
                                c = !1;
                            if (e.visibility & s.visFlags && (c = !0), c)
                                for (var l = s.handle, u = Vr.get(l, zr.PASS_COUNT), h = 0; h < u; h++) {
                                    var _ = s.passes[h];
                                    if (_.phase === this._phaseID) {
                                        var f = Vr.get(l, zr.SHADER_0 + h),
                                            d = vr.get(f),
                                            p = Sr.get(s.hInputAssembler),
                                            m = yr.get(s.hDescriptorSet),
                                            g = SA.getOrCreatePipelineState(i, _, d, t, p);
                                        r.bindPipelineState(g), r.bindDescriptorSet(Vu.MATERIAL, _.descriptorSet), r.bindDescriptorSet(Vu.LOCAL, m), r.bindInputAssembler(p), r.draw(p)
                                    }
                                }
                        }
                    }, e
                }(),
                _x = [new ps(0, 0, 0, 1)],
                fx = e("ForwardStage", (QA = A_("ForwardStage"), JA = ef([bA]), $A = q_(), QA((rx = ix = function(e) {
                    function t() {
                        var t;
                        return ne(t = e.call(this) || this, "renderQueues", nx, $(t)), t._renderQueues = [], t._renderArea = new ss, t._batchedQueue = void 0, t._instancedQueue = void 0, t._phaseID = tm("default"), t._clearFlag = 4294967295, t._batchedQueue = new MA, t._instancedQueue = new LA, t._uiPhase = new hx, t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.initialize = function(t) {
                        return e.prototype.initialize.call(this, t), t.renderQueues && (this.renderQueues = t.renderQueues), !0
                    }, n.activate = function(t, n) {
                        e.prototype.activate.call(this, t, n);
                        for (var i = 0; i < this.renderQueues.length; i++) this._renderQueues[i] = PA(this.renderQueues[i]);
                        this._additiveLightQueue = new cx(this._pipeline), this._planarQueue = new ux(this._pipeline), this._uiPhase.activate(t)
                    }, n.destroy = function() {}, n.render = function(e) {
                        this._instancedQueue.clear(), this._batchedQueue.clear();
                        var t = this._pipeline,
                            n = t.device;
                        this._renderQueues.forEach(OA);
                        for (var i = t.pipelineSceneData.renderObjects, r = 0, o = 0, a = 0, s = 0; s < i.length; ++s) {
                            var c = i[s],
                                l = c.model.subModels;
                            for (r = 0; r < l.length; ++r) {
                                var u = l[r],
                                    h = u.passes;
                                for (o = 0; o < h.length; ++o) {
                                    var _ = h[o];
                                    if (_.phase === this._phaseID) {
                                        var f = _.batchingScheme;
                                        if (f === Qp.INSTANCING) {
                                            var d = FA.get(_);
                                            d.merge(u, c.model.instancedAttributes, o), this._instancedQueue.queue.add(d)
                                        } else if (f === Qp.VB_MERGING) {
                                            var p = BA.get(_);
                                            p.merge(u, o, c.model), this._batchedQueue.queue.add(p)
                                        } else
                                            for (a = 0; a < this._renderQueues.length; a++) this._renderQueues[a].insertRenderPass(c, r, o)
                                    }
                                }
                            }
                        }
                        this._renderQueues.forEach(DA);
                        var m = t.commandBuffers[0];
                        this._instancedQueue.uploadBuffers(m), this._batchedQueue.uploadBuffers(m), this._additiveLightQueue.gatherLightPasses(e, m), this._planarQueue.gatherShadowPasses(e, m);
                        var g = t.pipelineSceneData;
                        if (this._renderArea = t.generateRenderArea(e), e.clearFlag & $a.COLOR)
                            if (g.isHDR) {
                                NA(_x[0], e.clearColor);
                                var v = g.fpScale / e.exposure;
                                _x[0].x *= v, _x[0].y *= v, _x[0].z *= v
                            } else _x[0].x = e.clearColor.x, _x[0].y = e.clearColor.y, _x[0].z = e.clearColor.z;
                        _x[0].w = e.clearColor.w;
                        var y = e.window.framebuffer,
                            S = y.colorTextures[0] ? y.renderPass : t.getRenderPass(e.clearFlag & this._clearFlag);
                        m.beginRenderPass(S, y, this._renderArea, _x, e.clearDepth, e.clearStencil), m.bindDescriptorSet(Vu.GLOBAL, t.descriptorSet), this._renderQueues[0].recordCommandBuffer(n, S, m), this._instancedQueue.recordCommandBuffer(n, S, m), this._batchedQueue.recordCommandBuffer(n, S, m), this._additiveLightQueue.recordCommandBuffer(n, S, m), this._planarQueue.recordCommandBuffer(n, S, m), this._renderQueues[1].recordCommandBuffer(n, S, m), this._uiPhase.render(e, S), m.endRenderPass()
                    }, t
                }(yS), ix.initInfo = {
                    name: "ForwardStage",
                    priority: WE.FORWARD,
                    tag: 0,
                    renderQueues: [{
                        isTransparent: !1,
                        sortMode: EA.FRONT_TO_BACK,
                        stages: ["default"]
                    }, {
                        isTransparent: !0,
                        sortMode: EA.BACK_TO_FRONT,
                        stages: ["default", "planarShadow"]
                    }]
                }, nx = ie((tx = rx).prototype, "renderQueues", [JA, w_, $A], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return []
                    }
                }), ex = tx)) || ex)),
                dx = e("ForwardFlow", A_("ForwardFlow")((sx = ax = function(e) {
                    function t() {
                        return e.apply(this, arguments) || this
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.initialize = function(t) {
                        if (e.prototype.initialize.call(this, t), 0 === this._stages.length) {
                            var n = new fx;
                            n.initialize(fx.initInfo), this._stages.push(n)
                        }
                        return !0
                    }, n.activate = function(t) {
                        e.prototype.activate.call(this, t)
                    }, n.render = function(t) {
                        e.prototype.render.call(this, t)
                    }, n.destroy = function() {
                        e.prototype.destroy.call(this)
                    }, t
                }(wS), ax.initInfo = {
                    name: Lu,
                    priority: jE.FORWARD,
                    stages: []
                }, ox = sx)) || ox),
                px = tm("shadow-caster"),
                mx = [];

            function gx(e, t) {
                t.length = 0;
                for (var n = !1, i = 0; i < e.length; i++) {
                    for (var r = e[i].passes, o = -1, a = 0; a < r.length; a++)
                        if (r[a].phase === px) {
                            o = a, n = !0;
                            break
                        }
                    t.push(o)
                }
                return n
            }
            var vx, yx, Sx, Ex, Tx, Ax, xx, Cx, bx, Rx, wx, Ix, Px, Ox, Dx, Nx, Mx, Lx, Bx, Fx, zx, Ux, Gx, Hx, kx, Vx, Wx = function() {
                    function e(e) {
                        this._pipeline = void 0, this._subModelsArray = [], this._passArray = [], this._shaderArray = [], this._instancedQueue = void 0, this._batchedQueue = void 0, this._pipeline = e, this._instancedQueue = new LA, this._batchedQueue = new MA
                    }
                    var t = e.prototype;
                    return t.gatherLightPasses = function(e, t) {
                        this.clear();
                        var n = this._pipeline.pipelineSceneData.shadows,
                            i = this._pipeline.pipelineSceneData.shadowObjects;
                        if (e && n.enabled && n.type === iE.ShadowMap) {
                            this._pipeline.pipelineUBO.updateShadowUBOLight(e);
                            for (var r = 0; r < i.length; r++) {
                                var o = i[r].model;
                                if (gx(o.subModels, mx)) switch (e.type) {
                                    case sm.DIRECTIONAL:
                                        this.add(o, t, mx);
                                        break;
                                    case sm.SPOT:
                                        if (o.worldBounds && (!Vl.aabbWithAABB(o.worldBounds, e.aabb) || !Vl.aabbFrustum(o.worldBounds, e.frustum))) continue;
                                        this.add(o, t, mx)
                                }
                            }
                        }
                    }, t.clear = function() {
                        this._subModelsArray.length = 0, this._shaderArray.length = 0, this._passArray.length = 0, this._instancedQueue.clear(), this._batchedQueue.clear()
                    }, t.add = function(e, t, n) {
                        for (var i = e.subModels, r = this._pipeline.descriptorSet.getBuffer(Ku.BINDING), o = 0; o < i.length; o++) {
                            var a = i[o],
                                s = n[o],
                                c = a.passes[s],
                                l = c.batchingScheme;
                            if (a.descriptorSet.bindBuffer(Ku.BINDING, r), a.descriptorSet.update(), l === Qp.INSTANCING) {
                                var u = FA.get(c);
                                u.merge(a, e.instancedAttributes, s), this._instancedQueue.queue.add(u)
                            } else if (c.batchingScheme === Qp.VB_MERGING) {
                                var h = BA.get(c);
                                h.merge(a, s, e), this._batchedQueue.queue.add(h)
                            } else {
                                var _ = vr.get(Fr.get(a.handle, Dr.SHADER_0 + s));
                                this._subModelsArray.push(a), this._shaderArray.push(_), this._passArray.push(c)
                            }
                        }
                        this._instancedQueue.uploadBuffers(t), this._batchedQueue.uploadBuffers(t)
                    }, t.recordCommandBuffer = function(e, t, n) {
                        this._instancedQueue.recordCommandBuffer(e, t, n), this._batchedQueue.recordCommandBuffer(e, t, n);
                        for (var i = 0; i < this._subModelsArray.length; ++i) {
                            var r = this._subModelsArray[i],
                                o = this._shaderArray[i],
                                a = this._passArray[i],
                                s = r.inputAssembler,
                                c = SA.getOrCreatePipelineState(e, a, o, t, s),
                                l = a.descriptorSet;
                            n.bindPipelineState(c), n.bindDescriptorSet(Vu.MATERIAL, l), n.bindDescriptorSet(Vu.LOCAL, r.descriptorSet), n.bindInputAssembler(s), n.draw(s)
                        }
                    }, e
                }(),
                jx = [new ps(1, 1, 1, 1)],
                qx = e("ShadowStage", A_("ShadowStage")((Sx = yx = function(e) {
                    function t() {
                        for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                        return (t = e.call.apply(e, [this].concat(i)) || this)._shadowFrameBuffer = null, t._renderArea = new ss, t._light = null, t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.setUsage = function(e, t) {
                        this._light = e, this._shadowFrameBuffer = t
                    }, n.destroy = function() {
                        this._additiveShadowQueue.clear()
                    }, n.clearFramebuffer = function(e) {
                        if (this._light && this._shadowFrameBuffer) {
                            jx[0].w = e.clearColor.w;
                            var t = this._pipeline.commandBuffers[0],
                                n = this._shadowFrameBuffer.renderPass;
                            t.beginRenderPass(n, this._shadowFrameBuffer, this._renderArea, jx, e.clearDepth, e.clearStencil), t.endRenderPass()
                        }
                    }, n.render = function(e) {
                        var t = this._pipeline,
                            n = t.pipelineSceneData,
                            i = n.shadows,
                            r = n.shadingScale,
                            o = t.commandBuffers[0];
                        if (this._light && this._shadowFrameBuffer) {
                            this._additiveShadowQueue.gatherLightPasses(this._light, o);
                            var a = e.viewport,
                                s = i.size;
                            this._renderArea.x = a.x * s.x, this._renderArea.y = a.y * s.y, this._renderArea.width = a.width * s.x * r, this._renderArea.height = a.height * s.y * r;
                            var c = t.device,
                                l = this._shadowFrameBuffer.renderPass;
                            o.beginRenderPass(l, this._shadowFrameBuffer, this._renderArea, jx, e.clearDepth, e.clearStencil), o.bindDescriptorSet(Vu.GLOBAL, t.descriptorSet), this._additiveShadowQueue.recordCommandBuffer(c, l, o), o.endRenderPass()
                        }
                    }, n.activate = function(t, n) {
                        e.prototype.activate.call(this, t, n), this._additiveShadowQueue = new Wx(t)
                    }, t
                }(yS), yx.initInfo = {
                    name: "ShadowStage",
                    priority: WE.FORWARD,
                    tag: 0
                }, vx = Sx)) || vx),
                Xx = e("ShadowFlow", A_("ShadowFlow")((Ax = Tx = function(e) {
                    function t() {
                        for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                        return (t = e.call.apply(e, [this].concat(i)) || this)._shadowRenderPass = null, t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.initialize = function(t) {
                        if (e.prototype.initialize.call(this, t), 0 === this._stages.length) {
                            var n = new qx;
                            n.initialize(qx.initInfo), this._stages.push(n)
                        }
                        return !0
                    }, n.render = function(e) {
                        var t = this._pipeline,
                            n = t.pipelineSceneData.shadows,
                            i = t.pipelineSceneData.shadowFrameBufferMap,
                            r = t.pipelineSceneData.shadowObjects;
                        if (n.enabled && n.type === iE.ShadowMap) {
                            var o = function(e, t) {
                                fE.length = 0;
                                var n = e.scene;
                                fE.push(n.mainLight);
                                for (var i = n.spotLights, r = 0; r < i.length; r++) {
                                    var o = i[r];
                                    es.set(dE, o.position.x, o.position.y, o.position.z, o.range), Vl.sphereFrustum(dE, e.frustum) && t > fE.length && fE.push(o)
                                }
                                return fE
                            }(e, n.maxReceived);
                            if (0 !== r.length) {
                                for (var a = 0; a < o.length; a++) {
                                    var s = o[a];
                                    i.has(s) || this._initShadowFrameBuffer(t, s);
                                    var c = i.get(s);
                                    n.shadowMapDirty && this.resizeShadowMap(s, n);
                                    for (var l = 0; l < this._stages.length; l++) {
                                        var u = this._stages[l];
                                        u.setUsage(s, c), u.render(e)
                                    }
                                }
                                t.pipelineUBO.updateShadowUBO(e)
                            } else this.clearShadowMap(o, e)
                        }
                    }, n.destroy = function() {
                        e.prototype.destroy.call(this);
                        for (var t = this._pipeline.pipelineSceneData.shadowFrameBufferMap, n = Array.from(t.values()), i = 0; i < n.length; i++) {
                            var r = n[i];
                            if (r) {
                                for (var o = r.colorTextures, a = 0; a < o.length; a++) {
                                    var s = o[i];
                                    s && s.destroy()
                                }
                                o.length = 0;
                                var c = r.depthStencilTexture;
                                c && c.destroy(), r.destroy()
                            }
                        }
                        t.clear(), this._shadowRenderPass && this._shadowRenderPass.destroy()
                    }, n._initShadowFrameBuffer = function(e, t) {
                        var n = e.device,
                            i = e.pipelineSceneData.shadows,
                            r = i.size,
                            o = e.pipelineSceneData.shadowFrameBufferMap,
                            a = n_(n) ? i.packing ? Ea.RGBA8 : Ea.RGBA16F : Ea.RGBA8;
                        if (!this._shadowRenderPass) {
                            var s = new Fs;
                            s.format = a, s.loadOp = Ga.CLEAR, s.storeOp = Ha.STORE, s.sampleCount = 1;
                            var c = new zs;
                            c.format = n.depthStencilFormat, c.depthLoadOp = Ga.CLEAR, c.depthStoreOp = Ha.DISCARD, c.stencilLoadOp = Ga.CLEAR, c.stencilStoreOp = Ha.DISCARD, c.sampleCount = 1;
                            var l = new Gs([s], c);
                            this._shadowRenderPass = n.createRenderPass(l)
                        }
                        var u = [];
                        u.push(n.createTexture(new Ts(wa.TEX2D, Ia.COLOR_ATTACHMENT | Ia.SAMPLED, a, r.x, r.y)));
                        var h = n.createTexture(new Ts(wa.TEX2D, Ia.DEPTH_STENCIL_ATTACHMENT, n.depthStencilFormat, r.x, r.y)),
                            _ = n.createFramebuffer(new Vs(this._shadowRenderPass, u, h));
                        o.set(t, _)
                    }, n.clearShadowMap = function(e, t) {
                        for (var n = this._pipeline.pipelineSceneData, i = 0; i < e.length; i++) {
                            var r = e[i],
                                o = n.shadowFrameBufferMap.get(r);
                            if (n.shadowFrameBufferMap.has(r))
                                for (var a = 0; a < this._stages.length; a++) {
                                    var s = this._stages[a];
                                    s.setUsage(r, o), s.clearFramebuffer(t)
                                }
                        }
                    }, n.resizeShadowMap = function(e, t) {
                        var n = t.size.x,
                            i = t.size.y,
                            r = this._pipeline,
                            o = r.device,
                            a = r.pipelineSceneData.shadowFrameBufferMap,
                            s = n_(o) ? t.packing ? Ea.RGBA8 : Ea.RGBA16F : Ea.RGBA8;
                        if (a.has(e)) {
                            var c = a.get(e);
                            if (!c) return;
                            var l = [];
                            l.push(r.device.createTexture(new Ts(wa.TEX2D, Ia.COLOR_ATTACHMENT | Ia.SAMPLED, s, n, i)));
                            var u = c.depthStencilTexture;
                            u && u.resize(n, i);
                            var h = c.renderPass;
                            c.destroy(), c.initialize(new Vs(h, l, u))
                        }
                    }, t
                }(wS), Tx.initInfo = {
                    name: Bu,
                    priority: jE.SHADOW,
                    tag: yA.SCENE,
                    stages: []
                }, Ex = Ax)) || Ex),
                Yx = [Da.LINEAR, Da.LINEAR, Da.NONE, Na.CLAMP, Na.CLAMP, Na.CLAMP],
                Kx = e("ForwardPipeline", (xx = A_("ForwardPipeline"), Cx = ef([TA]), bx = q_(), Rx = ef([AA]), wx = q_(), xx((Nx = function(e) {
                    function t() {
                        for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                        return ne(t = e.call.apply(e, [this].concat(i)) || this, "renderTextures", Ox, $(t)), ne(t, "materials", Dx, $(t)), t._renderPasses = new Map, t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.initialize = function(t) {
                        if (e.prototype.initialize.call(this, t), 0 === this._flows.length) {
                            var n = new Xx;
                            n.initialize(Xx.initInfo), this._flows.push(n);
                            var i = new dx;
                            i.initialize(dx.initInfo), this._flows.push(i)
                        }
                        return !0
                    }, n.activate = function() {
                        return !(!e.prototype.activate.call(this) || !this._activeRenderer() && (b(2402), 1))
                    }, n.render = function(e) {
                        this._commandBuffers[0].begin(), this._pipelineUBO.updateGlobalUBO();
                        for (var t = 0; t < e.length; t++) {
                            var n = e[t];
                            if (n.scene) {
                                EE(this, n), this._pipelineUBO.updateCameraUBO(n);
                                for (var i = 0; i < this._flows.length; i++) this._flows[i].render(n)
                            }
                        }
                        this._commandBuffers[0].end(), this._device.flushCommands(this._commandBuffers), this._device.queue.submit(this._commandBuffers)
                    }, n.getRenderPass = function(e) {
                        var t = this._renderPasses.get(e);
                        if (t) return t;
                        var n = this.device,
                            i = new Fs,
                            r = new zs;
                        i.format = n.colorFormat, r.format = n.depthStencilFormat, r.stencilStoreOp = Ha.DISCARD, r.depthStoreOp = Ha.DISCARD, e & $a.COLOR || (e & h_ ? i.loadOp = Ga.DISCARD : (i.loadOp = Ga.LOAD, i.beginAccesses = [ka.PRESENT])), (e & $a.DEPTH_STENCIL) !== $a.DEPTH_STENCIL && (e & $a.DEPTH || (r.depthLoadOp = Ga.LOAD), e & $a.STENCIL || (r.stencilLoadOp = Ga.LOAD), r.beginAccesses = [ka.DEPTH_STENCIL_ATTACHMENT_WRITE]);
                        var o = new Gs([i], r);
                        return t = n.createRenderPass(o), this._renderPasses.set(e, t), t
                    }, n._activeRenderer = function() {
                        var e = this.device;
                        this._commandBuffers.push(e.commandBuffer);
                        var t = Kf(Yx),
                            n = cd.getSampler(e, t);
                        return this._descriptorSet.bindSampler(Zu, n), this._descriptorSet.bindTexture(Zu, em.get("default-texture").getGFXTexture()), this._descriptorSet.bindSampler(gh, n), this._descriptorSet.bindTexture(gh, em.get("default-texture").getGFXTexture()), this._descriptorSet.update(), !0
                    }, n.destroyUBOs = function() {
                        this._descriptorSet && (this._descriptorSet.getBuffer(Xu.BINDING).destroy(), this._descriptorSet.getBuffer(Ku.BINDING).destroy(), this._descriptorSet.getBuffer(Yu.BINDING).destroy(), this._descriptorSet.getSampler(Zu).destroy(), this._descriptorSet.getSampler(gh).destroy(), this._descriptorSet.getTexture(Zu).destroy(), this._descriptorSet.getTexture(gh).destroy())
                    }, n.destroy = function() {
                        this.destroyUBOs();
                        for (var t = this._renderPasses.values(), n = t.next(); !n.done;) n.value.destroy(), n = t.next();
                        return this._commandBuffers.length = 0, e.prototype.destroy.call(this)
                    }, t
                }(XE), Ox = ie((Px = Nx).prototype, "renderTextures", [Cx, w_, bx], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return []
                    }
                }), Dx = ie(Px.prototype, "materials", [Rx, w_, wx], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return []
                    }
                }), Ix = Px)) || Ix));
            ! function(e) {
                e[e.GBUFFER = 10] = "GBUFFER", e[e.LIGHTING = 15] = "LIGHTING", e[e.TRANSPARENT = 18] = "TRANSPARENT", e[e.POSTPROCESS = 19] = "POSTPROCESS", e[e.UI = 20] = "UI"
            }(Mx || (Mx = {})),
            function(e) {
                e[e.SHADOW = 0] = "SHADOW", e[e.GBUFFER = 1] = "GBUFFER", e[e.LIGHTING = 5] = "LIGHTING", e[e.UI = 10] = "UI"
            }(Lx || (Lx = {}));
            var Zx, Qx, Jx, $x, eC, tC, nC, iC, rC, oC, aC, sC, cC, lC, uC, hC, _C, fC, dC, pC, mC, gC, vC, yC, SC, EC, TC, AC, xC, CC, bC, RC, wC, IC, PC, OC = [new ps(0, 0, 0, 0), new ps(0, 0, 0, 0), new ps(0, 0, 0, 0), new ps(0, 0, 0, 0)],
                DC = e("GbufferStage", (Bx = A_("GbufferStage"), Fx = ef([bA]), zx = q_(), Bx((Vx = kx = function(e) {
                    function t() {
                        var t;
                        return ne(t = e.call(this) || this, "renderQueues", Hx, $(t)), t._renderQueues = [], t._renderArea = new ss, t._batchedQueue = void 0, t._instancedQueue = void 0, t._phaseID = tm("deferred"), t._batchedQueue = new MA, t._instancedQueue = new LA, t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.initialize = function(t) {
                        return e.prototype.initialize.call(this, t), t.renderQueues && (this.renderQueues = t.renderQueues), !0
                    }, n.activate = function(t, n) {
                        e.prototype.activate.call(this, t, n);
                        for (var i = 0; i < this.renderQueues.length; i++) this._renderQueues[i] = PA(this.renderQueues[i])
                    }, n.destroy = function() {}, n.render = function(e) {
                        this._instancedQueue.clear(), this._batchedQueue.clear();
                        var t = this._pipeline,
                            n = t.device;
                        this._renderQueues.forEach(OA);
                        var i = t.pipelineSceneData.renderObjects;
                        if (0 !== i.length) {
                            for (var r = 0, o = 0, a = 0, s = 0; s < i.length; ++s) {
                                var c = i[s],
                                    l = c.model.subModels;
                                for (r = 0; r < l.length; ++r) {
                                    var u = l[r],
                                        h = u.passes;
                                    for (o = 0; o < h.length; ++o) {
                                        var _ = h[o];
                                        if (_.phase === this._phaseID) {
                                            var f = _.batchingScheme;
                                            if (f === Qp.INSTANCING) {
                                                var d = FA.get(_);
                                                d.merge(u, c.model.instancedAttributes, o), this._instancedQueue.queue.add(d)
                                            } else if (f === Qp.VB_MERGING) {
                                                var p = BA.get(_);
                                                p.merge(u, o, c.model), this._batchedQueue.queue.add(p)
                                            } else
                                                for (a = 0; a < this._renderQueues.length; a++) this._renderQueues[a].insertRenderPass(c, r, o)
                                        }
                                    }
                                }
                            }
                            this._renderQueues.forEach(DA);
                            var m = t.commandBuffers[0];
                            if (this._instancedQueue.uploadBuffers(m), this._batchedQueue.uploadBuffers(m), this._renderArea = t.generateRenderArea(e), t.updateQuadVertexData(this._renderArea), e.clearFlag & $a.COLOR)
                                if (t.pipelineSceneData.isHDR) {
                                    NA(OC[0], e.clearColor);
                                    var g = t.pipelineSceneData.fpScale / e.exposure;
                                    OC[0].x *= g, OC[0].y *= g, OC[0].z *= g
                                } else OC[0].x = e.clearColor.x, OC[0].y = e.clearColor.y, OC[0].z = e.clearColor.z;
                            OC[0].w = e.clearColor.w;
                            var v = t.getDeferredRenderData(e).gbufferFrameBuffer,
                                y = v.renderPass;
                            m.beginRenderPass(y, v, this._renderArea, OC, e.clearDepth, e.clearStencil), m.bindDescriptorSet(Vu.GLOBAL, t.descriptorSet);
                            for (var S = 0; S < this.renderQueues.length; S++) this._renderQueues[S].recordCommandBuffer(n, y, m);
                            this._instancedQueue.recordCommandBuffer(n, y, m), this._batchedQueue.recordCommandBuffer(n, y, m), m.endRenderPass()
                        }
                    }, t
                }(yS), kx.initInfo = {
                    name: "GbufferStage",
                    priority: Mx.GBUFFER,
                    tag: 0,
                    renderQueues: [{
                        isTransparent: !1,
                        sortMode: EA.FRONT_TO_BACK,
                        stages: ["default"]
                    }, {
                        isTransparent: !0,
                        sortMode: EA.BACK_TO_FRONT,
                        stages: ["default"]
                    }]
                }, Hx = ie((Gx = Vx).prototype, "renderQueues", [Fx, w_, zx], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return []
                    }
                }), Ux = Gx)) || Ux)),
                NC = e("GbufferFlow", A_("GbufferFlow")((Jx = Qx = function(e) {
                    function t() {
                        return e.apply(this, arguments) || this
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.initialize = function(t) {
                        if (e.prototype.initialize.call(this, t), 0 === this._stages.length) {
                            var n = new DC;
                            n.initialize(DC.initInfo), this._stages.push(n)
                        }
                        return !0
                    }, n.activate = function(t) {
                        e.prototype.activate.call(this, t)
                    }, n.render = function(t) {
                        e.prototype.render.call(this, t)
                    }, n.destroy = function() {
                        e.prototype.destroy.call(this)
                    }, t
                }(wS), Qx.initInfo = {
                    name: Nu,
                    priority: Lx.GBUFFER,
                    stages: []
                }, Zx = Jx)) || Zx),
                MC = [new ps(0, 0, 0, 1)],
                LC = e("LightingStage", ($x = A_("LightingStage"), eC = ef(nE), tC = q_(), nC = ef([bA]), iC = q_(), $x((lC = cC = function(e) {
                    function t() {
                        for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                        return (t = e.call.apply(e, [this].concat(i)) || this)._deferredLitsBufs = null, t._maxDeferredLights = xh.LIGHTS_PER_PASS, t._lightMeterScale = 1e4, t._descriptorSet = null, t._renderArea = new ss, ne(t, "_deferredMaterial", aC, $(t)), ne(t, "renderQueues", sC, $(t)), t._phaseID = tm("default"), t._defPhaseID = tm("deferred"), t._renderQueues = [], t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.initialize = function(t) {
                        return e.prototype.initialize.call(this, t), !0
                    }, n.gatherLights = function(e) {
                        for (var t = this._pipeline, n = t.commandBuffers[0], i = e.scene.sphereLights, r = e.scene.spotLights, o = es.create(0, 0, 0, 1), a = new Float32Array(4), s = e.exposure, c = 0, l = Wn.length, u = l * this._maxDeferredLights, h = 0; h < i.length && c < this._maxDeferredLights; h++, ++c) {
                            var _ = i[h];
                            if (es.set(o, _.position.x, _.position.y, _.position.z, _.range), Vl.sphereFrustum(o, e.frustum)) {
                                if (En.toArray(a, _.position), a[3] = 0, this._lightBufferData.set(a, c * l), En.toArray(a, _.color), _.useColorTemperature) {
                                    var f = _.colorTemperatureRGB;
                                    a[0] *= f.x, a[1] *= f.y, a[2] *= f.z
                                }
                                t.pipelineSceneData.isHDR ? a[3] = _.luminance * t.pipelineSceneData.fpScale * this._lightMeterScale : a[3] = _.luminance * s * this._lightMeterScale, this._lightBufferData.set(a, c * l + 1 * u), a[0] = _.size, a[1] = _.range, a[2] = 0, this._lightBufferData.set(a, c * l + 2 * u)
                            }
                        }
                        for (var d = 0; d < r.length && c < this._maxDeferredLights; d++, ++c) {
                            var p = r[d];
                            if (es.set(o, p.position.x, p.position.y, p.position.z, p.range), Vl.sphereFrustum(o, e.frustum)) {
                                if (En.toArray(a, p.position), a[3] = 1, this._lightBufferData.set(a, c * l + 0 * u), En.toArray(a, p.color), p.useColorTemperature) {
                                    var m = p.colorTemperatureRGB;
                                    a[0] *= m.x, a[1] *= m.y, a[2] *= m.z
                                }
                                t.pipelineSceneData.isHDR ? a[3] = p.luminance * t.pipelineSceneData.fpScale * this._lightMeterScale : a[3] = p.luminance * s * this._lightMeterScale, this._lightBufferData.set(a, c * l + 1 * u), a[0] = p.size, a[1] = p.range, a[2] = p.spotAngle, this._lightBufferData.set(a, c * l + 2 * u), En.toArray(a, p.direction), this._lightBufferData.set(a, c * l + 3 * u)
                            }
                        }
                        var g = 3 * u + 3;
                        this._lightBufferData.set([c], g), n.updateBuffer(this._deferredLitsBufs, this._lightBufferData)
                    }, n.activate = function(t, n) {
                        e.prototype.activate.call(this, t, n);
                        for (var i = t.device, r = 0; r < this.renderQueues.length; r++) this._renderQueues[r] = PA(this.renderQueues[r]);
                        var o = 16 * Float32Array.BYTES_PER_ELEMENT * this._maxDeferredLights;
                        o = Math.ceil(o / i.capabilities.uboOffsetAlignment) * i.capabilities.uboOffsetAlignment, this._deferredLitsBufs = i.createBuffer(new gs(xa.UNIFORM | xa.TRANSFER_DST, Ra.HOST | Ra.DEVICE, o, i.capabilities.uboOffsetAlignment));
                        var a = i.createBuffer(new vs(this._deferredLitsBufs, 0, o));
                        this._lightBufferData = new Float32Array(o / Float32Array.BYTES_PER_ELEMENT);
                        var s = new js(Uu.bindings);
                        this._descriptorSetLayout = i.createDescriptorSetLayout(s), this._descriptorSet = i.createDescriptorSet(new qs(this._descriptorSetLayout)), this._descriptorSet.bindBuffer(Ah.BINDING, a), this._planarQueue = new ux(this._pipeline)
                    }, n.destroy = function() {
                        this._deferredLitsBufs.destroy(), this._deferredLitsBufs = null, this._descriptorSet = null
                    }, n.render = function(e) {
                        var t = this._pipeline,
                            n = t.device,
                            i = t.commandBuffers[0],
                            r = t.pipelineSceneData.renderObjects;
                        if (0 !== r.length) {
                            if (this.gatherLights(e), this._descriptorSet.update(), this._planarQueue.gatherShadowPasses(e, i), i.bindDescriptorSet(Vu.LOCAL, this._descriptorSet, [0]), this._renderArea = t.generateRenderArea(e), e.clearFlag & $a.COLOR)
                                if (t.pipelineSceneData.isHDR) {
                                    NA(MC[0], e.clearColor);
                                    var o = t.pipelineSceneData.fpScale / e.exposure;
                                    MC[0].x *= o, MC[0].y *= o, MC[0].z *= o
                                } else MC[0].x = e.clearColor.x, MC[0].y = e.clearColor.y, MC[0].z = e.clearColor.z;
                            MC[0].w = 0;
                            var a, s, c = t.getDeferredRenderData(e).lightingFrameBuffer,
                                l = c.renderPass;
                            i.beginRenderPass(l, c, this._renderArea, MC, e.clearDepth, e.clearStencil), i.bindDescriptorSet(Vu.GLOBAL, t.descriptorSet);
                            var u = em.get("builtin-deferred-material");
                            u ? (a = u.passes[0], s = vr.get(a.getShaderVariant())) : (a = this._deferredMaterial.passes[1], s = vr.get(this._deferredMaterial.passes[1].getShaderVariant()));
                            var h = t.quadIAOffscreen,
                                _ = null;
                            null != a && null != s && null != h && (_ = SA.getOrCreatePipelineState(n, a, s, l, h)), null != _ && (i.bindPipelineState(_), i.bindInputAssembler(h), i.draw(h)), this._renderQueues.forEach(OA);
                            for (var f = 0, d = 0, p = 0, m = 0; m < r.length; ++m) {
                                var g = r[m],
                                    v = g.model.subModels;
                                for (f = 0; f < v.length; ++f) {
                                    var y = v[f].passes;
                                    for (d = 0; d < y.length; ++d) {
                                        var S = y[d];
                                        if (S.phase === this._phaseID || S.phase === this._defPhaseID)
                                            for (p = 0; p < this._renderQueues.length; p++) this._renderQueues[p].insertRenderPass(g, f, d)
                                    }
                                }
                            }
                            this._renderQueues.forEach(DA);
                            for (var E = 0; E < this._renderQueues.length; E++) this._renderQueues[E].recordCommandBuffer(n, l, i);
                            this._planarQueue.recordCommandBuffer(n, l, i), i.endRenderPass()
                        }
                    }, K(t, [{
                        key: "material",
                        set: function(e) {
                            this._deferredMaterial !== e && (this._deferredMaterial = e)
                        }
                    }]), t
                }(yS), cC.initInfo = {
                    name: "LightingStage",
                    priority: Mx.LIGHTING,
                    tag: 0
                }, aC = ie((oC = lC).prototype, "_deferredMaterial", [eC, w_, tC], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return null
                    }
                }), sC = ie(oC.prototype, "renderQueues", [nC, w_, iC], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return []
                    }
                }), rC = oC)) || rC)),
                BC = e("LightingFlow", A_("LightingFlow")((_C = hC = function(e) {
                    function t() {
                        return e.apply(this, arguments) || this
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.initialize = function(t) {
                        if (e.prototype.initialize.call(this, t), 0 === this._stages.length) {
                            var n = new LC;
                            n.initialize(LC.initInfo), this._stages.push(n)
                        }
                        return !0
                    }, n.activate = function(t) {
                        e.prototype.activate.call(this, t)
                    }, n.render = function(t) {
                        e.prototype.render.call(this, t)
                    }, n.destroy = function() {
                        e.prototype.destroy.call(this)
                    }, t
                }(wS), hC.initInfo = {
                    name: Mu,
                    priority: Lx.LIGHTING,
                    stages: []
                }, uC = _C)) || uC),
                FC = Kf([Da.LINEAR, Da.LINEAR, Da.NONE, Na.CLAMP, Na.CLAMP, Na.CLAMP]),
                zC = function() {
                    this.quadIB = null, this.quadVB = null, this.quadIA = null
                },
                UC = function() {
                    this.gbufferFrameBuffer = null, this.gbufferRenderTargets = [], this.lightingFrameBuffer = null, this.lightingRenderTargets = [], this.depthTex = null
                },
                GC = e("DeferredPipeline", (fC = A_("DeferredPipeline"), dC = ef([TA]), pC = q_(), mC = ef([AA]), gC = q_(), fC((TC = function(e) {
                    function t() {
                        for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                        return (t = e.call.apply(e, [this].concat(i)) || this)._quadIB = null, t._quadVBOnscreen = null, t._quadVBOffscreen = null, t._quadIAOnscreen = null, t._quadIAOffscreen = null, t._deferredRenderData = null, t._gbufferRenderPass = null, t._lightingRenderPass = null, t._width = 0, t._height = 0, t._lastUsedRenderArea = new ss, ne(t, "renderTextures", SC, $(t)), ne(t, "materials", EC, $(t)), t._renderPasses = new Map, t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.initialize = function(t) {
                        if (e.prototype.initialize.call(this, t), 0 === this._flows.length) {
                            var n = new Xx;
                            n.initialize(Xx.initInfo), this._flows.push(n);
                            var i = new NC;
                            i.initialize(NC.initInfo), this._flows.push(i);
                            var r = new BC;
                            r.initialize(BC.initInfo), this._flows.push(r)
                        }
                        return !0
                    }, n.activate = function() {
                        return this._macros.CC_PIPELINE_TYPE = 1, !(!e.prototype.activate.call(this) || !this._activeRenderer() && (b(2402), 1))
                    }, n.render = function(e) {
                        if (0 !== e.length) {
                            this._commandBuffers[0].begin(), this._pipelineUBO.updateGlobalUBO();
                            for (var t = 0; t < e.length; t++) {
                                var n = e[t];
                                if (n.scene) {
                                    EE(this, n), this._pipelineUBO.updateCameraUBO(n);
                                    for (var i = 0; i < this._flows.length; i++) this._flows[i].render(n)
                                }
                            }
                            this._commandBuffers[0].end(), this._device.queue.submit(this._commandBuffers)
                        }
                    }, n.getRenderPass = function(e) {
                        var t = this._renderPasses.get(e);
                        if (t) return t;
                        var n = this.device,
                            i = new Fs,
                            r = new zs;
                        i.format = n.colorFormat, r.format = n.depthStencilFormat, r.stencilStoreOp = Ha.DISCARD, r.depthStoreOp = Ha.DISCARD, e & $a.COLOR || (e & h_ ? i.loadOp = Ga.DISCARD : (i.loadOp = Ga.LOAD, i.beginAccesses = [ka.PRESENT])), (e & $a.DEPTH_STENCIL) !== $a.DEPTH_STENCIL && (e & $a.DEPTH || (r.depthLoadOp = Ga.LOAD), e & $a.STENCIL || (r.stencilLoadOp = Ga.LOAD), r.beginAccesses = [ka.DEPTH_STENCIL_ATTACHMENT_WRITE]);
                        var o = new Gs([i], r);
                        return t = n.createRenderPass(o), this._renderPasses.set(e, t), t
                    }, n.getDeferredRenderData = function() {
                        return this._deferredRenderData || this._generateDeferredRenderData(), this._deferredRenderData
                    }, n._activeRenderer = function() {
                        var e = this.device;
                        this._commandBuffers.push(e.commandBuffer);
                        var t = cd.getSampler(e, FC);
                        this._descriptorSet.bindSampler(Zu, t), this._descriptorSet.bindTexture(Zu, em.get("default-texture").getGFXTexture()), this._descriptorSet.bindSampler(gh, t), this._descriptorSet.bindTexture(gh, em.get("default-texture").getGFXTexture()), this._descriptorSet.update();
                        var n = new zC;
                        if (!(n = this.createQuadInputAssembler(ya.IDENTITY)).quadIB || !n.quadVB || !n.quadIA) return !1;
                        this._quadIB = n.quadIB, this._quadVBOffscreen = n.quadVB, this._quadIAOffscreen = n.quadIA;
                        var i = this.createQuadInputAssembler(e.surfaceTransform);
                        if (!i.quadIB || !i.quadVB || !i.quadIA) return !1;
                        if (this._quadVBOnscreen = i.quadVB, this._quadIAOnscreen = i.quadIA, !this._gbufferRenderPass) {
                            var r = new Fs;
                            r.format = Ea.RGBA16F, r.loadOp = Ga.CLEAR, r.storeOp = Ha.STORE;
                            var o = new Fs;
                            o.format = Ea.RGBA16F, o.loadOp = Ga.CLEAR, o.storeOp = Ha.STORE;
                            var a = new Fs;
                            a.format = Ea.RGBA16F, a.loadOp = Ga.CLEAR, a.storeOp = Ha.STORE;
                            var s = new Fs;
                            s.format = Ea.RGBA16F, s.loadOp = Ga.CLEAR, s.storeOp = Ha.STORE;
                            var c = new zs;
                            c.format = e.depthStencilFormat, c.depthLoadOp = Ga.CLEAR, c.depthStoreOp = Ha.STORE, c.stencilLoadOp = Ga.CLEAR, c.stencilStoreOp = Ha.STORE;
                            var l = new Gs([r, o, a, s], c);
                            this._gbufferRenderPass = e.createRenderPass(l)
                        }
                        if (!this._lightingRenderPass) {
                            var u = new Fs;
                            u.format = Ea.RGBA16F, u.loadOp = Ga.CLEAR, u.storeOp = Ha.STORE, u.endAccesses = [ka.COLOR_ATTACHMENT_WRITE];
                            var h = new zs;
                            h.format = e.depthStencilFormat, h.depthLoadOp = Ga.LOAD, h.depthStoreOp = Ha.DISCARD, h.stencilLoadOp = Ga.LOAD, h.stencilStoreOp = Ha.DISCARD, h.beginAccesses = [ka.DEPTH_STENCIL_ATTACHMENT_WRITE], h.endAccesses = [ka.DEPTH_STENCIL_ATTACHMENT_WRITE];
                            var _ = new Gs([u], h);
                            this._lightingRenderPass = e.createRenderPass(_)
                        }
                        return this._width = e.width, this._height = e.height, this._generateDeferredRenderData(), e.surfaceTransform === ya.IDENTITY || e.surfaceTransform === ya.ROTATE_180 ? (this._width = e.width, this._height = e.height) : (this._width = e.height, this._height = e.width), !0
                    }, n.destroyUBOs = function() {
                        this._descriptorSet && (this._descriptorSet.getBuffer(Xu.BINDING).destroy(), this._descriptorSet.getBuffer(Ku.BINDING).destroy(), this._descriptorSet.getBuffer(Yu.BINDING).destroy(), this._descriptorSet.getSampler(Zu).destroy(), this._descriptorSet.getSampler(gh).destroy(), this._descriptorSet.getTexture(Zu).destroy(), this._descriptorSet.getTexture(gh).destroy())
                    }, n.destroyDeferredData = function() {
                        var e = this._deferredRenderData;
                        if (e) {
                            e.gbufferFrameBuffer && e.gbufferFrameBuffer.destroy(), e.lightingFrameBuffer && e.lightingFrameBuffer.destroy(), e.depthTex && e.depthTex.destroy();
                            for (var t = 0; t < e.gbufferRenderTargets.length; t++) e.gbufferRenderTargets[t].destroy();
                            e.gbufferRenderTargets.length = 0;
                            for (var n = 0; n < e.lightingRenderTargets.length; n++) e.lightingRenderTargets[n].destroy();
                            e.lightingRenderTargets.length = 0
                        }
                        this._deferredRenderData = null
                    }, n.destroy = function() {
                        this.destroyUBOs(), this.destroyQuadInputAssembler(), this.destroyDeferredData();
                        for (var t = this._renderPasses.values(), n = t.next(); !n.done;) n.value.destroy(), n = t.next();
                        return this._commandBuffers.length = 0, e.prototype.destroy.call(this)
                    }, n.resize = function(e, t) {
                        this._width === e && this._height === t || (this._width = e, this._height = t, this.destroyDeferredData(), this._generateDeferredRenderData())
                    }, n.createQuadInputAssembler = function() {
                        var e = new zC,
                            t = 4 * Float32Array.BYTES_PER_ELEMENT,
                            n = 4 * t,
                            i = this._device.createBuffer(new gs(xa.VERTEX | xa.TRANSFER_DST, Ra.HOST | Ra.DEVICE, n, t));
                        if (!i) return e;
                        var r = Uint8Array.BYTES_PER_ELEMENT,
                            o = 6 * r,
                            a = this._device.createBuffer(new gs(xa.INDEX | xa.TRANSFER_DST, Ra.HOST | Ra.DEVICE, o, r));
                        if (!a) return e;
                        var s = new Uint8Array(6);
                        s[0] = 0, s[1] = 1, s[2] = 2, s[3] = 1, s[4] = 3, s[5] = 2, a.update(s);
                        var c = new Array(2);
                        c[0] = new Ms("a_position", Ea.RG32F), c[1] = new Ms("a_texCoord", Ea.RG32F);
                        var l = this._device.createInputAssembler(new Bs(c, [i], a));
                        return e.quadIB = a, e.quadVB = i, e.quadIA = l, e
                    }, n.updateQuadVertexData = function(e) {
                        if (this._lastUsedRenderArea !== e) {
                            this._lastUsedRenderArea = e;
                            var t = this.genQuadVertexData(ya.IDENTITY, e);
                            this._quadVBOffscreen.update(t);
                            var n = this.genQuadVertexData(this.device.surfaceTransform, e);
                            this._quadVBOnscreen.update(n)
                        }
                    }, n.genQuadVertexData = function(e, t) {
                        var n = new Float32Array(16),
                            i = t.x / this.device.width,
                            r = (t.x + t.width) / this.device.width,
                            o = t.y / this.device.height,
                            a = (t.y + t.height) / this.device.height;
                        if (this.device.capabilities.screenSpaceSignY > 0) {
                            var s = a;
                            a = o, o = s
                        }
                        var c = 0;
                        switch (e) {
                            case ya.IDENTITY:
                                c = 0, n[c++] = -1, n[c++] = -1, n[c++] = i, n[c++] = a, n[c++] = 1, n[c++] = -1, n[c++] = r, n[c++] = a, n[c++] = -1, n[c++] = 1, n[c++] = i, n[c++] = o, n[c++] = 1, n[c++] = 1, n[c++] = r, n[c++] = o;
                                break;
                            case ya.ROTATE_90:
                                c = 0, n[c++] = -1, n[c++] = -1, n[c++] = r, n[c++] = a, n[c++] = 1, n[c++] = -1, n[c++] = r, n[c++] = o, n[c++] = -1, n[c++] = 1, n[c++] = i, n[c++] = a, n[c++] = 1, n[c++] = 1, n[c++] = i, n[c++] = o;
                                break;
                            case ya.ROTATE_180:
                                c = 0, n[c++] = -1, n[c++] = -1, n[c++] = i, n[c++] = o, n[c++] = 1, n[c++] = -1, n[c++] = r, n[c++] = o, n[c++] = -1, n[c++] = 1, n[c++] = i, n[c++] = a, n[c++] = 1, n[c++] = 1, n[c++] = r, n[c++] = a;
                                break;
                            case ya.ROTATE_270:
                                c = 0, n[c++] = -1, n[c++] = -1, n[c++] = i, n[c++] = o, n[c++] = 1, n[c++] = -1, n[c++] = i, n[c++] = a, n[c++] = -1, n[c++] = 1, n[c++] = r, n[c++] = o, n[c++] = 1, n[c++] = 1, n[c++] = r, n[c++] = a
                        }
                        return n
                    }, n.destroyQuadInputAssembler = function() {
                        this._quadIB && (this._quadIB.destroy(), this._quadIB = null), this._quadVBOnscreen && (this._quadVBOnscreen.destroy(), this._quadVBOnscreen = null), this._quadVBOffscreen && (this._quadVBOffscreen.destroy(), this._quadVBOffscreen = null), this._quadIAOnscreen && (this._quadIAOnscreen.destroy(), this._quadIAOnscreen = null), this._quadIAOffscreen && (this._quadIAOffscreen.destroy(), this._quadIAOffscreen = null)
                    }, n._generateDeferredRenderData = function() {
                        var e = this.device,
                            t = this._deferredRenderData = new UC;
                        t.gbufferRenderTargets.push(e.createTexture(new Ts(wa.TEX2D, Ia.COLOR_ATTACHMENT | Ia.SAMPLED, Ea.RGBA16F, this._width, this._height))), t.gbufferRenderTargets.push(e.createTexture(new Ts(wa.TEX2D, Ia.COLOR_ATTACHMENT | Ia.SAMPLED, Ea.RGBA16F, this._width, this._height))), t.gbufferRenderTargets.push(e.createTexture(new Ts(wa.TEX2D, Ia.COLOR_ATTACHMENT | Ia.SAMPLED, Ea.RGBA16F, this._width, this._height))), t.gbufferRenderTargets.push(e.createTexture(new Ts(wa.TEX2D, Ia.COLOR_ATTACHMENT | Ia.SAMPLED, Ea.RGBA16F, this._width, this._height))), t.depthTex = e.createTexture(new Ts(wa.TEX2D, Ia.DEPTH_STENCIL_ATTACHMENT, e.depthStencilFormat, this._width, this._height)), t.gbufferFrameBuffer = e.createFramebuffer(new Vs(this._gbufferRenderPass, t.gbufferRenderTargets, t.depthTex)), t.lightingRenderTargets.push(e.createTexture(new Ts(wa.TEX2D, Ia.COLOR_ATTACHMENT | Ia.SAMPLED, Ea.RGBA16F, this._width, this._height))), t.lightingFrameBuffer = e.createFramebuffer(new Vs(this._lightingRenderPass, t.lightingRenderTargets, t.depthTex)), this._descriptorSet.bindTexture($u, t.gbufferFrameBuffer.colorTextures[0]), this._descriptorSet.bindTexture(nh, t.gbufferFrameBuffer.colorTextures[1]), this._descriptorSet.bindTexture(oh, t.gbufferFrameBuffer.colorTextures[2]), this._descriptorSet.bindTexture(hh, t.gbufferFrameBuffer.colorTextures[3]), this._descriptorSet.bindTexture(ch, t.lightingFrameBuffer.colorTextures[0]);
                        var n = cd.getSampler(e, FC);
                        this._descriptorSet.bindSampler($u, n), this._descriptorSet.bindSampler(nh, n), this._descriptorSet.bindSampler(oh, n), this._descriptorSet.bindSampler(hh, n), this._descriptorSet.bindSampler(ch, n)
                    }, K(t, [{
                        key: "quadIAOnscreen",
                        get: function() {
                            return this._quadIAOnscreen
                        }
                    }, {
                        key: "quadIAOffscreen",
                        get: function() {
                            return this._quadIAOffscreen
                        }
                    }]), t
                }(XE), SC = ie((yC = TC).prototype, "renderTextures", [dC, w_, pC], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return []
                    }
                }), EC = ie(yC.prototype, "materials", [mC, w_, gC], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return []
                    }
                }), vC = yC)) || vC)),
                HC = [new ps(0, 0, 0, 1)];

            function kC() {
                var e = new Kx;
                return e.initialize({
                    flows: []
                }), e
            }
            e("PostprocessStage", (AC = A_("PostprocessStage"), xC = ef(nE), CC = q_(), AC((PC = IC = function(e) {
                function t() {
                    var t;
                    return ne(t = e.call(this) || this, "_postprocessMaterial", wC, $(t)), t._renderArea = new ss, t._uiPhase = void 0, t._uiPhase = new hx, t
                }
                Q(t, e);
                var n = t.prototype;
                return n.initialize = function(t) {
                    return e.prototype.initialize.call(this, t), !0
                }, n.activate = function(t, n) {
                    e.prototype.activate.call(this, t, n), this._uiPhase.activate(t)
                }, n.destroy = function() {}, n.render = function(e) {
                    var t = this._pipeline,
                        n = t.device,
                        i = t.commandBuffers[0];
                    t.pipelineUBO.updateCameraUBO(e);
                    var r = e.viewport;
                    this._renderArea.x = r.x * e.width, this._renderArea.y = r.y * e.height, this._renderArea.width = r.width * e.width * t.pipelineSceneData.shadingScale, this._renderArea.height = r.height * e.height * t.pipelineSceneData.shadingScale;
                    var o, a, s = e.window.framebuffer,
                        c = s.colorTextures[0] ? s.renderPass : t.getRenderPass(e.clearFlag);
                    e.clearFlag & $a.COLOR && (HC[0].x = e.clearColor.x, HC[0].y = e.clearColor.y, HC[0].z = e.clearColor.z), HC[0].w = e.clearColor.w, i.beginRenderPass(c, s, this._renderArea, HC, e.clearDepth, e.clearStencil), i.bindDescriptorSet(Vu.GLOBAL, t.descriptorSet);
                    var l = em.get("builtin-post-process-material");
                    l ? (o = l.passes[0], a = vr.get(o.getShaderVariant())) : (o = this._postprocessMaterial.passes[0], a = vr.get(this._postprocessMaterial.passes[0].getShaderVariant()));
                    var u = e.window.hasOffScreenAttachments ? t.quadIAOffscreen : t.quadIAOnscreen,
                        h = null;
                    null != o && null != a && null != u && (h = SA.getOrCreatePipelineState(n, o, a, c, u));
                    var _ = t.pipelineSceneData.renderObjects;
                    null != h && _.length > 0 && (i.bindPipelineState(h), i.bindInputAssembler(u), i.draw(u)), this._uiPhase.render(e, c), i.endRenderPass()
                }, K(t, [{
                    key: "material",
                    set: function(e) {
                        this._postprocessMaterial !== e && (this._postprocessMaterial = e)
                    }
                }]), t
            }(yS), IC.initInfo = {
                name: "PostprocessStage",
                priority: Mx.POSTPROCESS,
                tag: 0
            }, wC = ie((RC = PC).prototype, "_postprocessMaterial", [xC, w_, CC], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return null
                }
            }), bC = RC)) || bC));
            var VC = e("Game", function(e) {
                function t() {
                    for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                    return (t = e.call.apply(e, [this].concat(i)) || this).frame = null, t.container = null, t.canvas = null, t.renderType = -1, t.eventTargetOn = e.prototype.on, t.eventTargetOnce = e.prototype.once, t.config = {}, t.onStart = null, t.collisionMatrix = [], t.groupList = [], t._persistRootNodes = {}, t._paused = !0, t._configLoaded = !1, t._isCloning = !1, t._inited = !1, t._engineInited = !1, t._rendererInitialized = !1, t._gfxDevice = null, t._intervalId = null, t
                }
                Q(t, e);
                var n = t.prototype;
                return n.setFrameRate = function(e) {
                    var t = this.config;
                    "number" != typeof e && (e = parseInt(e, 10), Number.isNaN(e) && (e = 60)), t.frameRate = e, this._paused = !0, this._setAnimFrame(), this._runMainLoop()
                }, n.getFrameRate = function() {
                    return this.config.frameRate || 0
                }, n.step = function() {
                    i.director.mainLoop()
                }, n.pause = function() {
                    this._paused || (this._paused = !0, this._intervalId && (window.cAF(this._intervalId), this._intervalId = 0))
                }, n.resume = function() {
                    this._paused && this._runMainLoop()
                }, n.isPaused = function() {
                    return this._paused
                }, n.restart = function() {
                    var e = this;
                    return new Promise((function(e) {
                        return i.director.once(i.Director.EVENT_AFTER_DRAW, (function() {
                            return e()
                        }))
                    })).then((function() {
                        for (var n in e._persistRootNodes) e.removePersistRootNode(e._persistRootNodes[n]);
                        return i.director.getScene().destroy(), i.Object._deferredDestroy(), i.director.reset(), e.pause(), e._setRenderPipelineNShowSplash().then((function() {
                            e.resume(), e._safeEmit(t.EVENT_RESTART)
                        }))
                    }))
                }, n.end = function() {
                    this._gfxDevice && (this._gfxDevice.destroy(), this._gfxDevice = null), window.close()
                }, n.on = function(e, n, i, r) {
                    return this._engineInited && e === t.EVENT_ENGINE_INITED ? n.call(i) : this.eventTargetOn(e, n, i, r)
                }, n.once = function(e, n, i) {
                    return this._engineInited && e === t.EVENT_ENGINE_INITED ? n.call(i) : this.eventTargetOnce(e, n, i)
                }, n.init = function(e) {
                    var t = this;
                    return this._initConfig(e), this.config.assetOptions && i.assetManager.init(this.config.assetOptions), this._initEngine().then((function() {
                        return t._initEvents(), i.director.root.dataPoolManager && i.director.root.dataPoolManager.jointTexturePool.registerCustomTextureLayouts(e.customJointTextureLayouts), t._engineInited
                    }))
                }, n.run = function(e, t) {
                    var n, i = this;
                    return "function" != typeof e && e ? (n = this.init(e), this.onStart = null != t ? t : null) : this.onStart = null != e ? e : null, Promise.resolve(n).then((function() {
                        return WC.config.registerSystemEvent && Gy.registerSystemEvent(), i._setRenderPipelineNShowSplash()
                    }))
                }, n.addPersistRootNode = function(e) {
                    if (i.Node.isNode(e) && e.uuid) {
                        var t = e.uuid;
                        if (!this._persistRootNodes[t]) {
                            var n = i.director._scene;
                            if (i.isValid(n))
                                if (e.parent) {
                                    if (!(e.parent instanceof i.Scene)) return void x(3801);
                                    if (e.parent !== n) return void x(3802);
                                    e._originalSceneId = n.uuid
                                } else e.parent = n;
                            this._persistRootNodes[t] = e, e._persistNode = !0, i.assetManager._releaseManager._addPersistNodeRef(e)
                        }
                    } else x(3800)
                }, n.removePersistRootNode = function(e) {
                    var t = e.uuid || "";
                    e === this._persistRootNodes[t] && (delete this._persistRootNodes[t], e._persistNode = !1, e._originalSceneId = "", i.assetManager._releaseManager._removePersistNodeRef(e))
                }, n.isPersistRootNode = function(e) {
                    return !!e._persistNode
                }, n._initEngine = function() {
                    var e = this;
                    return this._initDevice(), Promise.resolve(i.director._init()).then((function() {
                        f("Cocos Creator v" + r), e.emit(t.EVENT_ENGINE_INITED), e._engineInited = !0, i.internal.dynamicAtlasManager.enabled = !rt.CLEANUP_IMAGE_CACHE
                    }))
                }, n._setAnimFrame = function() {
                    this._lastTime = performance.now();
                    var e = this.config.frameRate;
                    this._frameTime = 1e3 / e, this._intervalId && (window.cAF(this._intervalId), this._intervalId = 0);
                    var t = window.requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame;
                    60 !== e && 30 !== e ? (window.rAF = t ? this._stTimeWithRAF : this._stTime, window.cAF = this._ctTime) : (window.rAF = t || this._stTime, window.cAF = window.cancelAnimationFrame || window.cancelRequestAnimationFrame || window.msCancelRequestAnimationFrame || window.mozCancelRequestAnimationFrame || window.oCancelRequestAnimationFrame || window.webkitCancelRequestAnimationFrame || window.msCancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.ocancelAnimationFrame || this._ctTime)
                }, n._stTimeWithRAF = function(e) {
                    var t = performance.now(),
                        n = Math.max(0, t - WC._lastTime),
                        i = Math.max(0, WC._frameTime - n),
                        r = window.setTimeout((function() {
                            window.requestAnimationFrame(e)
                        }), i);
                    return WC._lastTime = t + i, r
                }, n._stTime = function(e) {
                    var t = performance.now(),
                        n = Math.max(0, t - WC._lastTime),
                        i = Math.max(0, WC._frameTime - n),
                        r = window.setTimeout(e, i);
                    return WC._lastTime = t + i, r
                }, n._ctTime = function(e) {
                    window.clearTimeout(e)
                }, n._runMainLoop = function() {
                    var e = this;
                    if (this._inited) {
                        var t, n = this.config,
                            r = i.director,
                            o = n.frameRate;
                        if (D(!!n.showFPS), r.startAnimation(), 30 === o) {
                            var a = !0;
                            t = function(n) {
                                e._intervalId = window.rAF(t), (a = !a) || r.mainLoop(n)
                            }
                        } else t = function(n) {
                            e._intervalId = window.rAF(t), r.mainLoop(n)
                        };
                        this._intervalId && (window.cAF(this._intervalId), this._intervalId = 0), this._intervalId = window.rAF(t), this._paused = !1
                    }
                }, n._initConfig = function(e) {
                    "number" != typeof e.debugMode && (e.debugMode = R.NONE), e.exposeClassName = !!e.exposeClassName, "number" != typeof e.frameRate && (e.frameRate = 60);
                    var t = e.renderMode;
                    ("number" != typeof t || t > 2 || t < 0) && (e.renderMode = 0), "boolean" != typeof e.registerSystemEvent && (e.registerSystemEvent = !0), e.showFPS = !!e.showFPS, this.collisionMatrix = e.collisionMatrix || [], this.groupList = e.groupList || [], v(e.debugMode), this.config = e, this._configLoaded = !0, this._setAnimFrame()
                }, n._determineRenderType = function() {
                    var e = this.config,
                        n = parseInt(e.renderMode, 10);
                    this.renderType = t.RENDER_TYPE_CANVAS;
                    var r = !1;
                    if (0 === n ? i.sys.capabilities.opengl ? (this.renderType = t.RENDER_TYPE_WEBGL, r = !0) : i.sys.capabilities.canvas && (this.renderType = t.RENDER_TYPE_CANVAS, r = !0) : 1 === n && i.sys.capabilities.canvas ? (this.renderType = t.RENDER_TYPE_CANVAS, r = !0) : 2 === n && i.sys.capabilities.opengl && (this.renderType = t.RENDER_TYPE_WEBGL, r = !0), !r) throw new Error(P(3820, n))
                }, n._initDevice = function() {
                    if (!this._rendererInitialized) {
                        if (this.canvas = this.config.adapter.canvas, this.frame = this.config.adapter.frame, this.container = this.config.adapter.container, this._determineRenderType(), this.renderType === t.RENDER_TYPE_WEBGL) {
                            var e = [],
                                n = !!window.WebGL2RenderingContext,
                                r = window.navigator.userAgent.toLowerCase();
                            (-1 !== r.indexOf("safari") && -1 === r.indexOf("chrome") || Ei.browserType === fi.UC) && (n = !1), n && i.WebGL2Device && e.push(i.WebGL2Device), i.WebGLDevice && e.push(i.WebGLDevice);
                            for (var o = new ec(this.canvas, rt.ENABLE_WEBGL_ANTIALIAS, !1, window.devicePixelRatio, oS.windowPixelResolution.width, oS.windowPixelResolution.height, qu), a = 0; a < e.length && (this._gfxDevice = new e[a], !this._gfxDevice.initialize(o)); a++);
                        }
                        if (!this._gfxDevice) return p("can not support canvas rendering in 3D"), void(this.renderType = t.RENDER_TYPE_CANVAS);
                        this.canvas.oncontextmenu = function() {
                            return !1
                        }
                    }
                }, n._initEvents = function() {
                    Ei.onShow(this._onShow.bind(this)), Ei.onHide(this._onHide.bind(this))
                }, n._onHide = function() {
                    this.emit(t.EVENT_HIDE), this.pause()
                }, n._onShow = function() {
                    this.emit(t.EVENT_SHOW), this.resume()
                }, n._setRenderPipelineNShowSplash = function() {
                    var e = this;
                    return Promise.resolve(this._setupRenderPipeline()).then((function() {
                        return Promise.resolve(e._showSplashScreen()).then((function() {
                            e._inited = !0, e._setAnimFrame(), e._runMainLoop(), e._safeEmit(t.EVENT_GAME_INITED), e.onStart && e.onStart()
                        }))
                    }))
                }, n._setupRenderPipeline = function() {
                    var e = this,
                        t = this.config.renderPipeline;
                    return t ? new Promise((function(e, n) {
                        i.assetManager.loadAny(t, (function(t, i) {
                            return !t && i instanceof XE ? e(i) : n(t)
                        }))
                    })).then((function(t) {
                        e._setRenderPipeline(t)
                    })).catch((function(n) {
                        d(n), d("Failed load render pipeline: " + t + ", engine failed to initialize, will fallback to default pipeline"), e._setRenderPipeline()
                    })) : this._setRenderPipeline()
                }, n._showSplashScreen = function() {
                    if (i.internal.SplashScreen) {
                        var e = i.internal.SplashScreen.instance;
                        return e.main(i.director.root), new Promise((function(t) {
                            e.setOnFinish((function() {
                                return t()
                            })), e.loadFinish = !0
                        }))
                    }
                    return null
                }, n._setRenderPipeline = function(e) {
                    i.director.root.setRenderPipeline(e) || this._setRenderPipeline(), this._rendererInitialized = !0, this._safeEmit(t.EVENT_RENDERER_INITED)
                }, n._safeEmit = function(e) {
                    this.emit(e)
                }, K(t, [{
                    key: "inited",
                    get: function() {
                        return this._inited
                    }
                }, {
                    key: "frameTime",
                    get: function() {
                        return this._frameTime
                    }
                }]), t
            }(Si));
            VC.EVENT_HIDE = "game_on_hide", VC.EVENT_SHOW = "game_on_show", VC.EVENT_LOW_MEMORY = "game_on_low_memory", VC.EVENT_GAME_INITED = "game_inited", VC.EVENT_ENGINE_INITED = "engine_inited", VC.EVENT_RENDERER_INITED = "renderer_inited", VC.EVENT_RESTART = "game_on_restart", VC.RENDER_TYPE_CANVAS = 0, VC.RENDER_TYPE_WEBGL = 1, VC.RENDER_TYPE_OPENGL = 2, i.Game = VC;
            var WC = e("game", i.game = new VC),
                jC = {
                    topLeft: i.v2(0, 0),
                    topRight: i.v2(0, 0),
                    top: i.v2(0, 0),
                    bottomLeft: i.v2(0, 0),
                    bottomRight: i.v2(0, 0),
                    bottom: i.v2(0, 0),
                    center: i.v2(0, 0),
                    left: i.v2(0, 0),
                    right: i.v2(0, 0),
                    width: 0,
                    height: 0,
                    init: function(e) {
                        var t = this.width = e.width,
                            n = this.height = e.height,
                            i = e.x,
                            r = e.y,
                            o = r + n,
                            a = i + t;
                        this.topLeft.x = i, this.topLeft.y = o, this.topRight.x = a, this.topRight.y = o, this.top.x = i + t / 2, this.top.y = o, this.bottomLeft.x = i, this.bottomLeft.y = r, this.bottomRight.x = a, this.bottomRight.y = r, this.bottom.x = i + t / 2, this.bottom.y = r, this.center.x = i + t / 2, this.center.y = r + n / 2, this.left.x = i, this.left.y = r + n / 2, this.right.x = a, this.right.y = r + n / 2
                    }
                };
            i.visibleRect = jC;
            var qC = new(function() {
                function e() {
                    this.html = void 0, this.meta = {
                        width: "device-width"
                    }, this.adaptationType = i.sys.browserType
                }
                var t = e.prototype;
                return t.init = function() {
                    this.html = document.getElementsByTagName("html")[0]
                }, t.availWidth = function(e) {
                    return i.sys.isMobile || !e || e === this.html ? window.innerWidth : e.clientWidth
                }, t.availHeight = function(e) {
                    return i.sys.isMobile || !e || e === this.html ? window.innerHeight : e.clientHeight
                }, e
            }());
            switch (Ei.os === gi.IOS && (qC.adaptationType = fi.SAFARI), qC.adaptationType) {
                case fi.SAFARI:
                    qC.meta["minimal-ui"] = "true", qC.availWidth = function(e) {
                        return e.clientWidth
                    }, qC.availHeight = function(e) {
                        return e.clientHeight
                    };
                    break;
                case fi.SOUGOU:
                case fi.UC:
                    qC.availWidth = function(e) {
                        return e.clientWidth
                    }, qC.availHeight = function(e) {
                        return e.clientHeight
                    }
            }
            var XC = e("View", function(e) {
                function t() {
                    var t;
                    (t = e.call(this) || this)._resizeWithBrowserSize = void 0, t._designResolutionSize = void 0, t._originalDesignResolutionSize = void 0, t._frameSize = void 0, t._scaleX = void 0, t._scaleY = void 0, t._viewportRect = void 0, t._visibleRect = void 0, t._autoFullScreen = void 0, t._devicePixelRatio = void 0, t._maxPixelRatio = void 0, t._retinaEnabled = void 0, t._resizeCallback = void 0, t._resizing = void 0, t._orientationChanging = void 0, t._isRotated = void 0, t._orientation = void 0, t._isAdjustViewport = void 0, t._resolutionPolicy = void 0, t._rpExactFit = void 0, t._rpShowAll = void 0, t._rpNoBorder = void 0, t._rpFixedHeight = void 0, t._rpFixedWidth = void 0;
                    var n = YC,
                        r = KC;
                    return t._frameSize = new Xn(0, 0), t._designResolutionSize = new Xn(0, 0), t._originalDesignResolutionSize = new Xn(0, 0), t._scaleX = 1, t._scaleY = 1, t._viewportRect = new Kn(0, 0, 0, 0), t._visibleRect = new Kn(0, 0, 0, 0), t._autoFullScreen = !1, t._devicePixelRatio = 1, t._maxPixelRatio = 2, t._retinaEnabled = !1, t._resizeCallback = null, t._resizing = !1, t._resizeWithBrowserSize = !1, t._orientationChanging = !0, t._isRotated = !1, t._orientation = i.macro.ORIENTATION_AUTO, t._isAdjustViewport = !0, t._rpExactFit = new ZC(n.EQUAL_TO_FRAME, r.EXACT_FIT), t._rpShowAll = new ZC(n.EQUAL_TO_FRAME, r.SHOW_ALL), t._rpNoBorder = new ZC(n.EQUAL_TO_FRAME, r.NO_BORDER), t._rpFixedHeight = new ZC(n.EQUAL_TO_FRAME, r.FIXED_HEIGHT), t._rpFixedWidth = new ZC(n.EQUAL_TO_FRAME, r.FIXED_WIDTH), t._resolutionPolicy = t._rpShowAll, i.game.once(i.Game.EVENT_ENGINE_INITED, t.init, $(t)), t
                }
                Q(t, e);
                var n = t.prototype;
                return n.init = function() {
                    qC.init(), this._initFrameSize();
                    var e = i.game.canvas.width,
                        t = i.game.canvas.height;
                    this._designResolutionSize.width = e, this._designResolutionSize.height = t, this._originalDesignResolutionSize.width = e, this._originalDesignResolutionSize.height = t, this._viewportRect.width = e, this._viewportRect.height = t, this._visibleRect.width = e, this._visibleRect.height = t, i.winSize.width = this._visibleRect.width, i.winSize.height = this._visibleRect.height, i.visibleRect && i.visibleRect.init(this._visibleRect)
                }, n.resizeWithBrowserSize = function(e) {
                    e ? this._resizeWithBrowserSize || (this._resizeWithBrowserSize = !0, Ei.onViewResize(this._resizeEvent), Ei.onOrientationChange(this._orientationChange)) : this._resizeWithBrowserSize && (this._resizeWithBrowserSize = !1, Ei.offViewResize(this._resizeEvent), Ei.offOrientationChange(this._orientationChange))
                }, n.setResizeCallback = function(e) {
                    "function" != typeof e && null != e || (this._resizeCallback = e)
                }, n.setOrientation = function(e) {
                    (e &= i.macro.ORIENTATION_AUTO) && this._orientation !== e && (this._orientation = e)
                }, n.adjustViewportMeta = function(e) {
                    this._isAdjustViewport = e
                }, n.enableRetina = function(e) {
                    this._retinaEnabled = !!e
                }, n.isRetinaEnabled = function() {
                    return this._retinaEnabled
                }, n.enableAutoFullScreen = function(e) {
                    e && e !== this._autoFullScreen && i.sys.isMobile && Ei.browserType !== fi.WECHAT ? (this._autoFullScreen = !0, i.screen.autoFullScreen(i.game.frame)) : this._autoFullScreen = !1
                }, n.isAutoFullScreenEnabled = function() {
                    return this._autoFullScreen
                }, n.setCanvasSize = function(e, t) {
                    var n = i.game.canvas,
                        r = i.game.container;
                    this._devicePixelRatio = window.devicePixelRatio, n.width = oS.windowPixelResolution.width, n.height = oS.windowPixelResolution.height, n.style.width = e + "px", n.style.height = t + "px", r.style.width = e + "px", r.style.height = t + "px", this._resizeEvent()
                }, n.getCanvasSize = function() {
                    return new Xn(i.game.canvas.width, i.game.canvas.height)
                }, n.getFrameSize = function() {
                    return new Xn(this._frameSize.width, this._frameSize.height)
                }, n.setFrameSize = function(e, t) {
                    this._frameSize.width = e, this._frameSize.height = t, i.game.frame.style.width = e + "px", i.game.frame.style.height = t + "px", this._resizeEvent()
                }, n.getVisibleSize = function() {
                    return new Xn(this._visibleRect.width, this._visibleRect.height)
                }, n.getVisibleSizeInPixel = function() {
                    return new Xn(this._visibleRect.width * this._scaleX, this._visibleRect.height * this._scaleY)
                }, n.getVisibleOrigin = function() {
                    return new Gn(this._visibleRect.x, this._visibleRect.y)
                }, n.getVisibleOriginInPixel = function() {
                    return new Gn(this._visibleRect.x * this._scaleX, this._visibleRect.y * this._scaleY)
                }, n.getResolutionPolicy = function() {
                    return this._resolutionPolicy
                }, n.setResolutionPolicy = function(e) {
                    if (e instanceof ZC) this._resolutionPolicy = e;
                    else {
                        var t = ZC;
                        e === t.EXACT_FIT && (this._resolutionPolicy = this._rpExactFit), e === t.SHOW_ALL && (this._resolutionPolicy = this._rpShowAll), e === t.NO_BORDER && (this._resolutionPolicy = this._rpNoBorder), e === t.FIXED_HEIGHT && (this._resolutionPolicy = this._rpFixedHeight), e === t.FIXED_WIDTH && (this._resolutionPolicy = this._rpFixedWidth)
                    }
                }, n.setDesignResolutionSize = function(e, t, n) {
                    if (e > 0 && t > 0) {
                        this.setResolutionPolicy(n);
                        var r = this._resolutionPolicy;
                        if (r && r.preApply(this), i.sys.isMobile && this._adjustViewportMeta(), this._orientationChanging = !0, this._resizing || this._initFrameSize(), r) {
                            this._originalDesignResolutionSize.width = this._designResolutionSize.width = e, this._originalDesignResolutionSize.height = this._designResolutionSize.height = t;
                            var o = r.apply(this, this._designResolutionSize);
                            if (o.scale && 2 === o.scale.length && (this._scaleX = o.scale[0], this._scaleY = o.scale[1]), o.viewport) {
                                var a = this._viewportRect,
                                    s = this._visibleRect,
                                    c = o.viewport;
                                a.x = c.x, a.y = c.y, a.width = c.width, a.height = c.height, s.x = 0, s.y = 0, s.width = c.width / this._scaleX, s.height = c.height / this._scaleY
                            }
                            r.postApply(this), i.winSize.width = this._visibleRect.width, i.winSize.height = this._visibleRect.height, jC && jC.init(this._visibleRect), this.emit("design-resolution-changed")
                        } else T(2201)
                    } else b(2200)
                }, n.getDesignResolutionSize = function() {
                    return new Xn(this._designResolutionSize.width, this._designResolutionSize.height)
                }, n.setRealPixelResolution = function(e, t, n) {
                    this._setViewportMeta({
                        width: e
                    }, !0), document.documentElement.style.width = e + "px", document.body.style.width = e + "px", document.body.style.left = "0px", document.body.style.top = "0px", this.setDesignResolutionSize(e, t, n)
                }, n.getViewportRect = function() {
                    return this._viewportRect
                }, n.getScaleX = function() {
                    return this._scaleX
                }, n.getScaleY = function() {
                    return this._scaleY
                }, n.getDevicePixelRatio = function() {
                    return this._devicePixelRatio
                }, n.convertToLocationInView = function(e, t, n, r) {
                    var o = r || new Gn,
                        a = this._devicePixelRatio * (e - n.left),
                        s = this._devicePixelRatio * (n.top + n.height - t);
                    return this._isRotated ? (o.x = i.game.canvas.width - s, o.y = a) : (o.x = a, o.y = s), i.GAME_VIEW && (o.x /= i.gameView.canvas.width / i.game.canvas.width, o.y /= i.gameView.canvas.height / i.game.canvas.height), o
                }, n._convertPointWithScale = function(e) {
                    var t = this._viewportRect;
                    e.x = (e.x - t.x) / this._scaleX, e.y = (e.y - t.y) / this._scaleY
                }, n._resizeEvent = function() {
                    var e = i.view,
                        t = e._frameSize.width,
                        n = e._frameSize.height,
                        r = e._isRotated;
                    if (i.sys.isMobile) {
                        var o = i.game.container.style,
                            a = o.margin;
                        o.margin = "0", o.display = "none", e._initFrameSize(), o.margin = a, o.display = "block"
                    } else e._initFrameSize();
                    if (e._orientationChanging || e._isRotated !== r || e._frameSize.width !== t || e._frameSize.height !== n) {
                        var s = e._originalDesignResolutionSize.width,
                            c = e._originalDesignResolutionSize.height;
                        e._resizing = !0, s > 0 && e.setDesignResolutionSize(s, c, e._resolutionPolicy), e._resizing = !1, e.emit("canvas-resize"), e._resizeCallback && e._resizeCallback.call()
                    }
                }, n._orientationChange = function() {
                    i.view._orientationChanging = !0, i.view._resizeEvent()
                }, n._initFrameSize = function() {
                    var e = this._frameSize,
                        t = qC.availWidth(i.game.frame),
                        n = qC.availHeight(i.game.frame),
                        r = t >= n;
                    !i.sys.isMobile || r && this._orientation & i.macro.ORIENTATION_LANDSCAPE || !r && this._orientation & i.macro.ORIENTATION_PORTRAIT ? (e.width = t, e.height = n, i.game.container.style["-webkit-transform"] = "rotate(0deg)", i.game.container.style.transform = "rotate(0deg)", this._isRotated = !1) : (e.width = n, e.height = t, i.game.container.style["-webkit-transform"] = "rotate(90deg)", i.game.container.style.transform = "rotate(90deg)", i.game.container.style["-webkit-transform-origin"] = "0px 0px 0px", i.game.container.style.transformOrigin = "0px 0px 0px", this._isRotated = !0, i.game.canvas.style["-webkit-transform"] = "translateZ(0px)", i.game.canvas.style.transform = "translateZ(0px)"), this._orientationChanging && setTimeout((function() {
                        i.view._orientationChanging = !1
                    }), 1e3)
                }, n._adjustSizeKeepCanvasSize = function() {
                    var e = this._originalDesignResolutionSize.width,
                        t = this._originalDesignResolutionSize.height;
                    e > 0 && this.setDesignResolutionSize(e, t, this._resolutionPolicy)
                }, n._setViewportMeta = function(e, t) {
                    var n = document.getElementById("cocosMetaElement");
                    n && t && document.head.removeChild(n);
                    var i, r, o, a = document.getElementsByName("viewport"),
                        s = a ? a[0] : null;
                    for (r in i = s ? s.content : "", (n = n || document.createElement("meta")).id = "cocosMetaElement", n.name = "viewport", n.content = "", e) - 1 === i.indexOf(r) ? i += "," + r + "=" + e[r] : t && (o = new RegExp(r + "s*=s*[^,]+"), i = i.replace(o, r + "=" + e[r]));
                    /^,/.test(i) && (i = i.substr(1)), n.content = i, s && (s.content = i), document.head.appendChild(n)
                }, n._adjustViewportMeta = function() {
                    this._isAdjustViewport && (this._setViewportMeta(qC.meta, !1), this._isAdjustViewport = !1)
                }, n._convertMouseToLocation = function(e, t) {
                    e.x = this._devicePixelRatio * (e.x - t.left), e.y = this._devicePixelRatio * (t.top + t.height - e.y), i.GAME_VIEW && (e.x /= i.gameView.canvas.width / i.game.canvas.width, e.y /= i.gameView.canvas.height / i.game.canvas.height)
                }, n._convertTouchWidthScale = function(e) {
                    var t = this._viewportRect,
                        n = this._scaleX,
                        i = this._scaleY;
                    e._point.x = (e._point.x - t.x) / n, e._point.y = (e._point.y - t.y) / i, e._prevPoint.x = (e._prevPoint.x - t.x) / n, e._prevPoint.y = (e._prevPoint.y - t.y) / i
                }, n._convertTouchesWithScale = function(e) {
                    for (var t, n, i = this._viewportRect, r = this._scaleX, o = this._scaleY, a = 0; a < e.length; a++) {
                        var s = e[a];
                        t = s._point, n = s._prevPoint, t.x = (t.x - i.x) / r, t.y = (t.y - i.y) / o, n.x = (n.x - i.x) / r, n.y = (n.y - i.y) / o
                    }
                }, t
            }(Si));
            XC.instance = void 0;
            var YC = function() {
                function e() {
                    this.name = "ContainerStrategy"
                }
                var t = e.prototype;
                return t.preApply = function() {}, t.apply = function() {}, t.postApply = function() {}, t._setupContainer = function(e, t, n) {
                    var r = i.game.canvas,
                        o = i.game.container;
                    Ei.os === gi.ANDROID && (document.body.style.width = (e._isRotated ? n : t) + "px", document.body.style.height = (e._isRotated ? t : n) + "px"), o.style.width = r.style.width = t + "px", o.style.height = r.style.height = n + "px", e._devicePixelRatio = 1, e.isRetinaEnabled() && (e._devicePixelRatio = Math.min(e._maxPixelRatio, window.devicePixelRatio || 1)), r.width = t * e._devicePixelRatio, r.height = n * e._devicePixelRatio
                }, t._fixContainer = function() {
                    document.body.insertBefore(i.game.container, document.body.firstChild);
                    var e = document.body.style;
                    e.width = window.innerWidth + "px", e.height = window.innerHeight + "px", e.overflow = "hidden";
                    var t = i.game.container.style;
                    t.position = "fixed", t.left = t.top = "0px", document.body.scrollTop = 0
                }, e
            }();
            YC.EQUAL_TO_FRAME = void 0, YC.PROPORTION_TO_FRAME = void 0;
            var KC = function() {
                function e() {
                    this.name = "ContentStrategy", this._result = void 0, this._result = {
                        scale: [1, 1],
                        viewport: null
                    }
                }
                var t = e.prototype;
                return t.preApply = function() {}, t.apply = function() {
                    return {
                        scale: [1, 1]
                    }
                }, t.postApply = function() {}, t._buildResult = function(e, t, n, i, r, o) {
                    Math.abs(e - n) < 2 && (n = e), Math.abs(t - i) < 2 && (i = t);
                    var a = new Kn(Math.round((e - n) / 2), Math.round((t - i) / 2), n, i);
                    return this._result.scale = [r, o], this._result.viewport = a, this._result
                }, e
            }();
            KC.EXACT_FIT = void 0, KC.SHOW_ALL = void 0, KC.NO_BORDER = void 0, KC.FIXED_HEIGHT = void 0, KC.FIXED_WIDTH = void 0,
                function() {
                    var e = function(e) {
                            function t() {
                                for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                                return (t = e.call.apply(e, [this].concat(i)) || this).name = "EqualToFrame", t
                            }
                            return Q(t, e), t.prototype.apply = function(e) {
                                var t = e._frameSize.height,
                                    n = i.game.container.style;
                                this._setupContainer(e, e._frameSize.width, e._frameSize.height), e._isRotated ? n.margin = "0 0 0 " + t + "px" : n.margin = "0px", n.padding = "0px"
                            }, t
                        }(YC),
                        t = function(e) {
                            function t() {
                                for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                                return (t = e.call.apply(e, [this].concat(i)) || this).name = "ProportionalToFrame", t
                            }
                            return Q(t, e), t.prototype.apply = function(e, t) {
                                var n, r, o = e._frameSize.width,
                                    a = e._frameSize.height,
                                    s = i.game.container.style,
                                    c = t.width,
                                    l = t.height,
                                    u = o / c,
                                    h = a / l;
                                u < h ? (n = o, r = l * u) : (n = c * h, r = a);
                                var _ = Math.round((o - n) / 2),
                                    f = Math.round((a - r) / 2);
                                n = o - 2 * _, r = a - 2 * f, this._setupContainer(e, n, r), e._isRotated ? s.margin = "0 0 0 " + a + "px" : s.margin = "0px", s.paddingLeft = _ + "px", s.paddingRight = _ + "px", s.paddingTop = f + "px", s.paddingBottom = f + "px"
                            }, t
                        }(YC),
                        n = ("undefined" == typeof window ? global : window).__globalAdapter;
                    n && (n.adaptContainerStrategy && n.adaptContainerStrategy(YC.prototype), n.adaptView && n.adaptView(XC.prototype)), YC.EQUAL_TO_FRAME = new e, YC.PROPORTION_TO_FRAME = new t;
                    var r = function(e) {
                            function t() {
                                for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                                return (t = e.call.apply(e, [this].concat(i)) || this).name = "ExactFit", t
                            }
                            return Q(t, e), t.prototype.apply = function(e, t) {
                                var n = i.game.canvas.width,
                                    r = i.game.canvas.height,
                                    o = n / t.width,
                                    a = r / t.height;
                                return this._buildResult(n, r, n, r, o, a)
                            }, t
                        }(KC),
                        o = function(e) {
                            function t() {
                                for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                                return (t = e.call.apply(e, [this].concat(i)) || this).name = "ShowAll", t
                            }
                            return Q(t, e), t.prototype.apply = function(e, t) {
                                var n, r, o = i.game.canvas.width,
                                    a = i.game.canvas.height,
                                    s = t.width,
                                    c = t.height,
                                    l = o / s,
                                    u = a / c,
                                    h = 0;
                                return l < u ? (n = o, r = c * (h = l)) : (n = s * (h = u), r = a), this._buildResult(o, a, n, r, h, h)
                            }, t
                        }(KC),
                        a = function(e) {
                            function t() {
                                for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                                return (t = e.call.apply(e, [this].concat(i)) || this).name = "NoBorder", t
                            }
                            return Q(t, e), t.prototype.apply = function(e, t) {
                                var n, r, o, a = i.game.canvas.width,
                                    s = i.game.canvas.height,
                                    c = t.width,
                                    l = t.height,
                                    u = a / c,
                                    h = s / l;
                                return u < h ? (r = c * (n = h), o = s) : (r = a, o = l * (n = u)), this._buildResult(a, s, r, o, n, n)
                            }, t
                        }(KC),
                        s = function(e) {
                            function t() {
                                for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                                return (t = e.call.apply(e, [this].concat(i)) || this).name = "FixedHeight", t
                            }
                            return Q(t, e), t.prototype.apply = function(e, t) {
                                var n = i.game.canvas.width,
                                    r = i.game.canvas.height,
                                    o = r / t.height,
                                    a = n,
                                    s = r;
                                return this._buildResult(n, r, a, s, o, o)
                            }, t
                        }(KC),
                        c = function(e) {
                            function t() {
                                for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                                return (t = e.call.apply(e, [this].concat(i)) || this).name = "FixedWidth", t
                            }
                            return Q(t, e), t.prototype.apply = function(e, t) {
                                var n = i.game.canvas.width,
                                    r = i.game.canvas.height,
                                    o = n / t.width,
                                    a = n,
                                    s = r;
                                return this._buildResult(n, r, a, s, o, o)
                            }, t
                        }(KC);
                    KC.EXACT_FIT = new r, KC.SHOW_ALL = new o, KC.NO_BORDER = new a, KC.FIXED_HEIGHT = new s, KC.FIXED_WIDTH = new c
                }();
            var ZC = e("ResolutionPolicy", function() {
                function e(e, t) {
                    this.name = "ResolutionPolicy", this._containerStrategy = void 0, this._contentStrategy = void 0, this._containerStrategy = null, this._contentStrategy = null, this.setContainerStrategy(e), this.setContentStrategy(t)
                }
                var t = e.prototype;
                return t.preApply = function(e) {
                    this._containerStrategy.preApply(e), this._contentStrategy.preApply(e)
                }, t.apply = function(e, t) {
                    return this._containerStrategy.apply(e, t), this._contentStrategy.apply(e, t)
                }, t.postApply = function(e) {
                    this._containerStrategy.postApply(e), this._contentStrategy.postApply(e)
                }, t.setContainerStrategy = function(e) {
                    e instanceof YC && (this._containerStrategy = e)
                }, t.setContentStrategy = function(e) {
                    e instanceof KC && (this._contentStrategy = e)
                }, K(e, [{
                    key: "canvasSize",
                    get: function() {
                        return new Gn(i.game.canvas.width, i.game.canvas.height)
                    }
                }]), e
            }());
            ZC.EXACT_FIT = 0, ZC.NO_BORDER = 1, ZC.SHOW_ALL = 2, ZC.FIXED_HEIGHT = 3, ZC.FIXED_WIDTH = 4, ZC.UNKNOWN = 5, ZC.ContainerStrategy = YC, ZC.ContentStrategy = KC, i.ResolutionPolicy = ZC;
            var QC = e("view", XC.instance = i.view = new XC);
            i.winSize = new Xn, G(XC.prototype, "View.prototype", [{
                name: "isAntiAliasEnabled",
                suggest: "The API of Texture2d have been largely modified, no alternative"
            }, {
                name: "enableAntiAlias",
                suggest: "The API of Texture2d have been largely modified, no alternative"
            }]), U(Py, "EventMouse", ["DOWN", "UP", "MOVE"].map((function(e) {
                return {
                    name: e,
                    newName: "MOUSE_" + e,
                    target: jy.EventType,
                    targetName: "SystemEvent.EventType"
                }
            }))), U(Py, "EventMouse", [{
                name: "SCROLL",
                newName: "MOUSE_WHEEL",
                target: jy.EventType,
                targetName: "SystemEvent.EventType"
            }]), U(Oy, "EventTouch", [{
                name: "BEGAN",
                newName: "TOUCH_START",
                target: jy.EventType,
                targetName: "SystemEvent.EventType"
            }]), U(Oy, "EventTouch", [{
                name: "MOVED",
                newName: "TOUCH_MOVE",
                target: jy.EventType,
                targetName: "SystemEvent.EventType"
            }]), U(Oy, "EventTouch", [{
                name: "ENDED",
                newName: "TOUCH_END",
                target: jy.EventType,
                targetName: "SystemEvent.EventType"
            }]), U(Oy, "EventTouch", [{
                name: "CANCELLED",
                newName: "TOUCH_CANCEL",
                target: jy.EventType,
                targetName: "SystemEvent.EventType"
            }]), U(oS, "sys", ["UNKNOWN", "ENGLISH", "CHINESE", "FRENCH", "ITALIAN", "GERMAN", "SPANISH", "DUTCH", "RUSSIAN", "KOREAN", "JAPANESE", "HUNGARIAN", "PORTUGUESE", "ARABIC", "NORWEGIAN", "POLISH", "TURKISH", "UKRAINIAN", "ROMANIAN", "BULGARIAN"].map((function(e) {
                return {
                    name: "LANGUAGE_" + e,
                    newName: e,
                    target: oS.Language,
                    targetName: "sys.Language"
                }
            }))), U(oS, "sys", ["UNKNOWN", "IOS", "ANDROID", "WINDOWS", "LINUX", "OSX"].map((function(e) {
                return {
                    name: "OS_" + e,
                    newName: e,
                    target: oS.OS,
                    targetName: "sys.OS"
                }
            }))), U(oS, "sys", ["UNKNOWN", "WECHAT", "ANDROID", "IE", "EDGE", "QQ", "MOBILE_QQ", "UC", "UCBS", "BAIDU_APP", "BAIDU", "MAXTHON", "OPERA", "OUPENG", "MIUI", "FIREFOX", "SAFARI", "CHROME", "LIEBAO", "QZONE", "SOUGOU", "HUAWEI"].map((function(e) {
                return {
                    name: "BROWSER_TYPE_" + e,
                    newName: e,
                    target: oS.BrowserType,
                    targetName: "sys.BrowserType"
                }
            }))), U(oS, "sys", [{
                name: "BROWSER_TYPE_360",
                newName: "BROWSER_360",
                target: oS.BrowserType,
                targetName: "sys.BrowserType"
            }]), U(oS, "sys", ["UNKNOWN", "EDITOR_PAGE", "EDITOR_CORE", "MOBILE_BROWSER", "DESKTOP_BROWSER", "WIN32", "MACOS", "IOS", "ANDROID", "WECHAT_GAME", "BAIDU_MINI_GAME", "XIAOMI_QUICK_GAME", "ALIPAY_MINI_GAME", "BYTEDANCE_MINI_GAME", "OPPO_MINI_GAME", "VIVO_MINI_GAME", "HUAWEI_QUICK_GAME", "COCOSPLAY", "LINKSURE_MINI_GAME", "QTT_MINI_GAME"].map((function(e) {
                return {
                    name: e,
                    target: oS.Platform,
                    targetName: "sys.Platform"
                }
            }))), U(oS, "sys", [{
                name: "IPHONE",
                newName: "IOS",
                target: oS.Platform,
                targetName: "sys.Platform"
            }, {
                name: "IPAD",
                newName: "IOS",
                target: oS.Platform,
                targetName: "sys.Platform"
            }]), G(oS, "sys", ["LINUX", "BLACKBERRY", "NACL", "EMSCRIPTEN", "TIZEN", "WINRT", "WP8", "QQ_PLAY", "FB_PLAYABLE_ADS"].map((function(e) {
                return {
                    name: e
                }
            })));
            var JC = e("screen", {
                _supportsFullScreen: !1,
                _onfullscreenchange: null,
                _onfullscreenerror: null,
                _preOnFullScreenError: null,
                _preOnTouch: null,
                _touchEvent: "",
                _fn: null,
                _fnMap: [
                    ["requestFullscreen", "exitFullscreen", "fullscreenchange", "fullscreenEnabled", "fullscreenElement"],
                    ["requestFullScreen", "exitFullScreen", "fullScreenchange", "fullScreenEnabled", "fullScreenElement"],
                    ["webkitRequestFullScreen", "webkitCancelFullScreen", "webkitfullscreenchange", "webkitIsFullScreen", "webkitCurrentFullScreenElement"],
                    ["mozRequestFullScreen", "mozCancelFullScreen", "mozfullscreenchange", "mozFullScreen", "mozFullScreenElement"],
                    ["msRequestFullscreen", "msExitFullscreen", "MSFullscreenChange", "msFullscreenEnabled", "msFullscreenElement"]
                ],
                init: function() {
                    var e, t, n;
                    this._fn = {};
                    var i, r = this._fnMap;
                    for (e = 0, t = r.length; e < t; e++)
                        if ((n = r[e]) && void 0 !== document[n[1]]) {
                            for (e = 0, i = n.length; e < i; e++) this._fn[r[0][e]] = n[e];
                            break
                        }
                    this._supportsFullScreen = void 0 !== this._fn.requestFullscreen, this._touchEvent = "ontouchstart" in window ? "touchstart" : "mousedown"
                },
                get supportsFullScreen() {
                    return this._supportsFullScreen
                },
                fullScreen: function() {
                    return !!this._supportsFullScreen && void 0 !== document[this._fn.fullscreenElement] && null !== document[this._fn.fullscreenElement]
                },
                requestFullScreen: function(e, t, n) {
                    if (this._supportsFullScreen) {
                        if (e = e || document.documentElement, t) {
                            var i = this._fn.fullscreenchange;
                            this._onfullscreenchange && document.removeEventListener(i, this._onfullscreenchange), this._onfullscreenchange = t, document.addEventListener(i, t, !1)
                        }
                        if (n) {
                            var r = this._fn.fullscreenerror;
                            this._onfullscreenerror && document.removeEventListener(r, this._onfullscreenerror), this._onfullscreenerror = n, document.addEventListener(r, n, {
                                once: !0
                            })
                        }
                        var o = e[this._fn.requestFullscreen]();
                        return window.Promise && o instanceof Promise && o.catch((function() {})), o
                    }
                },
                exitFullScreen: function() {
                    var e;
                    return this.fullScreen() && (e = document[this._fn.exitFullscreen]()).catch((function() {})), e
                },
                autoFullScreen: function(e, t) {
                    e = e || document.body, this._ensureFullScreen(e, t), this.requestFullScreen(e, t)
                },
                disableAutoFullScreen: function(e) {
                    if (this._preOnTouch) {
                        var t = i.game.canvas || e,
                            n = this._touchEvent;
                        t.removeEventListener(n, this._preOnTouch), this._preOnTouch = null
                    }
                },
                _ensureFullScreen: function(e, t) {
                    var n = this,
                        r = i.game.canvas || e,
                        o = this._fn.fullscreenerror,
                        a = this._touchEvent,
                        s = function() {
                            n._preOnFullScreenError = null, n._preOnTouch && r.removeEventListener(a, n._preOnTouch), n._preOnTouch = function() {
                                n._preOnTouch = null, n.requestFullScreen(e, t)
                            }, r.addEventListener(a, n._preOnTouch, {
                                once: !0
                            })
                        };
                    this._preOnFullScreenError && e.removeEventListener(o, this._preOnFullScreenError), this._preOnFullScreenError = s, e.addEventListener(o, s, {
                        once: !0
                    })
                }
            });
            JC.init(), i.screen = JC;
            var $C, eb = new qs(null),
                tb = function() {
                    function e() {
                        this._device = null, this._passes = null, this._subMesh = null, this._patches = null, this._handle = 0, this._priority = Du.DEFAULT, this._inputAssembler = null, this._descriptorSet = null
                    }
                    var t = e.prototype;
                    return t.initialize = function(e, t, n) {
                        void 0 === n && (n = null), this._device = i.director.root.device, this._subMesh = e, this._patches = n, this._passes = t, this._handle = Fr.alloc(), this._flushPassInfo(), t[0].batchingScheme === Qp.VB_MERGING && this._subMesh.genFlatBuffers(), eb.layout = t[0].localSetLayout;
                        var r = yr.alloc(this._device, eb),
                            o = Sr.alloc(this._device, e.iaInfo);
                        Fr.set(this._handle, Dr.PRIORITY, Du.DEFAULT), Fr.set(this._handle, Dr.INPUT_ASSEMBLER, o), Fr.set(this._handle, Dr.DESCRIPTOR_SET, r), Fr.set(this._handle, Dr.SUB_MESH, e.handle), this._inputAssembler = Sr.get(o), this._descriptorSet = yr.get(r)
                    }, t.initPlanarShadowShader = function() {
                        var e = i.director.root.pipeline.pipelineSceneData.shadows.getPlanarShader(this._patches);
                        Fr.set(this._handle, Dr.PLANAR_SHADER, e)
                    }, t.initPlanarShadowInstanceShader = function() {
                        var e = i.director.root.pipeline.pipelineSceneData.shadows.getPlanarInstanceShader(this._patches);
                        Fr.set(this._handle, Dr.PLANAR_INSTANCE_SHADER, e)
                    }, t.destroy = function() {
                        yr.free(Fr.get(this._handle, Dr.DESCRIPTOR_SET)), Sr.free(Fr.get(this._handle, Dr.INPUT_ASSEMBLER)), Fr.free(this._handle), this._descriptorSet = null, this._inputAssembler = null, this._priority = Du.DEFAULT, this._handle = 0, this._patches = null, this._subMesh = null, this._passes = null
                    }, t.update = function() {
                        for (var e = 0; e < this._passes.length; ++e) this._passes[e].update();
                        this._descriptorSet.update()
                    }, t.onPipelineStateChanged = function() {
                        var e = this._passes;
                        if (e) {
                            for (var t = 0; t < e.length; t++) {
                                var n = e[t];
                                n.beginChangeStatesSilently(), n.tryCompile(), n.endChangeStatesSilently()
                            }
                            this._flushPassInfo()
                        }
                    }, t.onMacroPatchesStateChanged = function(e) {
                        this._patches = e;
                        var t = this._passes;
                        if (t) {
                            for (var n = 0; n < t.length; n++) {
                                var i = t[n];
                                i.beginChangeStatesSilently(), i.tryCompile(), i.endChangeStatesSilently()
                            }
                            this._flushPassInfo()
                        }
                    }, t._flushPassInfo = function() {
                        var e = this._passes;
                        if (e) {
                            Fr.set(this._handle, Dr.PASS_COUNT, e.length);
                            for (var t = Dr.PASS_0, n = Dr.SHADER_0, i = 0; i < e.length; i++, t++, n++) Fr.set(this._handle, t, e[i].handle), Fr.set(this._handle, n, e[i].getShaderVariant(this._patches))
                        }
                    }, K(e, [{
                        key: "passes",
                        get: function() {
                            return this._passes
                        },
                        set: function(e) {
                            if (e.length > 8) b(12004, 8);
                            else if (this._passes = e, this._flushPassInfo(), this._descriptorSet) {
                                yr.free(Fr.get(this._handle, Dr.DESCRIPTOR_SET)), eb.layout = e[0].localSetLayout;
                                var t = yr.alloc(this._device, eb);
                                Fr.set(this._handle, Dr.DESCRIPTOR_SET, t), this._descriptorSet = yr.get(t)
                            }
                        }
                    }, {
                        key: "subMesh",
                        get: function() {
                            return this._subMesh
                        },
                        set: function(e) {
                            this._subMesh = e, this._inputAssembler.destroy(), this._inputAssembler.initialize(e.iaInfo), this._passes[0].batchingScheme === Qp.VB_MERGING && this._subMesh.genFlatBuffers(), Fr.set(this._handle, Dr.SUB_MESH, e.handle)
                        }
                    }, {
                        key: "priority",
                        get: function() {
                            return this._priority
                        },
                        set: function(e) {
                            this._priority = e, Fr.set(this._handle, Dr.PRIORITY, e)
                        }
                    }, {
                        key: "handle",
                        get: function() {
                            return this._handle
                        }
                    }, {
                        key: "inputAssembler",
                        get: function() {
                            return this._inputAssembler
                        }
                    }, {
                        key: "descriptorSet",
                        get: function() {
                            return this._descriptorSet
                        }
                    }, {
                        key: "patches",
                        get: function() {
                            return this._patches
                        }
                    }, {
                        key: "planarShaderHandle",
                        get: function() {
                            return Fr.get(this._handle, Dr.PLANAR_SHADER)
                        }
                    }, {
                        key: "planarInstanceShaderHandle",
                        get: function() {
                            return Fr.get(this._handle, Dr.PLANAR_INSTANCE_SHADER)
                        }
                    }]), e
                }(),
                nb = new fr(hr.ATTRIBUTE, (function(e, t) {
                    return t || new Ms
                })),
                ib = new Bn,
                rb = new Jn((function() {
                    return new tb
                }), 32),
                ob = [{
                    name: "CC_RECEIVE_SHADOW",
                    value: !0
                }];
            ! function(e) {
                e[e.DEFAULT = 0] = "DEFAULT", e[e.SKINNING = 1] = "SKINNING", e[e.BAKED_SKINNING = 2] = "BAKED_SKINNING", e[e.BATCH_2D = 3] = "BATCH_2D", e[e.PARTICLE_BATCH = 4] = "PARTICLE_BATCH", e[e.LINE = 5] = "LINE"
            }($C || ($C = {}));
            var ab, sb, cb = Kf([Da.LINEAR, Da.LINEAR, Da.NONE, Na.CLAMP, Na.CLAMP, Na.CLAMP]),
                lb = Kf([Da.LINEAR, Da.LINEAR, Da.LINEAR, Na.CLAMP, Na.CLAMP, Na.CLAMP]),
                ub = function() {
                    function e() {
                        this.type = $C.DEFAULT, this.scene = null, this.isDynamicBatching = !1, this.instancedAttributes = {
                            buffer: null,
                            views: [],
                            attributes: []
                        }, this._worldBounds = null, this._modelBounds = null, this._subModels = [], this._node = null, this._transform = null, this._device = void 0, this._inited = !1, this._descriptorSetCount = 1, this._updateStamp = -1, this._transformUpdated = !0, this._handle = 0, this._hWorldBounds = 0, this._localData = new Float32Array(Sh.COUNT), this._localBuffer = null, this._instMatWorldIdx = -1, this._lightmap = null, this._lightmapUVParam = new Wn, this._device = i.director.root.device
                    }
                    var t = e.prototype;
                    return t.initialize = function() {
                        if (!this._inited) {
                            this._handle = Gr.alloc();
                            var e = Ar.alloc(),
                                t = Cr.alloc();
                            Gr.set(this._handle, Lr.INSTANCED_ATTR_ARRAY, t), Gr.set(this._handle, Lr.SUB_MODEL_ARRAY, e), Gr.set(this._handle, Lr.VIS_FLAGS, Pu.Enum.NONE), Gr.set(this._handle, Lr.ENABLED, 1), Gr.set(this._handle, Lr.RECEIVE_SHADOW, 1), Gr.set(this._handle, Lr.CAST_SHADOW, 0), this._inited = !0
                        }
                    }, t.destroy = function() {
                        for (var e = this._subModels, t = 0; t < e.length; t++) {
                            var n = this._subModels[t];
                            n.destroy(), rb.free(n)
                        }
                        if (this._localBuffer && (this._localBuffer.destroy(), this._localBuffer = null), this._worldBounds = null, this._modelBounds = null, this._subModels.length = 0, this._inited = !1, this._transformUpdated = !0, this._transform = null, this._node = null, this.isDynamicBatching = !1, this._handle) {
                            var i = Gr.get(this._handle, Lr.SUB_MODEL_ARRAY);
                            i && Ar.free(i);
                            var r = Gr.get(this._handle, Lr.INSTANCED_BUFFER);
                            r && Pr.free(r);
                            var o = Gr.get(this._handle, Lr.INSTANCED_ATTR_ARRAY);
                            o && mr(o, Cr, nb), Gr.free(this._handle), this._handle = 0
                        }
                        this._hWorldBounds && (qr.free(this._hWorldBounds), this._hWorldBounds = 0)
                    }, t.attachToScene = function(e) {
                        this.scene = e
                    }, t.detachFromScene = function() {
                        this.scene = null
                    }, t.updateTransform = function() {
                        var e = this.transform;
                        if (e.hasChangedFlags || e._dirtyFlags) {
                            e.updateWorldTransform(), this._transformUpdated = !0;
                            var t = this._worldBounds;
                            this._modelBounds && t && (this._modelBounds.transform(e._mat, e._pos, e._rot, e._scale, t), qr.setVec3(this._hWorldBounds, Hr.CENTER, t.center), qr.setVec3(this._hWorldBounds, Hr.HALF_EXTENSION, t.halfExtents))
                        }
                    }, t.updateWorldBound = function() {
                        var e = this.transform;
                        if (null !== e) {
                            e.updateWorldTransform(), this._transformUpdated = !0;
                            var t = this._worldBounds;
                            this._modelBounds && t && (this._modelBounds.transform(e._mat, e._pos, e._rot, e._scale, t), qr.setVec3(this._hWorldBounds, Hr.CENTER, t.center), qr.setVec3(this._hWorldBounds, Hr.HALF_EXTENSION, t.halfExtents))
                        }
                    }, t.updateUBOs = function(e) {
                        for (var t = this._subModels, n = 0; n < t.length; n++) t[n].update();
                        if (this._updateStamp = e, this._transformUpdated) {
                            this._transformUpdated = !1;
                            var i = this.transform._mat,
                                r = this._instMatWorldIdx;
                            if (r >= 0) {
                                var o = this.instancedAttributes.views;
                                ! function(e, t, n, i) {
                                    t[0] = e.m00, t[1] = e.m01, t[2] = e.m02, t[3] = e.m12, n[0] = e.m04, n[1] = e.m05, n[2] = e.m06, n[3] = e.m13, i[0] = e.m08, i[1] = e.m09, i[2] = e.m10, i[3] = e.m14
                                }(i, o[r], o[r + 1], o[r + 2])
                            } else this._localBuffer && (Bn.toArray(this._localData, i, Sh.MAT_WORLD_OFFSET), Bn.inverseTranspose(ib, i), Bn.toArray(this._localData, ib, Sh.MAT_WORLD_IT_OFFSET), this._localBuffer.update(this._localData))
                        }
                    }, t.createBoundingShape = function(e, t) {
                        e && t && (this._modelBounds = tu.fromPoints(tu.create(), e, t), this._worldBounds = tu.clone(this._modelBounds), 0 === this._hWorldBounds && (this._hWorldBounds = qr.alloc(), Gr.set(this._handle, Lr.WORLD_BOUNDS, this._hWorldBounds)), qr.setVec3(this._hWorldBounds, Hr.CENTER, this._worldBounds.center), qr.setVec3(this._hWorldBounds, Hr.HALF_EXTENSION, this._worldBounds.halfExtents))
                    }, t.initSubModel = function(e, t, n) {
                        this.initialize();
                        var i = !1;
                        if (null == this._subModels[e] ? (this._subModels[e] = rb.alloc(), i = !0) : this._subModels[e].destroy(), this._subModels[e].initialize(t, n.passes, this.getMacroPatches(e)), this._subModels[e].initPlanarShadowShader(), this._subModels[e].initPlanarShadowInstanceShader(), this._updateAttributesAndBinding(e), i) {
                            var r = Gr.get(this._handle, Lr.SUB_MODEL_ARRAY);
                            Ar.assign(r, e, this._subModels[e].handle)
                        }
                    }, t.setSubModelMesh = function(e, t) {
                        this._subModels[e] && (this._subModels[e].subMesh = t)
                    }, t.setSubModelMaterial = function(e, t) {
                        this._subModels[e] && (this._subModels[e].passes = t.passes, this._updateAttributesAndBinding(e))
                    }, t.onGlobalPipelineStateChanged = function() {
                        for (var e = this._subModels, t = 0; t < e.length; t++) e[t].onPipelineStateChanged()
                    }, t.onMacroPatchesStateChanged = function() {
                        for (var e = this._subModels, t = 0; t < e.length; t++) e[t].onMacroPatchesStateChanged(this.getMacroPatches(t))
                    }, t.updateLightingmap = function(e, t) {
                        Wn.toArray(this._localData, t, Sh.LIGHTINGMAP_UVPARAM), this._lightmap = e, this._lightmapUVParam = t, null === e && (e = em.get("empty-texture"));
                        var n = e.getGFXTexture();
                        if (n)
                            for (var i = cd.getSampler(this._device, e.mipmaps.length > 1 ? lb : cb), r = this._subModels, o = 0; o < r.length; o++) {
                                var a = r[o].descriptorSet;
                                a.bindTexture(kh, n), a.bindSampler(kh, i), a.update()
                            }
                    }, t.getMacroPatches = function() {
                        return this.receiveShadow ? ob : null
                    }, t._updateAttributesAndBinding = function(e) {
                        var t = this._subModels[e];
                        if (t) {
                            this._initLocalDescriptors(e), this._updateLocalDescriptors(e, t.descriptorSet);
                            var n = vr.get(Fr.get(t.handle, Dr.SHADER_0));
                            this._updateInstancedAttributes(n.attributes, t.passes[0])
                        }
                    }, t._getInstancedAttributeIndex = function(e) {
                        for (var t = this.instancedAttributes.attributes, n = 0; n < t.length; n++)
                            if (t[n].name === e) return n;
                        return -1
                    }, t._updateInstancedAttributes = function(e, t) {
                        if (t.device.hasFeature(Sa.INSTANCED_ARRAYS)) {
                            var n = Gr.get(this._handle, Lr.INSTANCED_BUFFER);
                            n && Pr.free(n);
                            var i = Gr.get(this._handle, Lr.INSTANCED_ATTR_ARRAY);
                            i && mr(i, Cr, nb, !1);
                            for (var r = 0, o = 0; o < e.length; o++) {
                                var a = e[o];
                                a.isInstanced && (r += tc[a.format].size)
                            }
                            var s = Pr.alloc(r),
                                c = Pr.getBuffer(s);
                            Gr.set(this._handle, Lr.INSTANCED_BUFFER, s);
                            var l = this.instancedAttributes;
                            l.buffer = new Uint8Array(c), l.views.length = l.attributes.length = 0;
                            for (var u = 0, h = 0; h < e.length; h++) {
                                var _ = e[h];
                                if (_.isInstanced) {
                                    var f = nb.alloc(),
                                        d = nb.get(f);
                                    d.format = _.format, d.name = _.name, d.isNormalized = _.isNormalized, d.location = _.location, l.attributes.push(d), Cr.push(i, f);
                                    var p = tc[_.format];
                                    l.views.push(new(uc(p))(c, u, p.count)), u += p.size
                                }
                            }
                            t.batchingScheme === Qp.INSTANCING && FA.get(t).destroy(), this._instMatWorldIdx = this._getInstancedAttributeIndex(Eh), this._transformUpdated = !0
                        }
                    }, t._initLocalDescriptors = function() {
                        this._localBuffer || (this._localBuffer = this._device.createBuffer(new gs(xa.UNIFORM | xa.TRANSFER_DST, Ra.HOST | Ra.DEVICE, Sh.SIZE, Sh.SIZE)))
                    }, t._updateLocalDescriptors = function(e, t) {
                        this._localBuffer && t.bindBuffer(Sh.BINDING, this._localBuffer)
                    }, K(e, [{
                        key: "subModels",
                        get: function() {
                            return this._subModels
                        }
                    }, {
                        key: "inited",
                        get: function() {
                            return this._inited
                        }
                    }, {
                        key: "worldBounds",
                        get: function() {
                            return this._worldBounds
                        }
                    }, {
                        key: "modelBounds",
                        get: function() {
                            return this._modelBounds
                        }
                    }, {
                        key: "localBuffer",
                        get: function() {
                            return this._localBuffer
                        }
                    }, {
                        key: "updateStamp",
                        get: function() {
                            return this._updateStamp
                        }
                    }, {
                        key: "isInstancingEnabled",
                        get: function() {
                            return this._instMatWorldIdx >= 0
                        }
                    }, {
                        key: "receiveShadow",
                        get: function() {
                            return !!Gr.get(this._handle, Lr.RECEIVE_SHADOW)
                        },
                        set: function(e) {
                            Gr.set(this._handle, Lr.RECEIVE_SHADOW, e ? 1 : 0), this.onMacroPatchesStateChanged()
                        }
                    }, {
                        key: "castShadow",
                        get: function() {
                            return !!Gr.get(this._handle, Lr.CAST_SHADOW)
                        },
                        set: function(e) {
                            Gr.set(this._handle, Lr.CAST_SHADOW, e ? 1 : 0)
                        }
                    }, {
                        key: "handle",
                        get: function() {
                            return this._handle
                        }
                    }, {
                        key: "node",
                        get: function() {
                            return this._node
                        },
                        set: function(e) {
                            this._node = e, Gr.set(this._handle, Lr.NODE, e.handle)
                        }
                    }, {
                        key: "transform",
                        get: function() {
                            return this._transform
                        },
                        set: function(e) {
                            this._transform = e, Gr.set(this._handle, Lr.TRANSFORM, e.handle)
                        }
                    }, {
                        key: "visFlags",
                        get: function() {
                            return Gr.get(this._handle, Lr.VIS_FLAGS)
                        },
                        set: function(e) {
                            Gr.set(this._handle, Lr.VIS_FLAGS, e)
                        }
                    }, {
                        key: "enabled",
                        get: function() {
                            return !!Gr.get(this._handle, Lr.ENABLED)
                        },
                        set: function(e) {
                            Gr.set(this._handle, Lr.ENABLED, e ? 1 : 0)
                        }
                    }]), e
                }(),
                hb = function(e) {
                    function t() {
                        var t;
                        return (t = e.call(this) || this)._needUpdate = !1, t._pos = void 0, t._aabb = void 0, t._hAABB = 0, t._aabb = tu.create(), t._pos = new En, t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.initialize = function() {
                        e.prototype.initialize.call(this), this._hAABB = qr.alloc(), Io.set(this._handle, xo.TYPE, sm.SPHERE), Io.set(this._handle, xo.SIZE, .15), Io.set(this._handle, xo.RANGE, 1), Io.set(this._handle, xo.AABB, this._hAABB), Io.set(this._handle, xo.ILLUMINANCE, 1700 / um(.15))
                    }, n.update = function() {
                        if (this._node && (this._node.hasChangedFlags || this._needUpdate)) {
                            this._node.getWorldPosition(this._pos);
                            var e = Io.get(this._handle, xo.RANGE);
                            tu.set(this._aabb, this._pos.x, this._pos.y, this._pos.z, e, e, e), this._needUpdate = !1, Io.setVec3(this._handle, xo.POSITION, this._pos), qr.setVec3(this._hAABB, Hr.CENTER, this._aabb.center), qr.setVec3(this._hAABB, Hr.HALF_EXTENSION, this._aabb.halfExtents)
                        }
                    }, n.destroy = function() {
                        return this._hAABB && (qr.free(this._hAABB), this._hAABB = 0), e.prototype.destroy.call(this)
                    }, K(t, [{
                        key: "position",
                        get: function() {
                            return this._pos
                        }
                    }, {
                        key: "size",
                        get: function() {
                            return Io.get(this._handle, xo.SIZE)
                        },
                        set: function(e) {
                            Io.set(this._handle, xo.SIZE, e)
                        }
                    }, {
                        key: "range",
                        get: function() {
                            return Io.get(this._handle, xo.RANGE)
                        },
                        set: function(e) {
                            Io.set(this._handle, xo.RANGE, e), this._needUpdate = !0
                        }
                    }, {
                        key: "luminance",
                        get: function() {
                            return Io.get(this._handle, xo.ILLUMINANCE)
                        },
                        set: function(e) {
                            Io.set(this._handle, xo.ILLUMINANCE, e)
                        }
                    }, {
                        key: "aabb",
                        get: function() {
                            return this._aabb
                        }
                    }]), t
                }(hm),
                _b = new En(0, 0, -1),
                fb = new wn,
                db = new Bn,
                pb = new Bn,
                mb = new Bn,
                gb = new Bn,
                vb = function(e) {
                    function t() {
                        var t;
                        return (t = e.call(this) || this)._dir = new En(1, -1, -1), t._range = 5, t._spotAngle = Math.cos(Math.PI / 6), t._pos = void 0, t._aabb = void 0, t._frustum = void 0, t._angle = 0, t._needUpdate = !1, t._hAABB = 0, t._hFrustum = 0, t._aabb = tu.create(), t._frustum = hu.create(), t._pos = new En, t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.initialize = function() {
                        e.prototype.initialize.call(this), this._hAABB = qr.alloc(), this._hFrustum = uo.alloc(), Io.set(this._handle, xo.TYPE, sm.SPOT), Io.set(this._handle, xo.SIZE, .15), Io.set(this._handle, xo.AABB, this._hAABB), Io.set(this._handle, xo.ILLUMINANCE, 1700 / um(.15)), Io.set(this._handle, xo.RANGE, Math.cos(Math.PI / 6)), Io.set(this._handle, xo.ASPECT, 1), Io.setVec3(this._handle, xo.DIRECTION, this._dir), Io.set(this._handle, xo.FRUSTUM, this._hFrustum)
                    }, n.update = function() {
                        this._node && (this._node.hasChangedFlags || this._needUpdate) && (this._node.getWorldPosition(this._pos), En.transformQuat(this._dir, _b, this._node.getWorldRotation(fb)), En.normalize(this._dir, this._dir), Io.setVec3(this._handle, xo.DIRECTION, this._dir), tu.set(this._aabb, this._pos.x, this._pos.y, this._pos.z, this._range, this._range, this._range), this._node.getWorldRT(db), Bn.invert(db, db), Bn.perspective(pb, this._angle, 1, .001, this._range), Bn.multiply(mb, pb, db), this._frustum.update(mb, gb), this._needUpdate = !1, Io.setVec3(this._handle, xo.POSITION, this._pos), qr.setVec3(this._hAABB, Hr.CENTER, this._aabb.center), qr.setVec3(this._hAABB, Hr.HALF_EXTENSION, this._aabb.halfExtents), _u(this._hFrustum, this._frustum))
                    }, n.destroy = function() {
                        return this._hAABB && (qr.free(this._hAABB), this._hAABB = 0), this._hFrustum && (uo.free(this._hFrustum), this._hFrustum = 0), e.prototype.destroy.call(this)
                    }, K(t, [{
                        key: "position",
                        get: function() {
                            return this._pos
                        }
                    }, {
                        key: "size",
                        get: function() {
                            return Io.get(this._handle, xo.SIZE)
                        },
                        set: function(e) {
                            Io.set(this._handle, xo.SIZE, e)
                        }
                    }, {
                        key: "range",
                        get: function() {
                            return Io.get(this._handle, xo.RANGE)
                        },
                        set: function(e) {
                            this._range = e, Io.set(this._handle, xo.RANGE, e), this._needUpdate = !0
                        }
                    }, {
                        key: "luminance",
                        get: function() {
                            return Io.get(this._handle, xo.ILLUMINANCE)
                        },
                        set: function(e) {
                            Io.set(this._handle, xo.ILLUMINANCE, e)
                        }
                    }, {
                        key: "direction",
                        get: function() {
                            return this._dir
                        }
                    }, {
                        key: "spotAngle",
                        get: function() {
                            return Io.get(this._handle, xo.SPOT_ANGLE)
                        },
                        set: function(e) {
                            this._angle = e, Io.set(this._handle, xo.SPOT_ANGLE, Math.cos(.5 * e)), this._needUpdate = !0
                        }
                    }, {
                        key: "aspect",
                        get: function() {
                            return Io.get(this._handle, xo.ASPECT)
                        },
                        set: function(e) {
                            Io.set(this._handle, xo.ASPECT, e), this._needUpdate = !0
                        }
                    }, {
                        key: "aabb",
                        get: function() {
                            return this._aabb
                        }
                    }, {
                        key: "frustum",
                        get: function() {
                            return this._frustum
                        }
                    }]), t
                }(hm),
                yb = Object.freeze({
                    __proto__: null,
                    Ambient: Ko,
                    get CameraFOVAxis() {
                        return Yh
                    },
                    get CameraProjection() {
                        return Kh
                    },
                    get CameraAperture() {
                        return Zh
                    },
                    get CameraISO() {
                        return Qh
                    },
                    get CameraShutter() {
                        return Jh
                    },
                    SKYBOX_FLAG: h_,
                    Camera: f_,
                    CameraVisFlags: am,
                    VisibilityFlags: cm,
                    DirectionalLight: dm,
                    ColorTemperatureToRGB: lm,
                    get LightType() {
                        return sm
                    },
                    nt2lm: um,
                    Light: hm,
                    get ModelType() {
                        return $C
                    },
                    Model: ub,
                    ShadowType: iE,
                    PCFType: rE,
                    Shadows: aE,
                    RenderScene: d_,
                    Skybox: ME,
                    SphereLight: hb,
                    SpotLight: vb,
                    SubModel: tb
                });

            function Sb(e) {
                return --e, e |= e >> 16, e |= e >> 8, e |= e >> 4, e |= e >> 2, e |= e >> 1, ++e
            }

            function Eb(e, t) {
                return Math.ceil(e / t) * t
            }! function(e) {
                e[e.OPAQUE = 0] = "OPAQUE", e[e.TRANSPARENT = 1] = "TRANSPARENT", e[e.OVERLAY = 2] = "OVERLAY"
            }(ab || (ab = {})),
            function(e) {
                e[e.DEFAULT = 1] = "DEFAULT", e[e.FORWARD = 2] = "FORWARD", e[e.SHADOWCAST = 4] = "SHADOWCAST"
            }(sb || (sb = {}));
            var Tb = function() {
                    function e(e) {
                        this._device = void 0, this._format = Ea.UNKNOWN, this._formatSize = 0, this._chunks = [], this._chunkCount = 0, this._handles = [], this._region0 = new fs, this._region1 = new fs, this._region2 = new fs, this._roundUpFn = null, this._bufferViewCtor = Uint8Array, this._channels = 4, this._alignment = 1, this._device = e
                    }
                    var t = e.prototype;
                    return t.initialize = function(e) {
                        var t = tc[e.format];
                        this._format = e.format, this._formatSize = t.size, this._channels = t.count, this._bufferViewCtor = uc(t), this._roundUpFn = e.roundUpFn || null, this._alignment = e.alignment || 1, e.inOrderFree && (this.alloc = this._McDonaldAlloc)
                    }, t.destroy = function() {
                        for (var e = 0; e < this._chunkCount; ++e) this._chunks[e].texture.destroy();
                        this._chunks.length = 0, this._handles.length = 0
                    }, t.alloc = function(e, t) {
                        e = Eb(e, this._alignment);
                        var n = -1,
                            i = -1;
                        if (void 0 !== t && (n = t, i = this._findAvailableSpace(e, n)), i < 0)
                            for (var r = 0; r < this._chunkCount && (n = r, !((i = this._findAvailableSpace(e, n)) >= 0)); ++r);
                        if (i >= 0) {
                            var o = this._chunks[n];
                            o.start += e;
                            var a = {
                                chunkIdx: n,
                                start: i,
                                end: i + e,
                                texture: o.texture
                            };
                            return this._handles.push(a), a
                        }
                        var s = Math.sqrt(e / this._formatSize),
                            c = this._roundUpFn && this._roundUpFn(s, this._formatSize) || Math.max(1024, Sb(s)),
                            l = this._chunks[this.createChunk(c)];
                        l.start += e;
                        var u = {
                            chunkIdx: this._chunkCount - 1,
                            start: 0,
                            end: e,
                            texture: l.texture
                        };
                        return this._handles.push(u), u
                    }, t.free = function(e) {
                        for (var t = 0; t < this._handles.length; ++t)
                            if (this._handles[t] === e) return this._chunks[e.chunkIdx].end = e.end, void this._handles.splice(t, 1)
                    }, t.createChunk = function(e) {
                        var t = e * e * this._formatSize;
                        console.info("TextureBufferPool: Allocate chunk " + this._chunkCount + ", size: " + t + ", format: " + this._format);
                        var n = {
                            texture: this._device.createTexture(new Ts(wa.TEX2D, Ia.SAMPLED | Ia.TRANSFER_DST, this._format, e, e, Pa.IMMUTABLE)),
                            size: t,
                            start: 0,
                            end: t
                        };
                        return this._chunks[this._chunkCount] = n, this._chunkCount++
                    }, t.update = function(e, t) {
                        var n = [],
                            i = [],
                            r = e.start / this._formatSize,
                            o = t.byteLength / this._formatSize,
                            a = r % e.texture.width,
                            s = Math.floor(r / e.texture.width),
                            c = Math.min(e.texture.width - a, o),
                            l = 0;
                        a > 0 && (this._region0.texOffset.x = a, this._region0.texOffset.y = s, this._region0.texExtent.width = c, this._region0.texExtent.height = 1, n.push(new this._bufferViewCtor(t, l * this._formatSize, c * this._channels)), i.push(this._region0), a = 0, s += 1, o -= c, l += c), o > 0 && (this._region1.texOffset.x = a, this._region1.texOffset.y = s, o > e.texture.width ? (this._region1.texExtent.width = e.texture.width, this._region1.texExtent.height = Math.floor(o / e.texture.width), c = this._region1.texExtent.width * this._region1.texExtent.height) : (c = o, this._region1.texExtent.width = c, this._region1.texExtent.height = 1), n.push(new this._bufferViewCtor(t, l * this._formatSize, c * this._channels)), i.push(this._region1), a = 0, s += this._region1.texExtent.height, o -= c, l += c), o > 0 && (this._region2.texOffset.x = a, this._region2.texOffset.y = s, this._region2.texExtent.width = o, this._region2.texExtent.height = 1, n.push(new this._bufferViewCtor(t, l * this._formatSize, o * this._channels)), i.push(this._region2)), this._device.copyBuffersToTexture(n, e.texture, i)
                    }, t._findAvailableSpace = function(e, t) {
                        var n = this._chunks[t],
                            i = !1,
                            r = n.start;
                        if (r + e <= n.size) i = !0;
                        else {
                            r = 0;
                            for (var o = this._handles.filter((function(e) {
                                    return e.chunkIdx === t
                                })).sort((function(e, t) {
                                    return e.start - t.start
                                })), a = 0; a < o.length; a++) {
                                var s = o[a];
                                if (r + e <= s.start) {
                                    i = !0;
                                    break
                                }
                                r = s.end
                            }!i && r + e <= n.size && (i = !0)
                        }
                        return i ? r : -1
                    }, t._McDonaldAlloc = function(e) {
                        e = Eb(e, this._alignment);
                        for (var t = 0; t < this._chunkCount; ++t) {
                            var n = this._chunks[t],
                                i = !1,
                                r = n.start;
                            if (r + e <= n.end ? i = !0 : r > n.end ? r + e <= n.size ? i = !0 : e <= n.end && (n.start = r = 0, i = !0) : r === n.end && (n.start = r = 0, n.end = n.size, e <= n.end && (i = !0)), i) {
                                n.start += e;
                                var o = {
                                    chunkIdx: t,
                                    start: r,
                                    end: r + e,
                                    texture: n.texture
                                };
                                return this._handles.push(o), o
                            }
                        }
                        var a = Math.sqrt(e / this._formatSize),
                            s = this._roundUpFn && this._roundUpFn(a, this._formatSize) || Math.max(1024, Sb(a)),
                            c = this._chunks[this.createChunk(s)];
                        c.start += e;
                        var l = {
                            chunkIdx: this._chunkCount,
                            start: 0,
                            end: e,
                            texture: c.texture
                        };
                        return this._handles.push(l), l
                    }, e
                }(),
                Ab = function(e) {
                    if (void 0 === sr[e]) {
                        var t = 1 << ar;
                        sr[e] = t, ar += 1
                    }
                },
                xb = Object.freeze({
                    __proto__: null,
                    addStage: Ab,
                    scene: yb,
                    createIA: function(e, t) {
                        if (!t.positions) return console.error("The data must have positions field"), null;
                        for (var n = [], i = t.positions.length / 3, r = 0; r < i; ++r) n.push(t.positions[3 * r], t.positions[3 * r + 1], t.positions[3 * r + 2]), t.normals && n.push(t.normals[3 * r], t.normals[3 * r + 1], t.normals[3 * r + 2]), t.uvs && n.push(t.uvs[2 * r], t.uvs[2 * r + 1]), t.colors && n.push(t.colors[3 * r], t.colors[3 * r + 1], t.colors[3 * r + 2]);
                        var o = [];
                        o.push(new Ms(is.ATTR_POSITION, Ea.RGB32F)), t.normals && o.push(new Ms(is.ATTR_NORMAL, Ea.RGB32F)), t.uvs && o.push(new Ms(is.ATTR_TEX_COORD, Ea.RG32F)), t.colors && o.push(new Ms(is.ATTR_COLOR, Ea.RGB32F));
                        var a = e.createBuffer(new gs(xa.VERTEX | xa.TRANSFER_DST, Ra.HOST | Ra.DEVICE, 4 * n.length, 4 * n.length / i));
                        a.update(new Float32Array(n));
                        var s = null;
                        return t.indices && (s = e.createBuffer(new gs(xa.INDEX | xa.TRANSFER_DST, Ra.HOST | Ra.DEVICE, 2 * t.indices.length, 2))).update(new Uint16Array(t.indices)), e.createInputAssembler(new Bs(o, [a], s))
                    },
                    get RenderQueue() {
                        return ab
                    },
                    get PassStage() {
                        return sb
                    },
                    get PropertyType() {
                        return xp
                    },
                    genHandle: Pp,
                    getPropertyTypeFromHandle: Op,
                    getTypeFromHandle: Dp,
                    getSetIndexFromHandle: function(e) {
                        return (e & wp) >>> 20
                    },
                    getBindingFromHandle: Np,
                    getOffsetFromHandle: Mp,
                    customizeType: Lp,
                    type2reader: Bp,
                    type2writer: Fp,
                    getDefaultFromType: Up,
                    overrideMacros: Gp,
                    get BatchingSchemes() {
                        return Qp
                    },
                    Pass: om,
                    getDeviceShaderVersion: Xp,
                    programLib: Yp,
                    get SamplerInfoIndex() {
                        return Vf
                    },
                    defaultSamplerHash: qf,
                    genSamplerHash: Kf,
                    samplerLib: cd,
                    nearestPOT: Sb,
                    TextureBufferPool: Tb,
                    MaterialInstance: OE,
                    PassInstance: PE,
                    ObjectPool: fr,
                    freeHandleArray: mr,
                    get PoolType() {
                        return hr
                    },
                    NULL_HANDLE: 0,
                    ShaderPool: vr,
                    DSPool: yr,
                    IAPool: Sr,
                    PipelineLayoutPool: Er,
                    FramebufferPool: Tr,
                    SubModelArrayPool: Ar,
                    ModelArrayPool: xr,
                    AttributeArrayPool: Cr,
                    FlatBufferArrayPool: br,
                    LightArrayPool: Rr,
                    BlendTargetArrayPool: wr,
                    UIBatchArrayPool: Ir,
                    RawBufferPool: Pr,
                    RawObjectPool: Or,
                    get PassView() {
                        return gr
                    },
                    PassPool: Mr,
                    get SubModelView() {
                        return Dr
                    },
                    SubModelPool: Fr,
                    get ModelView() {
                        return Lr
                    },
                    ModelPool: Gr,
                    get BatchView2D() {
                        return zr
                    },
                    BatchPool2D: Vr,
                    get AABBView() {
                        return Hr
                    },
                    AABBPool: qr,
                    get SceneView() {
                        return Wr
                    },
                    ScenePool: Kr,
                    get CameraView() {
                        return Xr
                    },
                    CameraPool: Jr,
                    get NodeView() {
                        return Zr
                    },
                    NodePool: to,
                    get RootView() {
                        return eo
                    },
                    RootPool: ro,
                    get RenderWindowView() {
                        return no
                    },
                    RenderWindowPool: so,
                    get FrustumView() {
                        return oo
                    },
                    FrustumPool: uo,
                    get AmbientView() {
                        return co
                    },
                    AmbientPool: fo,
                    get SkyboxView() {
                        return _o
                    },
                    SkyboxPool: go,
                    get FogView() {
                        return po
                    },
                    FogPool: So,
                    get ShadowsView() {
                        return yo
                    },
                    ShadowsPool: Ao,
                    get PipelineSceneDataView() {
                        return To
                    },
                    PipelineSceneDataPool: bo,
                    get LightView() {
                        return xo
                    },
                    LightPool: Io,
                    get SphereView() {
                        return Ro
                    },
                    SpherePool: Do,
                    get FlatBufferView() {
                        return Oo
                    },
                    FlatBufferPool: Lo,
                    get SubMeshView() {
                        return No
                    },
                    SubMeshPool: zo,
                    get RasterizerStateView() {
                        return Bo
                    },
                    RasterizerStatePool: Ho,
                    get DepthStencilStateView() {
                        return Uo
                    },
                    DepthStencilStatePool: Wo,
                    get BlendTargetView() {
                        return ko
                    },
                    BlendTargetPool: qo,
                    get BlendStateView() {
                        return jo
                    },
                    BlendStatePool: Yo
                });

            function Cb(e) {
                return e * e
            }

            function bb(e) {
                return e * (2 - e)
            }

            function Rb(e) {
                return e * e * e
            }

            function wb(e) {
                return --e * e * e + 1
            }

            function Ib(e) {
                return e * e * e * e
            }

            function Pb(e) {
                return 1 - --e * e * e * e
            }

            function Ob(e) {
                return e * e * e * e * e
            }

            function Db(e) {
                return --e * e * e * e * e + 1
            }

            function Nb(e) {
                return 1 - Math.cos(e * Math.PI / 2)
            }

            function Mb(e) {
                return Math.sin(e * Math.PI / 2)
            }

            function Lb(e) {
                return 0 === e ? 0 : Math.pow(1024, e - 1)
            }

            function Bb(e) {
                return 1 === e ? 1 : 1 - Math.pow(2, -10 * e)
            }

            function Fb(e) {
                return 1 - Math.sqrt(1 - e * e)
            }

            function zb(e) {
                return Math.sqrt(1 - --e * e)
            }

            function Ub(e) {
                var t, n = .1;
                return 0 === e ? 0 : 1 === e ? 1 : (!n || n < 1 ? (n = 1, t = .1) : t = .4 * Math.asin(1 / n) / (2 * Math.PI), -n * Math.pow(2, 10 * (e -= 1)) * Math.sin(2 * (e - t) * Math.PI / .4))
            }

            function Gb(e) {
                var t, n = .1;
                return 0 === e ? 0 : 1 === e ? 1 : (!n || n < 1 ? (n = 1, t = .1) : t = .4 * Math.asin(1 / n) / (2 * Math.PI), n * Math.pow(2, -10 * e) * Math.sin(2 * (e - t) * Math.PI / .4) + 1)
            }

            function Hb(e) {
                var t = 1.70158;
                return e * e * ((t + 1) * e - t)
            }

            function kb(e) {
                var t = 1.70158;
                return --e * e * ((t + 1) * e + t) + 1
            }

            function Vb(e) {
                return 1 - Wb(1 - e)
            }

            function Wb(e) {
                return e < 1 / 2.75 ? 7.5625 * e * e : e < 2 / 2.75 ? 7.5625 * (e -= 1.5 / 2.75) * e + .75 : e < 2.5 / 2.75 ? 7.5625 * (e -= 2.25 / 2.75) * e + .9375 : 7.5625 * (e -= 2.625 / 2.75) * e + .984375
            }
            e("renderer", xb);
            var jb = tR(Cb, bb),
                qb = tR(Rb, wb),
                Xb = tR(Ib, Pb),
                Yb = tR(Ob, Db),
                Kb = tR(Nb, Mb),
                Zb = tR(Lb, Bb),
                Qb = tR(Fb, zb),
                Jb = tR(Ub, Gb),
                $b = tR(Hb, kb),
                eR = tR(Vb, Wb);

            function tR(e, t) {
                return function(n) {
                    return n < .5 ? t(2 * n) / 2 : e(2 * n - 1) / 2 + .5
                }
            }
            var nR = Object.freeze({
                __proto__: null,
                constant: function() {
                    return 0
                },
                linear: function(e) {
                    return e
                },
                quadIn: Cb,
                quadOut: bb,
                quadInOut: function(e) {
                    return (e *= 2) < 1 ? .5 * e * e : -.5 * (--e * (e - 2) - 1)
                },
                cubicIn: Rb,
                cubicOut: wb,
                cubicInOut: function(e) {
                    return (e *= 2) < 1 ? .5 * e * e * e : .5 * ((e -= 2) * e * e + 2)
                },
                quartIn: Ib,
                quartOut: Pb,
                quartInOut: function(e) {
                    return (e *= 2) < 1 ? .5 * e * e * e * e : -.5 * ((e -= 2) * e * e * e - 2)
                },
                quintIn: Ob,
                quintOut: Db,
                quintInOut: function(e) {
                    return (e *= 2) < 1 ? .5 * e * e * e * e * e : .5 * ((e -= 2) * e * e * e * e + 2)
                },
                sineIn: Nb,
                sineOut: Mb,
                sineInOut: function(e) {
                    return .5 * (1 - Math.cos(Math.PI * e))
                },
                expoIn: Lb,
                expoOut: Bb,
                expoInOut: function(e) {
                    return 0 === e ? 0 : 1 === e ? 1 : (e *= 2) < 1 ? .5 * Math.pow(1024, e - 1) : .5 * (2 - Math.pow(2, -10 * (e - 1)))
                },
                circIn: Fb,
                circOut: zb,
                circInOut: function(e) {
                    return (e *= 2) < 1 ? -.5 * (Math.sqrt(1 - e * e) - 1) : .5 * (Math.sqrt(1 - (e -= 2) * e) + 1)
                },
                elasticIn: Ub,
                elasticOut: Gb,
                elasticInOut: function(e) {
                    var t, n = .1;
                    return 0 === e ? 0 : 1 === e ? 1 : (!n || n < 1 ? (n = 1, t = .1) : t = .4 * Math.asin(1 / n) / (2 * Math.PI), (e *= 2) < 1 ? n * Math.pow(2, 10 * (e -= 1)) * Math.sin(2 * (e - t) * Math.PI / .4) * -.5 : n * Math.pow(2, -10 * (e -= 1)) * Math.sin(2 * (e - t) * Math.PI / .4) * .5 + 1)
                },
                backIn: Hb,
                backOut: kb,
                backInOut: function(e) {
                    var t = 2.5949095;
                    return (e *= 2) < 1 ? e * e * ((t + 1) * e - t) * .5 : .5 * ((e -= 2) * e * ((t + 1) * e + t) + 2)
                },
                bounceIn: Vb,
                bounceOut: Wb,
                bounceInOut: function(e) {
                    return e < .5 ? .5 * Vb(2 * e) : .5 * Wb(2 * e - 1) + .5
                },
                smooth: function(e) {
                    return e <= 0 ? 0 : e >= 1 ? 1 : e * e * (3 - 2 * e)
                },
                fade: function(e) {
                    return e <= 0 ? 0 : e >= 1 ? 1 : e * e * e * (e * (6 * e - 15) + 10)
                },
                quadOutIn: jb,
                cubicOutIn: qb,
                quartOutIn: Xb,
                quintOutIn: Yb,
                sineOutIn: Kb,
                expoOutIn: Zb,
                circOutIn: Qb,
                elasticOutIn: Jb,
                backOutIn: $b,
                bounceOutIn: eR
            });
            e("easing", nR);
            var iR = new Gn,
                rR = function() {
                    var e = t.prototype;

                    function t() {
                        this.handle = 0, this.callBack = null, this.cancelAnimate = !1, this.startTime = -1, this._splashFinish = !1, this._loadFinish = !1, this._directCall = !1
                    }
                    return e.main = function(e) {
                        if (null != e) {
                            if (window._CCSettings && window._CCSettings.splashScreen) {
                                var t = this.settings = window._CCSettings.splashScreen;
                                t.totalTime = null != this.settings.totalTime ? this.settings.totalTime : 3e3, t.base64src = this.settings.base64src || "", t.effect = this.settings.effect || "FADE-INOUT", t.clearColor = this.settings.clearColor || new ps(.88, .88, .88, 1), t.displayRatio = null != this.settings.displayRatio ? this.settings.displayRatio : .4, t.displayWatermark = null == this.settings.displayWatermark || this.settings.displayWatermark
                            } else this.settings = {
                                totalTime: 3e3,
                                base64src: "",
                                effect: "FADE-INOUT",
                                clearColor: new ps(.88, .88, .88, 1),
                                displayRatio: .4,
                                displayWatermark: !0
                            };
                            if ("" === this.settings.base64src || this.settings.totalTime <= 0) this.callBack && this.callBack(), this.callBack = null, this.settings = null, this._directCall = !0;
                            else {
                                i.view.enableRetina(!0), i.view.resizeWithBrowserSize(!0);
                                var n = window._CCSettings.designResolution;
                                n ? i.view.setDesignResolutionSize(n.width, n.height, n.policy) : i.view.setDesignResolutionSize(960, 640, 4), this.root = e, this.device = e.device, i.game.once(i.Game.EVENT_GAME_INITED, (function() {
                                    i.director._lateUpdate = performance.now()
                                }), i.director), this.callBack = null, this.cancelAnimate = !1, this.startTime = -1, this.preInit(), this.logoImage = new Image, this.logoImage.onload = this.init.bind(this), this.logoImage.src = this.settings.base64src
                            }
                        } else p("RENDER ROOT IS NULL.")
                    }, e.setOnFinish = function(e) {
                        if (this._directCall && e) return t._ins = void 0, void e();
                        this.callBack = e
                    }, e._tryToStart = function() {
                        this._splashFinish && this._loadFinish && this.callBack && (this.callBack(), this.hide(), i.game.resume())
                    }, e.preInit = function() {
                        var e = this.settings.clearColor;
                        this.clearColors = [new ps(e.x, e.y, e.z, e.w)];
                        var t = this.device;
                        this.renderArea = new ss(0, 0, t.width, t.height), this.framebuffer = this.root.mainWindow.framebuffer, this.cmdBuff = t.commandBuffer;
                        var n = new Float32Array([.5, .5, 1, 0, -.5, .5, 0, 0, .5, -.5, 1, 1, -.5, -.5, 0, 1]),
                            i = 4 * Float32Array.BYTES_PER_ELEMENT,
                            r = 4 * i;
                        this.vertexBuffers = t.createBuffer(new gs(xa.VERTEX | xa.TRANSFER_DST, Ra.HOST | Ra.DEVICE, r, i)), this.vertexBuffers.update(n);
                        var o = new Uint16Array([0, 1, 2, 1, 3, 2]),
                            a = Uint16Array.BYTES_PER_ELEMENT,
                            s = 6 * a;
                        this.indicesBuffers = t.createBuffer(new gs(xa.INDEX | xa.TRANSFER_DST, Ra.HOST | Ra.DEVICE, s, a)), this.indicesBuffers.update(o);
                        var c = [new Ms("a_position", Ea.RG32F), new Ms("a_texCoord", Ea.RG32F)],
                            l = new Bs(c, [this.vertexBuffers], this.indicesBuffers);
                        this.quadAssmebler = t.createInputAssembler(l), this.projection = new Bn, Bn.ortho(this.projection, -1, 1, -1, 1, -1, 1, t.capabilities.clipSpaceMinZ, t.capabilities.clipSpaceSignY, t.surfaceTransform)
                    }, e.init = function() {
                        var e = this;
                        this.initLogo(), this.settings.displayWatermark && this.initWarterMark(), i.game.pause(), this.handle = requestAnimationFrame((function t(n) {
                            if (!e.cancelAnimate) {
                                var i = e.settings,
                                    r = e.device;
                                Bn.ortho(e.projection, -1, 1, -1, 1, -1, 1, r.capabilities.clipSpaceMinZ, r.capabilities.clipSpaceSignY, r.surfaceTransform);
                                var o = r.width,
                                    a = r.height,
                                    s = o < a ? o : a;
                                e.startTime < 0 && (e.startTime = n);
                                var c = n - e.startTime,
                                    l = wb(tn(c / i.totalTime));
                                "NONE" === i.effect && (l = 1);
                                var u = e.logoTexture.width,
                                    h = e.logoTexture.height,
                                    _ = s * i.displayRatio,
                                    f = _ * u / h,
                                    d = _;
                                if (r.surfaceTransform !== ya.ROTATE_90 && r.surfaceTransform !== ya.ROTATE_270 || (f = _ * o / a, d = _ * h / u * a / o), e.logoMat.setProperty("resolution", iR.set(o, a), 0), e.logoMat.setProperty("scale", iR.set(f, d), 0), e.logoMat.setProperty("translate", iR.set(.5 * o, .5 * a), 0), e.logoMat.setProperty("precent", l), e.logoMat.setProperty("u_projection", e.projection), e.logoMat.passes[0].update(), i.displayWatermark && e.watermarkMat) {
                                    var p = .5 * s,
                                        m = e.watermarkTexture.width,
                                        g = p,
                                        v = p * e.watermarkTexture.height / m;
                                    r.surfaceTransform !== ya.ROTATE_90 && r.surfaceTransform !== ya.ROTATE_270 || (g = .5 * p, v = p * o / a * .5), e.watermarkMat.setProperty("resolution", iR.set(o, a), 0), e.watermarkMat.setProperty("scale", iR.set(g, v), 0), e.watermarkMat.setProperty("translate", iR.set(.5 * o, .1 * a), 0), e.watermarkMat.setProperty("precent", l), e.watermarkMat.setProperty("u_projection", e.projection), e.watermarkMat.passes[0].update()
                                }
                                e.frame(), c > i.totalTime && (e.splashFinish = !0), requestAnimationFrame(t)
                            }
                        }))
                    }, e.hide = function() {
                        cancelAnimationFrame(this.handle), this.cancelAnimate = !0, setTimeout(this.destroy.bind(this))
                    }, e.initLogo = function() {
                        var e = this.device;
                        this.logoMat = new nE, this.logoMat.initialize({
                            effectName: "splash-screen"
                        });
                        var t = new xs;
                        t.addressU = Na.CLAMP, t.addressV = Na.CLAMP, t.addressW = Na.CLAMP, this.sampler = e.createSampler(t), this.logoTexture = e.createTexture(new Ts(wa.TEX2D, Ia.SAMPLED | Ia.TRANSFER_DST, Ea.RGBA8, this.logoImage.width, this.logoImage.height));
                        var n = this.logoMat.passes[0],
                            i = n.getBinding("mainTexture");
                        n.bindTexture(i, this.logoTexture), this.shader = vr.get(n.getShaderVariant());
                        var r = yr.get(Mr.get(n.handle, gr.DESCRIPTOR_SET));
                        r.bindSampler(i, this.sampler), r.update();
                        var o = new fs;
                        o.texExtent.width = this.logoImage.width, o.texExtent.height = this.logoImage.height, o.texExtent.depth = 1, e.copyTexImagesToTexture([this.logoImage], this.logoTexture, [o])
                    }, e.initWarterMark = function() {
                        var e = document.createElement("canvas");
                        e.width = 330, e.height = 30, e.style.width = "" + e.width, e.style.height = "" + e.height;
                        var t = e.getContext("2d");
                        t.font = "18px Arial", t.textBaseline = "top", t.textAlign = "left", t.fillStyle = "`#424242`";
                        var n = "Powered by Cocos Creator",
                            i = t.measureText(n);
                        t.fillText(n, (330 - i.width) / 2, 6);
                        var r = new fs;
                        r.texExtent.width = e.width, r.texExtent.height = e.height, r.texExtent.depth = 1, this.watermarkTexture = this.device.createTexture(new Ts(wa.TEX2D, Ia.SAMPLED | Ia.TRANSFER_DST, Ea.RGBA8, e.width, e.height)), this.device.copyTexImagesToTexture([e], this.watermarkTexture, [r]), this.watermarkMat = new nE, this.watermarkMat.initialize({
                            effectName: "splash-screen"
                        });
                        var o = this.watermarkMat.passes[0],
                            a = o.getBinding("mainTexture");
                        o.bindTexture(a, this.watermarkTexture), yr.get(Mr.get(o.handle, gr.DESCRIPTOR_SET)).update()
                    }, e.frame = function() {
                        var e = this.device;
                        e.acquire();
                        var t = this.cmdBuff,
                            n = this.framebuffer,
                            i = this.renderArea;
                        i.width = e.width, i.height = e.height, t.begin(), t.beginRenderPass(n.renderPass, n, i, this.clearColors, 1, 0);
                        var r = this.logoMat.passes[0],
                            o = SA.getOrCreatePipelineState(e, r, this.shader, n.renderPass, this.quadAssmebler);
                        if (t.bindPipelineState(o), t.bindDescriptorSet(Vu.MATERIAL, r.descriptorSet), t.bindInputAssembler(this.quadAssmebler), t.draw(this.quadAssmebler), this.settings.displayWatermark && this.watermarkMat) {
                            var a = this.watermarkMat.passes[0],
                                s = SA.getOrCreatePipelineState(e, a, this.shader, n.renderPass, this.quadAssmebler);
                            t.bindPipelineState(s), t.bindDescriptorSet(Vu.MATERIAL, a.descriptorSet), t.bindInputAssembler(this.quadAssmebler), t.draw(this.quadAssmebler)
                        }
                        t.endRenderPass(), t.end(), e.flushCommands([t]), e.queue.submit([t]), e.present()
                    }, e.destroy = function() {
                        this.callBack = null, this.root = null, this.device = null, this.clearColors = null, this.logoImage.destroy && this.logoImage.destroy(), this.logoImage = null, this.framebuffer = null, this.renderArea = null, this.cmdBuff = null, this.shader = null, this.logoMat.destroy(), this.logoMat = null, this.logoTexture.destroy(), this.logoTexture = null, this.quadAssmebler.destroy(), this.quadAssmebler = null, this.vertexBuffers.destroy(), this.vertexBuffers = null, this.indicesBuffers.destroy(), this.indicesBuffers = null, this.sampler.destroy(), this.sampler = null, this.watermarkTexture && (this.watermarkMat.destroy(), this.watermarkMat = null, this.watermarkTexture.destroy(), this.watermarkTexture = null), this.settings = null, t._ins = void 0
                    }, K(t, [{
                        key: "splashFinish",
                        set: function(e) {
                            this._splashFinish = e, this._tryToStart()
                        }
                    }, {
                        key: "loadFinish",
                        set: function(e) {
                            this._loadFinish = e, this._tryToStart()
                        }
                    }], [{
                        key: "instance",
                        get: function() {
                            return t._ins || (t._ins = new t), t._ins
                        }
                    }]), t
                }();
            rR._ins = void 0, i.internal.SplashScreen = rR;
            var oR = e("System", function() {
                    function e() {
                        this._id = "", this._priority = 0, this._executeInEditMode = !1
                    }
                    e.sortByPriority = function(e, t) {
                        return e._priority < t._priority ? 1 : e._priority > t.priority ? -1 : 0
                    };
                    var t = e.prototype;
                    return t.init = function() {}, t.update = function() {}, t.postUpdate = function() {}, K(e, [{
                        key: "priority",
                        get: function() {
                            return this._priority
                        },
                        set: function(e) {
                            this._priority = e
                        }
                    }, {
                        key: "id",
                        get: function() {
                            return this._id
                        },
                        set: function(e) {
                            this._id = e
                        }
                    }]), e
                }()),
                aR = new ue("Scheduler"),
                sR = function(e, t, n, i) {
                    this.target = void 0, this.priority = void 0, this.paused = void 0, this.markedForDeletion = void 0, this.target = e, this.priority = t, this.paused = n, this.markedForDeletion = i
                };
            sR.get = function(e, t, n, i) {
                var r = sR._listEntries.pop();
                return r ? (r.target = e, r.priority = t, r.paused = n, r.markedForDeletion = i) : r = new sR(e, t, n, i), r
            }, sR.put = function(e) {
                sR._listEntries.length < 20 && (e.target = null, sR._listEntries.push(e))
            }, sR._listEntries = [];
            var cR = function(e, t, n, i) {
                this.list = void 0, this.entry = void 0, this.target = void 0, this.callback = void 0, this.list = e, this.entry = t, this.target = n, this.callback = i
            };
            cR.get = function(e, t, n, i) {
                var r = cR._hashUpdateEntries.pop();
                return r ? (r.list = e, r.entry = t, r.target = n, r.callback = i) : r = new cR(e, t, n, i), r
            }, cR.put = function(e) {
                cR._hashUpdateEntries.length < 20 && (e.list = e.entry = e.target = e.callback = null, cR._hashUpdateEntries.push(e))
            }, cR._hashUpdateEntries = [];
            var lR = function(e, t, n, i, r, o) {
                this.timers = void 0, this.target = void 0, this.timerIndex = void 0, this.currentTimer = void 0, this.currentTimerSalvaged = void 0, this.paused = void 0, this.timers = e, this.target = t, this.timerIndex = n, this.currentTimer = i, this.currentTimerSalvaged = r, this.paused = o
            };
            lR.get = function(e, t, n, i, r, o) {
                var a = lR._hashTimerEntries.pop();
                return a ? (a.timers = e, a.target = t, a.timerIndex = n, a.currentTimer = i, a.currentTimerSalvaged = r, a.paused = o) : a = new lR(e, t, n, i, r, o), a
            }, lR.put = function(e) {
                lR._hashTimerEntries.length < 20 && (e.timers = e.target = e.currentTimer = null, lR._hashTimerEntries.push(e))
            }, lR._hashTimerEntries = [];
            var uR = function() {
                function e() {
                    this._lock = void 0, this._scheduler = void 0, this._elapsed = void 0, this._runForever = void 0, this._useDelay = void 0, this._timesExecuted = void 0, this._repeat = void 0, this._delay = void 0, this._interval = void 0, this._target = void 0, this._callback = void 0, this._lock = !1, this._scheduler = null, this._elapsed = -1, this._runForever = !1, this._useDelay = !1, this._timesExecuted = 0, this._repeat = 0, this._delay = 0, this._interval = 0, this._target = null, this._callback = null
                }
                var t = e.prototype;
                return t.initWithCallback = function(e, t, n, r, o, a) {
                    return this._lock = !1, this._scheduler = e, this._target = n, this._callback = t, this._elapsed = -1, this._interval = r, this._delay = a, this._useDelay = this._delay > 0, this._repeat = o, this._runForever = this._repeat === i.macro.REPEAT_FOREVER, !0
                }, t.getInterval = function() {
                    return this._interval
                }, t.setInterval = function(e) {
                    this._interval = e
                }, t.update = function(e) {
                    -1 === this._elapsed ? (this._elapsed = 0, this._timesExecuted = 0) : (this._elapsed += e, this._runForever && !this._useDelay ? this._elapsed >= this._interval && (this.trigger(), this._elapsed = 0) : (this._useDelay ? this._elapsed >= this._delay && (this.trigger(), this._elapsed -= this._delay, this._timesExecuted += 1, this._useDelay = !1) : this._elapsed >= this._interval && (this.trigger(), this._elapsed = 0, this._timesExecuted += 1), this._callback && !this._runForever && this._timesExecuted > this._repeat && this.cancel()))
                }, t.getCallback = function() {
                    return this._callback
                }, t.trigger = function() {
                    this._target && this._callback && (this._lock = !0, this._callback.call(this._target, this._elapsed), this._lock = !1)
                }, t.cancel = function() {
                    this._scheduler.unschedule(this._callback, this._target)
                }, e
            }();
            uR._timers = [], uR.get = function() {
                return uR._timers.pop() || new uR
            }, uR.put = function(e) {
                uR._timers.length < 20 && !e._lock && (e._scheduler = e._target = e._callback = null, uR._timers.push(e))
            };
            var hR = e("Scheduler", function(e) {
                function t() {
                    var t;
                    return (t = e.call(this) || this)._timeScale = void 0, t._updatesNegList = void 0, t._updates0List = void 0, t._updatesPosList = void 0, t._hashForUpdates = void 0, t._hashForTimers = void 0, t._currentTarget = void 0, t._currentTargetSalvaged = void 0, t._updateHashLocked = void 0, t._arrayForTimers = void 0, t._timeScale = 1, t._updatesNegList = [], t._updates0List = [], t._updatesPosList = [], t._hashForUpdates = Te(!0), t._hashForTimers = Te(!0), t._currentTarget = null, t._currentTargetSalvaged = !1, t._updateHashLocked = !1, t._arrayForTimers = [], t
                }
                Q(t, e), t.enableForTarget = function(e) {
                    var t = !1;
                    (e.uuid || e.id) && (t = !0), t || (e.__instanceId ? x(1513) : e.id = aR.getNewId())
                };
                var n = t.prototype;
                return n.setTimeScale = function(e) {
                    this._timeScale = e
                }, n.getTimeScale = function() {
                    return this._timeScale
                }, n.update = function(e) {
                    var t, n, i, r, o;
                    for (this._updateHashLocked = !0, 1 !== this._timeScale && (e *= this._timeScale), t = 0, i = (n = this._updatesNegList).length; t < i; t++)(r = n[t]).paused || r.markedForDeletion || r.target.update(e);
                    for (t = 0, i = (n = this._updates0List).length; t < i; t++)(r = n[t]).paused || r.markedForDeletion || r.target.update(e);
                    for (t = 0, i = (n = this._updatesPosList).length; t < i; t++)(r = n[t]).paused || r.markedForDeletion || r.target.update(e);
                    var a = this._arrayForTimers;
                    for (t = 0; t < a.length; t++) {
                        if (o = a[t], this._currentTarget = o, this._currentTargetSalvaged = !1, !o.paused)
                            for (o.timerIndex = 0; o.timerIndex < o.timers.length; ++o.timerIndex) o.currentTimer = o.timers[o.timerIndex], o.currentTimerSalvaged = !1, o.currentTimer.update(e), o.currentTimer = null;
                        this._currentTargetSalvaged && 0 === this._currentTarget.timers.length && (this._removeHashElement(this._currentTarget), --t)
                    }
                    for (t = 0, n = this._updatesNegList; t < n.length;)(r = n[t]).markedForDeletion ? this._removeUpdateFromHash(r) : t++;
                    for (t = 0, n = this._updates0List; t < n.length;)(r = n[t]).markedForDeletion ? this._removeUpdateFromHash(r) : t++;
                    for (t = 0, n = this._updatesPosList; t < n.length;)(r = n[t]).markedForDeletion ? this._removeUpdateFromHash(r) : t++;
                    this._updateHashLocked = !1, this._currentTarget = null
                }, n.schedule = function(e, t, n, r, o, a) {
                    if ("function" != typeof e) {
                        var s = e;
                        e = t, t = s
                    }
                    3 !== arguments.length && 4 !== arguments.length && 5 !== arguments.length || (a = !!r, r = i.macro.REPEAT_FOREVER, o = 0), I(t, 1502);
                    var c = t.uuid || t.id;
                    if (c) {
                        var l, u, h = this._hashForTimers[c];
                        if (h ? h.paused !== a && x(1511) : (h = lR.get(null, t, 0, null, null, a), this._arrayForTimers.push(h), this._hashForTimers[c] = h), null == h.timers) h.timers = [];
                        else
                            for (u = 0; u < h.timers.length; ++u)
                                if ((l = h.timers[u]) && e === l._callback) return T(1507, l.getInterval(), n), void(l._interval = n);
                        (l = uR.get()).initWithCallback(this, e, t, n, r, o), h.timers.push(l), this._currentTarget === h && this._currentTargetSalvaged && (this._currentTargetSalvaged = !1)
                    } else b(1510)
                }, n.scheduleUpdate = function(e, t, n) {
                    var i = e.uuid || e.id;
                    if (i) {
                        var r = this._hashForUpdates[i];
                        if (r && r.entry) {
                            if (r.entry.priority === t) return r.entry.markedForDeletion = !1, void(r.entry.paused = n);
                            if (this._updateHashLocked) return T(1506), r.entry.markedForDeletion = !1, void(r.entry.paused = n);
                            this.unscheduleUpdate(e)
                        }
                        var o, a = sR.get(e, t, n, !1);
                        0 === t ? (o = this._updates0List, this._appendIn(o, a)) : (o = t < 0 ? this._updatesNegList : this._updatesPosList, this._priorityIn(o, a, t)), this._hashForUpdates[i] = cR.get(o, a, e, null)
                    } else b(1510)
                }, n.unschedule = function(e, t) {
                    if (t && e) {
                        var n = t.uuid || t.id;
                        if (n) {
                            var i = this,
                                r = i._hashForTimers[n];
                            if (r)
                                for (var o = r.timers, a = 0, s = o.length; a < s; a++) {
                                    var c = o[a];
                                    if (e === c._callback) return c !== r.currentTimer || r.currentTimerSalvaged || (r.currentTimerSalvaged = !0), o.splice(a, 1), uR.put(c), r.timerIndex >= a && r.timerIndex--, void(0 === o.length && (i._currentTarget === r ? i._currentTargetSalvaged = !0 : i._removeHashElement(r)))
                                }
                        } else b(1510)
                    }
                }, n.unscheduleUpdate = function(e) {
                    if (e) {
                        var t = e.uuid || e.id;
                        if (t) {
                            var n = this._hashForUpdates[t];
                            n && (this._updateHashLocked ? n.entry.markedForDeletion = !0 : this._removeUpdateFromHash(n.entry))
                        } else b(1510)
                    }
                }, n.unscheduleAllForTarget = function(e) {
                    if (e) {
                        var t = e.uuid || e.id;
                        if (t) {
                            var n = this._hashForTimers[t];
                            if (n) {
                                var i = n.timers;
                                i.indexOf(n.currentTimer) > -1 && !n.currentTimerSalvaged && (n.currentTimerSalvaged = !0);
                                for (var r = 0, o = i.length; r < o; r++) uR.put(i[r]);
                                i.length = 0, this._currentTarget === n ? this._currentTargetSalvaged = !0 : this._removeHashElement(n)
                            }
                            this.unscheduleUpdate(e)
                        } else b(1510)
                    }
                }, n.unscheduleAll = function() {
                    this.unscheduleAllWithMinPriority(i.Scheduler.PRIORITY_SYSTEM)
                }, n.unscheduleAllWithMinPriority = function(e) {
                    var t, n, i, r = this._arrayForTimers;
                    for (t = r.length - 1; t >= 0; t--) n = r[t], this.unscheduleAllForTarget(n.target);
                    var o = 0;
                    if (e < 0)
                        for (t = 0; t < this._updatesNegList.length;) o = this._updatesNegList.length, (i = this._updatesNegList[t]) && i.priority >= e && this.unscheduleUpdate(i.target), o === this._updatesNegList.length && t++;
                    if (e <= 0)
                        for (t = 0; t < this._updates0List.length;) o = this._updates0List.length, (i = this._updates0List[t]) && this.unscheduleUpdate(i.target), o === this._updates0List.length && t++;
                    for (t = 0; t < this._updatesPosList.length;) o = this._updatesPosList.length, (i = this._updatesPosList[t]) && i.priority >= e && this.unscheduleUpdate(i.target), o === this._updatesPosList.length && t++
                }, n.isScheduled = function(e, t) {
                    I(e, 1508), I(t, 1509);
                    var n = t.uuid || t.id;
                    if (n) {
                        var i = this._hashForTimers[n];
                        if (!i) return !1;
                        if (null == i.timers) return !1;
                        for (var r = i.timers, o = 0; o < r.length; ++o)
                            if (e === r[o]._callback) return !0;
                        return !1
                    }
                    b(1510)
                }, n.pauseAllTargets = function() {
                    return this.pauseAllTargetsWithMinPriority(i.Scheduler.PRIORITY_SYSTEM)
                }, n.pauseAllTargetsWithMinPriority = function(e) {
                    var t, n, i, r, o = [],
                        a = this._arrayForTimers;
                    for (n = 0, i = a.length; n < i; n++)(t = a[n]) && (t.paused = !0, o.push(t.target));
                    if (e < 0)
                        for (n = 0; n < this._updatesNegList.length; n++)(r = this._updatesNegList[n]) && r.priority >= e && (r.paused = !0, o.push(r.target));
                    if (e <= 0)
                        for (n = 0; n < this._updates0List.length; n++)(r = this._updates0List[n]) && (r.paused = !0, o.push(r.target));
                    for (n = 0; n < this._updatesPosList.length; n++)(r = this._updatesPosList[n]) && r.priority >= e && (r.paused = !0, o.push(r.target));
                    return o
                }, n.resumeTargets = function(e) {
                    if (e)
                        for (var t = 0; t < e.length; t++) this.resumeTarget(e[t])
                }, n.pauseTarget = function(e) {
                    I(e, 1503);
                    var t = e.uuid || e.id;
                    if (t) {
                        var n = this._hashForTimers[t];
                        n && (n.paused = !0);
                        var i = this._hashForUpdates[t];
                        i && (i.entry.paused = !0)
                    } else b(1510)
                }, n.resumeTarget = function(e) {
                    I(e, 1504);
                    var t = e.uuid || e.id;
                    if (t) {
                        var n = this._hashForTimers[t];
                        n && (n.paused = !1);
                        var i = this._hashForUpdates[t];
                        i && (i.entry.paused = !1)
                    } else b(1510)
                }, n.isTargetPaused = function(e) {
                    I(e, 1505);
                    var t = e.uuid || e.id;
                    if (!t) return b(1510), !1;
                    var n = this._hashForTimers[t];
                    if (n) return n.paused;
                    var i = this._hashForUpdates[t];
                    return !!i && i.entry.paused
                }, n._removeHashElement = function(e) {
                    var t = e.target.uuid || e.target.id;
                    delete this._hashForTimers[t];
                    for (var n = this._arrayForTimers, i = 0, r = n.length; i < r; i++)
                        if (n[i] === e) {
                            n.splice(i, 1);
                            break
                        }
                    lR.put(e)
                }, n._removeUpdateFromHash = function(e) {
                    var t = e.target.uuid || e.target.id,
                        n = this._hashForUpdates[t];
                    if (n) {
                        for (var i = n.list, r = n.entry, o = 0, a = i.length; o < a; o++)
                            if (i[o] === r) {
                                i.splice(o, 1);
                                break
                            }
                        delete this._hashForUpdates[t], sR.put(r), cR.put(n)
                    }
                }, n._priorityIn = function(e, t, n) {
                    for (var i = 0; i < e.length; i++)
                        if (n < e[i].priority) return void e.splice(i, 0, t);
                    e.push(t)
                }, n._appendIn = function(e, t) {
                    e.push(t)
                }, t
            }(oR));
            hR.PRIORITY_SYSTEM = 1 << 31, hR.PRIORITY_NON_SYSTEM = hR.PRIORITY_SYSTEM + 1, hR.ID = "scheduler", i.Scheduler = hR;
            var _R = function() {
                    function e() {
                        this._title = "", this._width = 1, this._height = 1, this._nativeWidth = 1, this._nativeHeight = 1, this._renderPass = null, this._colorTextures = [], this._depthStencilTexture = null, this._swapchainBufferIndices = 0, this._shouldSyncSizeWithSwapchain = !1, this._poolHandle = 0, this._cameras = []
                    }
                    e.registerCreateFunc = function(t) {
                        t._createWindowFun = function(t) {
                            return new e(t)
                        }
                    };
                    var t = e.prototype;
                    return t.initialize = function(e, t) {
                        this._poolHandle = so.alloc(), void 0 !== t.title && (this._title = t.title), void 0 !== t.swapchainBufferIndices && (this._swapchainBufferIndices = t.swapchainBufferIndices), void 0 !== t.shouldSyncSizeWithSwapchain && (this._shouldSyncSizeWithSwapchain = t.shouldSyncSizeWithSwapchain), this._width = t.width, this._height = t.height, this._nativeWidth = this._width, this._nativeHeight = this._height;
                        for (var n = t.renderPassInfo, i = n.colorAttachments, r = n.depthStencilAttachment, o = 0; o < i.length; o++) i[o].format === Ea.UNKNOWN && (i[o].format = e.colorFormat);
                        r && r.format === Ea.UNKNOWN && (r.format = e.depthStencilFormat), this._renderPass = e.createRenderPass(t.renderPassInfo);
                        for (var a = 0; a < i.length; a++) {
                            var s = null;
                            this._swapchainBufferIndices & 1 << a ? so.set(this._poolHandle, no.HAS_ON_SCREEN_ATTACHMENTS, 1) : (s = e.createTexture(new Ts(wa.TEX2D, Ia.COLOR_ATTACHMENT | Ia.SAMPLED, i[a].format, this._width, this._height)), so.set(this._poolHandle, no.HAS_OFF_SCREEN_ATTACHMENTS, 1)), this._colorTextures.push(s)
                        }
                        r && (this._swapchainBufferIndices >= 0 ? (this._depthStencilTexture = e.createTexture(new Ts(wa.TEX2D, Ia.DEPTH_STENCIL_ATTACHMENT | Ia.SAMPLED, r.format, this._width, this._height)), so.set(this._poolHandle, no.HAS_OFF_SCREEN_ATTACHMENTS, 1)) : so.set(this._poolHandle, no.HAS_ON_SCREEN_ATTACHMENTS, 1));
                        var c = Tr.alloc(e, new Vs(this._renderPass, this._colorTextures, this._depthStencilTexture));
                        return so.set(this._poolHandle, no.FRAMEBUFFER, c), !0
                    }, t.destroy = function() {
                        this.clearCameras(), this._depthStencilTexture && (this._depthStencilTexture.destroy(), this._depthStencilTexture = null);
                        for (var e = 0; e < this._colorTextures.length; e++) {
                            var t = this._colorTextures[e];
                            t && t.destroy()
                        }
                        this._colorTextures.length = 0, this._poolHandle && (Tr.get(so.get(this._poolHandle, no.FRAMEBUFFER)).destroy(), this._poolHandle = 0)
                    }, t.resize = function(e, t) {
                        if (this._width = e, this._height = t, e > this._nativeWidth || t > this._nativeHeight) {
                            this._nativeWidth = e, this._nativeHeight = t;
                            var n = !1;
                            this._depthStencilTexture && (this._depthStencilTexture.resize(e, t), n = !0);
                            for (var i = 0; i < this._colorTextures.length; i++) {
                                var r = this._colorTextures[i];
                                r && (r.resize(e, t), n = !0)
                            }
                            var o = Tr.get(so.get(this._poolHandle, no.FRAMEBUFFER));
                            n && o && (o.destroy(), o.initialize(new Vs(this._renderPass, this._colorTextures, this._depthStencilTexture)))
                        }
                        for (var a, s = te(this._cameras); !(a = s()).done;) {
                            var c = a.value;
                            c.isWindowSize && c.resize(e, t)
                        }
                    }, t.extractRenderCameras = function(e) {
                        for (var t = 0; t < this._cameras.length; t++) {
                            var n = this._cameras[t];
                            n.enabled && (n.update(), e.push(n))
                        }
                    }, t.attachCamera = function(e) {
                        for (var t = 0; t < this._cameras.length; t++)
                            if (this._cameras[t] === e) return;
                        this._cameras.push(e), this.sortCameras()
                    }, t.detachCamera = function(e) {
                        for (var t = 0; t < this._cameras.length; ++t)
                            if (this._cameras[t] === e) return void this._cameras.splice(t, 1)
                    }, t.clearCameras = function() {
                        this._cameras.length = 0
                    }, t.sortCameras = function() {
                        this._cameras.sort((function(e, t) {
                            return e.priority - t.priority
                        }))
                    }, K(e, [{
                        key: "width",
                        get: function() {
                            return this._width
                        }
                    }, {
                        key: "height",
                        get: function() {
                            return this._height
                        }
                    }, {
                        key: "framebuffer",
                        get: function() {
                            return Tr.get(so.get(this._poolHandle, no.FRAMEBUFFER))
                        }
                    }, {
                        key: "shouldSyncSizeWithSwapchain",
                        get: function() {
                            return this._shouldSyncSizeWithSwapchain
                        }
                    }, {
                        key: "hasOnScreenAttachments",
                        get: function() {
                            return 1 === so.get(this._poolHandle, no.HAS_ON_SCREEN_ATTACHMENTS)
                        }
                    }, {
                        key: "hasOffScreenAttachments",
                        get: function() {
                            return 1 === so.get(this._poolHandle, no.HAS_OFF_SCREEN_ATTACHMENTS)
                        }
                    }, {
                        key: "handle",
                        get: function() {
                            return this._poolHandle
                        }
                    }, {
                        key: "cameras",
                        get: function() {
                            return this._cameras
                        }
                    }]), e
                }(),
                fR = function() {
                    function e(e) {
                        var t = this;
                        this._createSceneFun = null, this._createWindowFun = null, this._device = void 0, this._windows = [], this._mainWindow = null, this._curWindow = null, this._tempWindow = null, this._pipeline = null, this._batcher = null, this._dataPoolMgr = void 0, this._scenes = [], this._modelPools = new Map, this._cameraPool = null, this._lightPools = new Map, this._fpsTime = 0, this._frameCount = 0, this._fps = 0, this._fixedFPS = 0, this._fixedFPSFrameTime = 0, this._poolHandle = 0, this._useDeferredPipeline = !1, this._device = e, this._dataPoolMgr = i.internal.DataPoolManager && new i.internal.DataPoolManager(e), d_.registerCreateFunc(this), _R.registerCreateFunc(this), this._cameraPool = new Jn((function() {
                            return new f_(t._device)
                        }), 4)
                    }
                    var t = e.prototype;
                    return t.initialize = function() {
                        var e = this;
                        this._poolHandle = ro.alloc();
                        var t = new Fs,
                            n = new zs;
                        n.depthStoreOp = Ha.DISCARD, n.stencilStoreOp = Ha.DISCARD;
                        var r = new Gs([t], n);
                        return this._mainWindow = this.createWindow({
                            title: "rootMainWindow",
                            width: this._device.width,
                            height: this._device.height,
                            renderPassInfo: r,
                            swapchainBufferIndices: -1
                        }), this._curWindow = this._mainWindow, Promise.resolve(em.initBuiltinRes(this._device)).then((function() {
                            i.view.on("design-resolution-changed", (function() {
                                var t = i.game.canvas.width,
                                    n = i.game.canvas.height;
                                e.resize(t, n)
                            }), e)
                        }))
                    }, t.destroy = function() {
                        this.destroyScenes(), this._pipeline && (this._pipeline.destroy(), this._pipeline = null), this._batcher && (this._batcher.destroy(), this._batcher = null), this._curWindow = null, this._mainWindow = null, this.dataPoolManager.clear(), this._poolHandle && (ro.free(this._poolHandle), this._poolHandle = 0)
                    }, t.resize = function(e, t) {
                        this._device.resize(e, t), this._mainWindow.resize(e, t);
                        for (var n, i = te(this._windows); !(n = i()).done;) {
                            var r = n.value;
                            r.shouldSyncSizeWithSwapchain && r.resize(e, t)
                        }
                        this._pipeline && this._pipeline.resize(e, t)
                    }, t.setRenderPipeline = function(e) {
                        if (e instanceof GC && (this._useDeferredPipeline = !0), e || (e = kC()), this._pipeline = e, !this._pipeline.activate()) return !1;
                        var t = i.director.getScene();
                        return t && t.globals.activate(), this.onGlobalPipelineStateChanged(), !(!this._batcher && i.internal.Batcher2D && (this._batcher = new i.internal.Batcher2D(this), !this._batcher.initialize()) && (this.destroy(), 1))
                    }, t.onGlobalPipelineStateChanged = function() {
                        for (var e = 0; e < this._scenes.length; e++) this._scenes[e].onGlobalPipelineStateChanged();
                        this._pipeline.pipelineSceneData.initDeferredPassInfo()
                    }, t.activeWindow = function(e) {
                        this._curWindow = e
                    }, t.resetCumulativeTime = function() {
                        ro.set(this._poolHandle, eo.CUMULATIVE_TIME, 0)
                    }, t.frameMove = function(e) {
                        ro.set(this._poolHandle, eo.FRAME_TIME, e), ++this._frameCount, ro.set(this._poolHandle, eo.CUMULATIVE_TIME, ro.get(this._poolHandle, eo.CUMULATIVE_TIME) + e), this._fpsTime += e, this._fpsTime > 1 && (this._fps = this._frameCount, this._frameCount = 0, this._fpsTime = 0);
                        for (var t = 0; t < this._scenes.length; ++t) this._scenes[t].removeBatches();
                        this._batcher && this._batcher.update();
                        for (var n = this._windows, r = [], o = 0; o < n.length; o++) n[o].extractRenderCameras(r);
                        if (this._pipeline && r.length > 0) {
                            this._device.acquire();
                            var a = this._scenes,
                                s = i.director.getTotalFrames();
                            this._batcher && this._batcher.uploadBuffers();
                            for (var c = 0; c < a.length; c++) a[c].update(s);
                            i.director.emit(i.Director.EVENT_BEFORE_COMMIT), r.sort((function(e, t) {
                                return e.priority - t.priority
                            })), this._pipeline.render(r), this._device.present()
                        }
                        this._batcher && this._batcher.reset()
                    }, t.createWindow = function(e) {
                        var t = this._createWindowFun(this);
                        return t.initialize(this.device, e), this._windows.push(t), t
                    }, t.destroyWindow = function(e) {
                        for (var t = 0; t < this._windows.length; ++t)
                            if (this._windows[t] === e) return e.destroy(), void this._windows.splice(t, 1)
                    }, t.destroyWindows = function() {
                        for (var e, t = te(this._windows); !(e = t()).done;) e.value.destroy();
                        this._windows = []
                    }, t.createScene = function(e) {
                        var t = this._createSceneFun(this);
                        return t.initialize(e), this._scenes.push(t), t
                    }, t.destroyScene = function(e) {
                        for (var t = 0; t < this._scenes.length; ++t)
                            if (this._scenes[t] === e) return e.destroy(), void this._scenes.splice(t, 1)
                    }, t.destroyScenes = function() {
                        for (var e, t = te(this._scenes); !(e = t()).done;) e.value.destroy();
                        this._scenes = []
                    }, t.createModel = function(e) {
                        var t = this._modelPools.get(e);
                        t || (this._modelPools.set(e, new Jn((function() {
                            return new e
                        }), 10)), t = this._modelPools.get(e));
                        var n = t.alloc();
                        return n.initialize(), n
                    }, t.destroyModel = function(e) {
                        var t = this._modelPools.get(e.constructor);
                        t ? (t.free(e), e.destroy(), e.scene && e.scene.removeModel(e)) : x(1300, e.constructor.name)
                    }, t.createCamera = function() {
                        return this._cameraPool.alloc()
                    }, t.createLight = function(e) {
                        var t = this._lightPools.get(e);
                        t || (this._lightPools.set(e, new Jn((function() {
                            return new e
                        }), 4)), t = this._lightPools.get(e));
                        var n = t.alloc();
                        return n.initialize(), n
                    }, t.destroyLight = function(e) {
                        var t = this._lightPools.get(e.constructor);
                        if (e.destroy(), t && (t.free(e), e.scene)) switch (e.type) {
                            case sm.SPHERE:
                                e.scene.removeSphereLight(e);
                                break;
                            case sm.SPOT:
                                e.scene.removeSpotLight(e)
                        }
                    }, K(e, [{
                        key: "device",
                        get: function() {
                            return this._device
                        }
                    }, {
                        key: "mainWindow",
                        get: function() {
                            return this._mainWindow
                        }
                    }, {
                        key: "curWindow",
                        get: function() {
                            return this._curWindow
                        },
                        set: function(e) {
                            this._curWindow = e
                        }
                    }, {
                        key: "tempWindow",
                        get: function() {
                            return this._tempWindow
                        },
                        set: function(e) {
                            this._tempWindow = e
                        }
                    }, {
                        key: "windows",
                        get: function() {
                            return this._windows
                        }
                    }, {
                        key: "pipeline",
                        get: function() {
                            return this._pipeline
                        }
                    }, {
                        key: "batcher2D",
                        get: function() {
                            return this._batcher
                        }
                    }, {
                        key: "scenes",
                        get: function() {
                            return this._scenes
                        }
                    }, {
                        key: "cumulativeTime",
                        get: function() {
                            return ro.get(this._poolHandle, eo.CUMULATIVE_TIME)
                        }
                    }, {
                        key: "frameTime",
                        get: function() {
                            return ro.get(this._poolHandle, eo.FRAME_TIME)
                        }
                    }, {
                        key: "frameCount",
                        get: function() {
                            return this._frameCount
                        }
                    }, {
                        key: "fps",
                        get: function() {
                            return this._fps
                        }
                    }, {
                        key: "fixedFPS",
                        get: function() {
                            return this._fixedFPS
                        },
                        set: function(e) {
                            e > 0 ? (this._fixedFPS = e, this._fixedFPSFrameTime = 1e3 / e) : this._fixedFPSFrameTime = 0
                        }
                    }, {
                        key: "dataPoolManager",
                        get: function() {
                            return this._dataPoolMgr
                        }
                    }, {
                        key: "handle",
                        get: function() {
                            return this._poolHandle
                        }
                    }, {
                        key: "useDeferredPipeline",
                        get: function() {
                            return this._useDeferredPipeline
                        }
                    }]), e
                }();
            i.Root = fR;
            var dR = {};
            U(dR, "vmath", [{
                name: "vec2",
                newName: "Vec2",
                target: Qn,
                targetName: "math"
            }, {
                name: "vec3",
                newName: "Vec3",
                target: Qn,
                targetName: "math"
            }, {
                name: "vec4",
                newName: "Vec4",
                target: Qn,
                targetName: "math"
            }, {
                name: "quat",
                newName: "Quat",
                target: Qn,
                targetName: "math"
            }, {
                name: "mat3",
                newName: "Mat3",
                target: Qn,
                targetName: "math"
            }, {
                name: "mat4",
                newName: "Mat4",
                target: Qn,
                targetName: "math"
            }, {
                name: "color4",
                newName: "Color",
                target: Qn,
                targetName: "math"
            }, {
                name: "rect",
                newName: "Rect",
                target: Qn,
                targetName: "math"
            }, {
                name: "approx",
                newName: "approx",
                target: Qn,
                targetName: "math"
            }, {
                name: "EPSILON",
                newName: "EPSILON",
                target: Qn,
                targetName: "math"
            }, {
                name: "equals",
                newName: "equals",
                target: Qn,
                targetName: "math"
            }, {
                name: "clamp",
                newName: "clamp",
                target: Qn,
                targetName: "math"
            }, {
                name: "clamp01",
                newName: "clamp01",
                target: Qn,
                targetName: "math"
            }, {
                name: "lerp",
                newName: "lerp",
                target: Qn,
                targetName: "math"
            }, {
                name: "toRadian",
                newName: "toRadian",
                target: Qn,
                targetName: "math"
            }, {
                name: "toDegree",
                newName: "toDegree",
                target: Qn,
                targetName: "math"
            }, {
                name: "random",
                newName: "random",
                target: Qn,
                targetName: "math"
            }, {
                name: "randomRange",
                newName: "randomRange",
                target: Qn,
                targetName: "math"
            }, {
                name: "randomRangeInt",
                newName: "randomRangeInt",
                target: Qn,
                targetName: "math"
            }, {
                name: "pseudoRandom",
                newName: "pseudoRandom",
                target: Qn,
                targetName: "math"
            }, {
                name: "pseudoRandomRangeInt",
                newName: "pseudoRandomRangeInt",
                target: Qn,
                targetName: "math"
            }, {
                name: "nextPow2",
                newName: "nextPow2",
                target: Qn,
                targetName: "math"
            }, {
                name: "repeat",
                newName: "repeat",
                target: Qn,
                targetName: "math"
            }, {
                name: "pingPong",
                newName: "pingPong",
                target: Qn,
                targetName: "math"
            }, {
                name: "inverseLerp",
                newName: "inverseLerp",
                target: Qn,
                targetName: "math"
            }]), i.vmath = dR, U(hR.prototype, "Scheduler.prototype", [{
                name: "enableForTarget",
                newName: "enableForTarget",
                target: hR,
                targetName: "Scheduler"
            }]), U(Oy.prototype, "EventTouch.prototype", [{
                name: "getUILocationInView",
                newName: "getLocationInView",
                target: Oy,
                targetName: "EventTouch"
            }]), U(tb.prototype, "SubModel.prototype", [{
                name: "subMeshData",
                newName: "subMesh"
            }]), G(tb.prototype, "SubModel.prototype", [{
                name: "getSubModel",
                suggest: "Use `subModels[i]` instead"
            }, {
                name: "subModelNum",
                suggest: "Use `subModels.length` instead"
            }]), U(fR.prototype, "Root.prototype", [{
                name: "ui",
                newName: "batcher2D"
            }]);
            var pR = Object.freeze({
                __proto__: null,
                ccclass: A_,
                property: R_,
                requireComponent: x_,
                executionOrder: C_,
                disallowMultiple: b_,
                executeInEditMode: O_,
                menu: D_,
                playOnFocus: N_,
                inspector: M_,
                icon: L_,
                help: B_,
                type: ef,
                integer: Z_,
                float: Q_,
                boolean: J_,
                string: $_
            });
            e("_decorator", pR);
            var mR, gR, vR, yR, SR, ER, TR, AR, xR, CR, bR, RR = ni.Flags.Destroyed,
                wR = ni.Flags.PersistentMask,
                IR = [];

            function PR(e) {
                var t;
                if (e instanceof ni) {
                    if (e._instantiate) return i.game._isCloning = !0, t = e._instantiate(null, !0), i.game._isCloning = !1, t;
                    if (e instanceof i.Asset) throw new TypeError(P(6903))
                }
                return i.game._isCloning = !0, t = OR(e), i.game._isCloning = !1, t
            }

            function OR(e, t) {
                var n;
                DR(e, n = e._iN$t ? e._iN$t : e.constructor ? new(0, e.constructor) : Object.create(null), t);
                for (var i = 0, r = IR.length; i < r; ++i) IR[i]._iN$t = null;
                return IR.length = 0, n
            }

            function DR(e, t, n) {
                Qe.value(e, "_iN$t", t, !0), IR.push(e);
                var r = e.constructor;
                if (i.Class._isCCClass(r)) ! function(e, t, n, i) {
                    for (var r = e.__values__, o = 0; o < r.length; o++) {
                        var a = r[o],
                            s = t[a];
                        if ("object" == typeof s && s) {
                            var c = n[a];
                            c instanceof it && c.constructor === s.constructor ? c.set(s) : n[a] = s._iN$t || NR(s, i)
                        } else n[a] = s
                    }
                }(r, e, t, n);
                else
                    for (var o in e)
                        if (e.hasOwnProperty(o) && (95 !== o.charCodeAt(0) || 95 !== o.charCodeAt(1) || "__type__" === o)) {
                            var a = e[o];
                            if ("object" == typeof a && a) {
                                if (a === t) continue;
                                t[o] = a._iN$t || NR(a, n)
                            } else t[o] = a
                        }
                e instanceof ni && (t._objFlags &= wR)
            }

            function NR(e, t) {
                if (e instanceof it) return e.clone();
                if (e instanceof i.Asset) return e;
                var n;
                if (ArrayBuffer.isView(e)) {
                    var r = e.length;
                    n = new e.constructor(r), e._iN$t = n, IR.push(e);
                    for (var o = 0; o < r; ++o) n[o] = e[o];
                    return n
                }
                if (Array.isArray(e)) {
                    var a = e.length;
                    n = new Array(a), e._iN$t = n, IR.push(e);
                    for (var s = 0; s < a; ++s) {
                        var c = e[s];
                        n[s] = "object" == typeof c && c ? c._iN$t || NR(c, t) : c
                    }
                    return n
                }
                if (e._objFlags & RR) return null;
                var l = e.constructor;
                if (i.Class._isCCClass(l)) {
                    if (t)
                        if (t instanceof i.Component) {
                            if (e instanceof i._BaseNode || e instanceof i.Component) return e
                        } else if (t instanceof i._BaseNode)
                        if (e instanceof i._BaseNode) {
                            if (!e.isChildOf(t)) return e
                        } else if (e instanceof i.Component && e.node && !e.node.isChildOf(t)) return e;
                    n = new l
                } else if (l === Object) n = {};
                else {
                    if (l) return e;
                    n = Object.create(null)
                }
                return DR(e, n, t), n
            }

            function MR(e, t) {
                return (t << 3) + e
            }
            PR._clone = OR, i.instantiate = PR,
                function(e) {
                    e[e.Uint8 = 0] = "Uint8", e[e.Uint16 = 1] = "Uint16", e[e.Uint32 = 2] = "Uint32", e[e.Int8 = 3] = "Int8", e[e.Int16 = 4] = "Int16", e[e.Int32 = 5] = "Int32", e[e.Float32 = 6] = "Float32", e[e.Float64 = 7] = "Float64"
                }(CR || (CR = {})),
                function(e) {
                    e[e.Scalar = 0] = "Scalar", e[e.Vec2 = 1] = "Vec2", e[e.Vec3 = 2] = "Vec3", e[e.Vec4 = 3] = "Vec4", e[e.Quat = 4] = "Quat", e[e.Mat4 = 5] = "Mat4"
                }(bR || (bR = {}));
            var LR = e("CompactValueTypeArray", A_("cc.CompactValueTypeArray")((AR = TR = function() {
                function e() {
                    ne(this, "_byteOffset", vR, this), ne(this, "_unitCount", yR, this), ne(this, "_unitElement", SR, this), ne(this, "_length", ER, this)
                }
                return e.lengthFor = function(e, t, n) {
                    return BR(t).requiredUnits * e.length * FR(n).BYTES_PER_ELEMENT
                }, e.compress = function(t, n, i, r, o, a) {
                    for (var s = BR(n), c = FR(i), l = s.requiredUnits * t.length, u = new c(r, o, l), h = 0; h < t.length; ++h) s.compress(u, h, t[h]);
                    var _ = new e;
                    return _._unitElement = MR(i, n), _._byteOffset = a, _._unitCount = l, _._length = t.length, _
                }, e.prototype.decompress = function(e) {
                    for (var t, n = {
                            storageUnit: 7 & (t = this._unitElement),
                            elementType: t >> 3
                        }, i = n.storageUnit, r = BR(n.elementType), o = new(FR(i))(e, this._byteOffset, this._unitCount), a = new Array(this._length), s = 0; s < this._length; ++s) a[s] = r.decompress(o, s);
                    return a
                }, e
            }(), TR.StorageUnit = CR, TR.ElementType = bR, vR = ie((gR = AR).prototype, "_byteOffset", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return 0
                }
            }), yR = ie(gR.prototype, "_unitCount", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return 0
                }
            }), SR = ie(gR.prototype, "_unitElement", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return MR(CR.Uint8, bR.Scalar)
                }
            }), ER = ie(gR.prototype, "_length", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return 0
                }
            }), mR = gR)) || mR);

            function BR(e) {
                return GR[e]
            }

            function FR(e) {
                switch (e) {
                    case CR.Uint8:
                        return Uint8Array;
                    case CR.Uint16:
                        return Uint16Array;
                    case CR.Uint32:
                        return Uint32Array;
                    case CR.Int8:
                        return Int8Array;
                    case CR.Int16:
                        return Int16Array;
                    case CR.Int32:
                        return Int32Array;
                    case CR.Float32:
                        return Float32Array;
                    case CR.Float64:
                        return Float64Array
                }
            }
            var zR, UR, GR = ((xR = {})[bR.Scalar] = {
                requiredUnits: 1,
                compress: function(e, t, n) {
                    e[t] = n
                },
                decompress: function(e, t) {
                    return e[t]
                }
            }, xR[bR.Vec2] = {
                requiredUnits: 2,
                compress: function(e, t, n) {
                    e[2 * t] = n.x, e[2 * t + 1] = n.y
                },
                decompress: function(e, t) {
                    return new En(e[2 * t], e[2 * t + 1])
                }
            }, xR[bR.Vec3] = {
                requiredUnits: 3,
                compress: function(e, t, n) {
                    e[3 * t] = n.x, e[3 * t + 1] = n.y, e[3 * t + 2] = n.z
                },
                decompress: function(e, t) {
                    return new En(e[3 * t], e[3 * t + 1], e[3 * t + 2])
                }
            }, xR[bR.Vec4] = {
                requiredUnits: 4,
                compress: function(e, t, n) {
                    e[4 * t] = n.x, e[4 * t + 1] = n.y, e[4 * t + 2] = n.z, e[4 * t + 3] = n.w
                },
                decompress: function(e, t) {
                    return new Wn(e[4 * t], e[4 * t + 1], e[4 * t + 2], e[4 * t + 3])
                }
            }, xR[bR.Quat] = {
                requiredUnits: 4,
                compress: function(e, t, n) {
                    e[4 * t] = n.x, e[4 * t + 1] = n.y, e[4 * t + 2] = n.z, e[4 * t + 3] = n.w
                },
                decompress: function(e, t) {
                    return new wn(e[4 * t], e[4 * t + 1], e[4 * t + 2], e[4 * t + 3])
                }
            }, xR[bR.Mat4] = {
                requiredUnits: 16,
                compress: function(e, t, n) {
                    Bn.toArray(e, n, 16 * t)
                },
                decompress: function(e, t) {
                    return Bn.fromArray(new Bn, e, 16 * t)
                }
            }, xR);
            i._decorator = pR, G(ud.prototype, "TextureBase.prototype", [{
                name: "hasPremultipliedAlpha"
            }, {
                name: "setPremultiplyAlpha"
            }, {
                name: "setFlipY"
            }]), U(tE.prototype, "RenderTexture.prototype", [{
                name: "getGFXWindow",
                customFunction: function() {
                    return this._window
                }
            }]);
            var HR, kR = e("BufferAsset", A_("cc.BufferAsset")((ie((UR = function(e) {
                function t() {
                    for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                    return (t = e.call.apply(e, [this].concat(i)) || this)._buffer = null, t
                }
                Q(t, e);
                var n = t.prototype;
                return n.buffer = function() {
                    return this._buffer
                }, n.validate = function() {
                    return !!this.buffer
                }, K(t, [{
                    key: "_nativeAsset",
                    get: function() {
                        return this._buffer
                    },
                    set: function(e) {
                        e instanceof ArrayBuffer ? this._buffer = e : this._buffer = e.buffer
                    }
                }]), t
            }(Nf)).prototype, "_nativeAsset", [tf], Object.getOwnPropertyDescriptor(UR.prototype, "_nativeAsset"), UR.prototype), zR = UR)) || zR);
            i.BufferAsset = kR;
            var VR = ((HR = {})[Ta.UNORM] = "Uint", HR[Ta.SNORM] = "Int", HR[Ta.UINT] = "Uint", HR[Ta.INT] = "Int", HR[Ta.UFLOAT] = "Float", HR[Ta.FLOAT] = "Float", HR.default = "Uint", HR);

            function WR(e) {
                return "" + (VR[e.type] || VR.default) + e.size / e.count * 8
            }

            function jR(e, t, n, i, r) {
                void 0 === n && (n = Ea.R32F), void 0 === i && (i = 0), void 0 === r && (r = 0);
                var o = tc[n];
                r || (r = o.size);
                for (var a = "set" + WR(o), s = o.size / o.count, c = Math.floor(t.length / o.count), l = oS.isLittleEndian, u = 0; u < c; ++u)
                    for (var h = i + r * u, _ = 0; _ < o.count; ++_) {
                        var f = h + s * _;
                        e[a](f, t[o.count * u + _], l)
                    }
            }

            function qR(e, t, n, i, r, o) {
                void 0 === t && (t = Ea.R32F), void 0 === n && (n = 0), void 0 === i && (i = e.byteLength - n), void 0 === r && (r = 0), void 0 === o && (o = []);
                var a = tc[t];
                r || (r = a.size);
                for (var s = "get" + WR(a), c = a.size / a.count, l = Math.floor(i / r), u = oS.isLittleEndian, h = 0; h < l; ++h)
                    for (var _ = n + r * h, f = 0; f < a.count; ++f) {
                        var d = _ + c * f;
                        o[a.count * h + f] = e[s](d, u)
                    }
                return o
            }

            function XR(e, t, n, i, r, o, a) {
                void 0 === n && (n = Ea.R32F), void 0 === i && (i = 0), void 0 === r && (r = e.byteLength - i), void 0 === o && (o = 0), a || (a = new DataView(e.buffer.slice(e.byteOffset, e.byteOffset + e.byteLength)));
                var s = tc[n];
                o || (o = s.size);
                for (var c = "set" + WR(s), l = "get" + WR(s), u = s.size / s.count, h = Math.floor(r / o), _ = oS.isLittleEndian, f = 0; f < h; ++f)
                    for (var d = i + o * f, p = 0; p < s.count; ++p) {
                        var m = d + u * p,
                            g = e[l](m, _);
                        a[c](m, t(g, p, e), _)
                    }
                return a
            }
            var YR = e("RenderingSubMesh", function() {
                    function e(e, t, n, i, r) {
                        void 0 === i && (i = null), void 0 === r && (r = null), this.mesh = void 0, this.subMeshIdx = void 0, this._flatBuffers = [], this._jointMappedBuffers = void 0, this._jointMappedBufferIndices = void 0, this._vertexIdChannel = void 0, this._geometricInfo = void 0, this._vertexBuffers = void 0, this._attributes = void 0, this._indexBuffer = null, this._indirectBuffer = null, this._primitiveMode = void 0, this._iaInfo = void 0, this._handle = 0, this._attributes = t, this._vertexBuffers = e, this._indexBuffer = i, this._indirectBuffer = r, this._primitiveMode = n, this._iaInfo = new Bs(t, e, i, r), this._handle = zo.alloc();
                        var o = br.alloc();
                        zo.set(this._handle, No.FLAT_BUFFER_ARRAY, o)
                    }
                    var t = e.prototype;
                    return t.genFlatBuffers = function() {
                        if (!this._flatBuffers.length && this.mesh && void 0 !== this.subMeshIdx) {
                            var e = this.mesh,
                                t = 0,
                                n = e.struct.primitives[this.subMeshIdx],
                                i = zo.get(this._handle, No.FLAT_BUFFER_ARRAY);
                            n.indexView && (t = n.indexView.count);
                            for (var r = 0; r < n.vertexBundelIndices.length; r++) {
                                var o = n.vertexBundelIndices[r],
                                    a = e.struct.vertexBundles[o],
                                    s = n.indexView ? n.indexView.count : a.view.count,
                                    c = a.view.stride,
                                    l = c * s,
                                    u = new Uint8Array(e.data.buffer, a.view.offset, a.view.length),
                                    h = Pr.alloc(n.indexView ? l : a.view.length),
                                    _ = Lo.alloc();
                                Lo.set(_, Oo.STRIDE, c), Lo.set(_, Oo.AMOUNT, s), Lo.set(_, Oo.BUFFER, h), br.push(i, _);
                                var f = Pr.getBuffer(h),
                                    d = new Uint8Array(f);
                                if (n.indexView) {
                                    for (var p = e.readIndices(this.subMeshIdx), m = 0; m < t; ++m)
                                        for (var g = m * c, v = p[m] * c, y = 0; y < c; ++y) d[g + y] = u[v + y];
                                    this._flatBuffers.push({
                                        stride: c,
                                        count: s,
                                        buffer: d
                                    })
                                } else d.set(e.data.subarray(a.view.offset, a.view.offset + a.view.length)), this._flatBuffers.push({
                                    stride: c,
                                    count: s,
                                    buffer: d
                                })
                            }
                        }
                    }, t.destroy = function() {
                        for (var e = 0; e < this.vertexBuffers.length; e++) this.vertexBuffers[e].destroy();
                        if (this.vertexBuffers.length = 0, this._indexBuffer && (this._indexBuffer.destroy(), this._indexBuffer = null), this._jointMappedBuffers && this._jointMappedBufferIndices) {
                            for (var t = 0; t < this._jointMappedBufferIndices.length; t++) this._jointMappedBuffers[this._jointMappedBufferIndices[t]].destroy();
                            this._jointMappedBuffers = void 0, this._jointMappedBufferIndices = void 0
                        }
                        this._indirectBuffer && (this._indirectBuffer.destroy(), this._indirectBuffer = null), this._handle && (mr(zo.get(this._handle, No.FLAT_BUFFER_ARRAY), br, Lo), zo.free(this._handle), this._handle = 0)
                    }, t.enableVertexIdChannel = function(e) {
                        if (!this._vertexIdChannel) {
                            var t = this.vertexBuffers.length,
                                n = this.attributes.length,
                                i = this._allocVertexIdBuffer(e);
                            this._vertexBuffers.push(i), this._attributes.push(new Ms("a_vertexId", Ea.R32F, !1, t)), this._iaInfo.attributes = this._attributes, this._iaInfo.vertexBuffers = this._vertexBuffers, this._vertexIdChannel = {
                                stream: t,
                                index: n
                            }
                        }
                    }, t._allocVertexIdBuffer = function(e) {
                        for (var t = 0 === this.vertexBuffers.length || 0 === this.vertexBuffers[0].stride ? 0 : this.vertexBuffers[0].size / this.vertexBuffers[0].stride, n = new Float32Array(t), i = 0; i < t; ++i) n[i] = i + .5;
                        var r = e.createBuffer(new gs(xa.VERTEX | xa.TRANSFER_DST, Ra.DEVICE, n.byteLength, n.BYTES_PER_ELEMENT));
                        return r.update(n), r
                    }, K(e, [{
                        key: "attributes",
                        get: function() {
                            return this._attributes
                        }
                    }, {
                        key: "vertexBuffers",
                        get: function() {
                            return this._vertexBuffers
                        }
                    }, {
                        key: "indexBuffer",
                        get: function() {
                            return this._indexBuffer
                        }
                    }, {
                        key: "indirectBuffer",
                        get: function() {
                            return this._indirectBuffer
                        }
                    }, {
                        key: "primitiveMode",
                        get: function() {
                            return this._primitiveMode
                        }
                    }, {
                        key: "geometricInfo",
                        get: function() {
                            if (this._geometricInfo) return this._geometricInfo;
                            if (void 0 === this.mesh) return {
                                positions: new Float32Array,
                                indices: new Uint8Array,
                                boundingBox: {
                                    min: En.ZERO,
                                    max: En.ZERO
                                }
                            };
                            if (void 0 === this.subMeshIdx) return {
                                positions: new Float32Array,
                                indices: new Uint8Array,
                                boundingBox: {
                                    min: En.ZERO,
                                    max: En.ZERO
                                }
                            };
                            var e = this.mesh,
                                t = this.subMeshIdx,
                                n = e.readAttribute(t, is.ATTR_POSITION),
                                i = e.readIndices(t),
                                r = new En,
                                o = new En,
                                a = this.attributes.find((function(e) {
                                    return e.name === is.ATTR_POSITION
                                }));
                            if (a) {
                                var s = tc[a.format].count;
                                2 === s ? (r.set(n[0], n[1], 0), o.set(n[0], n[1], 0)) : (r.set(n[0], n[1], n[2]), o.set(n[0], n[1], n[2]));
                                for (var c = 0; c < n.length; c += s) 2 === s ? (r.x = n[c] > r.x ? n[c] : r.x, r.y = n[c + 1] > r.y ? n[c + 1] : r.y, o.x = n[c] < o.x ? n[c] : o.x, o.y = n[c + 1] < o.y ? n[c + 1] : o.y) : (r.x = n[c] > r.x ? n[c] : r.x, r.y = n[c + 1] > r.y ? n[c + 1] : r.y, r.z = n[c + 2] > r.z ? n[c + 2] : r.z, o.x = n[c] < o.x ? n[c] : o.x, o.y = n[c + 1] < o.y ? n[c + 1] : o.y, o.z = n[c + 2] < o.z ? n[c + 2] : o.z)
                            }
                            return this._geometricInfo = {
                                positions: n,
                                indices: i,
                                boundingBox: {
                                    max: r,
                                    min: o
                                }
                            }, this._geometricInfo
                        }
                    }, {
                        key: "flatBuffers",
                        get: function() {
                            return this._flatBuffers
                        }
                    }, {
                        key: "jointMappedBuffers",
                        get: function() {
                            var e = this;
                            if (this._jointMappedBuffers) return this._jointMappedBuffers;
                            var t = this._jointMappedBuffers = [],
                                n = this._jointMappedBufferIndices = [];
                            if (!this.mesh || void 0 === this.subMeshIdx) return this._jointMappedBuffers = this.vertexBuffers;
                            var r, o, a = this.mesh.struct,
                                s = a.primitives[this.subMeshIdx];
                            if (!a.jointMaps || void 0 === s.jointMapIndex || !a.jointMaps[s.jointMapIndex]) return this._jointMappedBuffers = this.vertexBuffers;
                            for (var c = i.director.root.device, l = 0; l < s.vertexBundelIndices.length; l++) {
                                var u = a.vertexBundles[s.vertexBundelIndices[l]];
                                o = 0, r = Ea.UNKNOWN;
                                for (var h = 0; h < u.attributes.length; h++) {
                                    var _ = u.attributes[h];
                                    if (_.name === is.ATTR_JOINTS) {
                                        r = _.format;
                                        break
                                    }
                                    o += tc[_.format].size
                                }
                                r ? function() {
                                    var i = new Uint8Array(e.mesh.data.buffer, u.view.offset, u.view.length),
                                        h = new DataView(i.slice().buffer),
                                        _ = a.jointMaps[s.jointMapIndex];
                                    XR(h, (function(e) {
                                        return _.indexOf(e)
                                    }), r, o, u.view.length, u.view.stride, h);
                                    var f = c.createBuffer(new gs(xa.VERTEX | xa.TRANSFER_DST, Ra.DEVICE, u.view.length, u.view.stride));
                                    f.update(h.buffer), t.push(f), n.push(l)
                                }() : t.push(this.vertexBuffers[s.vertexBundelIndices[l]])
                            }
                            return this._vertexIdChannel && t.push(this._allocVertexIdBuffer(c)), t
                        }
                    }, {
                        key: "iaInfo",
                        get: function() {
                            return this._iaInfo
                        }
                    }, {
                        key: "handle",
                        get: function() {
                            return this._handle
                        }
                    }]), e
                }()),
                KR = new Array(16),
                ZR = null,
                QR = new Gn,
                JR = [Om.TOUCH_START.toString(), Om.TOUCH_MOVE.toString(), Om.TOUCH_END.toString(), Om.TOUCH_CANCEL.toString()],
                $R = [Om.MOUSE_DOWN.toString(), Om.MOUSE_ENTER.toString(), Om.MOUSE_MOVE.toString(), Om.MOUSE_LEAVE.toString(), Om.MOUSE_UP.toString(), Om.MOUSE_WHEEL.toString()];

            function ew(e, t) {
                var n = this.owner;
                return !(!n || !n._uiProps.uiTransformComp || (e.getUILocation(QR), !n._uiProps.uiTransformComp.isHit(QR, this) || (t.type = Om.TOUCH_START.toString(), t.touch = e, t.bubbles = !0, n.dispatchEvent(t), 0)))
            }

            function tw(e, t) {
                var n = this.owner;
                return !(!n || !n._uiProps.uiTransformComp || (t.type = Om.TOUCH_MOVE.toString(), t.touch = e, t.bubbles = !0, n.dispatchEvent(t), 0))
            }

            function nw(e, t) {
                var n = this.owner;
                n && n._uiProps.uiTransformComp && (e.getUILocation(QR), n._uiProps.uiTransformComp.isHit(QR, this) ? t.type = Om.TOUCH_END.toString() : t.type = Om.TOUCH_CANCEL.toString(), t.touch = e, t.bubbles = !0, n.dispatchEvent(t))
            }

            function iw(e, t) {
                var n = this.owner;
                n && n._uiProps.uiTransformComp && (t.type = Om.TOUCH_CANCEL.toString(), t.touch = e, t.bubbles = !0, n.dispatchEvent(t))
            }

            function rw(e) {
                var t = this.owner;
                t && t._uiProps.uiTransformComp && (QR = e.getUILocation(), t._uiProps.uiTransformComp.isHit(QR, this) && (e.type = Om.MOUSE_DOWN.toString(), e.bubbles = !0, t.dispatchEvent(e)))
            }

            function ow(e) {
                var t = this.owner;
                if (t && t._uiProps.uiTransformComp) {
                    if (QR = e.getUILocation(), t._uiProps.uiTransformComp.isHit(QR, this)) this._previousIn || (ZR && ZR.eventProcessor.mouseListener && (e.type = Om.MOUSE_LEAVE, ZR.dispatchEvent(e), ZR.eventProcessor.mouseListener && (ZR.eventProcessor.mouseListener._previousIn = !1)), ZR = t, e.type = Om.MOUSE_ENTER.toString(), t.dispatchEvent(e), this._previousIn = !0), e.type = Om.MOUSE_MOVE.toString(), e.bubbles = !0, t.dispatchEvent(e);
                    else {
                        if (!this._previousIn) return;
                        e.type = Om.MOUSE_LEAVE.toString(), t.dispatchEvent(e), this._previousIn = !1, ZR = null
                    }
                    e.propagationStopped = !0
                }
            }

            function aw(e) {
                var t = this.owner;
                t && t._uiProps.uiTransformComp && (QR = e.getUILocation(), t._uiProps.uiTransformComp.isHit(QR, this) && (e.type = Om.MOUSE_UP.toString(), e.bubbles = !0, t.dispatchEvent(e), e.propagationStopped = !0))
            }

            function sw(e) {
                var t = this.owner;
                t && t._uiProps.uiTransformComp && (QR = e.getUILocation(), t._uiProps.uiTransformComp.isHit(QR, this) && (e.type = Om.MOUSE_WHEEL.toString(), e.bubbles = !0, t.dispatchEvent(e), e.propagationStopped = !0))
            }

            function cw(e, t) {
                if (t) {
                    for (var n = 0, i = [], r = e; r && Yv.isNode(r); r = r.parent, ++n) {
                        var o = r.getComponent(t);
                        if (o) {
                            var a = {
                                index: n,
                                comp: o
                            };
                            i ? i.push(a) : i = [a]
                        }
                    }
                    return i.length > 0 ? i : null
                }
                return null
            }

            function lw(e, t) {
                if (!e._persistNode) {
                    if (e.eventProcessor.bubblingTargets)
                        for (var n = 0; n < t.length; ++n)
                            if (e.eventProcessor.bubblingTargets.hasEventListener(t[n])) return !0;
                    if (e.eventProcessor.capturingTargets)
                        for (var i = 0; i < t.length; ++i)
                            if (e.eventProcessor.capturingTargets.hasEventListener(t[i])) return !0;
                    return !1
                }
                return !0
            }
            var uw, hw = function() {
                function e(e) {
                    this.bubblingTargets = null, this.capturingTargets = null, this.touchListener = null, this.mouseListener = null, this._node = void 0, this._node = e
                }
                var t = e.prototype;
                return t.reattach = function() {
                    var t;
                    this.node.walk((function(n) {
                        t || (t = cw(n, e._comp)), n.eventProcessor.touchListener && (n.eventProcessor.touchListener.mask = t), n.eventProcessor.mouseListener && (n.eventProcessor.mouseListener.mask = t)
                    }))
                }, t.destroy = function() {
                    ZR === this._node && (ZR = null), (this.touchListener || this.mouseListener) && (Vm.removeListeners(this._node), this.touchListener && (this.touchListener.owner = null, this.touchListener.mask = null, this.touchListener = null), this.mouseListener && (this.mouseListener.owner = null, this.mouseListener.mask = null, this.mouseListener = null)), this.capturingTargets && this.capturingTargets.clear(), this.bubblingTargets && this.bubblingTargets.clear()
                }, t.on = function(e, t, n, i) {
                    return this._checknSetupSysEvent(e) ? this._onDispatch(e, t, n, i) : (this.bubblingTargets || (this.bubblingTargets = new hi), this.bubblingTargets.on(e, t, n))
                }, t.once = function(e, t, n, i) {
                    var r, o = this;
                    (r = this._checknSetupSysEvent(e) && i ? this.capturingTargets = this.capturingTargets || new hi : this.bubblingTargets = this.bubblingTargets || new hi).on(e, t, n, !0), r.on(e, (function() {
                        o.off(e, t, n)
                    }), void 0, !0)
                }, t.off = function(e, t, n, i) {
                    var r = -1 !== JR.indexOf(e),
                        o = !r && -1 !== $R.indexOf(e);
                    r || o ? (this._offDispatch(e, t, n, i), r ? this.touchListener && !lw(this._node, JR) && (Vm.removeListener(this.touchListener), this.touchListener = null) : o && this.mouseListener && !lw(this._node, $R) && (Vm.removeListener(this.mouseListener), this.mouseListener = null)) : this.bubblingTargets && this.bubblingTargets.off(e, t, n)
                }, t.emit = function(e, t, n, i, r, o) {
                    this.bubblingTargets && this.bubblingTargets.emit(e, t, n, i, r, o)
                }, t.dispatchEvent = function(e) {
                    ! function(e, t) {
                        var n, i = 0;
                        for (t.target = e, KR.length = 0, e.eventProcessor.getCapturingTargets(t.type, KR), t.eventPhase = 1, i = KR.length - 1; i >= 0; --i)
                            if ((n = KR[i]).eventProcessor.capturingTargets && (t.currentTarget = n, n.eventProcessor.capturingTargets.emit(t.type, t, KR), t.propagationStopped)) return void(KR.length = 0);
                        if (KR.length = 0, t.eventPhase = 2, t.currentTarget = e, e.eventProcessor.capturingTargets && e.eventProcessor.capturingTargets.emit(t.type, t), !t.propagationImmediateStopped && e.eventProcessor.bubblingTargets && e.eventProcessor.bubblingTargets.emit(t.type, t), !t.propagationStopped && t.bubbles)
                            for (e.eventProcessor.getBubblingTargets(t.type, KR), t.eventPhase = 3, i = 0; i < KR.length; ++i)
                                if ((n = KR[i]).eventProcessor.bubblingTargets && (t.currentTarget = n, n.eventProcessor.bubblingTargets.emit(t.type, t), t.propagationStopped)) return void(KR.length = 0);
                        KR.length = 0
                    }(this._node, e), KR.length = 0
                }, t.hasEventListener = function(e, t, n) {
                    var i = !1;
                    return this.bubblingTargets && (i = this.bubblingTargets.hasEventListener(e, t, n)), !i && this.capturingTargets && (i = this.capturingTargets.hasEventListener(e, t, n)), i
                }, t.targetOff = function(e) {
                    this.capturingTargets && this.capturingTargets.removeAll(e), this.bubblingTargets && this.bubblingTargets.removeAll(e), this.touchListener && !lw(this.node, JR) && (Vm.removeListener(this.touchListener), this.touchListener = null), this.mouseListener && !lw(this.node, $R) && (Vm.removeListener(this.mouseListener), this.mouseListener = null)
                }, t.getCapturingTargets = function(e, t) {
                    for (var n = this._node.parent; n;) n.eventProcessor.capturingTargets && n.eventProcessor.capturingTargets.hasEventListener(e) && t.push(n), n = n.parent
                }, t.getBubblingTargets = function(e, t) {
                    for (var n = this._node.parent; n;) n.eventProcessor.bubblingTargets && n.eventProcessor.bubblingTargets.hasEventListener(e) && t.push(n), n = n.parent
                }, t._checknSetupSysEvent = function(t) {
                    var n = this,
                        r = !1,
                        o = !1;
                    return -1 !== JR.indexOf(t) ? (this.touchListener || (this.touchListener = i.EventListener.create({
                        event: i.EventListener.TOUCH_ONE_BY_ONE,
                        swallowTouches: !0,
                        owner: this._node,
                        mask: cw(this._node, e._comp),
                        onTouchBegan: ew,
                        onTouchMoved: tw,
                        onTouchEnded: nw,
                        onTouchCancelled: iw
                    }), Vm.addListener(this.touchListener, this._node), r = !0), o = !0) : -1 !== $R.indexOf(t) && (this.mouseListener || (this.mouseListener = i.EventListener.create({
                        event: i.EventListener.MOUSE,
                        _previousIn: !1,
                        owner: this._node,
                        mask: cw(this._node, e._comp),
                        onMouseDown: rw,
                        onMouseMove: ow,
                        onMouseUp: aw,
                        onMouseScroll: sw
                    }), Vm.addListener(this.mouseListener, this._node), r = !0), o = !0), r && !this._node.activeInHierarchy && i.director.getScheduler().schedule((function() {
                        n._node.activeInHierarchy || Vm.pauseTarget(n._node)
                    }), this._node, 0, 0, 0, !1), o
                }, t._onDispatch = function(e, t, n, i) {
                    if ("boolean" == typeof n ? (i = n, n = void 0) : i = !!i, t) {
                        var r = null;
                        return (r = i ? this.capturingTargets = this.capturingTargets || new hi : this.bubblingTargets = this.bubblingTargets || new hi).hasEventListener(e, t, n) || r.on(e, t, n), t
                    }
                    b(6800)
                }, t._offDispatch = function(e, t, n, i) {
                    if ("boolean" == typeof n ? (i = n, n = void 0) : i = !!i, t) {
                        var r = i ? this.capturingTargets : this.bubblingTargets;
                        r && r.off(e, t, n)
                    } else this.capturingTargets && this.capturingTargets.removeAll(e), this.bubblingTargets && this.bubblingTargets.removeAll(e)
                }, K(e, [{
                    key: "node",
                    get: function() {
                        return this._node
                    }
                }]), e
            }();
            hw._comp = null, i.NodeEventProcessor = hw, U(pg.prototype, "BaseNode", [{
                name: "childrenCount",
                newName: "children.length",
                customGetter: function() {
                    return this.children.length
                }
            }]), U(Yv.prototype, "Node", [{
                name: "width",
                targetName: "node.getComponent(UITransform)",
                customGetter: function() {
                    return this._uiProps.uiTransformComp.width
                },
                customSetter: function(e) {
                    this._uiProps.uiTransformComp.width = e
                }
            }, {
                name: "height",
                targetName: "node.getComponent(UITransform)",
                customGetter: function() {
                    return this._uiProps.uiTransformComp.height
                },
                customSetter: function(e) {
                    this._uiProps.uiTransformComp.height = e
                }
            }, {
                name: "anchorX",
                targetName: "node.getComponent(UITransform)",
                customGetter: function() {
                    return this._uiProps.uiTransformComp.anchorX
                },
                customSetter: function(e) {
                    this._uiProps.uiTransformComp.anchorX = e
                }
            }, {
                name: "anchorY",
                targetName: "node.getComponent(UITransform)",
                customGetter: function() {
                    return this._uiProps.uiTransformComp.anchorY
                },
                customSetter: function(e) {
                    this._uiProps.uiTransformComp.anchorY = e
                }
            }, {
                name: "getAnchorPoint",
                targetName: "node.getComponent(UITransform)",
                customFunction: function(e) {
                    return e || (e = new Gn), e.set(this._uiProps.uiTransformComp.anchorPoint), e
                }
            }, {
                name: "setAnchorPoint",
                targetName: "node.getComponent(UITransform)",
                customFunction: function(e, t) {
                    this._uiProps.uiTransformComp.setAnchorPoint(e, t)
                }
            }, {
                name: "getContentSize",
                targetName: "node.getComponent(UITransform)",
                customFunction: function(e) {
                    return e || (e = new Xn), e.set(this._uiProps.uiTransformComp.contentSize), e
                }
            }, {
                name: "setContentSize",
                targetName: "node.getComponent(UITransform)",
                customFunction: function(e, t) {
                    "number" == typeof e ? this._uiProps.uiTransformComp.setContentSize(e, t) : this._uiProps.uiTransformComp.setContentSize(e)
                }
            }]), G(Yv.prototype, "Node.prototype", [{
                name: "addLayer"
            }, {
                name: "removeLayer"
            }]), G(Pu, "Layers", [{
                name: "All"
            }, {
                name: "RaycastMask"
            }, {
                name: "check"
            }]), U(Pu, "Layers", [{
                name: "Default",
                newName: "DEFAULT",
                target: Pu.Enum,
                targetName: "Layers.Enum"
            }, {
                name: "Always",
                newName: "ALWAYS",
                target: Pu.Enum,
                targetName: "Layers.Enum"
            }, {
                name: "IgnoreRaycast",
                newName: "IGNORE_RAYCAST",
                target: Pu.Enum,
                targetName: "Layers.Enum"
            }, {
                name: "Gizmos",
                newName: "GIZMOS",
                target: Pu.Enum,
                targetName: "Layers.Enum"
            }, {
                name: "Editor",
                newName: "EDITOR",
                target: Pu.Enum,
                targetName: "Layers.Enum"
            }, {
                name: "UI",
                newName: "UI_3D",
                target: Pu.Enum,
                targetName: "Layers.Enum"
            }, {
                name: "UI2D",
                newName: "UI_2D",
                target: Pu.Enum,
                targetName: "Layers.Enum"
            }, {
                name: "SceneGizmo",
                newName: "SCENE_GIZMO",
                target: Pu.Enum,
                targetName: "Layers.Enum"
            }, {
                name: "makeInclusiveMask",
                newName: "makeMaskInclude",
                target: Pu,
                targetName: "Layers"
            }, {
                name: "makeExclusiveMask",
                newName: "makeMaskExclude",
                target: Pu,
                targetName: "Layers"
            }]), G(Pu.Enum, "Layers.Enum", [{
                name: "ALWAYS"
            }]), G(Pu.BitMask, "Layers.BitMask", [{
                name: "ALWAYS"
            }]);
            var _w, fw, dw, pw, mw, gw, vw, yw, Sw, Ew, Tw, Aw, xw, Cw, bw, Rw, ww, Iw, Pw, Ow, Dw, Nw, Mw, Lw, Bw, Fw, zw, Uw, Gw, Hw, kw, Vw, Ww, jw, qw, Xw, Yw, Kw, Zw, Qw, Jw, $w, eI, tI, nI, iI, rI, oI, aI, sI, cI, lI, uI, hI, _I, fI, dI, pI, mI, gI, vI, yI, SI, EI, TI, AI, xI, CI, bI, RI, wI, II, PI, OI, DI, NI, MI, LI, BI, FI, zI, UI, GI, HI, kI, VI, WI, jI, qI, XI, YI, KI, ZI, QI, JI, $I, eP, tP, nP, iP, rP, oP, aP, sP, cP, lP, uP, hP, _P, fP, dP, pP, mP, gP, vP, yP, SP, EP, TP, AP = ni.Flags.HideInHierarchy,
                xP = ni.Flags.DontSave,
                CP = e("PrivateNode", A_("cc.PrivateNode")(uw = function(e) {
                    function t(t) {
                        var n;
                        return x(12003, (n = e.call(this, t) || this).name), n.hideFlags |= xP | AP, n
                    }
                    return Q(t, e), t
                }(Yv)) || uw);
            i.PrivateNode = CP;
            var bP = new En(0, 1, 0),
                RP = new En,
                wP = new wn,
                IP = (_w = A_("cc.AmbientInfo"), fw = ef(Rt), _w((yw = function() {
                    function e() {
                        ne(this, "_skyColor", mw, this), ne(this, "_skyIllum", gw, this), ne(this, "_groundAlbedo", vw, this), this._resource = null
                    }
                    return e.prototype.activate = function(e) {
                        this._resource = e, this._resource.initialize(this)
                    }, K(e, [{
                        key: "skyColor",
                        get: function() {
                            return this._skyColor
                        },
                        set: function(e) {
                            this._skyColor.set(e), this._resource && (this._resource.skyColor = this._skyColor)
                        }
                    }, {
                        key: "skyIllum",
                        get: function() {
                            return this._skyIllum
                        },
                        set: function(e) {
                            this._skyIllum = e, this._resource && (this._resource.skyIllum = this.skyIllum)
                        }
                    }, {
                        key: "groundAlbedo",
                        get: function() {
                            return this._groundAlbedo
                        },
                        set: function(e) {
                            this._groundAlbedo.set(e), this._resource && (this._resource.groundAlbedo = this._groundAlbedo)
                        }
                    }]), e
                }(), mw = ie((pw = yw).prototype, "_skyColor", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return new yn(51, 128, 204, 1)
                    }
                }), gw = ie(pw.prototype, "_skyIllum", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return Ko.SKY_ILLUM
                    }
                }), vw = ie(pw.prototype, "_groundAlbedo", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return new yn(51, 51, 51, 255)
                    }
                }), ie(pw.prototype, "skyColor", [F_], Object.getOwnPropertyDescriptor(pw.prototype, "skyColor"), pw.prototype), ie(pw.prototype, "skyIllum", [F_, fw], Object.getOwnPropertyDescriptor(pw.prototype, "skyIllum"), pw.prototype), ie(pw.prototype, "groundAlbedo", [F_], Object.getOwnPropertyDescriptor(pw.prototype, "groundAlbedo"), pw.prototype), dw = pw)) || dw);
            i.AmbientInfo = IP;
            var PP = (Sw = A_("cc.SkyboxInfo"), Ew = ef(Sp), Tw = ef(Sp), Sw((Iw = function() {
                function e() {
                    ne(this, "_envmap", Cw, this), ne(this, "_isRGBE", bw, this), ne(this, "_enabled", Rw, this), ne(this, "_useIBL", ww, this), this._resource = null
                }
                return e.prototype.activate = function(e) {
                    this._resource = e, this._resource.initialize(this), this._resource.activate()
                }, K(e, [{
                    key: "enabled",
                    get: function() {
                        return this._enabled
                    },
                    set: function(e) {
                        this._enabled !== e && (this._enabled = e, this._resource && (this._resource.enabled = this._enabled))
                    }
                }, {
                    key: "useIBL",
                    get: function() {
                        return this._useIBL
                    },
                    set: function(e) {
                        this._useIBL = e, this._resource && (this._resource.useIBL = this._useIBL)
                    }
                }, {
                    key: "envmap",
                    get: function() {
                        return this._envmap
                    },
                    set: function(e) {
                        this._envmap = e, this._resource && (this._resource.envmap = this._envmap)
                    }
                }, {
                    key: "isRGBE",
                    get: function() {
                        return this._isRGBE
                    },
                    set: function(e) {
                        this._isRGBE = e, this._resource && (this._resource.isRGBE = this._isRGBE)
                    }
                }]), e
            }(), Cw = ie((xw = Iw).prototype, "_envmap", [Ew], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return null
                }
            }), bw = ie(xw.prototype, "_isRGBE", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return !1
                }
            }), Rw = ie(xw.prototype, "_enabled", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return !1
                }
            }), ww = ie(xw.prototype, "_useIBL", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return !1
                }
            }), ie(xw.prototype, "enabled", [F_], Object.getOwnPropertyDescriptor(xw.prototype, "enabled"), xw.prototype), ie(xw.prototype, "useIBL", [F_], Object.getOwnPropertyDescriptor(xw.prototype, "useIBL"), xw.prototype), ie(xw.prototype, "envmap", [F_, Tw], Object.getOwnPropertyDescriptor(xw.prototype, "envmap"), xw.prototype), ie(xw.prototype, "isRGBE", [F_], Object.getOwnPropertyDescriptor(xw.prototype, "isRGBE"), xw.prototype), Aw = xw)) || Aw);
            i.SkyboxInfo = PP;
            var OP = (Pw = A_("cc.FogInfo"), Ow = ef(RE), Dw = z_(), Nw = ef(Rt), Mw = H_(), Lw = W_(), Bw = q_(), Fw = z_(), zw = ef(Rt), Uw = W_(), Gw = q_(), Hw = z_(), kw = ef(Rt), Vw = W_(), Ww = q_(), jw = z_(), qw = ef(Rt), Xw = k_(), Yw = W_(), Kw = q_(), Zw = z_(), Qw = ef(Rt), Jw = W_(), $w = q_(), eI = z_(), tI = ef(Rt), nI = W_(), iI = q_(), Pw((mI = pI = function() {
                    function e() {
                        ne(this, "_type", aI, this), ne(this, "_fogColor", sI, this), ne(this, "_enabled", cI, this), ne(this, "_fogDensity", lI, this), ne(this, "_fogStart", uI, this), ne(this, "_fogEnd", hI, this), ne(this, "_fogAtten", _I, this), ne(this, "_fogTop", fI, this), ne(this, "_fogRange", dI, this), this._resource = null
                    }
                    return e.prototype.activate = function(e) {
                        this._resource = e, this._resource.initialize(this), this._resource.activate()
                    }, K(e, [{
                        key: "enabled",
                        get: function() {
                            return this._enabled
                        },
                        set: function(e) {
                            this._enabled !== e && (this._enabled = e, this._resource && (this._resource.enabled = e, e && (this._resource.type = this._type)))
                        }
                    }, {
                        key: "fogColor",
                        get: function() {
                            return this._fogColor
                        },
                        set: function(e) {
                            this._fogColor.set(e), this._resource && (this._resource.fogColor = this._fogColor)
                        }
                    }, {
                        key: "type",
                        get: function() {
                            return this._type
                        },
                        set: function(e) {
                            this._type = e, this._resource && (this._resource.type = e)
                        }
                    }, {
                        key: "fogDensity",
                        get: function() {
                            return this._fogDensity
                        },
                        set: function(e) {
                            this._fogDensity = e, this._resource && (this._resource.fogDensity = e)
                        }
                    }, {
                        key: "fogStart",
                        get: function() {
                            return this._fogStart
                        },
                        set: function(e) {
                            this._fogStart = e, this._resource && (this._resource.fogStart = e)
                        }
                    }, {
                        key: "fogEnd",
                        get: function() {
                            return this._fogEnd
                        },
                        set: function(e) {
                            this._fogEnd = e, this._resource && (this._resource.fogEnd = e)
                        }
                    }, {
                        key: "fogAtten",
                        get: function() {
                            return this._fogAtten
                        },
                        set: function(e) {
                            this._fogAtten = e, this._resource && (this._resource.fogAtten = e)
                        }
                    }, {
                        key: "fogTop",
                        get: function() {
                            return this._fogTop
                        },
                        set: function(e) {
                            this._fogTop = e, this._resource && (this._resource.fogTop = e)
                        }
                    }, {
                        key: "fogRange",
                        get: function() {
                            return this._fogRange
                        },
                        set: function(e) {
                            this._fogRange = e, this._resource && (this._resource.fogRange = e)
                        }
                    }]), e
                }(), pI.FogType = RE, aI = ie((oI = mI).prototype, "_type", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return RE.LINEAR
                    }
                }), sI = ie(oI.prototype, "_fogColor", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return new yn("#C8C8C8")
                    }
                }), cI = ie(oI.prototype, "_enabled", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return !1
                    }
                }), lI = ie(oI.prototype, "_fogDensity", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return .3
                    }
                }), uI = ie(oI.prototype, "_fogStart", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return .5
                    }
                }), hI = ie(oI.prototype, "_fogEnd", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 300
                    }
                }), _I = ie(oI.prototype, "_fogAtten", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 5
                    }
                }), fI = ie(oI.prototype, "_fogTop", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 1.5
                    }
                }), dI = ie(oI.prototype, "_fogRange", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 1.2
                    }
                }), ie(oI.prototype, "enabled", [F_], Object.getOwnPropertyDescriptor(oI.prototype, "enabled"), oI.prototype), ie(oI.prototype, "fogColor", [F_], Object.getOwnPropertyDescriptor(oI.prototype, "fogColor"), oI.prototype), ie(oI.prototype, "type", [F_, Ow], Object.getOwnPropertyDescriptor(oI.prototype, "type"), oI.prototype), ie(oI.prototype, "fogDensity", [Dw, Nw, Mw, Lw, j_, Bw], Object.getOwnPropertyDescriptor(oI.prototype, "fogDensity"), oI.prototype), ie(oI.prototype, "fogStart", [Fw, zw, Uw, Gw], Object.getOwnPropertyDescriptor(oI.prototype, "fogStart"), oI.prototype), ie(oI.prototype, "fogEnd", [Hw, kw, Vw, Ww], Object.getOwnPropertyDescriptor(oI.prototype, "fogEnd"), oI.prototype), ie(oI.prototype, "fogAtten", [jw, qw, Xw, Yw, Kw], Object.getOwnPropertyDescriptor(oI.prototype, "fogAtten"), oI.prototype), ie(oI.prototype, "fogTop", [Zw, Qw, Jw, $w], Object.getOwnPropertyDescriptor(oI.prototype, "fogTop"), oI.prototype), ie(oI.prototype, "fogRange", [eI, tI, nI, iI], Object.getOwnPropertyDescriptor(oI.prototype, "fogRange"), oI.prototype), rI = oI)) || rI),
                DP = (gI = A_("cc.ShadowsInfo"), vI = ef(iE), yI = z_(), SI = ef(Rt), EI = z_(), TI = ef(rE), AI = z_(), xI = ef(bt), CI = z_(), bI = ef(Rt), RI = z_(), wI = ef(wt), II = z_(), PI = ef(wt), OI = z_(), DI = ef(wt), NI = z_(), MI = ef(Rt), LI = z_(), BI = ef(wt), FI = z_(), zI = ef(Rt), UI = z_(), GI = ef(Rt), HI = z_(), kI = ef(Rt), VI = z_(), WI = z_(), jI = ef(Rt), qI = z_(), gI((fP = function() {
                    function e() {
                        ne(this, "_type", KI, this), ne(this, "_enabled", ZI, this), ne(this, "_normal", QI, this), ne(this, "_distance", JI, this), ne(this, "_shadowColor", $I, this), ne(this, "_autoAdapt", eP, this), ne(this, "_pcf", tP, this), ne(this, "_bias", nP, this), ne(this, "_packing", iP, this), ne(this, "_linear", rP, this), ne(this, "_selfShadow", oP, this), ne(this, "_normalBias", aP, this), ne(this, "_near", sP, this), ne(this, "_far", cP, this), ne(this, "_aspect", lP, this), ne(this, "_orthoSize", uP, this), ne(this, "_maxReceived", hP, this), ne(this, "_size", _P, this), this._resource = null
                    }
                    var t = e.prototype;
                    return t.setPlaneFromNode = function(e) {
                        e.getWorldRotation(wP), this.normal = En.transformQuat(RP, bP, wP), e.getWorldPosition(RP), this.distance = En.dot(this._normal, RP)
                    }, t.activate = function(e) {
                        this._resource = e, this._resource.initialize(this), this._resource.activate()
                    }, K(e, [{
                        key: "enabled",
                        get: function() {
                            return this._enabled
                        },
                        set: function(e) {
                            this._enabled !== e && (this._enabled = e, this._resource && (this._resource.enabled = e, e && (this._resource.type = this._type)))
                        }
                    }, {
                        key: "type",
                        get: function() {
                            return this._type
                        },
                        set: function(e) {
                            this._type = e, this._resource && (this._resource.type = e)
                        }
                    }, {
                        key: "shadowColor",
                        get: function() {
                            return this._shadowColor
                        },
                        set: function(e) {
                            this._shadowColor.set(e), this._resource && (this._resource.shadowColor = e)
                        }
                    }, {
                        key: "normal",
                        get: function() {
                            return this._normal
                        },
                        set: function(e) {
                            En.copy(this._normal, e), this._resource && (this._resource.normal = e)
                        }
                    }, {
                        key: "distance",
                        get: function() {
                            return this._distance
                        },
                        set: function(e) {
                            this._distance = e, this._resource && (this._resource.distance = e)
                        }
                    }, {
                        key: "pcf",
                        get: function() {
                            return this._pcf
                        },
                        set: function(e) {
                            this._pcf = e, this._resource && (this._resource.pcf = e)
                        }
                    }, {
                        key: "maxReceived",
                        get: function() {
                            return this._maxReceived
                        },
                        set: function(e) {
                            this._maxReceived = e, this._resource && (this._resource.maxReceived = e)
                        }
                    }, {
                        key: "bias",
                        get: function() {
                            return this._bias
                        },
                        set: function(e) {
                            this._bias = e, this._resource && (this._resource.bias = e)
                        }
                    }, {
                        key: "packing",
                        get: function() {
                            return this._packing
                        },
                        set: function(e) {
                            this._packing = e, e && (this._linear = !this._linear && this._linear, this._resource && (this._resource.linear = this._linear)), this._resource && (this._resource.packing = e, this._resource.shadowMapDirty = !0)
                        }
                    }, {
                        key: "linear",
                        get: function() {
                            return this._linear
                        },
                        set: function(e) {
                            this._linear = e, e && (this._packing = !this._packing && this._packing, this._resource && (this._resource.packing = this._packing)), this._resource && (this._resource.linear = e)
                        }
                    }, {
                        key: "selfShadow",
                        get: function() {
                            return this._selfShadow
                        },
                        set: function(e) {
                            this._selfShadow = e, this._resource && (this._resource.selfShadow = e)
                        }
                    }, {
                        key: "normalBias",
                        get: function() {
                            return this._normalBias
                        },
                        set: function(e) {
                            this._normalBias = e, this._resource && (this._resource.normalBias = e)
                        }
                    }, {
                        key: "autoAdapt",
                        get: function() {
                            return this._autoAdapt
                        },
                        set: function(e) {
                            this._autoAdapt = e, this._resource && (this._resource.autoAdapt = e)
                        }
                    }, {
                        key: "near",
                        get: function() {
                            return this._near
                        },
                        set: function(e) {
                            this._near = e, this._resource && (this._resource.near = e)
                        }
                    }, {
                        key: "far",
                        get: function() {
                            return this._far
                        },
                        set: function(e) {
                            this._far = e, this._resource && (this._resource.far = e)
                        }
                    }, {
                        key: "orthoSize",
                        get: function() {
                            return this._orthoSize
                        },
                        set: function(e) {
                            this._orthoSize = e, this._resource && (this._resource.orthoSize = e)
                        }
                    }, {
                        key: "shadowMapSize",
                        get: function() {
                            return this._size
                        },
                        set: function(e) {
                            this._size.set(e), this._resource && (this._resource.size = e, this._resource.shadowMapDirty = !0)
                        }
                    }, {
                        key: "aspect",
                        get: function() {
                            return this._aspect
                        },
                        set: function(e) {
                            this._aspect = e, this._resource && (this._resource.aspect = e)
                        }
                    }]), e
                }(), KI = ie((YI = fP).prototype, "_type", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return iE.Planar
                    }
                }), ZI = ie(YI.prototype, "_enabled", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return !1
                    }
                }), QI = ie(YI.prototype, "_normal", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return new En(0, 1, 0)
                    }
                }), JI = ie(YI.prototype, "_distance", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 0
                    }
                }), $I = ie(YI.prototype, "_shadowColor", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return new yn(0, 0, 0, 76)
                    }
                }), eP = ie(YI.prototype, "_autoAdapt", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return !0
                    }
                }), tP = ie(YI.prototype, "_pcf", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return rE.HARD
                    }
                }), nP = ie(YI.prototype, "_bias", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 1e-5
                    }
                }), iP = ie(YI.prototype, "_packing", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return !1
                    }
                }), rP = ie(YI.prototype, "_linear", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return !0
                    }
                }), oP = ie(YI.prototype, "_selfShadow", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return !1
                    }
                }), aP = ie(YI.prototype, "_normalBias", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 0
                    }
                }), sP = ie(YI.prototype, "_near", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 1
                    }
                }), cP = ie(YI.prototype, "_far", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 30
                    }
                }), lP = ie(YI.prototype, "_aspect", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 1
                    }
                }), uP = ie(YI.prototype, "_orthoSize", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 5
                    }
                }), hP = ie(YI.prototype, "_maxReceived", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 4
                    }
                }), _P = ie(YI.prototype, "_size", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return new Gn(512, 512)
                    }
                }), ie(YI.prototype, "enabled", [F_], Object.getOwnPropertyDescriptor(YI.prototype, "enabled"), YI.prototype), ie(YI.prototype, "type", [F_, vI], Object.getOwnPropertyDescriptor(YI.prototype, "type"), YI.prototype), ie(YI.prototype, "shadowColor", [F_], Object.getOwnPropertyDescriptor(YI.prototype, "shadowColor"), YI.prototype), ie(YI.prototype, "normal", [yI], Object.getOwnPropertyDescriptor(YI.prototype, "normal"), YI.prototype), ie(YI.prototype, "distance", [SI, EI], Object.getOwnPropertyDescriptor(YI.prototype, "distance"), YI.prototype), ie(YI.prototype, "pcf", [TI, AI], Object.getOwnPropertyDescriptor(YI.prototype, "pcf"), YI.prototype), ie(YI.prototype, "maxReceived", [xI, CI], Object.getOwnPropertyDescriptor(YI.prototype, "maxReceived"), YI.prototype), ie(YI.prototype, "bias", [bI, RI], Object.getOwnPropertyDescriptor(YI.prototype, "bias"), YI.prototype), ie(YI.prototype, "packing", [wI, II], Object.getOwnPropertyDescriptor(YI.prototype, "packing"), YI.prototype), ie(YI.prototype, "linear", [PI, OI], Object.getOwnPropertyDescriptor(YI.prototype, "linear"), YI.prototype), ie(YI.prototype, "selfShadow", [DI, NI], Object.getOwnPropertyDescriptor(YI.prototype, "selfShadow"), YI.prototype), ie(YI.prototype, "normalBias", [MI, LI], Object.getOwnPropertyDescriptor(YI.prototype, "normalBias"), YI.prototype), ie(YI.prototype, "autoAdapt", [BI, FI], Object.getOwnPropertyDescriptor(YI.prototype, "autoAdapt"), YI.prototype), ie(YI.prototype, "near", [zI, UI], Object.getOwnPropertyDescriptor(YI.prototype, "near"), YI.prototype), ie(YI.prototype, "far", [GI, HI], Object.getOwnPropertyDescriptor(YI.prototype, "far"), YI.prototype), ie(YI.prototype, "orthoSize", [kI, VI], Object.getOwnPropertyDescriptor(YI.prototype, "orthoSize"), YI.prototype), ie(YI.prototype, "shadowMapSize", [WI], Object.getOwnPropertyDescriptor(YI.prototype, "shadowMapSize"), YI.prototype), ie(YI.prototype, "aspect", [jI, qI], Object.getOwnPropertyDescriptor(YI.prototype, "aspect"), YI.prototype), XI = YI)) || XI);
            i.ShadowsInfo = DP;
            var NP, MP, LP, BP, FP = (dP = A_("cc.SceneGlobals"), pP = ef(PP), dP((TP = function() {
                function e() {
                    ne(this, "ambient", vP, this), ne(this, "shadows", yP, this), ne(this, "_skybox", SP, this), ne(this, "fog", EP, this)
                }
                return e.prototype.activate = function() {
                    var e = i.director.root.pipeline.pipelineSceneData;
                    this.ambient.activate(e.ambient), this.skybox.activate(e.skybox), this.shadows.activate(e.shadows), this.fog.activate(e.fog)
                }, K(e, [{
                    key: "skybox",
                    get: function() {
                        return this._skybox
                    },
                    set: function(e) {
                        this._skybox = e
                    }
                }]), e
            }(), vP = ie((gP = TP).prototype, "ambient", [w_, F_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return new IP
                }
            }), yP = ie(gP.prototype, "shadows", [w_, F_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return new DP
                }
            }), SP = ie(gP.prototype, "_skybox", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return new PP
                }
            }), EP = ie(gP.prototype, "fog", [F_, w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return new OP
                }
            }), ie(gP.prototype, "skybox", [F_, pP], Object.getOwnPropertyDescriptor(gP.prototype, "skybox"), gP.prototype), mP = gP)) || mP);
            i.SceneGlobals = FP;
            var zP = e("Scene", A_("cc.Scene")((ie((MP = function(e) {
                Q(n, e);
                var t = n.prototype;

                function n(t) {
                    var n;
                    return ne(n = e.call(this, t) || this, "autoReleaseAssets", LP, $(n)), ne(n, "_globals", BP, $(n)), n._renderScene = null, n.dependAssets = null, n._inited = void 0, n._prefabSyncedInLiveReload = !1, n._pos = En.ZERO, n._rot = wn.IDENTITY, n._scale = En.ONE, n._mat = Bn.IDENTITY, n._dirtyFlags = 0, n._activeInHierarchy = !1, i.director && i.director.root && (n._renderScene = i.director.root.createScene({})), n._inited = !i.game || !i.game._isCloning, n
                }
                return t._updateScene = function() {
                    this._scene = this
                }, t.destroy = function() {
                    var e = ni.prototype.destroy.call(this);
                    if (e)
                        for (var t = this._children, n = 0; n < t.length; ++n) t[n].active = !1;
                    return i.director.root.destroyScene(this._renderScene), this._active = !1, this._activeInHierarchy = !1, e
                }, t.addComponent = function() {
                    throw new Error(P(3822))
                }, t._onHierarchyChanged = function() {}, t._onBatchCreated = function(t) {
                    e.prototype._onBatchCreated.call(this, t);
                    for (var n = this._children.length, i = 0; i < n; ++i) this.children[i]._siblingIndex = i, this._children[i]._onBatchCreated(t);
                    Ag(this)
                }, t.getPosition = function(e) {
                    return En.copy(e || new En, En.ZERO)
                }, t.getRotation = function(e) {
                    return wn.copy(e || new wn, wn.IDENTITY)
                }, t.getScale = function(e) {
                    return En.copy(e || new En, En.ONE)
                }, t.getWorldPosition = function(e) {
                    return En.copy(e || new En, En.ZERO)
                }, t.getWorldRotation = function(e) {
                    return wn.copy(e || new wn, wn.IDENTITY)
                }, t.getWorldScale = function(e) {
                    return En.copy(e || new En, En.ONE)
                }, t.getWorldMatrix = function(e) {
                    return Bn.copy(e || new Bn, Bn.IDENTITY)
                }, t.getWorldRS = function(e) {
                    return Bn.copy(e || new Bn, Bn.IDENTITY)
                }, t.getWorldRT = function(e) {
                    return Bn.copy(e || new Bn, Bn.IDENTITY)
                }, t.updateWorldTransform = function() {}, t._instantiate = function() {}, t._load = function() {
                    this._inited || (this._onBatchCreated(false), this._inited = !0), this.walk(pg._setScene)
                }, t._activate = function(e) {
                    e = !1 !== e, i.director._nodeActivator.activateNode(this, e), this._globals.activate()
                }, K(n, [{
                    key: "renderScene",
                    get: function() {
                        return this._renderScene
                    }
                }, {
                    key: "globals",
                    get: function() {
                        return this._globals
                    }
                }, {
                    key: "position",
                    get: function() {
                        return En.ZERO
                    }
                }, {
                    key: "worldPosition",
                    get: function() {
                        return En.ZERO
                    }
                }, {
                    key: "rotation",
                    get: function() {
                        return wn.IDENTITY
                    }
                }, {
                    key: "worldRotation",
                    get: function() {
                        return wn.IDENTITY
                    }
                }, {
                    key: "scale",
                    get: function() {
                        return En.ONE
                    }
                }, {
                    key: "worldScale",
                    get: function() {
                        return En.ONE
                    }
                }, {
                    key: "eulerAngles",
                    get: function() {
                        return En.ZERO
                    }
                }, {
                    key: "worldMatrix",
                    get: function() {
                        return Bn.IDENTITY
                    }
                }]), n
            }(pg)).prototype, "globals", [F_], Object.getOwnPropertyDescriptor(MP.prototype, "globals"), MP.prototype), LP = ie(MP.prototype, "autoReleaseAssets", [w_, F_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return !1
                }
            }), BP = ie(MP.prototype, "_globals", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return new FP
                }
            }), NP = MP)) || NP);

            function UP(e, t) {
                if (!t) {
                    var n = i.director.getScene();
                    if (!n) return null;
                    t = n
                }
                return t.getChildByPath(e)
            }
            i.Scene = zP, i.find = UP;
            var GP = Ze.fastRemoveAt,
                HP = ni.Flags.IsStartCalled,
                kP = ni.Flags.IsOnEnableCalled;

            function VP(e, t) {
                for (var n = t.constructor._executionOrder, i = t._id, r = 0, o = e.length - 1, a = o >>> 1; r <= o; a = r + o >>> 1) {
                    var s = e[a],
                        c = s.constructor._executionOrder;
                    if (c > n) o = a - 1;
                    else if (c < n) r = a + 1;
                    else {
                        var l = s._id;
                        if (l > i) o = a - 1;
                        else {
                            if (!(l < i)) return a;
                            r = a + 1
                        }
                    }
                }
                return ~r
            }

            function WP(e, t) {
                for (var n = e.array, i = e.i + 1; i < n.length;) {
                    var r = n[i];
                    r.node._activeInHierarchy ? ++i : (e.removeAt(i), t && (r._objFlags &= ~t))
                }
            }
            ni.Flags.IsEditorOnEnableCalled;
            var jP = function(e) {
                this._zero = void 0, this._neg = void 0, this._pos = void 0, this._invoke = void 0;
                var t = re;
                this._zero = new t([]), this._neg = new t([]), this._pos = new t([]), this._invoke = e
            };

            function qP(e, t) {
                return e.constructor._executionOrder - t.constructor._executionOrder
            }
            jP.stableRemoveInactive = WP;
            var XP = function(e) {
                    function t() {
                        return e.apply(this, arguments) || this
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.add = function(e) {
                        var t = e.constructor._executionOrder;
                        (0 === t ? this._zero : t < 0 ? this._neg : this._pos).array.push(e)
                    }, n.remove = function(e) {
                        var t = e.constructor._executionOrder;
                        (0 === t ? this._zero : t < 0 ? this._neg : this._pos).fastRemove(e)
                    }, n.cancelInactive = function(e) {
                        WP(this._zero, e), WP(this._neg, e), WP(this._pos, e)
                    }, n.invoke = function() {
                        var e = this._neg;
                        e.array.length > 0 && (e.array.sort(qP), this._invoke(e), e.array.length = 0), this._invoke(this._zero), this._zero.array.length = 0;
                        var t = this._pos;
                        t.array.length > 0 && (t.array.sort(qP), this._invoke(t), t.array.length = 0)
                    }, t
                }(jP),
                YP = function(e) {
                    function t() {
                        return e.apply(this, arguments) || this
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.add = function(e) {
                        var t = e.constructor._executionOrder;
                        if (0 === t) this._zero.array.push(e);
                        else {
                            var n = t < 0 ? this._neg.array : this._pos.array,
                                i = VP(n, e);
                            i < 0 && n.splice(~i, 0, e)
                        }
                    }, n.remove = function(e) {
                        var t = e.constructor._executionOrder;
                        if (0 === t) this._zero.fastRemove(e);
                        else {
                            var n = t < 0 ? this._neg : this._pos,
                                i = VP(n.array, e);
                            i >= 0 && n.removeAt(i)
                        }
                    }, n.invoke = function(e) {
                        this._neg.array.length > 0 && this._invoke(this._neg, e), this._invoke(this._zero, e), this._pos.array.length > 0 && this._invoke(this._pos, e)
                    }, t
                }(jP);

            function KP(e, t, n) {
                var r = "var a=it.array;for(it.i=0;it.i<a.length;++it.i){var c=a[it.i];" + e + "}",
                    o = t ? Function("it", "dt", r) : Function("it", r);
                return function(e, t, n) {
                    return function(r, o) {
                        try {
                            t(r, o)
                        } catch (t) {
                            i._throw(t);
                            var a = r.array;
                            for (n && (a[r.i]._objFlags |= n), ++r.i; r.i < a.length; ++r.i) try {
                                e(a[r.i], o)
                            } catch (e) {
                                i._throw(e), n && (a[r.i]._objFlags |= n)
                            }
                        }
                    }
                }(Function("c", "dt", e), o, n)
            }
            var ZP = KP("c.start();c._objFlags|=" + HP, !1, HP),
                QP = KP("c.update(dt)", !0),
                JP = KP("c.lateUpdate(dt)", !0),
                $P = function(e) {
                    var t = i.director._compScheduler,
                        n = e.array;
                    for (e.i = 0; e.i < n.length; ++e.i) {
                        var r = n[e.i];
                        r._enabled && (r.onEnable(), !r.node._activeInHierarchy || t._onEnabled(r))
                    }
                },
                eO = function() {
                    function e() {
                        this._deferredComps = [], this.unscheduleAll()
                    }
                    var t = e.prototype;
                    return t.unscheduleAll = function() {
                        this.startInvoker = new XP(ZP), this.updateInvoker = new YP(QP), this.lateUpdateInvoker = new YP(JP), this._updating = !1
                    }, t._onEnabled = function(e) {
                        i.director.getScheduler().resumeTarget(e), e._objFlags |= kP, this._updating ? this._deferredComps.push(e) : this._scheduleImmediate(e)
                    }, t._onDisabled = function(e) {
                        i.director.getScheduler().pauseTarget(e), e._objFlags &= ~kP;
                        var t = this._deferredComps.indexOf(e);
                        t >= 0 ? GP(this._deferredComps, t) : (!e.start || e._objFlags & HP || this.startInvoker.remove(e), e.update && this.updateInvoker.remove(e), e.lateUpdate && this.lateUpdateInvoker.remove(e))
                    }, t.enableComp = function(e, t) {
                        if (!(e._objFlags & kP)) {
                            if (e.onEnable) {
                                if (t) return void t.add(e);
                                if (e.onEnable(), !e.node._activeInHierarchy) return
                            }
                            this._onEnabled(e)
                        }
                    }, t.disableComp = function(e) {
                        e._objFlags & kP && (e.onDisable && e.onDisable(), this._onDisabled(e))
                    }, t.startPhase = function() {
                        this._updating = !0, this.startInvoker.invoke(), this._startForNewComps()
                    }, t.updatePhase = function(e) {
                        this.updateInvoker.invoke(e)
                    }, t.lateUpdatePhase = function(e) {
                        this.lateUpdateInvoker.invoke(e), this._updating = !1, this._startForNewComps()
                    }, t._startForNewComps = function() {
                        this._deferredComps.length > 0 && (this._deferredSchedule(), this.startInvoker.invoke())
                    }, t._scheduleImmediate = function(e) {
                        "function" != typeof e.start || e._objFlags & HP || this.startInvoker.add(e), "function" == typeof e.update && this.updateInvoker.add(e), "function" == typeof e.lateUpdate && this.lateUpdateInvoker.add(e)
                    }, t._deferredSchedule = function() {
                        for (var e = this._deferredComps, t = 0, n = e.length; t < n; t++) this._scheduleImmediate(e[t]);
                        e.length = 0
                    }, e
                }(),
                tO = ni.Flags.IsPreloadStarted,
                nO = ni.Flags.IsOnLoadStarted,
                iO = ni.Flags.IsOnLoadCalled,
                rO = ni.Flags.Deactivating,
                oO = function(e) {
                    function t() {
                        return e.apply(this, arguments) || this
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.add = function(e) {
                        this._zero.array.push(e)
                    }, n.remove = function(e) {
                        this._zero.fastRemove(e)
                    }, n.cancelInactive = function(e) {
                        jP.stableRemoveInactive(this._zero, e)
                    }, n.invoke = function() {
                        this._invoke(this._zero), this._zero.array.length = 0
                    }, t
                }(jP),
                aO = KP("c.__preload();"),
                sO = KP("c.onLoad();c._objFlags|=" + iO, !1, iO),
                cO = new Ke(4);

            function lO(e, t, n) {
                t ? e._removeComponent(t) : Ze.removeAt(e._components, n)
            }
            cO.get = function() {
                var e = this._get() || {
                    preload: new oO(aO),
                    onLoad: new XP(sO),
                    onEnable: new XP($P)
                };
                e.preload._zero.i = -1;
                var t = e.onLoad;
                return t._zero.i = -1, t._neg.i = -1, t._pos.i = -1, (t = e.onEnable)._zero.i = -1, t._neg.i = -1, t._pos.i = -1, e
            };
            var uO, hO, _O, fO, dO, pO, mO, gO, vO = e("NodeActivator", function() {
                    function e() {
                        this.resetComp = void 0, this.reset()
                    }
                    var t = e.prototype;
                    return t.reset = function() {
                        this._activatingStack = []
                    }, t.activateNode = function(e, t) {
                        if (t) {
                            var n = cO.get();
                            this._activatingStack.push(n), this._activateNodeRecursively(e, n.preload, n.onLoad, n.onEnable), n.preload.invoke(), n.onLoad.invoke(), n.onEnable.invoke(), this._activatingStack.pop(), cO.put(n)
                        } else {
                            this._deactivateNodeRecursively(e);
                            for (var i, r = te(this._activatingStack); !(i = r()).done;) {
                                var o = i.value;
                                o.preload.cancelInactive(tO), o.onLoad.cancelInactive(nO), o.onEnable.cancelInactive()
                            }
                        }
                        e.emit("active-in-hierarchy-changed", e)
                    }, t.activateComp = function(e, t, n, r) {
                        if (ri(e, !0) && (e._objFlags & tO || (e._objFlags |= tO, e.__preload && (t ? t.add(e) : e.__preload())), e._objFlags & nO || (e._objFlags |= nO, e.onLoad ? n ? n.add(e) : (e.onLoad(), e._objFlags |= iO) : e._objFlags |= iO), e._enabled)) {
                            if (!e.node._activeInHierarchy) return;
                            i.director._compScheduler.enableComp(e, r)
                        }
                    }, t.destroyComp = function(e) {
                        i.director._compScheduler.disableComp(e), e.onDestroy && e._objFlags & iO && e.onDestroy()
                    }, t._activateNodeRecursively = function(e, t, n, r) {
                        if (e._objFlags & rO) b(3816, e.name);
                        else {
                            e._activeInHierarchy = !0;
                            for (var o = e._components.length, a = 0; a < o; ++a) {
                                var s = e._components[a];
                                s instanceof i.Component ? this.activateComp(s, t, n, r) : (lO(e, s, a), --a, --o)
                            }
                            e._childArrivalOrder = e._children.length;
                            for (var c = 0, l = e._children.length; c < l; ++c) {
                                var u = e._children[c];
                                u._active && this._activateNodeRecursively(u, t, n, r)
                            }
                            e._onPostActivated(!0)
                        }
                    }, t._deactivateNodeRecursively = function(e) {
                        e._objFlags |= rO, e._activeInHierarchy = !1;
                        for (var t = e._components.length, n = 0; n < t; ++n) {
                            var r = e._components[n];
                            if (r._enabled && (i.director._compScheduler.disableComp(r), e._activeInHierarchy)) return void(e._objFlags &= ~rO)
                        }
                        for (var o = 0, a = e._children.length; o < a; ++o) {
                            var s = e._children[o];
                            if (s._activeInHierarchy && (this._deactivateNodeRecursively(s), e._activeInHierarchy)) return void(e._objFlags &= ~rO)
                        }
                        e._onPostActivated(!1), e._objFlags &= ~rO
                    }, e
                }()),
                yO = e("SceneAsset", A_("cc.SceneAsset")((fO = function(e) {
                    function t() {
                        for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                        return ne(t = e.call.apply(e, [this].concat(i)) || this, "scene", _O, $(t)), t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.initDefault = function(t) {
                        e.prototype.initDefault.call(this, t), this.scene = new zP("New Scene")
                    }, n.validate = function() {
                        return !!this.scene
                    }, t
                }(Nf), _O = ie((hO = fO).prototype, "scene", [F_, w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return null
                    }
                }), uO = hO)) || uO);
            i.SceneAsset = yO;
            var SO, EO, TO, AO, xO = e("TextAsset", A_("cc.TextAsset")((gO = function(e) {
                function t() {
                    for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                    return ne(t = e.call.apply(e, [this].concat(i)) || this, "text", mO, $(t)), t
                }
                return Q(t, e), t.prototype.toString = function() {
                    return this.text
                }, t
            }(Nf), mO = ie((pO = gO).prototype, "text", [w_, F_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return ""
                }
            }), dO = pO)) || dO);
            i.TextAsset = xO;
            var CO = e("JsonAsset", A_("cc.JsonAsset")((AO = function(e) {
                function t() {
                    for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                    return ne(t = e.call.apply(e, [this].concat(i)) || this, "json", TO, $(t)), t
                }
                return Q(t, e), t
            }(Nf), TO = ie((EO = AO).prototype, "json", [w_, F_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return null
                }
            }), SO = EO)) || SO);
            i.JsonAsset = CO;
            var bO = e("Director", function(e) {
                function t() {
                    var t;
                    return (t = e.call(this) || this)._compScheduler = void 0, t._nodeActivator = void 0, t._invalid = void 0, t._paused = void 0, t._purgeDirectorInNextLoop = void 0, t._root = void 0, t._loadingScene = void 0, t._scene = void 0, t._totalFrames = void 0, t._lastUpdate = void 0, t._deltaTime = void 0, t._startTime = void 0, t._scheduler = void 0, t._systems = void 0, t._invalid = !1, t._paused = !1, t._purgeDirectorInNextLoop = !1, t._root = null, t._loadingScene = "", t._scene = null, t._totalFrames = 0, t._lastUpdate = 0, t._deltaTime = 0, t._startTime = 0, t._scheduler = new hR, t._compScheduler = new eO, t._nodeActivator = new vO, t._systems = [], i.game.once(VC.EVENT_RENDERER_INITED, t._initOnRendererInitialized, $(t)), t
                }
                Q(t, e);
                var n = t.prototype;
                return n.calculateDeltaTime = function(e) {
                    e || (e = performance.now()), this._deltaTime = e > this._lastUpdate ? (e - this._lastUpdate) / 1e3 : 0, this._lastUpdate = e
                }, n.convertToGL = function(e) {
                    var t = i.game.container,
                        n = i.view,
                        r = t.getBoundingClientRect(),
                        o = r.left + window.pageXOffset - t.clientLeft,
                        a = r.top + window.pageYOffset - t.clientTop,
                        s = n._devicePixelRatio * (e.x - o),
                        c = n._devicePixelRatio * (a + r.height - e.y);
                    return n._isRotated ? Vn(n._viewportRect.width - c, s) : Vn(s, c)
                }, n.convertToUI = function(e) {
                    var t = i.game.container,
                        n = i.view,
                        r = t.getBoundingClientRect(),
                        o = r.left + window.pageXOffset - t.clientLeft,
                        a = r.top + window.pageYOffset - t.clientTop,
                        s = Vn(0, 0);
                    return n._isRotated ? (s.x = o + e.y / n._devicePixelRatio, s.y = a + r.height - (n._viewportRect.width - e.x) / n._devicePixelRatio) : (s.x = o + e.x * n._devicePixelRatio, s.y = a + r.height - e.y * n._devicePixelRatio), s
                }, n.end = function() {
                    this._purgeDirectorInNextLoop = !0
                }, n.getWinSize = function() {
                    return Yn(i.winSize)
                }, n.getWinSizeInPixels = function() {
                    return Yn(i.winSize)
                }, n.pause = function() {
                    this._paused || (this._paused = !0)
                }, n.purgeCachedData = function() {
                    i.assetManager.releaseAll()
                }, n.purgeDirector = function() {
                    this._scheduler.unscheduleAll(), this._compScheduler.unscheduleAll(), this._nodeActivator.reset(), Vm && Vm.setEnabled(!1), i.isValid(this._scene) && this._scene.destroy(), this._scene = null, this.stopAnimation(), i.assetManager.releaseAll()
                }, n.reset = function() {
                    this.purgeDirector(), this.emit(t.EVENT_RESET), Vm && Vm.setEnabled(!0), this.startAnimation()
                }, n.runSceneImmediate = function(e, t, n) {
                    e instanceof yO && (e = e.scene), I(e instanceof zP, 1216), e._load();
                    for (var r = Object.keys(i.game._persistRootNodes).map((function(e) {
                            return i.game._persistRootNodes[e]
                        })), o = 0; o < r.length; o++) {
                        var a = r[o];
                        a.emit(i.Node.SCENE_CHANGED_FOR_PERSISTS, e.renderScene);
                        var s = e.uuid === a._originalSceneId && e.getChildByUuid(a.uuid);
                        if (s) {
                            var c = s.getSiblingIndex();
                            s._destroyImmediate(), e.insertChild(a, c)
                        } else a.parent = e
                    }
                    var l = this._scene;
                    i.isValid(l) && l.destroy(), i.assetManager._releaseManager._autoRelease(l, e, i.game._persistRootNodes), this._scene = null, ni._deferredDestroy(), t && t(), this.emit(i.Director.EVENT_BEFORE_SCENE_LAUNCH, e), this._scene = e, e._activate(), this._root && this._root.resetCumulativeTime(), this.startAnimation(), n && n(null, e), this.emit(i.Director.EVENT_AFTER_SCENE_LAUNCH, e)
                }, n.runScene = function(e, t, n) {
                    var r = this;
                    e instanceof yO && (e = e.scene), I(e, 1205), I(e instanceof zP, 1216), e._load(), this.once(i.Director.EVENT_AFTER_DRAW, (function() {
                        r.runSceneImmediate(e, t, n)
                    }))
                }, n.loadScene = function(e, t, n) {
                    var r = this;
                    if (this._loadingScene) return x(1208, e, this._loadingScene), !1;
                    var o = i.assetManager.bundles.find((function(t) {
                        return !!t.getSceneInfo(e)
                    }));
                    return o ? (this.emit(i.Director.EVENT_BEFORE_SCENE_LOADING, e), this._loadingScene = e, console.time("LoadScene " + e), o.loadScene(e, (function(i, o) {
                        console.timeEnd("LoadScene " + e), r._loadingScene = "", i ? (p(i), t && t(i)) : r.runSceneImmediate(o, n, t)
                    })), !0) : (b(1209, e), !1)
                }, n.preloadScene = function(e, t, n) {
                    var r = i.assetManager.bundles.find((function(t) {
                        return !!t.getSceneInfo(e)
                    }));
                    if (r) r.preloadScene(e, null, t, n);
                    else {
                        var o = 'Can not preload the scene "' + e + '" because it is not in the build settings.';
                        n && n(new Error(o)), p("preloadScene: " + o)
                    }
                }, n.resume = function() {
                    this._paused && (this._lastUpdate = performance.now(), this._lastUpdate || T(1200), this._paused = !1, this._deltaTime = 0)
                }, n.setDepthTest = function(e) {
                    i.Camera.main && (i.Camera.main.depth = !!e)
                }, n.setClearColor = function(e) {
                    i.Camera.main && (i.Camera.main.backgroundColor = e)
                }, n.getRunningScene = function() {
                    return this._scene
                }, n.getScene = function() {
                    return this._scene
                }, n.getAnimationInterval = function() {
                    return 1e3 / i.game.getFrameRate()
                }, n.setAnimationInterval = function(e) {
                    i.game.setFrameRate(Math.round(1e3 / e))
                }, n.getDeltaTime = function() {
                    return this._deltaTime
                }, n.getTotalTime = function() {
                    return performance.now() - this._startTime
                }, n.getCurrentTime = function() {
                    return this._lastUpdate
                }, n.getTotalFrames = function() {
                    return this._totalFrames
                }, n.isPaused = function() {
                    return this._paused
                }, n.getScheduler = function() {
                    return this._scheduler
                }, n.setScheduler = function(e) {
                    this._scheduler !== e && (this.unregisterSystem(this._scheduler), this._scheduler = e, this.registerSystem(hR.ID, e, 200))
                }, n.registerSystem = function(e, t, n) {
                    t.id = e, t.priority = n, t.init(), this._systems.push(t), this._systems.sort(oR.sortByPriority)
                }, n.unregisterSystem = function(e) {
                    Ze.fastRemove(this._systems, e), this._systems.sort(oR.sortByPriority)
                }, n.getSystem = function(e) {
                    return this._systems.find((function(t) {
                        return t.id === e
                    }))
                }, n.getAnimationManager = function() {
                    return this.getSystem(i.AnimationManager.ID)
                }, n.startAnimation = function() {
                    this._invalid = !1, this._lastUpdate = performance.now()
                }, n.stopAnimation = function() {
                    this._invalid = !0
                }, n.mainLoop = function(e) {
                    if (this._purgeDirectorInNextLoop) this._purgeDirectorInNextLoop = !1, this.purgeDirector();
                    else if (!this._invalid) {
                        this.calculateDeltaTime(e);
                        var n = this._deltaTime;
                        if (!this._paused) {
                            this.emit(t.EVENT_BEFORE_UPDATE), this._compScheduler.startPhase(), this._compScheduler.updatePhase(n);
                            for (var i = 0; i < this._systems.length; ++i) this._systems[i].update(n);
                            this._compScheduler.lateUpdatePhase(n), this.emit(t.EVENT_AFTER_UPDATE), ni._deferredDestroy();
                            for (var r = 0; r < this._systems.length; ++r) this._systems[r].postUpdate(n)
                        }
                        this.emit(t.EVENT_BEFORE_DRAW), this._root.frameMove(this._deltaTime), this.emit(t.EVENT_AFTER_DRAW), Vm.frameUpdateListeners(), Yv.clearBooks(), this._totalFrames++
                    }
                }, n._initOnRendererInitialized = function() {
                    this._totalFrames = 0, this._lastUpdate = performance.now(), this._startTime = this._lastUpdate, this._paused = !1, this._purgeDirectorInNextLoop = !1, Vm && Vm.setEnabled(!0), this.registerSystem(hR.ID, this._scheduler, 200), this.emit(t.EVENT_INIT)
                }, n._init = function() {
                    return this._root = new fR(i.game._gfxDevice), this._root.initialize({}).catch((function(e) {
                        return b(1217), Promise.reject(e)
                    }))
                }, K(t, [{
                    key: "root",
                    get: function() {
                        return this._root
                    }
                }]), t
            }(Si));
            bO.EVENT_INIT = "director_init", bO.EVENT_RESET = "director_reset", bO.EVENT_BEFORE_SCENE_LOADING = "director_before_scene_loading", bO.EVENT_BEFORE_SCENE_LAUNCH = "director_before_scene_launch", bO.EVENT_AFTER_SCENE_LAUNCH = "director_after_scene_launch", bO.EVENT_BEFORE_UPDATE = "director_before_update", bO.EVENT_AFTER_UPDATE = "director_after_update", bO.EVENT_BEFORE_DRAW = "director_before_draw", bO.EVENT_AFTER_DRAW = "director_after_draw", bO.EVENT_BEFORE_COMMIT = "director_before_commit", bO.EVENT_BEFORE_PHYSICS = "director_before_physics", bO.EVENT_AFTER_PHYSICS = "director_after_physics", bO.instance = void 0, i.Director = bO;
            var RO = e("director", bO.instance = i.director = new bO),
                wO = function() {
                    function e() {
                        this.name = "", this.base = "", this.importBase = "", this.nativeBase = "", this.deps = null, this.assetInfos = new nf, this.scenes = new nf, this.paths = new nf
                    }
                    var t = e.prototype;
                    return t.init = function(e) {
                        ! function(e) {
                            var t = e.uuids,
                                n = e.paths,
                                i = e.types,
                                r = e.deps,
                                o = e.paths = Object.create(null);
                            if (!1 === e.debug) {
                                for (var a = 0, s = t.length; a < s; a++) t[a] = Sf(t[a]);
                                for (var c in n) {
                                    var l = n[c],
                                        u = l[1];
                                    l[1] = i[u]
                                }
                            } else {
                                for (var h = Object.create(null), _ = 0, f = t.length; _ < f; _++) {
                                    var d = t[_];
                                    t[_] = h[d] = Sf(d)
                                }
                                t = h
                            }
                            for (var p in n) {
                                var m = n[p];
                                o[t[p]] = m
                            }
                            var g = e.scenes;
                            for (var v in g) {
                                var y = g[v];
                                g[v] = t[y]
                            }
                            var S = e.packs;
                            for (var E in S)
                                for (var T = S[E], A = 0; A < T.length; ++A) T[A] = t[T[A]];
                            var x = e.versions;
                            if (x)
                                for (var C in x)
                                    for (var b = x[C], R = 0; R < b.length; R += 2) {
                                        var w = b[R];
                                        b[R] = t[w] || w
                                    }
                            var I = e.redirect;
                            if (I)
                                for (var P = 0; P < I.length; P += 2) I[P] = t[I[P]], I[P + 1] = r[I[P + 1]]
                        }(e), this.importBase = e.importBase || "", this.nativeBase = e.nativeBase || "", this.base = e.base || "", this.name = e.name || "", this.deps = e.deps || [], this._initUuid(e.uuids), this._initPath(e.paths), this._initScene(e.scenes), this._initPackage(e.packs), this._initVersion(e.versions), this._initRedirect(e.redirect)
                    }, t.getInfoWithPath = function(e, t) {
                        if (!e) return null;
                        e = Cf(e);
                        var n = this.paths.get(e);
                        if (n) {
                            if (!t) return n[0];
                            for (var i = 0, r = n.length; i < r; i++) {
                                var o = n[i];
                                if (Qe.isChildClassOf(o.ctor, t)) return o
                            }
                        }
                        return null
                    }, t.getDirWithPath = function(e, t, n) {
                        "/" === (e = Cf(e))[e.length - 1] && (e = e.slice(0, -1));
                        var i = n || [];
                        return this.paths.forEach((function(n, r) {
                            if (r.startsWith(e) && function(e, t) {
                                    return !(e.length > t.length) || 47 === e.charCodeAt(t.length)
                                }(r, e) || !e)
                                for (var o = 0, a = n.length; o < a; o++) {
                                    var s = n[o];
                                    t && !Qe.isChildClassOf(s.ctor, t) || i.push(s)
                                }
                        })), i
                    }, t.getAssetInfo = function(e) {
                        return this.assetInfos.get(e) || null
                    }, t.getSceneInfo = function(e) {
                        return e.endsWith(".scene") || (e += ".scene"), "/" === e[0] || e.startsWith("db://") || (e = "/" + e), this.scenes.find((function(t, n) {
                            return n.endsWith(e)
                        }))
                    }, t.destroy = function() {
                        this.paths.destroy(), this.scenes.destroy(), this.assetInfos.destroy()
                    }, t._initUuid = function(e) {
                        if (e) {
                            this.assetInfos.clear();
                            for (var t = 0, n = e.length; t < n; t++) {
                                var i = e[t];
                                this.assetInfos.add(i, {
                                    uuid: i
                                })
                            }
                        }
                    }, t._initPath = function(e) {
                        if (e) {
                            var t = this.paths;
                            for (var n in t.clear(), e) {
                                var i = e[n],
                                    r = i[0],
                                    o = i[1],
                                    a = 3 === i.length,
                                    s = this.assetInfos.get(n);
                                s.path = r, s.ctor = Qe._getClassById(o), t.has(r) ? a ? t.get(r).push(s) : t.get(r).splice(0, 0, s) : t.add(r, [s])
                            }
                        }
                    }, t._initScene = function(e) {
                        if (e) {
                            var t = this.scenes;
                            t.clear();
                            var n = this.assetInfos;
                            for (var i in e) {
                                var r = e[i],
                                    o = n.get(r);
                                o.url = i, t.add(i, o)
                            }
                        }
                    }, t._initPackage = function(e) {
                        if (e) {
                            var t = this.assetInfos;
                            for (var n in e) {
                                var i = e[n],
                                    r = {
                                        uuid: n,
                                        packedUuids: i,
                                        ext: ".json"
                                    };
                                t.add(n, r);
                                for (var o = 0, a = i.length; o < a; o++) {
                                    var s = i[o],
                                        c = t.get(s),
                                        l = c.packs;
                                    l ? 1 === a ? l.splice(0, 0, r) : l.push(r) : c.packs = [r]
                                }
                            }
                        }
                    }, t._initVersion = function(e) {
                        if (e) {
                            var t = this.assetInfos,
                                n = e.import;
                            if (n)
                                for (var i = 0, r = n.length; i < r; i += 2) {
                                    var o = n[i];
                                    t.get(o).ver = n[i + 1]
                                }
                            if (n = e.native)
                                for (var a = 0, s = n.length; a < s; a += 2) {
                                    var c = n[a];
                                    t.get(c).nativeVer = n[a + 1]
                                }
                        }
                    }, t._initRedirect = function(e) {
                        if (e)
                            for (var t = this.assetInfos, n = 0, i = e.length; n < i; n += 2) {
                                var r = e[n];
                                t.get(r).redirect = e[n + 1]
                            }
                    }, e
                }();

            function IO(e, t) {
                e._uuid && t.push(e._uuid)
            }

            function PO(e, t) {
                for (var n = Object.getOwnPropertyNames(e), i = 0; i < n.length; i++) {
                    var r = n[i];
                    if ("node" !== r && "__eventTargets" !== r) {
                        var o = e[r];
                        if ("object" == typeof o && o)
                            if (Array.isArray(o))
                                for (var a = 0; a < o.length; a++) {
                                    var s = o[a];
                                    s instanceof Nf && IO(s, t)
                                } else if (o.constructor && o.constructor !== Object) o instanceof Nf && IO(o, t);
                                else
                                    for (var c = Object.getOwnPropertyNames(o), l = 0; l < c.length; l++) {
                                        var u = o[c[l]];
                                        u instanceof Nf && IO(u, t)
                                    }
                    }
                }
            }

            function OO(e, t) {
                for (var n = 0; n < e._components.length; n++) PO(e._components[n], t);
                for (var i = 0; i < e._children.length; i++) OO(e._children[i], t)
            }

            function DO(e, t, n, i) {
                n.push(e._uuid);
                for (var r = ip.getDeps(e._uuid), o = 0, a = r.length; o < a; o++) {
                    var s = af.get(r[o]);
                    if (s) {
                        var c = s._uuid;
                        c in t ? t[c] += i : t[c] = s.refCount + i, n.includes(c) || DO(s, t, n, i)
                    }
                }
            }
            var NO = [],
                MO = new(function() {
                    function e() {
                        this._persistNodeDeps = new nf, this._toDelete = new nf, this._eventListener = !1
                    }
                    var t = e.prototype;
                    return t.init = function() {
                        this._persistNodeDeps.clear(), this._toDelete.clear()
                    }, t._addPersistNodeRef = function(e) {
                        var t = [];
                        OO(e, t);
                        for (var n = 0, i = t.length; n < i; n++) {
                            var r = af.get(t[n]);
                            r && r.addRef()
                        }
                        this._persistNodeDeps.add(e.uuid, t)
                    }, t._removePersistNodeRef = function(e) {
                        if (this._persistNodeDeps.has(e.uuid)) {
                            for (var t = this._persistNodeDeps.get(e.uuid), n = 0, i = t.length; n < i; n++) {
                                var r = af.get(t[n]);
                                r && r.decRef()
                            }
                            this._persistNodeDeps.remove(e.uuid)
                        }
                    }, t._autoRelease = function(e, t, n) {
                        if (e) {
                            for (var i = ip.getDeps(e.uuid), r = 0, o = i.length; r < o; r++) {
                                var a = af.get(i[r]);
                                a && a.decRef(e.autoReleaseAssets)
                            }
                            var s = ip._depends.get(e.uuid);
                            if (s && s.persistDeps)
                                for (var c = s.persistDeps, l = 0, u = c.length; l < u; l++) {
                                    var h = af.get(c[l]);
                                    h && h.decRef(e.autoReleaseAssets)
                                }
                            e.uuid !== t.uuid && ip.remove(e.uuid)
                        }
                        var _ = ip._depends.get(t.uuid);
                        for (var f in _ && (_.persistDeps = []), n) {
                            for (var d, p, m = n[f], g = this._persistNodeDeps.get(m.uuid), v = te(g); !(p = v()).done;) {
                                var y = p.value,
                                    S = af.get(y);
                                S && S.addRef()
                            }
                            _ && (d = _.persistDeps).push.apply(d, g)
                        }
                    }, t.tryRelease = function(e, t) {
                        void 0 === t && (t = !1), e instanceof Nf && (t ? this._free(e, t) : (this._toDelete.add(e._uuid, e), this._eventListener || (this._eventListener = !0, dt(this._freeAssets.bind(this)))))
                    }, t._freeAssets = function() {
                        var e = this;
                        this._eventListener = !1, this._toDelete.forEach((function(t) {
                            e._free(t)
                        })), this._toDelete.clear()
                    }, t._free = function(e, t) {
                        void 0 === t && (t = !1);
                        var n = e._uuid;
                        if (this._toDelete.remove(n), ri(e, !0) && !(!t && e.refCount > 0 && function(e) {
                                var t = Object.create(null);
                                if (t[e._uuid] = e.refCount, DO(e, t, NO, -1), NO.length = 0, 0 !== t[e._uuid]) return t[e._uuid];
                                for (var n in t) 0 !== t[n] && DO(af.get(n), t, NO, 1);
                                return NO.length = 0, t[e._uuid]
                            }(e) > 0)) {
                            af.remove(n);
                            for (var i = ip.getDeps(n), r = 0, o = i.length; r < o; r++) {
                                var a = af.get(i[r]);
                                a && (a.decRef(!1), this._free(a, !1))
                            }
                            e.destroy(), ip.remove(n)
                        }
                    }, e
                }()),
                LO = null;

            function BO(e, t) {
                for (var n = 0, i = e.input.length; n < i; n++) {
                    var r = e.input[n];
                    t && !r.isNative && r.content instanceof Nf && r.content.decRef(!1), r.recycle()
                }
                e.input = null
            }

            function FO(e, t) {
                return t ? /\?/.test(e) ? e + "&_t=" + Date.now() : e + "?_t=" + Date.now() : e
            }

            function zO(e, t, n, i, r) {
                void 0 === r && (r = 0), e(r, (function(o, a) {
                    r++, !o || r > t ? i && i(o, a) : setTimeout((function() {
                        zO(e, t, n, i, r)
                    }), n)
                }))
            }

            function UO(e, t, n, i, r) {
                try {
                    for (var o = ip.parse(e, t), a = 0, s = o.deps.length; a < s; a++) {
                        var c = o.deps[a];
                        c in n || (n[c] = !0, i.push({
                            uuid: c,
                            bundle: r && r.name
                        }))
                    }
                    o.nativeDep && (r && (o.nativeDep.bundle = r.name), i.push(Z({}, o.nativeDep)))
                } catch (e) {
                    p(e.message, e.stack)
                }
            }

            function GO(e, t, n) {
                t && (n = void 0 !== n ? n : i.assetManager.cacheAsset, xf(t) || !n || t.isDefault || af.add(e, t))
            }

            function HO(e, t, n) {
                var i = 0,
                    r = [],
                    o = e.length;
                0 === o && n && n(r);
                for (var a = function(e) {
                        e && r.push(e), ++i === o && n && n(r)
                    }, s = 0; s < o; s++) t(e[s], a)
            }

            function kO(e, t, n) {
                var i = e,
                    r = t,
                    o = n;
                if (void 0 === n) {
                    var a = "function" == typeof e;
                    t ? (o = t, a || (r = null)) : void 0 === t && a && (o = e, i = null, r = null), void 0 !== t && a && (r = e, i = null)
                }
                return {
                    options: i || Object.create(null),
                    onProgress: r,
                    onComplete: o
                }
            }

            function VO(e, t, n) {
                var i = e,
                    r = t,
                    o = n;
                if (void 0 === n) {
                    var a = Qe.isChildClassOf(e, Nf);
                    t ? (o = t, a && (r = null)) : void 0 !== t || a || (o = e, r = null, i = null), void 0 === t || a || (r = e, i = null)
                }
                return {
                    type: i,
                    onProgress: r || LO,
                    onComplete: o
                }
            }

            function WO(e, t, n, i) {
                if (void 0 === i && (i = {}), !n[t] || i[t]) return !1;
                i[t] = !0;
                var r = !1,
                    o = ip.getDeps(t);
                if (o)
                    for (var a = 0, s = o.length; a < s; a++) {
                        var c = o[a];
                        if (c === e || WO(e, c, n, i)) {
                            r = !0;
                            break
                        }
                    }
                return r
            }

            function jO(e) {
                return function(t, n) {
                    if (e) {
                        var i = [];
                        Array.isArray(n) ? n.forEach((function(e) {
                            return e instanceof Nf && i.push(e.addRef())
                        })) : n instanceof Nf && i.push(n.addRef()), dt((function() {
                            i.forEach((function(e) {
                                return e.decRef(!1)
                            })), e(t, n)
                        }))
                    }
                }
            }
            var qO = function() {
                    function e() {
                        this._config = new wO
                    }
                    var t = e.prototype;
                    return t.getInfoWithPath = function(e, t) {
                        return this._config.getInfoWithPath(e, t)
                    }, t.getDirWithPath = function(e, t, n) {
                        return this._config.getDirWithPath(e, t, n)
                    }, t.getAssetInfo = function(e) {
                        return this._config.getAssetInfo(e)
                    }, t.getSceneInfo = function(e) {
                        return this._config.getSceneInfo(e)
                    }, t.init = function(e) {
                        this._config.init(e), lf.add(e.name, this)
                    }, t.load = function(e, t, n, r) {
                        var o = VO(t, n, r),
                            a = o.type,
                            s = o.onProgress,
                            c = o.onComplete,
                            l = {
                                __requestType__: of .PATH,
                                type: a,
                                bundle: this.name,
                                __outputAsArray__: Array.isArray(e)
                            };
                        i.assetManager.loadAny(e, l, s, c)
                    }, t.preload = function(e, t, n, r) {
                        var o = VO(t, n, r),
                            a = o.type,
                            s = o.onProgress,
                            c = o.onComplete;
                        i.assetManager.preloadAny(e, {
                            __requestType__: of .PATH,
                            type: a,
                            bundle: this.name
                        }, s, c)
                    }, t.loadDir = function(e, t, n, r) {
                        var o = VO(t, n, r),
                            a = o.type,
                            s = o.onProgress,
                            c = o.onComplete;
                        i.assetManager.loadAny(e, {
                            __requestType__: of .DIR,
                            type: a,
                            bundle: this.name,
                            __outputAsArray__: !0
                        }, s, c)
                    }, t.preloadDir = function(e, t, n, r) {
                        var o = VO(t, n, r),
                            a = o.type,
                            s = o.onProgress,
                            c = o.onComplete;
                        i.assetManager.preloadAny(e, {
                            __requestType__: of .DIR,
                            type: a,
                            bundle: this.name
                        }, s, c)
                    }, t.loadScene = function(e, t, n, r) {
                        var o = kO(t, n, r),
                            a = o.options,
                            s = o.onProgress,
                            c = o.onComplete;
                        a.preset = a.preset || "scene", a.bundle = this.name, i.assetManager.loadAny({
                            scene: e
                        }, a, s, (function(e, t) {
                            if (e) p(e.message, e.stack);
                            else if (t instanceof yO && t.scene) {
                                var n = t.scene;
                                n._id = t._uuid, n.name = t.name
                            } else e = new Error("The asset " + t._uuid + " is not a scene");
                            c && c(e, t)
                        }))
                    }, t.preloadScene = function(e, t, n, r) {
                        var o = kO(t, n, r),
                            a = o.options,
                            s = o.onProgress,
                            c = o.onComplete;
                        a.bundle = this.name, i.assetManager.preloadAny({
                            scene: e
                        }, a, s, (function(t) {
                            t && b(1210, e, t.message), c && c(t)
                        }))
                    }, t.get = function(e, t) {
                        var n = this.getInfoWithPath(e, t);
                        return n && af.get(n.uuid) || null
                    }, t.release = function(e, t) {
                        var n = this.get(e, t);
                        n && MO.tryRelease(n, !0)
                    }, t.releaseUnusedAssets = function() {
                        var e = this;
                        af.forEach((function(t) {
                            var n = e.getAssetInfo(t._uuid);
                            n && !n.redirect && MO.tryRelease(t)
                        }))
                    }, t.releaseAll = function() {
                        var e = this;
                        af.forEach((function(t) {
                            var n = e.getAssetInfo(t._uuid);
                            n && !n.redirect && MO.tryRelease(t, !0)
                        }))
                    }, t._destroy = function() {
                        this._config.destroy()
                    }, K(e, [{
                        key: "config",
                        get: function() {
                            return this._config
                        }
                    }, {
                        key: "name",
                        get: function() {
                            return this._config.name
                        }
                    }, {
                        key: "deps",
                        get: function() {
                            return this._config.deps
                        }
                    }, {
                        key: "base",
                        get: function() {
                            return this._config.base
                        }
                    }]), e
                }(),
                XO = e("resources", new qO);

            function YO(e, t, n) {
                var i = new Image;

                function r() {
                    i.removeEventListener("load", r), i.removeEventListener("error", o), n && n(null, i)
                }

                function o() {
                    i.removeEventListener("load", r), i.removeEventListener("error", o), n && n(new Error(P(4930, e)))
                }
                return "file:" !== window.location.protocol && (i.crossOrigin = "anonymous"), i.addEventListener("load", r), i.addEventListener("error", o), i.src = e, i
            }

            function KO(e, t, n, i) {
                var r = new XMLHttpRequest,
                    o = "download failed: " + e + ", status: ";
                if (r.open("GET", e, !0), void 0 !== t.xhrResponseType && (r.responseType = t.xhrResponseType), void 0 !== t.xhrWithCredentials && (r.withCredentials = t.xhrWithCredentials), void 0 !== t.xhrMimeType && r.overrideMimeType && r.overrideMimeType(t.xhrMimeType), void 0 !== t.xhrTimeout && (r.timeout = t.xhrTimeout), t.xhrHeader)
                    for (var a in t.xhrHeader) r.setRequestHeader(a, t.xhrHeader[a]);
                return r.onload = function() {
                    200 === r.status || 0 === r.status ? i && i(null, r.response) : i && i(new Error("" + o + r.status + "(no response)"))
                }, n && (r.onprogress = function(e) {
                    e.lengthComputable && n(e.loaded, e.total)
                }), r.onerror = function() {
                    i && i(new Error("" + o + r.status + "(error)"))
                }, r.ontimeout = function() {
                    i && i(new Error("" + o + r.status + "(time out)"))
                }, r.onabort = function() {
                    i && i(new Error("" + o + r.status + "(abort)"))
                }, r.send(null), r
            }
            i.resources = XO;
            var ZO = {};

            function QO(e, t, n) {
                if (ZO[e]) return n && n(null), null;
                var i = document.createElement("script");

                function r() {
                    i.parentNode.removeChild(i), i.removeEventListener("load", r, !1), i.removeEventListener("error", o, !1), ZO[e] = !0, n && n(null)
                }

                function o() {
                    i.parentNode.removeChild(i), i.removeEventListener("load", r, !1), i.removeEventListener("error", o, !1), n && n(new Error(P(4928, e)))
                }
                return "file:" !== window.location.protocol && (i.crossOrigin = "anonymous"), i.async = t.scriptAsyncLoading || !1, i.src = e, i.addEventListener("load", r, !1), i.addEventListener("error", o, !1), document.body.appendChild(i), i
            }
            var JO = /^(?:\w+:\/\/|\.+\/).+/,
                $O = function(e, t, n) {
                    (oS.capabilities.imageBitmap && i.assetManager.allowImageBitmap ? eD : YO)(e, t, n)
                },
                eD = function(e, t, n) {
                    t.xhrResponseType = "blob", KO(e, t, t.onFileProgress, n)
                },
                tD = function(e, t, n) {
                    t.xhrResponseType = "json", KO(e, t, t.onFileProgress, n)
                },
                nD = function(e, t, n) {
                    t.xhrResponseType = "arraybuffer", KO(e, t, t.onFileProgress, n)
                },
                iD = function(e, t, n) {
                    t.xhrResponseType = "text", KO(e, t, t.onFileProgress, n)
                },
                rD = function(e, t, n) {
                    var i = wi(e),
                        r = e;
                    JO.test(r) || (r = -1 !== oD.remoteBundles.indexOf(i) ? oD.remoteServerAddress + "remote/" + i : "assets/" + i);
                    var o = t.version || oD.bundleVers[i],
                        a = 0,
                        s = null,
                        c = null;
                    tD(r + "/config." + (o ? o + "." : "") + "json", t, (function(e, t) {
                        c = e, (s = t) && (s.base = r + "/"), 2 == ++a && n(c, s)
                    })), QO(r + "/index." + (o ? o + "." : "") + "js", t, (function(e) {
                        c = e, 2 == ++a && n(e, s)
                    }))
                },
                oD = new(function() {
                    function e() {
                        this.maxConcurrency = 6, this.maxRequestsPerFrame = 6, this.maxRetryCount = 3, this.appendTimeStamp = !1, this.limited = !0, this.retryInterval = 2e3, this.bundleVers = null, this.remoteBundles = [], this.downloadDomImage = YO, this.downloadDomAudio = null, this.downloadFile = KO, this.downloadScript = QO, this._downloaders = {
                            ".png": $O,
                            ".jpg": $O,
                            ".bmp": $O,
                            ".jpeg": $O,
                            ".gif": $O,
                            ".ico": $O,
                            ".tiff": $O,
                            ".webp": $O,
                            ".image": $O,
                            ".pvr": nD,
                            ".pkm": nD,
                            ".astc": nD,
                            ".txt": iD,
                            ".xml": iD,
                            ".vsh": iD,
                            ".fsh": iD,
                            ".atlas": iD,
                            ".tmx": iD,
                            ".tsx": iD,
                            ".json": tD,
                            ".ExportJson": tD,
                            ".plist": iD,
                            ".fnt": iD,
                            ".binary": nD,
                            ".bin": nD,
                            ".dbbin": nD,
                            ".skel": nD,
                            ".js": QO,
                            bundle: rD,
                            default: iD
                        }, this._downloading = new nf, this._queue = [], this._queueDirty = !1, this._totalNum = 0, this._totalNumThisPeriod = 0, this._lastDate = -1, this._checkNextPeriod = !1, this._remoteServerAddress = "", this._maxInterval = 1 / 30
                    }
                    var t = e.prototype;
                    return t.init = function(e, t, n) {
                        void 0 === e && (e = ""), void 0 === t && (t = {}), void 0 === n && (n = []), this._downloading.clear(), this._queue.length = 0, this._remoteServerAddress = e, this.bundleVers = t, this.remoteBundles = n
                    }, t.register = function(e, t) {
                        "object" == typeof e ? Ne(this._downloaders, e) : this._downloaders[e] = t
                    }, t.download = function(e, t, n, i, r) {
                        var o = this,
                            a = sf.get(e);
                        if (a) r(null, a);
                        else {
                            var s = this._downloading.get(e);
                            if (s) {
                                s.push(r);
                                var c = this._queue.find((function(t) {
                                    return t.id === e
                                }));
                                if (!c) return;
                                var l = i.priority || 0;
                                c.priority < l && (c.priority = l, this._queueDirty = !0)
                            } else {
                                var u = void 0 !== i.maxRetryCount ? i.maxRetryCount : this.maxRetryCount,
                                    h = void 0 !== i.maxConcurrency ? i.maxConcurrency : this.maxConcurrency,
                                    _ = void 0 !== i.maxRequestsPerFrame ? i.maxRequestsPerFrame : this.maxRequestsPerFrame,
                                    f = this._downloaders[n] || this._downloaders.default;
                                zO((function(n, a) {
                                    if (0 === n && o._downloading.add(e, [r]), o.limited) {
                                        o._updateTime();
                                        var s = function(e, t) {
                                            o._totalNum--, o._handleQueueInNextFrame(h, _), a(e, t)
                                        };
                                        o._totalNum < h && o._totalNumThisPeriod < _ ? (f(FO(t, o.appendTimeStamp), i, s), o._totalNum++, o._totalNumThisPeriod++) : (o._queue.push({
                                            id: e,
                                            priority: i.priority || 0,
                                            url: t,
                                            options: i,
                                            done: s,
                                            handler: f
                                        }), o._queueDirty = !0, o._totalNum < h && o._handleQueueInNextFrame(h, _))
                                    } else f(FO(t, o.appendTimeStamp), i, a)
                                }), u, this.retryInterval, (function(t, n) {
                                    t || sf.add(e, n);
                                    for (var i = o._downloading.remove(e), r = 0, a = i.length; r < a; r++) i[r](t, n)
                                }))
                            }
                        }
                    }, t.loadSubpackage = function(e, t) {
                        i.assetManager.loadBundle(e, null, t)
                    }, t._updateTime = function() {
                        var e = Date.now(),
                            t = i.director.getDeltaTime(),
                            n = t > this._maxInterval ? this._maxInterval : t;
                        e - this._lastDate > 1e3 * n && (this._totalNumThisPeriod = 0, this._lastDate = e)
                    }, t._handleQueue = function(e, t) {
                        for (this._checkNextPeriod = !1, this._updateTime(); this._queue.length > 0 && this._totalNum < e && this._totalNumThisPeriod < t;) {
                            this._queueDirty && (this._queue.sort((function(e, t) {
                                return e.priority - t.priority
                            })), this._queueDirty = !1);
                            var n = this._queue.pop();
                            if (!n) break;
                            this._totalNum++, this._totalNumThisPeriod++, n.handler(FO(n.url, this.appendTimeStamp), n.options, n.done)
                        }
                        this._handleQueueInNextFrame(e, t)
                    }, t._handleQueueInNextFrame = function(e, t) {
                        !this._checkNextPeriod && this._queue.length > 0 && (dt(this._handleQueue.bind(this), e, t), this._checkNextPeriod = !0)
                    }, K(e, [{
                        key: "remoteServerAddress",
                        get: function() {
                            return this._remoteServerAddress
                        }
                    }]), e
                }());

            function aD(e, t, n, i) {
                var r = null,
                    o = null;
                try {
                    (r = new Wf)._nativeUrl = e, r._nativeAsset = t
                } catch (e) {
                    o = e
                }
                i(o, r)
            }

            function sD(e, t, n, i) {
                var r = new CO;
                r.json = t, i(null, r)
            }

            function cD(e, t, n, i) {
                var r = new xO;
                r.text = t, i(null, r)
            }

            function lD(e, t, n, i) {
                var r = new kR;
                r._nativeUrl = e, r._nativeAsset = t, i(null, r)
            }

            function uD(e, t, n, i) {
                var r = new Nf;
                r._nativeUrl = e, r._nativeAsset = t, i(null, r)
            }

            function hD(e, n, i, r) {
                var o = lf.get(n.name);
                o || (o = n.name === ff.RESOURCES ? XO : new qO, n.base = n.base || e + "/", o.init(n)), t.import("virtual:///prerequisite-imports/" + o.name).then((function() {
                    r(null, o)
                })).catch(r)
            }
            var _D = new(function() {
                    function e() {
                        this._creating = new nf, this._producers = {
                            ".png": aD,
                            ".jpg": aD,
                            ".bmp": aD,
                            ".jpeg": aD,
                            ".gif": aD,
                            ".ico": aD,
                            ".tiff": aD,
                            ".webp": aD,
                            ".image": aD,
                            ".pvr": aD,
                            ".pkm": aD,
                            ".txt": cD,
                            ".xml": cD,
                            ".vsh": cD,
                            ".fsh": cD,
                            ".atlas": cD,
                            ".tmx": cD,
                            ".tsx": cD,
                            ".fnt": cD,
                            ".json": sD,
                            ".ExportJson": sD,
                            ".binary": lD,
                            ".bin": lD,
                            ".dbbin": lD,
                            ".skel": lD,
                            bundle: hD,
                            default: uD
                        }
                    }
                    var t = e.prototype;
                    return t.register = function(e, t) {
                        "object" == typeof e ? Qe.mixin(this._producers, e) : this._producers[e] = t
                    }, t.create = function(e, t, n, i, r) {
                        var o = this,
                            a = this._producers[n] || this._producers.default,
                            s = af.get(e);
                        if (i.reloadAsset || !s) {
                            var c = this._creating.get(e);
                            c ? c.push(r) : (this._creating.add(e, [r]), a(e, t, i, (function(t, n) {
                                !t && n instanceof Nf && (n._uuid = e, GO(e, n, i.cacheAsset));
                                for (var r = o._creating.remove(e), a = 0, s = r.length; a < s; a++) r[a](t, n)
                            })))
                        } else r(null, s)
                    }, e
                }()),
                fD = new(function() {
                    function e() {
                        this._loading = new nf, this._unpackers = {
                            ".json": this.unpackJson
                        }
                    }
                    var t = e.prototype;
                    return t.unpackJson = function(e, t, n, i) {
                        var r = Qe.createMap(!0),
                            o = null;
                        if (Array.isArray(t)) {
                            (t = function(e) {
                                if (e[0] < 1) throw new Error(P(5304, e[0]));
                                xd(e, !0, void 0), Cd(e);
                                for (var t = new Pd(e[0]), n = e[1], i = e[2], r = e[3], o = e[4], a = e[5], s = 0; s < a.length; ++s) a[s].unshift(t, n, i, r, o);
                                return a
                            }(t)).length !== e.length && b(4915);
                            for (var a = 0; a < e.length; a++) r[e[a] + "@import"] = t[a]
                        } else {
                            var s = Qe._getClassId(yp),
                                c = Qe._getClassId(Wf);
                            if (t.type === s && t.data) {
                                var l = t.data;
                                l.length !== e.length && b(4915);
                                for (var u = 0; u < e.length; u++) r[e[u] + "@import"] = Od(s, {
                                    base: l[u][0],
                                    mipmaps: l[u][1]
                                })
                            } else if (t.type === c && t.data) {
                                var h = t.data;
                                h.length !== e.length && b(4915);
                                for (var _ = 0; _ < e.length; _++) r[e[_] + "@import"] = h[_]
                            } else o = new Error("unmatched type pack!"), r = null
                        }
                        i(o, r)
                    }, t.init = function() {
                        this._loading.clear()
                    }, t.register = function(e, t) {
                        "object" == typeof e ? Qe.mixin(this._unpackers, e) : this._unpackers[e] = t
                    }, t.unpack = function(e, t, n, i, r) {
                        t ? (0, this._unpackers[n])(e, t, i, r) : r(new Error("package data is wrong!"))
                    }, t.load = function(e, t, n) {
                        var i = this;
                        if (!e.isNative && e.info && e.info.packs)
                            if (sf.has(e.id)) n(null, sf.get(e.id));
                            else {
                                var r = e.info.packs,
                                    o = r.find((function(e) {
                                        return i._loading.has(e.uuid)
                                    }));
                                if (o) this._loading.get(o.uuid).push({
                                    onComplete: n,
                                    id: e.id
                                });
                                else {
                                    o = r[0], this._loading.add(o.uuid, [{
                                        onComplete: n,
                                        id: e.id
                                    }]);
                                    var a = bf(o.uuid, {
                                        ext: o.ext,
                                        bundle: e.config.name
                                    });
                                    oD.download(o.uuid, a, o.ext, e.options, (function(t, n) {
                                        sf.remove(o.uuid), t && p(t.message, t.stack), i.unpack(o.packedUuids, n, o.ext, e.options, (function(e, n) {
                                            if (!e)
                                                for (var r in n) sf.add(r, n[r]);
                                            for (var a = i._loading.remove(o.uuid), s = 0, c = a.length; s < c; s++) {
                                                var l = a[s];
                                                if (t || e) l.onComplete(t || e);
                                                else {
                                                    var u = n[l.id];
                                                    u ? l.onComplete(null, u) : l.onComplete(new Error("can not retrieve data from package"))
                                                }
                                            }
                                        }))
                                    }))
                                }
                            }
                        else oD.download(e.id, e.url, e.ext, e.options, n)
                    }, e
                }());

            function dD(e, t) {
                var n = !1;
                e.progress || (e.progress = {
                    finish: 0,
                    total: e.input.length,
                    canInvoke: !0
                }, n = !0);
                var r = e.options,
                    o = e.progress,
                    a = [],
                    s = o.total,
                    c = r.__exclude__ = r.__exclude__ || Object.create(null);
                e.output = [], HO(e.input, (function(r, l) {
                    if (!r.isNative && af.has(r.uuid)) {
                        var u = af.get(r.uuid);
                        return r.content = u.addRef(), e.output.push(r), o.canInvoke && e.dispatch("progress", ++o.finish, o.total, r), void l()
                    }
                    fD.load(r, e.options, (function(u, h) {
                        u ? e.isFinish || (!i.assetManager.force || n ? (p(u.message, u.stack), o.canInvoke = !1, t(u)) : (e.output.push(r), o.canInvoke && e.dispatch("progress", ++o.finish, o.total, r))) : e.isFinish || (r.file = h, e.output.push(r), r.isNative || (c[r.uuid] = !0, UO(r.uuid, h, c, a, r.config), o.total = s + a.length), o.canInvoke && e.dispatch("progress", ++o.finish, o.total, r)), l()
                    }))
                }), (function() {
                    if (e.isFinish) return BO(e, !0), void e.dispatch("error");
                    if (a.length > 0) {
                        var i = pf.create({
                            input: a,
                            progress: o,
                            options: r,
                            onProgress: e.onProgress,
                            onError: pf.prototype.recycle,
                            onComplete: function(r) {
                                var o;
                                r || ((o = e.output).push.apply(o, i.output), i.recycle()), n && pD(e), t(r)
                            }
                        });
                        hf.async(i)
                    } else n && pD(e), t()
                }))
            }

            function pD(e) {
                for (var t = e.output, n = 0, i = t.length; n < i; n++) t[n].content && t[n].content.decRef(!1)
            }
            var mD = new(function(e) {
                function t() {
                    return e.apply(this, arguments) || this
                }
                Q(t, e);
                var n = t.prototype;
                return n.parse = function(e) {
                    var t = this._parseXML(e).documentElement;
                    if ("plist" !== t.tagName) return x(5100), {};
                    for (var n = null, i = 0, r = t.childNodes.length; i < r && 1 !== (n = t.childNodes[i]).nodeType; i++);
                    return this._parseNode(n)
                }, n._parseNode = function(e) {
                    var t = null,
                        n = e.tagName;
                    if ("dict" === n) t = this._parseDict(e);
                    else if ("array" === n) t = this._parseArray(e);
                    else if ("string" === n)
                        if (1 === e.childNodes.length) t = e.firstChild.nodeValue;
                        else {
                            t = "";
                            for (var i = 0; i < e.childNodes.length; i++) t += e.childNodes[i].nodeValue
                        }
                    else "false" === n ? t = !1 : "true" === n ? t = !0 : "real" === n ? t = parseFloat(e.firstChild.nodeValue) : "integer" === n && (t = parseInt(e.firstChild.nodeValue, 10));
                    return t
                }, n._parseArray = function(e) {
                    for (var t = [], n = 0, i = e.childNodes.length; n < i; n++) {
                        var r = e.childNodes[n];
                        1 === r.nodeType && t.push(this._parseNode(r))
                    }
                    return t
                }, n._parseDict = function(e) {
                    for (var t = {}, n = "", i = 0, r = e.childNodes.length; i < r; i++) {
                        var o = e.childNodes[i];
                        1 === o.nodeType && ("key" === o.tagName ? n = o.firstChild.nodeValue : t[n] = this._parseNode(o))
                    }
                    return t
                }, t
            }(function() {
                function e() {
                    this._parser = null, window.DOMParser && (this._parser = new DOMParser)
                }
                var t = e.prototype;
                return t.parse = function(e) {
                    return this._parseXML(e)
                }, t._parseXML = function(e) {
                    if (this._parser) return this._parser.parseFromString(e, "text/xml");
                    throw new Error("Dom parser is not supported in this platform!")
                }, e
            }()));

            function gD(e, t) {
                return e[t] << 8 | e[t + 1]
            }
            var vD = new(function() {
                function e() {
                    this._parsing = new nf, this._parsers = {
                        ".png": this.parseImage,
                        ".jpg": this.parseImage,
                        ".bmp": this.parseImage,
                        ".jpeg": this.parseImage,
                        ".gif": this.parseImage,
                        ".ico": this.parseImage,
                        ".tiff": this.parseImage,
                        ".webp": this.parseImage,
                        ".image": this.parseImage,
                        ".pvr": this.parsePVRTex,
                        ".pkm": this.parsePKMTex,
                        ".astc": this.parseASTCTex,
                        ".mp3": this.parseAudio,
                        ".ogg": this.parseAudio,
                        ".wav": this.parseAudio,
                        ".m4a": this.parseAudio,
                        ".plist": this.parsePlist,
                        import: this.parseImport
                    }
                }
                var t = e.prototype;
                return t.parseImage = function(e, t, n) {
                    e instanceof HTMLImageElement ? n(null, e) : createImageBitmap(e, {
                        premultiplyAlpha: "none"
                    }).then((function(e) {
                        n(null, e)
                    }), (function(e) {
                        n(e, null)
                    }))
                }, t.parseAudio = function(e, t, n) {
                    e instanceof ArrayBuffer ? oS.__audioSupport.context.decodeAudioData(e, (function(e) {
                        n(null, e)
                    }), (function(e) {
                        n(new Error("Error with decoding audio data" + e.err), null)
                    })) : n(null, e)
                }, t.parsePVRTex = function(e, t, n) {
                    var i = null,
                        r = null;
                    try {
                        var o = e instanceof ArrayBuffer ? e : e.buffer,
                            a = new Int32Array(o, 0, 13);
                        if (55727696 === a[0]) {
                            var s = a[7],
                                c = a[6],
                                l = a[12] + 52;
                            r = {
                                _data: new Uint8Array(o, l),
                                _compressed: !0,
                                width: s,
                                height: c,
                                format: 0
                            }
                        } else {
                            if (559044176 !== a[11]) throw new Error("Invalid magic number in PVR header");
                            var u = a[0],
                                h = a[1],
                                _ = a[2];
                            r = {
                                _data: new Uint8Array(o, u),
                                _compressed: !0,
                                width: _,
                                height: h,
                                format: 0
                            }
                        }
                    } catch (e) {
                        i = e
                    }
                    n(i, r)
                }, t.parsePKMTex = function(e, t, n) {
                    var i = null,
                        r = null;
                    try {
                        var o = e instanceof ArrayBuffer ? e : e.buffer,
                            a = new Uint8Array(o),
                            s = gD(a, 6);
                        if (0 !== s && 1 !== s && 3 !== s) throw new Error("Invalid magic number in ETC header");
                        var c = gD(a, 12),
                            l = gD(a, 14);
                        gD(a, 8), gD(a, 10), r = {
                            _data: new Uint8Array(o, 16),
                            _compressed: !0,
                            width: c,
                            height: l,
                            format: 0
                        }
                    } catch (e) {
                        i = e
                    }
                    n(i, r)
                }, t.parseASTCTex = function(e, t, n) {
                    var i = null,
                        r = null;
                    try {
                        var o = e instanceof ArrayBuffer ? e : e.buffer,
                            a = new Uint8Array(o);
                        if (1554098963 !== a[0] + (a[1] << 8) + (a[2] << 16) + (a[3] << 24)) throw new Error("Invalid magic number in ASTC header");
                        var s = a[4],
                            c = a[5],
                            l = a[6];
                        if ((s < 3 || s > 6 || c < 3 || c > 6 || l < 3 || l > 6) && (s < 4 || 7 === s || 9 === s || 11 === s || s > 12 || c < 4 || 7 === c || 9 === c || 11 === c || c > 12 || 1 !== l)) throw new Error("Invalid block number in ASTC header");
                        var u = function(e, t) {
                                return 4 === e ? Mf.RGBA_ASTC_4x4 : 5 === e ? 4 === t ? Mf.RGBA_ASTC_5x4 : Mf.RGBA_ASTC_5x5 : 6 === e ? 5 === t ? Mf.RGBA_ASTC_6x5 : Mf.RGBA_ASTC_6x6 : 8 === e ? 5 === t ? Mf.RGBA_ASTC_8x5 : 6 === t ? Mf.RGBA_ASTC_8x6 : Mf.RGBA_ASTC_8x8 : 10 === e ? 5 === t ? Mf.RGBA_ASTC_10x5 : 6 === t ? Mf.RGBA_ASTC_10x6 : 8 === t ? Mf.RGBA_ASTC_10x8 : Mf.RGBA_ASTC_10x10 : 10 === t ? Mf.RGBA_ASTC_12x10 : Mf.RGBA_ASTC_12x12
                            }(s, c),
                            h = a[7] + (a[8] << 8) + (a[9] << 16),
                            _ = a[10] + (a[11] << 8) + (a[12] << 16);
                        a[13], a[14], a[15], r = {
                            _data: new Uint8Array(o, 16),
                            _compressed: !0,
                            width: h,
                            height: _,
                            format: u
                        }
                    } catch (e) {
                        i = e
                    }
                    n(i, r)
                }, t.parsePlist = function(e, t, n) {
                    var i = null,
                        r = mD.parse(e);
                    r || (i = new Error("parse failed")), n(i, r)
                }, t.parseImport = function(e, t, n) {
                    if (e) {
                        var i = null,
                            r = null;
                        try {
                            i = tp(e, t)
                        } catch (e) {
                            r = e
                        }
                        n(r, i)
                    } else n(new Error("The json file of asset " + t.__uuid__ + " is empty or missing"))
                }, t.init = function() {
                    this._parsing.clear()
                }, t.register = function(e, t) {
                    "object" == typeof e ? Ne(this._parsers, e) : this._parsers[e] = t
                }, t.parse = function(e, t, n, i, r) {
                    var o = this,
                        a = cf.get(e);
                    if (a) r(null, a);
                    else {
                        var s = this._parsing.get(e);
                        if (s) s.push(r);
                        else {
                            var c = this._parsers[n];
                            c ? (this._parsing.add(e, [r]), c(t, i, (function(t, n) {
                                t ? sf.remove(e) : xf(n) || cf.add(e, n);
                                for (var i = o._parsing.remove(e), r = 0, a = i.length; r < a; r++) i[r](t, n)
                            }))) : r(null, t)
                        }
                    }
                }, e
            }());

            function yD(e, t) {
                var n = !1;
                e.progress || (e.progress = {
                    finish: 0,
                    total: e.input.length,
                    canInvoke: !0
                }, n = !0);
                var r = e.options,
                    o = e.progress;
                r.__exclude__ = r.__exclude__ || Object.create(null), e.output = [], HO(e.input, (function(a, s) {
                    var c = pf.create({
                        input: a,
                        onProgress: e.onProgress,
                        options: r,
                        progress: o,
                        onComplete: function(r, l) {
                            r && !e.isFinish && (!i.assetManager.force || n ? (p(r.message, r.stack), o.canInvoke = !1, t(r)) : o.canInvoke && e.dispatch("progress", ++o.finish, o.total, a)), e.output.push(l), c.recycle(), s(null)
                        }
                    });
                    SD.async(c)
                }), (function() {
                    if (r.__exclude__ = null, e.isFinish) return BO(e, !0), void e.dispatch("error");
                    ! function(e) {
                        var t = e.source;
                        if (e.options.__outputAsArray__ || 1 !== t.length)
                            for (var n = e.output = [], i = 0, r = t.length; i < r; i++) n.push(t[i].content);
                        else e.output = t[0].content
                    }(e), BO(e, !0), t()
                }))
            }
            var SD = new rf("loadOneAsset", [function(e, t) {
                var n = e.output = e.input,
                    i = n.options,
                    r = n.isNative,
                    o = n.uuid,
                    a = n.file,
                    s = i.reloadAsset;
                a || !s && !r && af.has(o) ? t() : fD.load(n, e.options, (function(e, i) {
                    n.file = i, t(e)
                }))
            }, function(e, t) {
                var n = e.output = e.input,
                    i = e.progress,
                    r = e.options.__exclude__,
                    o = n.id,
                    a = n.file,
                    s = n.options;
                if (n.isNative) vD.parse(o, a, n.ext, s, (function(r, a) {
                    r ? t(r) : (n.content = a, i.canInvoke && e.dispatch("progress", ++i.finish, i.total, n), sf.remove(o), cf.remove(o), t())
                }));
                else {
                    var c = n.uuid;
                    if (c in r) {
                        var l = r[c],
                            u = l.finish,
                            h = l.content,
                            _ = l.err,
                            f = l.callbacks;
                        i.canInvoke && e.dispatch("progress", ++i.finish, i.total, n), u || WO(c, c, r) ? (h && h.addRef(), n.content = h, t(_)) : f.push({
                            done: t,
                            item: n
                        })
                    } else if (!s.reloadAsset && af.has(c)) {
                        var d = af.get(c);
                        n.content = d.addRef(), i.canInvoke && e.dispatch("progress", ++i.finish, i.total, n), t()
                    } else s.__uuid__ = c, vD.parse(o, a, "import", s, (function(n, i) {
                        n ? t(n) : function(e, t, n) {
                            var i = e.input,
                                r = e.progress,
                                o = i,
                                a = o.uuid,
                                s = o.id,
                                c = o.options,
                                l = o.config,
                                u = c.cacheAsset,
                                h = [];
                            t.addRef && t.addRef(), UO(a, t, Object.create(null), h, l), r.canInvoke && e.dispatch("progress", ++r.finish, r.total += h.length, i);
                            var _ = e.options.__exclude__[a] = {
                                    content: t,
                                    finish: !1,
                                    callbacks: [{
                                        done: n,
                                        item: i
                                    }]
                                },
                                f = pf.create({
                                    input: h,
                                    options: e.options,
                                    onProgress: e.onProgress,
                                    onError: pf.prototype.recycle,
                                    progress: r,
                                    onComplete: function(e) {
                                        if (t.decRef && t.decRef(!1), _.finish = !0, _.err = e, !e) {
                                            for (var n, i = Array.isArray(f.output) ? f.output : [f.output], r = Object.create(null), o = te(i); !(n = o()).done;) {
                                                var c = n.value;
                                                c && (r[c instanceof Nf ? c._uuid + "@import" : a + "@native"] = c)
                                            }! function(e, t, n) {
                                                var i = t.__depends__;
                                                if (i) {
                                                    for (var r = 0, o = i.length; r < o; r++) {
                                                        var a = i[r],
                                                            s = n[a.uuid + "@import"];
                                                        if (s) a.owner[a.prop] = s.addRef();
                                                        else {
                                                            if (p("The asset " + a.uuid + " is missing!"), a.type && a.type !== Nf) {
                                                                var c = new a.type;
                                                                c.initDefault(a.uuid), a.owner[a.prop] = c
                                                            }!0
                                                        }
                                                    }
                                                    t.__depends__ = null
                                                }
                                                t.__nativeDepend__ && (n[e + "@native"] ? t._nativeAsset = n[e + "@native"] : (!0, console.error("the native asset of " + e + " is missing!")), t.__nativeDepend__ = !1)
                                            }(a, t, r);
                                            try {
                                                "function" != typeof t.onLoaded || t.__onLoadedInvoked__ || t.__nativeDepend__ || (t.onLoaded(), t.__onLoadedInvoked__ = !0)
                                            } catch (e) {
                                                p("The asset " + a + " is invalid for some reason, detail message: " + e.message + ", stack: " + e.stack)
                                            }
                                            sf.remove(s), cf.remove(s), GO(a, t, u), f.recycle()
                                        }
                                        for (var l = _.callbacks, h = 0, d = l.length; h < d; h++) {
                                            var m = l[h];
                                            t.addRef && t.addRef(), m.item.content = t, m.done(e)
                                        }
                                        l.length = 0
                                    }
                                });
                            uf.async(f)
                        }(e, i, t)
                    }))
                }
            }]);

            function ED(e, t) {
                var n = e.options,
                    i = Object.create(null),
                    r = Object.create(null);
                for (var o in n) switch (o) {
                    case of.PATH:
                    case of.UUID:
                    case of.DIR:
                    case of.SCENE:
                    case of.URL:
                        break;
                    case "__requestType__":
                    case "__isNative__":
                    case "ext":
                    case "type":
                    case "__nativeName__":
                    case "audioLoadMode":
                    case "bundle":
                        i[o] = n[o];
                        break;
                    case "__exclude__":
                    case "__outputAsArray__":
                        r[o] = n[o];
                        break;
                    default:
                        i[o] = n[o], r[o] = n[o]
                }
                e.options = r;
                var a = pf.create({
                        input: e.input,
                        options: i
                    }),
                    s = null;
                try {
                    e.output = e.source = _f.sync(a)
                } catch (e) {
                    s = e;
                    for (var c = 0, l = a.output.length; c < l; c++) a.output[c].recycle()
                }
                a.recycle(), t(s)
            }
            var TD = function() {
                function e() {
                    this.uuid = "", this.url = "", this.ext = ".json", this.content = null, this.file = null, this.info = null, this.config = null, this.isNative = !1, this.options = Object.create(null), this._id = ""
                }
                return e.create = function() {
                    return 0 !== e._deadPool.length ? e._deadPool.pop() : new e
                }, e.prototype.recycle = function() {
                    e._deadPool.length !== e.MAX_DEAD_NUM && (this._id = "", this.uuid = "", this.url = "", this.ext = ".json", this.content = null, this.file = null, this.info = null, this.config = null, this.isNative = !1, this.options = Object.create(null), e._deadPool.push(this))
                }, K(e, [{
                    key: "id",
                    get: function() {
                        return this._id || (this._id = this.uuid + "@" + (this.isNative ? "native" : "import")), this._id
                    }
                }]), e
            }();
            TD.MAX_DEAD_NUM = 500, TD._deadPool = [];
            var AD = [];

            function xD(e) {
                var t = e.options,
                    n = Array.isArray(e.input) ? e.input : [e.input];
                e.output = [];
                for (var i = function(i) {
                        var r = n[i],
                            o = TD.create(),
                            a = null,
                            s = null;
                        if ("string" == typeof r && ((r = Object.create(null))[t.__requestType__ || of .UUID] = n[i]), "object" == typeof r)
                            for (var c in De(r, t), r.preset && De(r, df[r.preset]), r) {
                                switch (c) {
                                    case of.UUID:
                                        if ("break" === function() {
                                                var e = o.uuid = Sf(r.uuid);
                                                if (!r.bundle) {
                                                    var t = lf.find((function(t) {
                                                        return !!t.getAssetInfo(e)
                                                    }));
                                                    r.bundle = t && t.name
                                                }
                                                if (lf.has(r.bundle)) {
                                                    if (a = lf.get(r.bundle).config, (s = a.getAssetInfo(e)) && s.redirect) {
                                                        if (!lf.has(s.redirect)) throw new Error("Please load bundle " + s.redirect + " first");
                                                        a = lf.get(s.redirect).config, s = a.getAssetInfo(e)
                                                    }
                                                    o.config = a, o.info = s
                                                }
                                                return o.ext = r.ext || ".json", "break"
                                            }()) break;
                                    case "__requestType__":
                                    case "ext":
                                    case "bundle":
                                    case "preset":
                                    case "type":
                                        break;
                                    case of.DIR:
                                        if (lf.has(r.bundle)) {
                                            lf.get(r.bundle).config.getDirWithPath(r.dir, r.type, AD);
                                            for (var l, u = te(AD); !(l = u()).done;) {
                                                var h = l.value;
                                                n.push({
                                                    uuid: h.uuid,
                                                    __isNative__: !1,
                                                    ext: ".json",
                                                    bundle: r.bundle
                                                })
                                            }
                                            AD.length = 0
                                        }
                                        o.recycle(), o = null;
                                        break;
                                    case of.PATH:
                                        if (lf.has(r.bundle)) {
                                            if (a = lf.get(r.bundle).config, (s = a.getInfoWithPath(r.path, r.type)) && s.redirect) {
                                                if (!lf.has(s.redirect)) throw new Error("you need to load bundle " + s.redirect + " first");
                                                a = lf.get(s.redirect).config, s = a.getAssetInfo(s.uuid)
                                            }
                                            if (!s) throw o.recycle(), new Error("Bundle " + r.bundle + " doesn't contain " + r.path);
                                            o.config = a, o.uuid = s.uuid, o.info = s
                                        }
                                        o.ext = r.ext || ".json";
                                        break;
                                    case of.SCENE:
                                        if (!r.bundle) {
                                            var _ = lf.find((function(e) {
                                                return !!e.getSceneInfo(r.scene)
                                            }));
                                            r.bundle = _ && _.name
                                        }
                                        if (lf.has(r.bundle)) {
                                            if (a = lf.get(r.bundle).config, (s = a.getSceneInfo(r.scene)) && s.redirect) {
                                                if (!lf.has(s.redirect)) throw new Error("you need to load bundle " + s.redirect + " first");
                                                a = lf.get(s.redirect).config, s = a.getAssetInfo(s.uuid)
                                            }
                                            if (!s) throw o.recycle(), new Error("Bundle " + a.name + " doesn't contain scene " + r.scene);
                                            o.config = a, o.uuid = s.uuid, o.info = s
                                        }
                                        break;
                                    case "__isNative__":
                                        o.isNative = r.__isNative__;
                                        break;
                                    case of.URL:
                                        o.url = r.url, o.uuid = r.uuid || r.url, o.ext = r.ext || bi(r.url), o.isNative = void 0 === r.__isNative__ || r.__isNative__;
                                        break;
                                    default:
                                        o.options[c] = r[c]
                                }
                                if (!o) break
                            }
                        if (!o) return "continue";
                        if (e.output.push(o), !o.uuid && !o.url) throw new Error("Can not parse this input:" + JSON.stringify(r))
                    }, r = 0; r < n.length; r++) i(r);
                return null
            }

            function CD(e) {
                for (var t = e.output = e.input, n = 0; n < t.length; n++) {
                    var r = t[n];
                    if (!r.url) {
                        var o, a, s = r.config;
                        a = r.isNative ? s && s.nativeBase ? s.base + s.nativeBase : i.assetManager.generalNativeBase : s && s.importBase ? s.base + s.importBase : i.assetManager.generalImportBase;
                        var c = r.uuid,
                            l = "";
                        r.info && (l = r.isNative ? r.info.nativeVer ? "." + r.info.nativeVer : "" : r.info.ver ? "." + r.info.ver : ""), o = ".ttf" === r.ext ? a + "/" + c.slice(0, 2) + "/" + c + l + "/" + r.options.__nativeName__ : a + "/" + c.slice(0, 2) + "/" + c + l + r.ext, r.url = o
                    }
                }
                return null
            }
            var bD = e("AssetManager", function() {
                function e() {
                    this.pipeline = uf.append(ED).append(yD), this.fetchPipeline = hf.append(ED).append(dD), this.transformPipeline = _f.append(xD).append(CD), this.bundles = lf, this.assets = af, this.generalImportBase = "", this.generalNativeBase = "", this.dependUtil = ip, this.force = !1, this.allowImageBitmap = !oS.isMobile, this.utils = Of, this.downloader = oD, this.parser = vD, this.packManager = fD, this.cacheAsset = !0, this.cacheManager = null, this.presets = df, this.factory = _D, this.preprocessPipe = ED, this.fetchPipe = dD, this.loadPipe = yD, this.references = null, this._releaseManager = MO, this._files = sf, this._parsed = cf, this._parsePipeline = null
                }
                var t = e.prototype;
                return t.init = function(e) {
                    void 0 === e && (e = {}), this._files.clear(), this._parsed.clear(), this._releaseManager.init(), this.assets.clear(), this.bundles.clear(), this.packManager.init(), this.downloader.init(e.server, e.bundleVers, e.remoteBundles), this.parser.init(), this.dependUtil.init();
                    var t = e.importBase || "";
                    t && t.endsWith("/") && (t = t.substr(0, t.length - 1));
                    var n = e.nativeBase || "";
                    n && n.endsWith("/") && (n = n.substr(0, n.length - 1)), this.generalImportBase = t, this.generalNativeBase = n
                }, t.getBundle = function(e) {
                    return lf.get(e) || null
                }, t.removeBundle = function(e) {
                    e._destroy(), lf.remove(e.name)
                }, t.loadAny = function(e, t, n, i) {
                    var r = kO(t, n, i),
                        o = r.options,
                        a = r.onProgress,
                        s = r.onComplete;
                    o.preset = o.preset || "default", e = Array.isArray(e) ? e.slice() : e;
                    var c = pf.create({
                        input: e,
                        onProgress: a,
                        onComplete: jO(s),
                        options: o
                    });
                    uf.async(c)
                }, t.preloadAny = function(e, t, n, i) {
                    var r = kO(t, n, i),
                        o = r.options,
                        a = r.onProgress,
                        s = r.onComplete;
                    o.preset = o.preset || "preload", e = Array.isArray(e) ? e.slice() : e;
                    var c = pf.create({
                        input: e,
                        onProgress: a,
                        onComplete: jO(s),
                        options: o
                    });
                    hf.async(c)
                }, t.postLoadNative = function(e, t, n) {
                    var i = kO(t, void 0, n),
                        r = i.options,
                        o = i.onComplete;
                    if (e._native && e.__nativeDepend__) {
                        var a = ip.getNativeDep(e._uuid);
                        if (a) {
                            if (!lf.has(a.bundle)) {
                                var s = lf.find((function(t) {
                                    return !!t.getAssetInfo(e._uuid)
                                }));
                                s && (a.bundle = s.name)
                            }
                            this.loadAny(a, r, (function(t, n) {
                                t ? p(t.message, t.stack) : e.isValid && e.__nativeDepend__ && (e._nativeAsset = n, e.__nativeDepend__ = !1), o && o(t)
                            }))
                        }
                    } else jO(o)(null)
                }, t.loadRemote = function(e, t, n) {
                    var i = kO(t, void 0, n),
                        r = i.options,
                        o = i.onComplete;
                    r.reloadAsset || !this.assets.has(e) ? (r.__isNative__ = !0, r.preset = r.preset || "remote", this.loadAny({
                        url: e
                    }, r, null, (function(t, n) {
                        t ? (p(t.message, t.stack), o && o(t, n)) : _D.create(e, n, r.ext || bi(e), r, (function(e, t) {
                            o && o(e, t)
                        }))
                    }))) : jO(o)(null, this.assets.get(e))
                }, t.loadBundle = function(e, t, n) {
                    var i = kO(t, void 0, n),
                        r = i.options,
                        o = i.onComplete,
                        a = wi(e);
                    this.bundles.has(a) ? jO(o)(null, this.getBundle(a)) : (r.preset = r.preset || "bundle", r.ext = "bundle", r.__isNative__ = !0, this.loadAny({
                        url: e
                    }, r, null, (function(t, n) {
                        t ? (p(t.message, t.stack), o && o(t, n)) : _D.create(e, n, "bundle", r, (function(e, t) {
                            o && o(e, t)
                        }))
                    })))
                }, t.releaseAsset = function(e) {
                    MO.tryRelease(e, !0)
                }, t.releaseUnusedAssets = function() {
                    af.forEach((function(e) {
                        MO.tryRelease(e)
                    }))
                }, t.releaseAll = function() {
                    af.forEach((function(e) {
                        MO.tryRelease(e, !0)
                    }))
                }, t.loadWithJson = function() {
                    throw new Error("Only valid in Editor")
                }, K(e, [{
                    key: "main",
                    get: function() {
                        return lf.get(ff.MAIN) || null
                    }
                }, {
                    key: "resources",
                    get: function() {
                        return lf.get(ff.RESOURCES) || null
                    }
                }]), e
            }());
            bD.Pipeline = rf, bD.Task = pf, bD.Cache = nf, bD.RequestItem = TD, bD.Bundle = qO, bD.BuiltinBundleName = ff;
            var RD = e("assetManager", i.assetManager = new bD);
            i.AssetManager = bD;
            var wD = [".png", ".jpg", ".bmp", ".jpeg", ".gif", ".ico", ".tiff", ".webp", ".image", ".pvr", ".pkm", ".astc"],
                ID = [".mp3", ".ogg", ".wav", ".m4a"];

            function PD() {
                return !0
            }
            var OD = {
                    transformURL: function(e) {
                        var t = Tf(e);
                        if (!t) return e;
                        var n = lf.find((function(e) {
                            return !!e.getAssetInfo(t)
                        }));
                        if (!n) return e;
                        var i, r = n.getAssetInfo(t);
                        if (!(i = e.startsWith(n.base + n.config.nativeBase) ? r.nativeVer || "" : r.ver || "") || -1 !== e.indexOf(i)) return e;
                        var o = !1;
                        if (".ttf" === bi(e) && (o = !0), o) {
                            var a = Ii(e),
                                s = wi(e);
                            e = a + "." + i + "/" + s
                        } else e = e.replace(/.*[/\\][0-9a-fA-F]{2}[/\\]([0-9a-fA-F-@]{8,}).*/, (function(e) {
                            return e + "." + i
                        }));
                        return e
                    }
                },
                DD = e("CCLoader", function() {
                    function e() {
                        this._autoReleaseSetting = Object.create(null), this._parseLoadResArgs = VO
                    }
                    var t = e.prototype;
                    return t.load = function(e, t, n) {
                        void 0 === n && void 0 !== t && (n = t, t = null);
                        for (var i = Array.isArray(e) ? e : [e], r = 0; r < i.length; r++) {
                            var o = i[r];
                            "string" == typeof o ? i[r] = {
                                url: o,
                                __isNative__: !0
                            } : (o.type && (o.ext = "." + o.type, o.type = void 0), o.url && (o.__isNative__ = !0))
                        }
                        var a = [],
                            s = [];
                        RD.loadAny(i, null, (function(e, n, i) {
                            i.content && (wD.includes(i.ext) ? a.push(i.content) : ID.includes(i.ext) && s.push(i.content)), t && t(e, n, i)
                        }), (function(e, t) {
                            var r = null;
                            if (!e) {
                                t = Array.isArray(t) ? t : [t];
                                for (var o = function(e) {
                                        var n = t[e];
                                        if (!(n instanceof Nf)) {
                                            var r = n,
                                                o = i[e].url;
                                            a.includes(r) ? _D.create(o, n, ".png", {}, (function(n, i) {
                                                r = t[e] = i
                                            })) : s.includes(r) && _D.create(o, n, ".mp3", {}, (function(n, i) {
                                                r = t[e] = i
                                            })), af.add(o, r)
                                        }
                                    }, c = 0; c < t.length; c++) o(c);
                                if (t.length > 1) {
                                    var l = Object.create(null);
                                    t.forEach((function(e) {
                                        l[e._uuid] = e
                                    })), r = {
                                        isCompleted: PD,
                                        _map: l
                                    }
                                } else r = t[0]
                            }
                            n && n(e, r)
                        }))
                    }, t.getXMLHttpRequest = function() {
                        return new XMLHttpRequest
                    }, t.getItem = function(e) {
                        return RD.assets.has(e) ? {
                            content: RD.assets.get(e)
                        } : null
                    }, t.loadRes = function(e, t, n, i) {
                        var r = this._parseLoadResArgs(t, n, i),
                            o = r.type,
                            a = r.onProgress,
                            s = r.onComplete,
                            c = bi(e);
                        c && !XO.getInfoWithPath(e, o) && (e = e.slice(0, -c.length)), XO.load(e, o, a, s)
                    }, t.loadResArray = function(e, t, n, i) {
                        var r = this._parseLoadResArgs(t, n, i),
                            o = r.type,
                            a = r.onProgress,
                            s = r.onComplete;
                        e.forEach((function(t, n) {
                            var i = bi(t);
                            i && !XO.getInfoWithPath(t, o) && (e[n] = t.slice(0, -i.length))
                        })), XO.load(e, o, a, s)
                    }, t.loadResDir = function(e, t, n, i) {
                        var r = this._parseLoadResArgs(t, n, i),
                            o = r.type,
                            a = r.onProgress,
                            s = r.onComplete;
                        XO.loadDir(e, o, a, (function(t, n) {
                            var i = [];
                            t || (i = XO.getDirWithPath(e, o).map((function(e) {
                                return e.path
                            }))), s && s(t, n, i)
                        }))
                    }, t.getRes = function(e, t) {
                        return af.has(e) ? af.get(e) : XO.get(e, t)
                    }, t.getResCount = function() {
                        return af.count
                    }, t.getDependsRecursively = function(e) {
                        if (!e) return [];
                        var t = "string" == typeof e ? e : e._uuid;
                        return ip.getDepsRecursively(t).concat([t])
                    }, t.addDownloadHandlers = function(e) {
                        var t = Object.create(null),
                            n = function(n) {
                                var i = e[n];
                                t["." + n] = function(e, t, n) {
                                    i({
                                        url: e
                                    }, n)
                                }
                            };
                        for (var i in e) n(i);
                        oD.register(t)
                    }, t.addLoadHandlers = function(e) {
                        var t = Object.create(null),
                            n = function(n) {
                                var i = e[n];
                                t["." + n] = function(e, t, n) {
                                    i({
                                        content: e
                                    }, n)
                                }
                            };
                        for (var i in e) n(i);
                        vD.register(t)
                    }, t.release = function(e) {
                        if (Array.isArray(e))
                            for (var t = 0; t < e.length; t++) {
                                var n = e[t];
                                "string" == typeof n && (n = af.get(n)), RD.releaseAsset(n)
                            } else e && ("string" == typeof e && (e = af.get(e)), RD.releaseAsset(e))
                    }, t.releaseAsset = function(e) {
                        RD.releaseAsset(e)
                    }, t.releaseRes = function(e, t) {
                        XO.release(e, t)
                    }, t.releaseAll = function() {
                        RD.releaseAll(), af.clear()
                    }, t.removeItem = function(e) {
                        return !!af.remove(e)
                    }, t.setAutoRelease = function(e, t) {
                        "object" == typeof e && (e = e._uuid), this._autoReleaseSetting[e] = !!t
                    }, t.setAutoReleaseRecursively = function(e, t) {
                        "object" == typeof e && (e = e._uuid), t = !!t, this._autoReleaseSetting[e] = t;
                        for (var n = ip.getDepsRecursively(e), i = 0; i < n.length; i++) this._autoReleaseSetting[n[i]] = t
                    }, t.isAutoRelease = function(e) {
                        return "object" == typeof e && (e = e._uuid), !!this._autoReleaseSetting[e]
                    }, K(e, [{
                        key: "onProgress",
                        set: function(e) {
                            LO = e
                        }
                    }, {
                        key: "_cache",
                        get: function() {
                            return af._map
                        }
                    }, {
                        key: "md5Pipe",
                        get: function() {
                            return OD
                        }
                    }, {
                        key: "downloader",
                        get: function() {
                            return oD
                        }
                    }, {
                        key: "loader",
                        get: function() {
                            return RD.parser
                        }
                    }]), e
                }()),
                ND = e("loader", new DD),
                MD = e("AssetLibrary", {
                    init: function(e) {
                        e.importBase = e.libraryPath, e.nativeBase = e.rawAssetsBase, RD.init(e), e.rawAssets && XO.init({
                            base: "",
                            deps: [],
                            scenes: {},
                            redirect: [],
                            debug: !0,
                            packs: {},
                            types: [],
                            versions: {
                                import: [],
                                native: []
                            },
                            name: ff.RESOURCES,
                            importBase: e.importBase,
                            nativeBase: e.nativeBase,
                            paths: e.rawAssets.assets,
                            uuids: Object.keys(e.rawAssets.assets)
                        })
                    },
                    loadAsset: function(e, t) {
                        RD.loadAny(e, t)
                    }
                }),
                LD = e("url", {});
            U(LD, "url", [{
                name: "normalize",
                target: RD.utils,
                targetName: "assetManager.utils",
                newName: "normalize"
            }, {
                name: "raw",
                targetName: "Asset.prototype",
                newName: "nativeUrl",
                customFunction: function(e) {
                    return e.startsWith("resources/") ? bf({
                        path: Pi(e.substr(10)),
                        bundle: ff.RESOURCES,
                        __isNative__: !0,
                        ext: bi(e)
                    }) : ""
                }
            }]), G(MD, "AssetLibrary", [{
                name: "getLibUrlNoExt",
                suggest: "AssetLibrary.getLibUrlNoExt was removed, if you want to transform url, please use cc.assetManager.utils.getUrlWithUuid instead"
            }, {
                name: "queryAssetInfo",
                suggest: "AssetLibrary.queryAssetInfo was removed"
            }]), G(ND, "loader", [{
                name: "releaseResDir",
                suggest: "loader.releaseResDir was removed, please use assetManager.releaseAsset instead"
            }, {
                name: "flowInDeps",
                suggest: "loader.flowInDeps was removed"
            }, {
                name: "assetLoader",
                suggest: "cc.loader.assetLoader was removed, assetLoader and md5Pipe were merged into cc.assetManager.transformPipeline"
            }]), U(i, "cc", [{
                name: "loader",
                newName: "assetManager",
                logTimes: 1,
                customGetter: function() {
                    return ND
                }
            }, {
                name: "AssetLibrary",
                newName: "assetManager",
                logTimes: 1,
                customGetter: function() {
                    return MD
                }
            }, {
                name: "Pipeline",
                target: bD,
                targetName: "AssetManager",
                newName: "Pipeline",
                logTimes: 1
            }, {
                name: "url",
                targetName: "assetManager",
                newName: "utils",
                logTimes: 1,
                customGetter: function() {
                    return LD
                }
            }]), G(i, "cc", [{
                name: "LoadingItems",
                suggest: P(1400, "cc.LoadingItems", "cc.AssetManager.Task")
            }]), U(rt, "macro", [{
                name: "DOWNLOAD_MAX_CONCURRENT",
                target: oD,
                targetName: "assetManager.downloader",
                newName: "maxConcurrency"
            }]), U(RO, "director", [{
                name: "_getSceneUuid",
                targetName: "assetManager.main",
                newName: "getSceneInfo",
                customFunction: function(e) {
                    var t;
                    return RD.main ? null === (t = RD.main.getSceneInfo(e)) || void 0 === t ? void 0 : t.uuid : ""
                }
            }]), U(WC, "game", [{
                name: "_sceneInfos",
                targetName: "assetManager.main",
                newName: "getSceneInfo",
                customGetter: function() {
                    var e = [];
                    return RD.main && RD.main.config.scenes.forEach((function(t) {
                        e.push(t)
                    })), e
                }
            }]);
            var BD, FD, zD, UD, GD, HD, kD, VD, WD, jD, qD, XD, YD, KD, ZD = MO._autoRelease;
            MO._autoRelease = function(e, t, n) {
                ZD.call(MO, e, t, n);
                for (var i = ND._autoReleaseSetting, r = Object.keys(i), o = 0; o < r.length; o++) {
                    var a = r[o];
                    if (!0 === i[a]) {
                        var s = af.get(a);
                        s && MO.tryRelease(s)
                    }
                }
            };
            var QD, JD, $D, eN, tN, nN, iN, rN, oN, aN, sN, cN, lN, uN, hN, _N, fN, dN, pN, mN, gN, vN, yN, SN, EN, TN, AN, xN, CN, bN, RN, wN, IN, PN, ON, DN, NN, MN, LN, BN, FN, zN, UN, GN, HN, kN, VN, WN, jN, qN, XN, YN, KN, ZN, QN, JN, $N, eM, tM, nM, iM, rM, oM, aM, sM, cM, lM, uM = e("EventHandler", (BD = A_("cc.ClickEvent"), FD = ef(i.Node), zD = G_(), UD = G_(), GD = G_(), HD = G_(), BD((KD = function() {
                function e() {
                    ne(this, "target", WD, this), ne(this, "component", jD, this), ne(this, "_componentId", qD, this), ne(this, "handler", XD, this), ne(this, "customEventData", YD, this)
                }
                e.emitEvents = function(t) {
                    for (var n = arguments.length, i = new Array(n > 1 ? n - 1 : 0), r = 1; r < n; r++) i[r - 1] = arguments[r];
                    for (var o = 0, a = t.length; o < a; o++) {
                        var s = t[o];
                        s instanceof e && s.emit(i)
                    }
                };
                var t = e.prototype;
                return t.emit = function(e) {
                    var t = this.target;
                    if (i.isValid(t)) {
                        this._genCompIdIfNeeded();
                        var n = i.js._getClassById(this._componentId),
                            r = t.getComponent(n);
                        if (i.isValid(r)) {
                            var o = r[this.handler];
                            "function" == typeof o && (null != this.customEventData && "" !== this.customEventData && (e = e.slice()).push(this.customEventData), o.apply(r, e))
                        }
                    }
                }, t._compName2Id = function(e) {
                    var t = i.js.getClassByName(e);
                    return i.js._getClassId(t)
                }, t._compId2Name = function(e) {
                    var t = i.js._getClassById(e);
                    return i.js.getClassName(t)
                }, t._genCompIdIfNeeded = function() {
                    this._componentId || (this._componentName = this.component, this.component = "")
                }, K(e, [{
                    key: "_componentName",
                    get: function() {
                        return this._genCompIdIfNeeded(), this._compId2Name(this._componentId)
                    },
                    set: function(e) {
                        this._componentId = this._compName2Id(e)
                    }
                }]), e
            }(), WD = ie((VD = KD).prototype, "target", [w_, FD, zD], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return null
                }
            }), jD = ie(VD.prototype, "component", [w_, F_, UD], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return ""
                }
            }), qD = ie(VD.prototype, "_componentId", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return ""
                }
            }), XD = ie(VD.prototype, "handler", [w_, F_, GD], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return ""
                }
            }), YD = ie(VD.prototype, "customEventData", [w_, F_, HD], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return ""
                }
            }), kD = VD)) || kD));
            i.Component.EventHandler = uM;
            var hM, _M, fM, dM, pM, mM, gM, vM, yM, SM, EM, TM = new En,
                AM = $e(Kh),
                xM = $e(Yh),
                CM = $e(Zh),
                bM = $e(Jh),
                RM = $e(Qh),
                wM = $e({
                    SKYBOX: h_ | $a.DEPTH_STENCIL,
                    SOLID_COLOR: $a.ALL,
                    DEPTH_ONLY: $a.DEPTH_STENCIL,
                    DONT_CLEAR: $a.NONE
                }),
                IM = (QD = A_("cc.Camera"), JD = B_(), $D = D_(), eN = q_(), tN = G_(), nN = ef(Pu.BitMask), iN = q_(), rN = G_(), oN = ef(wM), aN = q_(), sN = G_(), cN = q_(), lN = G_(), uN = q_(), hN = G_(), _N = q_(), fN = G_(), dN = ef(AM), pN = q_(), mN = G_(), gN = ef(xM), vN = q_(), yN = G_(), SN = q_(), EN = G_(), TN = q_(), AN = G_(), xN = q_(), CN = G_(), bN = q_(), RN = G_(), wN = ef(CM), IN = q_(), PN = G_(), ON = ef(bM), DN = q_(), NN = G_(), MN = ef(RM), LN = q_(), BN = G_(), FN = q_(), zN = G_(), UN = ef(tE), GN = q_(), HN = G_(), hM = QD(kN = JD(kN = $D(kN = O_((lM = cM = function(e) {
                    function t() {
                        for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                        return ne(t = e.call.apply(e, [this].concat(i)) || this, "_projection", WN, $(t)), ne(t, "_priority", jN, $(t)), ne(t, "_fov", qN, $(t)), ne(t, "_fovAxis", XN, $(t)), ne(t, "_orthoHeight", YN, $(t)), ne(t, "_near", KN, $(t)), ne(t, "_far", ZN, $(t)), ne(t, "_color", QN, $(t)), ne(t, "_depth", JN, $(t)), ne(t, "_stencil", $N, $(t)), ne(t, "_clearFlags", eM, $(t)), ne(t, "_rect", tM, $(t)), ne(t, "_aperture", nM, $(t)), ne(t, "_shutter", iM, $(t)), ne(t, "_iso", rM, $(t)), ne(t, "_screenScale", oM, $(t)), ne(t, "_visibility", aM, $(t)), ne(t, "_targetTexture", sM, $(t)), t._camera = null, t._inEditorMode = !1, t._flows = void 0, t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.onLoad = function() {
                        this._createCamera()
                    }, n.onEnable = function() {
                        this.node.hasChangedFlags |= r_.POSITION, this._camera && this._attachToScene()
                    }, n.onDisable = function() {
                        this._camera && this._detachFromScene()
                    }, n.onDestroy = function() {
                        this._camera && (this._camera.destroy(), this._camera = null), this._targetTexture && this._targetTexture.off("resize")
                    }, n.screenPointToRay = function(e, t, n) {
                        return n || (n = ua.create()), this._camera && this._camera.screenPointToRay(n, e, t), n
                    }, n.worldToScreen = function(e, t) {
                        return t || (t = new En), this._camera && this._camera.worldToScreen(t, e), t
                    }, n.screenToWorld = function(e, t) {
                        return t || (t = this.node.getWorldPosition()), this._camera && this._camera.screenToWorld(t, e), t
                    }, n.convertToUINode = function(e, t, n) {
                        if (n || (n = new En), !this._camera) return n;
                        this.worldToScreen(e, TM);
                        var r = t.getComponent("cc.UITransform"),
                            o = QC.getVisibleSize(),
                            a = TM.x - .5 * this._camera.width,
                            s = TM.y - .5 * this._camera.height;
                        return TM.x = a / i.view.getScaleX() + .5 * o.width, TM.y = s / i.view.getScaleY() + .5 * o.height, r && r.convertToNodeSpaceAR(TM, n), n
                    }, n._createCamera = function() {
                        this._camera || (this._camera = i.director.root.createCamera(), this._camera.initialize({
                            name: this.node.name,
                            node: this.node,
                            projection: this._projection,
                            window: this._inEditorMode ? i.director.root && i.director.root.mainWindow : i.director.root && i.director.root.tempWindow,
                            priority: this._priority
                        }), this._camera.viewport = this._rect, this._camera.fovAxis = this._fovAxis, this._camera.fov = rn(this._fov), this._camera.orthoHeight = this._orthoHeight, this._camera.nearClip = this._near, this._camera.farClip = this._far, this._camera.clearColor = this._color, this._camera.clearDepth = this._depth, this._camera.clearStencil = this._stencil, this._camera.clearFlag = this._clearFlags, this._camera.visibility = this._visibility, this._camera.aperture = this._aperture, this._camera.shutter = this._shutter, this._camera.iso = this._iso), this._updateTargetTexture()
                    }, n._attachToScene = function() {
                        this.node.scene && this._camera && (this._camera && this._camera.scene && this._camera.scene.removeCamera(this._camera), this._getRenderScene().addCamera(this._camera))
                    }, n._detachFromScene = function() {
                        this._camera && this._camera.scene && this._camera.scene.removeCamera(this._camera)
                    }, n._chechTargetTextureEvent = function(e) {
                        var t = this;
                        e && e.off("resize"), this._targetTexture && this._targetTexture.on("resize", (function(e) {
                            t._camera && t._camera.setFixedSize(e.width, e.height)
                        }), this)
                    }, n._updateTargetTexture = function() {
                        if (this._camera && this._targetTexture) {
                            var e = this._targetTexture.window;
                            this._camera.changeTargetWindow(e), this._camera.setFixedSize(e.width, e.height)
                        }
                    }, K(t, [{
                        key: "camera",
                        get: function() {
                            return this._camera
                        }
                    }, {
                        key: "priority",
                        get: function() {
                            return this._priority
                        },
                        set: function(e) {
                            this._priority = e, this._camera && (this._camera.priority = e)
                        }
                    }, {
                        key: "visibility",
                        get: function() {
                            return this._visibility
                        },
                        set: function(e) {
                            this._visibility = e, this._camera && (this._camera.visibility = e)
                        }
                    }, {
                        key: "clearFlags",
                        get: function() {
                            return this._clearFlags
                        },
                        set: function(e) {
                            this._clearFlags = e, this._camera && (this._camera.clearFlag = e)
                        }
                    }, {
                        key: "clearColor",
                        get: function() {
                            return this._color
                        },
                        set: function(e) {
                            this._color.set(e), this._camera && (this._camera.clearColor = this._color)
                        }
                    }, {
                        key: "clearDepth",
                        get: function() {
                            return this._depth
                        },
                        set: function(e) {
                            this._depth = e, this._camera && (this._camera.clearDepth = e)
                        }
                    }, {
                        key: "clearStencil",
                        get: function() {
                            return this._stencil
                        },
                        set: function(e) {
                            this._stencil = e, this._camera && (this._camera.clearStencil = e)
                        }
                    }, {
                        key: "projection",
                        get: function() {
                            return this._projection
                        },
                        set: function(e) {
                            this._projection = e, this._camera && (this._camera.projectionType = e)
                        }
                    }, {
                        key: "fovAxis",
                        get: function() {
                            return this._fovAxis
                        },
                        set: function(e) {
                            e !== this._fovAxis && (this._fovAxis = e, this._camera && (this._camera.fovAxis = e, e === Yh.VERTICAL ? this.fov = this._fov * this._camera.aspect : this.fov = this._fov / this._camera.aspect))
                        }
                    }, {
                        key: "fov",
                        get: function() {
                            return this._fov
                        },
                        set: function(e) {
                            this._fov = e, this._camera && (this._camera.fov = rn(e))
                        }
                    }, {
                        key: "orthoHeight",
                        get: function() {
                            return this._orthoHeight
                        },
                        set: function(e) {
                            this._orthoHeight = e, this._camera && (this._camera.orthoHeight = e)
                        }
                    }, {
                        key: "near",
                        get: function() {
                            return this._near
                        },
                        set: function(e) {
                            this._near = e, this._camera && (this._camera.nearClip = e)
                        }
                    }, {
                        key: "far",
                        get: function() {
                            return this._far
                        },
                        set: function(e) {
                            this._far = e, this._camera && (this._camera.farClip = e)
                        }
                    }, {
                        key: "aperture",
                        get: function() {
                            return this._aperture
                        },
                        set: function(e) {
                            this._aperture = e, this._camera && (this._camera.aperture = e)
                        }
                    }, {
                        key: "shutter",
                        get: function() {
                            return this._shutter
                        },
                        set: function(e) {
                            this._shutter = e, this._camera && (this._camera.shutter = e)
                        }
                    }, {
                        key: "iso",
                        get: function() {
                            return this._iso
                        },
                        set: function(e) {
                            this._iso = e, this._camera && (this._camera.iso = e)
                        }
                    }, {
                        key: "rect",
                        get: function() {
                            return this._rect
                        },
                        set: function(e) {
                            this._rect = e, this._camera && (this._camera.viewport = e)
                        }
                    }, {
                        key: "targetTexture",
                        get: function() {
                            return this._targetTexture
                        },
                        set: function(e) {
                            if (this._targetTexture !== e) {
                                var t = this._targetTexture;
                                this._targetTexture = e, this._chechTargetTextureEvent(t), this._updateTargetTexture(), !e && this._camera && (this._camera.changeTargetWindow(null), this._camera.isWindowSize = !0)
                            }
                        }
                    }, {
                        key: "screenScale",
                        get: function() {
                            return this._screenScale
                        },
                        set: function(e) {
                            this._screenScale = e, this._camera && (this._camera.screenScale = e)
                        }
                    }, {
                        key: "inEditorMode",
                        get: function() {
                            return this._inEditorMode
                        },
                        set: function(e) {
                            this._inEditorMode = e, this._camera && this._camera.changeTargetWindow(e ? i.director.root && i.director.root.mainWindow : i.director.root && i.director.root.tempWindow)
                        }
                    }]), t
                }(Jd), cM.ProjectionType = AM, cM.FOVAxis = xM, cM.ClearFlag = wM, cM.Aperture = CM, cM.Shutter = bM, cM.ISO = RM, WN = ie((VN = lM).prototype, "_projection", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return AM.PERSPECTIVE
                    }
                }), jN = ie(VN.prototype, "_priority", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 0
                    }
                }), qN = ie(VN.prototype, "_fov", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 45
                    }
                }), XN = ie(VN.prototype, "_fovAxis", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return xM.VERTICAL
                    }
                }), YN = ie(VN.prototype, "_orthoHeight", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 10
                    }
                }), KN = ie(VN.prototype, "_near", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 1
                    }
                }), ZN = ie(VN.prototype, "_far", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 1e3
                    }
                }), QN = ie(VN.prototype, "_color", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return new yn("#333333")
                    }
                }), JN = ie(VN.prototype, "_depth", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 1
                    }
                }), $N = ie(VN.prototype, "_stencil", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 0
                    }
                }), eM = ie(VN.prototype, "_clearFlags", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return wM.SOLID_COLOR
                    }
                }), tM = ie(VN.prototype, "_rect", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return new Kn(0, 0, 1, 1)
                    }
                }), nM = ie(VN.prototype, "_aperture", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return CM.F16_0
                    }
                }), iM = ie(VN.prototype, "_shutter", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return bM.D125
                    }
                }), rM = ie(VN.prototype, "_iso", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return RM.ISO100
                    }
                }), oM = ie(VN.prototype, "_screenScale", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 1
                    }
                }), aM = ie(VN.prototype, "_visibility", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return $h
                    }
                }), sM = ie(VN.prototype, "_targetTexture", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return null
                    }
                }), ie(VN.prototype, "priority", [eN, tN], Object.getOwnPropertyDescriptor(VN.prototype, "priority"), VN.prototype), ie(VN.prototype, "visibility", [nN, iN, rN], Object.getOwnPropertyDescriptor(VN.prototype, "visibility"), VN.prototype), ie(VN.prototype, "clearFlags", [oN, aN, sN], Object.getOwnPropertyDescriptor(VN.prototype, "clearFlags"), VN.prototype), ie(VN.prototype, "clearColor", [cN, lN], Object.getOwnPropertyDescriptor(VN.prototype, "clearColor"), VN.prototype), ie(VN.prototype, "clearDepth", [uN, hN], Object.getOwnPropertyDescriptor(VN.prototype, "clearDepth"), VN.prototype), ie(VN.prototype, "clearStencil", [_N, fN], Object.getOwnPropertyDescriptor(VN.prototype, "clearStencil"), VN.prototype), ie(VN.prototype, "projection", [dN, pN, mN], Object.getOwnPropertyDescriptor(VN.prototype, "projection"), VN.prototype), ie(VN.prototype, "fovAxis", [gN, vN, yN], Object.getOwnPropertyDescriptor(VN.prototype, "fovAxis"), VN.prototype), ie(VN.prototype, "fov", [SN, EN], Object.getOwnPropertyDescriptor(VN.prototype, "fov"), VN.prototype), ie(VN.prototype, "orthoHeight", [TN, AN], Object.getOwnPropertyDescriptor(VN.prototype, "orthoHeight"), VN.prototype), ie(VN.prototype, "near", [xN, CN], Object.getOwnPropertyDescriptor(VN.prototype, "near"), VN.prototype), ie(VN.prototype, "far", [bN, RN], Object.getOwnPropertyDescriptor(VN.prototype, "far"), VN.prototype), ie(VN.prototype, "aperture", [wN, IN, PN], Object.getOwnPropertyDescriptor(VN.prototype, "aperture"), VN.prototype), ie(VN.prototype, "shutter", [ON, DN, NN], Object.getOwnPropertyDescriptor(VN.prototype, "shutter"), VN.prototype), ie(VN.prototype, "iso", [MN, LN, BN], Object.getOwnPropertyDescriptor(VN.prototype, "iso"), VN.prototype), ie(VN.prototype, "rect", [FN, zN], Object.getOwnPropertyDescriptor(VN.prototype, "rect"), VN.prototype), ie(VN.prototype, "targetTexture", [UN, GN, HN], Object.getOwnPropertyDescriptor(VN.prototype, "targetTexture"), VN.prototype), kN = VN)) || kN) || kN) || kN) || kN, e({
                    Camera: hM,
                    CameraComponent: hM
                }), hM);
            i.Camera = IM;
            var PM, OM, DM, NM, MM, LM, BM, FM, zM = {
                    parent: null,
                    owner: null,
                    subModelIdx: 0
                },
                UM = e("RenderableComponent", (_M = A_("cc.RenderableComponent"), fM = ef([nE]), dM = ef(nE), pM = q_(), mM = U_(), _M((EM = function(e) {
                    function t() {
                        for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                        return ne(t = e.call.apply(e, [this].concat(i)) || this, "_materials", yM, $(t)), ne(t, "_visFlags", SM, $(t)), t._materialInstances = [], t._models = [], t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.getMaterial = function(e) {
                        return e < 0 || e >= this._materials.length ? null : this._materials[e]
                    }, n.setMaterial = function(e, t) {
                        e && e instanceof OE && console.error("Can't set a material instance to a sharedMaterial slot"), this._materials[t] = e;
                        var n = this._materialInstances[t];
                        n ? n.parent !== this._materials[t] && (n.destroy(), this._materialInstances[t] = null, this._onMaterialModified(t, this._materials[t])) : this._onMaterialModified(t, this._materials[t])
                    }, n.getMaterialInstance = function(e) {
                        if (!this._materials[e]) return null;
                        if (!this._materialInstances[e]) {
                            zM.parent = this._materials[e], zM.owner = this, zM.subModelIdx = e;
                            var t = new OE(zM);
                            this.setMaterialInstance(e, t)
                        }
                        return this._materialInstances[e]
                    }, n.setMaterialInstance = function(e, t) {
                        t && t.parent ? t !== this._materialInstances[e] && (this._materialInstances[e] = t, this._onMaterialModified(e, t)) : t !== this._materials[e] && this.setMaterial(t, e)
                    }, n.getRenderMaterial = function(e) {
                        return this._materialInstances[e] || this._materials[e]
                    }, n._collectModels = function() {
                        return this._models
                    }, n._attachToScene = function() {}, n._detachFromScene = function() {}, n._onMaterialModified = function() {}, n._onRebuildPSO = function() {}, n._clearMaterials = function() {}, n._onVisibilityChange = function() {}, K(t, [{
                        key: "visibility",
                        get: function() {
                            return this._visFlags
                        },
                        set: function(e) {
                            this._visFlags = e, this._onVisibilityChange(e)
                        }
                    }, {
                        key: "sharedMaterials",
                        get: function() {
                            return this._materials
                        },
                        set: function(e) {
                            for (var t = 0; t < e.length; t++) e[t] !== this._materials[t] && this.setMaterial(e[t], t);
                            if (e.length < this._materials.length) {
                                for (var n = e.length; n < this._materials.length; n++) this.setMaterial(null, n);
                                this._materials.splice(e.length)
                            }
                        }
                    }, {
                        key: "materials",
                        get: function() {
                            for (var e = 0; e < this._materials.length; e++) this._materialInstances[e] = this.getMaterialInstance(e);
                            return this._materialInstances
                        },
                        set: function(e) {
                            var t = e.length - this._materials.length;
                            if (t > 0) this._materials.length = e.length, this._materialInstances.length = e.length;
                            else if (t < 0)
                                for (var n = this._materials.length - t; n < this._materials.length; ++n) this.setMaterialInstance(n, null);
                            for (var i = 0; i < this._materialInstances.length; i++) this._materialInstances[i] != e[i] && this.setMaterialInstance(i, e[i])
                        }
                    }, {
                        key: "sharedMaterial",
                        get: function() {
                            return this.getMaterial(0)
                        }
                    }, {
                        key: "material",
                        get: function() {
                            return this.getMaterialInstance(0)
                        },
                        set: function(e) {
                            1 === this._materials.length && this._materials[0] === e || this.setMaterialInstance(0, e)
                        }
                    }]), t
                }(Jd), yM = ie((vM = EM).prototype, "_materials", [fM], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return []
                    }
                }), SM = ie(vM.prototype, "_visFlags", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return Pu.Enum.NONE
                    }
                }), ie(vM.prototype, "sharedMaterials", [dM, pM, mM], Object.getOwnPropertyDescriptor(vM.prototype, "sharedMaterials"), vM.prototype), gM = vM)) || gM));

            function GM(e) {
                return "string" == typeof e || "number" == typeof e
            }

            function HM(e, t) {
                return e instanceof t
            }
            i.RenderableComponent = UM, U(IM, "Camera", [{
                name: "CameraClearFlag",
                newName: "ClearFlag"
            }]), U(IM.prototype, "Camera.prototype", [{
                name: "color",
                newName: "clearColor"
            }, {
                name: "depth",
                newName: "clearDepth"
            }, {
                name: "stencil",
                newName: "clearStencil"
            }]), i.CameraComponent = IM, Qe.setClassAlias(IM, "cc.CameraComponent");
            var kM, VM, WM, jM, qM, XM, YM = A_("cc.animation.HierarchyPath")((NM = function() {
                    function e(e) {
                        ne(this, "path", DM, this), this.path = e || ""
                    }
                    return e.prototype.get = function(e) {
                        return e instanceof Yv ? e.getChildByPath(this.path) || (d('Node "' + e.name + '" has no path "' + this.path + '"'), null) : (d("Target of hierarchy path should be of type Node."), null)
                    }, e
                }(), DM = ie((OM = NM).prototype, "path", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return ""
                    }
                }), PM = OM)) || PM,
                KM = A_("cc.animation.ComponentPath")((FM = function() {
                    function e(e) {
                        ne(this, "component", BM, this), this.component = e || ""
                    }
                    return e.prototype.get = function(e) {
                        return e instanceof Yv ? e.getComponent(this.component) || (d('Node "' + e.name + '" has no component "' + this.component + '"'), null) : (d("Target of component path should be of type Node."), null)
                    }, e
                }(), BM = ie((LM = FM).prototype, "component", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return ""
                    }
                }), MM = LM)) || MM;

            function ZM(e) {
                for (var t = e, n = 0; n < (arguments.length <= 1 ? 0 : arguments.length - 1); ++n) {
                    var i = n + 1 < 1 || arguments.length <= n + 1 ? void 0 : arguments[n + 1];
                    if (GM(i)) {
                        if (!(i in t)) return d('Target object has no property "' + i + '"'), null;
                        t = t[i]
                    } else t = i.get(t);
                    if (null === t) break
                }
                return t
            }
            var QM, JM, $M, eL, tL, nL, iL, rL, oL, aL, sL, cL = A_("cc.animation.UniformProxyFactory")((XM = function() {
                    function e(e, t) {
                        ne(this, "passIndex", WM, this), ne(this, "uniformName", jM, this), ne(this, "channelIndex", qM, this), this.passIndex = t || 0, this.uniformName = e || ""
                    }
                    return e.prototype.forTarget = function(e) {
                        var t = e.passes[this.passIndex],
                            n = t.getHandle(this.uniformName);
                        if (!n) throw new Error('Material "' + e.name + '" has no uniform "' + this.uniformName + '"');
                        var r = om.getPropertyTypeFromHandle(n);
                        if (r === xp.BUFFER) {
                            var o = void 0 === this.channelIndex ? n : t.getHandle(this.uniformName, this.channelIndex, Aa.FLOAT);
                            if (!o) throw new Error('Uniform "' + this.uniformName + " (in material " + e.name + ") has no channel " + this.channelIndex + '"');
                            return function(e, t) {
                                for (var n, i = te(e.shaderInfo.blocks); !(n = i()).done;)
                                    for (var r, o = te(n.value.members); !(r = o()).done;) {
                                        var a = r.value;
                                        if (a.name === t) return a.count > 1
                                    }
                                return !1
                            }(t, this.uniformName) ? {
                                set: function(e) {
                                    t.setUniformArray(o, e)
                                }
                            } : {
                                set: function(e) {
                                    t.setUniform(o, e)
                                }
                            }
                        }
                        if (r === xp.TEXTURE) {
                            var a = om.getBindingFromHandle(n),
                                s = t.properties[this.uniformName],
                                c = s && s.value ? s.value + "-texture" : Up(s.type),
                                l = em.get(c);
                            return l || (d("Illegal texture default value: " + c + "."), l = em.get("default-texture")), {
                                set: function(e) {
                                    e || (e = l);
                                    var n = e.getGFXTexture();
                                    n && n.width && n.height && (t.bindTexture(a, n), e instanceof ud && t.bindSampler(a, cd.getSampler(i.game._gfxDevice, e.getSamplerHash())))
                                }
                            }
                        }
                        throw new Error("Animations are not available for uniforms with property type " + r + ".")
                    }, e
                }(), WM = ie((VM = XM).prototype, "passIndex", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 0
                    }
                }), jM = ie(VM.prototype, "uniformName", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return ""
                    }
                }), qM = ie(VM.prototype, "channelIndex", [Q_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {}
                }), kM = VM)) || kM,
                lL = A_("cc.animation.MorphWeightsValueProxy")((eL = function() {
                    function e() {
                        ne(this, "subMeshIndex", $M, this)
                    }
                    return e.prototype.forTarget = function(e) {
                        var t = this;
                        return {
                            set: function(n) {
                                e.setWeights(n, t.subMeshIndex)
                            }
                        }
                    }, e
                }(), $M = ie((JM = eL).prototype, "subMeshIndex", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 0
                    }
                }), QM = JM)) || QM,
                uL = A_("cc.animation.MorphWeightsAllValueProxy")(tL = function() {
                    function e() {}
                    return e.prototype.forTarget = function(e) {
                        return {
                            set: function(t) {
                                for (var n, i, r = null !== (n = null === (i = e.mesh) || void 0 === i ? void 0 : i.struct.primitives.length) && void 0 !== n ? n : 0, o = 0; o < r; ++o) e.setWeights(t, o)
                            }
                        }
                    }, e
                }()) || tL;

            function hL(e, t, n, i) {
                var r, o, a, s, c, l, u = new t,
                    h = new t,
                    _ = new t,
                    f = A_(e)((l = function() {
                        function e(e, n, i) {
                            ne(this, "dataPoint", a, this), ne(this, "inTangent", s, this), ne(this, "outTangent", c, this), this.dataPoint = e || new t, this.inTangent = n || new t, this.outTangent = i || new t
                        }
                        var r = e.prototype;
                        return r.lerp = function(e, t, r) {
                            var o = this.dataPoint,
                                a = e.dataPoint;
                            h = n(h, this.inTangent, r), _ = n(_, e.outTangent, r);
                            var s = t * t * t,
                                c = t * t,
                                l = s - 2 * c + t,
                                f = -2 * s + 3 * c,
                                d = s - c;
                            return u = n(u, o, 2 * s - 3 * c + 1), u = i(u, u, h, l), u = i(u, u, a, f), u = i(u, u, _, d)
                        }, r.getNoLerp = function() {
                            return this.dataPoint
                        }, e
                    }(), a = ie((o = l).prototype, "dataPoint", [w_], {
                        configurable: !0,
                        enumerable: !0,
                        writable: !0,
                        initializer: function() {
                            return new t
                        }
                    }), s = ie(o.prototype, "inTangent", [w_], {
                        configurable: !0,
                        enumerable: !0,
                        writable: !0,
                        initializer: function() {
                            return new t
                        }
                    }), c = ie(o.prototype, "outTangent", [w_], {
                        configurable: !0,
                        enumerable: !0,
                        writable: !0,
                        initializer: function() {
                            return new t
                        }
                    }), r = o)) || r;
                if (t === wn) {
                    var d = f.prototype.lerp;
                    f.prototype.lerp = function(e, t, n) {
                        var i = d.call(this, e, t, n);
                        return wn.normalize(i, i), i
                    }
                }
                return f
            }
            var _L = e("CubicSplineVec2Value", hL("cc.CubicSplineVec2Value", Gn, Gn.multiplyScalar, Gn.scaleAndAdd));
            i.CubicSplineVec2Value = _L;
            var fL = e("CubicSplineVec3Value", hL("cc.CubicSplineVec3Value", En, En.multiplyScalar, En.scaleAndAdd));
            i.CubicSplineVec3Value = fL;
            var dL = e("CubicSplineVec4Value", hL("cc.CubicSplineVec4Value", Wn, Wn.multiplyScalar, Wn.scaleAndAdd));
            i.CubicSplineVec4Value = dL;
            var pL = e("CubicSplineQuatValue", hL("cc.CubicSplineQuatValue", wn, wn.multiplyScalar, wn.scaleAndAdd));
            i.CubicSplineQuatValue = pL;
            var mL = e("CubicSplineNumberValue", A_("cc.CubicSplineNumberValue")((sL = function() {
                function e(e, t, n) {
                    ne(this, "dataPoint", rL, this), ne(this, "inTangent", oL, this), ne(this, "outTangent", aL, this), this.dataPoint = e, this.inTangent = t, this.outTangent = n
                }
                var t = e.prototype;
                return t.lerp = function(e, t, n) {
                    var i = this.dataPoint,
                        r = e.dataPoint,
                        o = t * t * t,
                        a = t * t;
                    return i * (2 * o - 3 * a + 1) + this.outTangent * n * (o - 2 * a + t) + r * (-2 * o + 3 * a) + e.inTangent * n * (o - a)
                }, t.getNoLerp = function() {
                    return this.dataPoint
                }, e
            }(), rL = ie((iL = sL).prototype, "dataPoint", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return 0
                }
            }), oL = ie(iL.prototype, "inTangent", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return 0
                }
            }), aL = ie(iL.prototype, "outTangent", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return 0
                }
            }), nL = iL)) || nL);

            function gL(e, t, n) {
                void 0 === n && (n = 1e-6);
                for (var i = 0, r = e.length - 1, o = r >>> 1; i <= r; o = i + r >>> 1) {
                    var a = e[o];
                    if (a > t + n) r = o - 1;
                    else {
                        if (!(a < t - n)) return o;
                        i = o + 1
                    }
                }
                return ~i
            }

            function vL(e, t, n, i, r) {
                var o = 1 - r;
                return o * (o * (e + (3 * t - e) * r) + 3 * n * r * r) + i * r * r * r
            }
            i.CubicSplineNumberValue = mL, e("animation", Object.freeze({
                __proto__: null,
                UniformProxyFactory: cL,
                MorphWeightsValueProxy: lL,
                MorphWeightsAllValueProxy: uL,
                isPropertyPath: GM,
                isCustomPath: HM,
                HierarchyPath: YM,
                ComponentPath: KM,
                evaluatePath: ZM,
                CubicSplineVec2Value: _L,
                CubicSplineVec3Value: fL,
                CubicSplineVec4Value: dL,
                CubicSplineQuatValue: pL,
                CubicSplineNumberValue: mL
            })), i.bezier = vL;
            var yL = Math.cos,
                SL = Math.acos,
                EL = Math.max,
                TL = 2 * Math.PI,
                AL = Math.sqrt;

            function xL(e) {
                return e < 0 ? -Math.pow(-e, 1 / 3) : Math.pow(e, 1 / 3)
            }

            function CL(e, t) {
                var n = function(e, t) {
                        var n, i, r, o, a = t - 0,
                            s = t - e[0],
                            c = 3 * a,
                            l = 3 * s,
                            u = 3 * (t - e[2]),
                            h = 1 / (-a + l - u + (t - 1)),
                            _ = 1 / 3,
                            f = (c - 6 * s + u) * h,
                            d = f * _,
                            p = (-c + l) * h,
                            m = (3 * p - f * f) * _,
                            g = m * _,
                            v = (2 * f * f * f - 9 * f * p + a * h * 27) / 27,
                            y = v / 2,
                            S = y * y + g * g * g;
                        if (S < 0) {
                            var E = -m * _,
                                T = AL(E * E * E),
                                A = -v / (2 * T),
                                x = SL(A < -1 ? -1 : A > 1 ? 1 : A),
                                C = 2 * xL(T);
                            return i = C * yL(x * _) - d, r = C * yL((x + TL) * _) - d, o = C * yL((x + 2 * TL) * _) - d, i >= 0 && i <= 1 ? r >= 0 && r <= 1 ? o >= 0 && o <= 1 ? EL(i, r, o) : EL(i, r) : o >= 0 && o <= 1 ? EL(i, o) : i : r >= 0 && r <= 1 ? o >= 0 && o <= 1 ? EL(r, o) : r : o
                        }
                        if (0 === S) return r = -(n = y < 0 ? xL(-y) : -xL(y)) - d, (i = 2 * n - d) >= 0 && i <= 1 ? r >= 0 && r <= 1 ? EL(i, r) : i : r;
                        var b = AL(S);
                        return (n = xL(-y + b)) - xL(y + b) - d
                    }(e, t),
                    i = e[1];
                return ((1 - n) * (i + (e[3] - i) * n) * 3 + n * n) * n
            }
            i.bezierByTime = CL;
            var bL = e("RatioSampler", function() {
                function e(e) {
                    var t, n;
                    this.ratios = void 0, this._findRatio = void 0, this.ratios = e;
                    for (var i = !0, r = 1, o = e.length; r < o; r++)
                        if (t = e[r] - e[r - 1], 1 === r) n = t;
                        else if (Math.abs(t - n) > 1e-6) {
                        i = !1;
                        break
                    }
                    this._findRatio = i ? PL : gL
                }
                return e.prototype.sample = function(e) {
                    return this._findRatio(this.ratios, e)
                }, e
            }());
            i.RatioSampler = bL;
            var RL = e("AnimCurve", function() {
                function e(t, n) {
                    this.types = void 0, this.type = null, this._values = [], this._lerp = void 0, this._duration = void 0, this._array = void 0, this._duration = n, this._values = t.values;
                    var i = function(t) {
                        return "string" == typeof t ? t : Array.isArray(t) ? t[0] === t[1] && t[2] === t[3] ? e.Linear : e.Bezier(t) : e.Linear
                    };
                    if (void 0 !== t.easingMethod) this.type = i(t.easingMethod);
                    else if (Array.isArray(t.easingMethods)) this.types = t.easingMethods.map(i);
                    else if (void 0 !== t.easingMethods) {
                        this.types = new Array(this._values.length).fill(null);
                        for (var r = 0, o = Object.keys(t.easingMethods); r < o.length; r++) {
                            var a = o[r];
                            this.types[a] = i(t.easingMethods[a])
                        }
                    } else this.type = null;
                    var s = t.values[0];
                    (void 0 === t.interpolate || t.interpolate) && (this._lerp = qL(s)), void 0 !== t._arrayLength && (this._array = new Array(t._arrayLength))
                }
                e.Bezier = function(e) {
                    return e
                };
                var t = e.prototype;
                return t.hasLerp = function() {
                    return !!this._lerp
                }, t.valueAt = function(e) {
                    if (void 0 === this._array) {
                        var t = this._values[e];
                        return t && t.getNoLerp ? t.getNoLerp() : t
                    }
                    for (var n = 0; n < this._array.length; ++n) this._array[n] = this._values[this._array.length * e + n];
                    return this._array
                }, t.valueBetween = function(e, t, n, i, r) {
                    if (this._lerp) {
                        var o = this.types ? this.types[t] : this.type,
                            a = r - n,
                            s = (e - n) / a;
                        if (o && (s = IL(s, o)), void 0 === this._array) {
                            var c = this._values[t],
                                l = this._values[i];
                            return this._lerp(c, l, s, a * this._duration)
                        }
                        for (var u = 0; u < this._array.length; ++u) {
                            var h = this._values[this._array.length * t + u],
                                _ = this._values[this._array.length * i + u];
                            this._array[u] = this._lerp(h, _, s, a * this._duration)
                        }
                        return this._array
                    }
                    if (void 0 === this._array) return this.valueAt(t);
                    for (var f = 0; f < this._array.length; ++f) this._array[f] = this._values[this._array.length * t + f];
                    return this._array
                }, t.empty = function() {
                    return 0 === this._values.length
                }, t.constant = function() {
                    return 1 === this._values.length
                }, e
            }());

            function wL(e, t, n) {
                var i = t.sample(n);
                if (i < 0)
                    if ((i = ~i) <= 0) i = 0;
                    else {
                        if (!(i >= t.ratios.length)) return e.valueBetween(n, i - 1, t.ratios[i - 1], i, t.ratios[i]);
                        i = t.ratios.length - 1
                    }
                return e.valueAt(i)
            }

            function IL(e, t) {
                if ("string" == typeof t) {
                    var n = nR[t];
                    n ? e = n(e) : b(3906, t)
                } else Array.isArray(t) && (e = CL(t, e));
                return e
            }

            function PL(e, t) {
                var n = e.length - 1;
                if (0 === n) return 0;
                var i = e[0];
                if (t < i) return 0;
                var r = e[n];
                if (t > r) return n;
                var o = (t = (t - i) / (r - i)) / (1 / n),
                    a = 0 | o,
                    s = 1e-6;
                return o - a < s ? a : a + 1 - o < s ? a + 1 : ~(a + 1)
            }
            RL.Linear = null, i.AnimCurve = RL, e("EventInfo", function() {
                function e() {
                    this.events = []
                }
                return e.prototype.add = function(e, t) {
                    this.events.push({
                        func: e || "",
                        params: t || []
                    })
                }, e
            }()), i.sampleAnimationCurve = wL;
            var OL, DL, NL, ML, LL, BL, FL, zL, UL, GL, HL, kL, VL, WL, jL, qL = function() {
                    function e(e, t, n, i) {
                        return e.lerp(t, n, i)
                    }
                    return function(t) {
                        if (null !== t) {
                            if ("number" == typeof t) return nn;
                            if ("object" == typeof t && t.constructor) {
                                if (t instanceof wn) return n = new wn,
                                    function(e, t, i) {
                                        return wn.slerp(n, e, t, i)
                                    };
                                if (t instanceof it) return function(e) {
                                    var t = new e;
                                    return function(n, i, r) {
                                        return e.lerp(t, n, i, r), t
                                    }
                                }(t.constructor);
                                if (t.constructor === Number) return nn;
                                if ("function" == typeof t.lerp) return e
                            }
                            var n
                        }
                    }
                }(),
                XL = e("SkelAnimDataHub", function() {
                    function e() {}
                    return e.getOrExtract = function(t) {
                        var n = e.pool.get(t);
                        return n && n.info.sample === t.sample || (n && i.director.root.dataPoolManager.releaseAnimationClip(t), n = function(e) {
                            var t = {};
                            e.curves.forEach((function(e) {
                                if (!e.valueAdapter && HM(e.modifiers[0], YM) && GM(e.modifiers[1])) {
                                    var n = e.modifiers[0].path,
                                        i = t[n];
                                    i || (i = t[n] = {}), i[e.modifiers[1]] = {
                                        values: e.data.values,
                                        keys: e.data.keys
                                    }
                                }
                            }));
                            for (var n = Math.ceil(e.sample * e.duration) + 1, i = function() {
                                    var i = o[r],
                                        a = t[i];
                                    if (!a) return "continue";
                                    Object.defineProperty(a, "worldMatrix", {
                                        get: function() {
                                            if (!a._worldMatrix) {
                                                var r = a.position,
                                                    o = a.rotation,
                                                    s = a.scale;
                                                YL(e, r, n), YL(e, o, n), YL(e, s, n),
                                                    function(e, t, n) {
                                                        var i = n.position.values,
                                                            r = n.rotation.values,
                                                            o = n.scale.values,
                                                            a = i.map((function() {
                                                                return new Bn
                                                            })),
                                                            s = t.lastIndexOf("/"),
                                                            c = null;
                                                        if (s > 0) {
                                                            var l = e[t.substring(0, s)];
                                                            if (!l) return void console.warn("no data for parent bone?");
                                                            c = l.worldMatrix.values
                                                        }
                                                        for (var u = 0; u < i.length; u++) {
                                                            var h = i[u],
                                                                _ = r[u],
                                                                f = o[u],
                                                                d = a[u];
                                                            Bn.fromRTS(d, _, h, f), c && Bn.multiply(d, c[u], d)
                                                        }
                                                        Object.keys(n).forEach((function(e) {
                                                            return delete n[e]
                                                        })), n._worldMatrix = {
                                                            keys: 0,
                                                            interpolate: !1,
                                                            values: a
                                                        }
                                                    }(t, i, a)
                                            }
                                            return a._worldMatrix
                                        }
                                    })
                                }, r = 0, o = Object.keys(t); r < o.length; r++) i();
                            return {
                                info: {
                                    frames: n,
                                    sample: e.sample
                                },
                                data: t
                            }
                        }(t), e.pool.set(t, n)), n
                    }, e.destroy = function(t) {
                        e.pool.delete(t)
                    }, e
                }());

            function YL(e, t, n) {
                var i = e.keys[t.keys],
                    r = [];
                if (i && 1 !== i.length)
                    for (var o = t.values[0] instanceof wn, a = 0, s = 0; a < n; a++) {
                        for (var c = a / e.sample; i[s] <= c;) s++;
                        s > i.length - 1 ? c = i[s = i.length - 1] : 0 === s && (s = 1);
                        var l = t.values[s - 1].clone(),
                            u = i[s] - i[s - 1],
                            h = u ? tn((c - i[s - 1]) / u) : 1;
                        o ? l.slerp(t.values[s], h) : l.lerp(t.values[s], h), r[a] = l
                    } else
                        for (var _ = 0; _ < n; _++) r[_] = t.values[0].clone();
                t.values = r
            }
            XL.pool = new Map;
            var KL = e("AnimationClip", A_("cc.AnimationClip")((jL = WL = function(e) {
                function t() {
                    for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                    return ne(t = e.call.apply(e, [this].concat(i)) || this, "sample", NL, $(t)), ne(t, "speed", ML, $(t)), ne(t, "wrapMode", LL, $(t)), ne(t, "events", BL, $(t)), ne(t, "enableTrsBlending", FL, $(t)), ne(t, "_duration", zL, $(t)), ne(t, "_keys", UL, $(t)), ne(t, "_stepness", GL, $(t)), ne(t, "_curves", HL, $(t)), ne(t, "_commonTargets", kL, $(t)), ne(t, "_hash", VL, $(t)), t.frameRate = 0, t._ratioSamplers = [], t._runtimeCurves = void 0, t._runtimeEvents = void 0, t._data = null, t
                }
                Q(t, e), t.createWithSpriteFrames = function(e, n) {
                    if (!Array.isArray(e)) return b(3905), null;
                    var i = new t;
                    i.sample = n || i.sample, i.duration = e.length / i.sample;
                    for (var r = 1 / i.sample, o = new Array(e.length), a = new Array(o.length), s = 0; s < e.length; s++) o[s] = s * r, a[s] = e[s];
                    return i.keys = [o], i.curves = [{
                        modifiers: [new KM("cc.Sprite"), "spriteFrame"],
                        data: {
                            keys: 0,
                            values: a
                        }
                    }], i
                };
                var n = t.prototype;
                return n.onLoaded = function() {
                    this.frameRate = this.sample, this._decodeCVTAs()
                }, n.getPropertyCurves = function() {
                    return this._runtimeCurves || this._createPropertyCurves(), this._runtimeCurves
                }, n.updateEventDatas = function() {
                    delete this._runtimeEvents
                }, n.getEventGroupIndexAtRatio = function(e) {
                    return this._runtimeEvents || this._createRuntimeEvents(), gL(this._runtimeEvents.ratios, e)
                }, n.hasEvents = function() {
                    return 0 !== this.events.length
                }, n.destroy = function() {
                    return i.director.root.dataPoolManager && i.director.root.dataPoolManager.releaseAnimationClip(this), XL.destroy(this), e.prototype.destroy.call(this)
                }, n._createPropertyCurves = function() {
                    var e = this;
                    this._ratioSamplers = this._keys.map((function(t) {
                        return new bL(t.map((function(t) {
                            return t / e._duration
                        })))
                    })), this._runtimeCurves = this._curves.map((function(t) {
                        return {
                            curve: new RL(t.data, e._duration),
                            modifiers: t.modifiers,
                            valueAdapter: t.valueAdapter,
                            sampler: e._ratioSamplers[t.data.keys],
                            commonTarget: t.commonTarget
                        }
                    })), this._applyStepness()
                }, n._createRuntimeEvents = function() {
                    for (var e, t = this, n = [], i = [], r = function() {
                            var r = e.value,
                                o = r.frame / t._duration,
                                a = n.findIndex((function(e) {
                                    return e === o
                                }));
                            a < 0 && (a = n.length, n.push(o), i.push({
                                events: []
                            })), i[a].events.push({
                                functionName: r.func,
                                parameters: r.params
                            })
                        }, o = te(this.events.sort((function(e, t) {
                            return e.frame - t.frame
                        }))); !(e = o()).done;) r();
                    this._runtimeEvents = {
                        ratios: n,
                        eventGroups: i
                    }
                }, n._applyStepness = function() {}, n._decodeCVTAs = function() {
                    var e = ArrayBuffer.isView(this._nativeAsset) ? this._nativeAsset.buffer : this._nativeAsset;
                    if (e) {
                        for (var t = this._keys, n = 0; n < t.length; ++n) {
                            var i = t[n];
                            i instanceof LR && (t[n] = i.decompress(e))
                        }
                        for (var r = 0; r < this._curves.length; ++r) {
                            var o = this._curves[r];
                            o.data.values instanceof LR && (o.data.values = o.data.values.decompress(e))
                        }
                    }
                }, n.validate = function() {
                    return this.keys.length > 0 && this.curves.length > 0
                }, K(t, [{
                    key: "duration",
                    get: function() {
                        return this._duration
                    },
                    set: function(e) {
                        this._duration = e
                    }
                }, {
                    key: "keys",
                    get: function() {
                        return this._keys
                    },
                    set: function(e) {
                        this._keys = e
                    }
                }, {
                    key: "eventGroups",
                    get: function() {
                        return this._runtimeEvents || this._createRuntimeEvents(), this._runtimeEvents.eventGroups
                    }
                }, {
                    key: "stepness",
                    get: function() {
                        return this._stepness
                    },
                    set: function(e) {
                        this._stepness = e, this._applyStepness()
                    }
                }, {
                    key: "hash",
                    get: function() {
                        if (this._hash) return this._hash;
                        var e = this._nativeAsset,
                            t = new Uint8Array(ArrayBuffer.isView(e) ? e.buffer : e);
                        return this._hash = vc(t, 666)
                    }
                }, {
                    key: "curves",
                    get: function() {
                        return this._curves
                    },
                    set: function(e) {
                        this._curves = e, delete this._runtimeCurves
                    }
                }, {
                    key: "data",
                    get: function() {
                        return this._data
                    }
                }, {
                    key: "commonTargets",
                    get: function() {
                        return this._commonTargets
                    },
                    set: function(e) {
                        this._commonTargets = e
                    }
                }]), t
            }(Nf), WL.WrapMode = uu, NL = ie((DL = jL).prototype, "sample", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return 60
                }
            }), ML = ie(DL.prototype, "speed", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return 1
                }
            }), LL = ie(DL.prototype, "wrapMode", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return uu.Normal
                }
            }), BL = ie(DL.prototype, "events", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return []
                }
            }), FL = ie(DL.prototype, "enableTrsBlending", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return !1
                }
            }), zL = ie(DL.prototype, "_duration", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return 0
                }
            }), UL = ie(DL.prototype, "_keys", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return []
                }
            }), GL = ie(DL.prototype, "_stepness", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return 0
                }
            }), HL = ie(DL.prototype, "_curves", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return []
                }
            }), kL = ie(DL.prototype, "_commonTargets", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return []
                }
            }), VL = ie(DL.prototype, "_hash", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return 0
                }
            }), OL = DL)) || OL);

            function ZL(e, t, n) {
                var i = t[t.length - 1];
                if (0 !== t.length && GM(i) && !n) {
                    var r = ZM.apply(void 0, [e].concat(t.slice(0, t.length - 1)));
                    return null === r ? null : {
                        setValue: function(e) {
                            r[i] = e
                        },
                        getValue: function() {
                            return r[i]
                        }
                    }
                }
                if (n) {
                    var o = ZM.apply(void 0, [e].concat(t));
                    if (null === o) return null;
                    var a = n.forTarget(o);
                    return {
                        setValue: function(e) {
                            a.set(e)
                        },
                        getValue: function() {
                            return a.get ? a.get() : (p("Target doesn't provide a get method."), null)
                        }
                    }
                }
                return p("Empty animation curve."), null
            }

            function QL(e, t, n) {
                var i = ZL(e, t, n);
                if (null === i) return null;
                var r = i.getValue(),
                    o = $L(r);
                if (!o) return p("Value is not copyable!"), null;
                var a = o.createBuffer(),
                    s = o.copy;
                return Object.assign(i, {
                    peek: function() {
                        return a
                    },
                    pull: function() {
                        var e = i.getValue();
                        s(a, e)
                    },
                    push: function() {
                        i.setValue(a)
                    }
                })
            }
            i.AnimationClip = KL;
            var JL, $L = ((JL = new Map).set(Gn, {
                    createBuffer: function() {
                        return new Gn
                    },
                    copy: Gn.copy
                }), JL.set(En, {
                    createBuffer: function() {
                        return new En
                    },
                    copy: En.copy
                }), JL.set(Wn, {
                    createBuffer: function() {
                        return new Wn
                    },
                    copy: Wn.copy
                }), JL.set(yn, {
                    createBuffer: function() {
                        return new yn
                    },
                    copy: yn.copy
                }), JL.set(Xn, {
                    createBuffer: function() {
                        return new Xn
                    },
                    copy: function(e, t) {
                        return e.set(t)
                    }
                }), function(e) {
                    return JL.get(null == e ? void 0 : e.constructor)
                }),
                eB = function() {
                    function e() {
                        this._isPlaying = !1, this._isPaused = !1, this._stepOnce = !1
                    }
                    var t = e.prototype;
                    return t.play = function() {
                        this._isPlaying ? this._isPaused ? (this._isPaused = !1, this.onResume()) : this.onError(P(3912)) : (this._isPlaying = !0, this.onPlay())
                    }, t.stop = function() {
                        this._isPlaying && (this._isPlaying = !1, this.onStop(), this._isPaused = !1)
                    }, t.pause = function() {
                        this._isPlaying && !this._isPaused && (this._isPaused = !0, this.onPause())
                    }, t.resume = function() {
                        this._isPlaying && this._isPaused && (this._isPaused = !1, this.onResume())
                    }, t.step = function() {
                        this.pause(), this._stepOnce = !0, this._isPlaying || this.play()
                    }, t.update = function() {}, t.onPlay = function() {}, t.onPause = function() {}, t.onResume = function() {}, t.onStop = function() {}, t.onError = function() {}, K(e, [{
                        key: "isPlaying",
                        get: function() {
                            return this._isPlaying
                        }
                    }, {
                        key: "isPaused",
                        get: function() {
                            return this._isPaused
                        }
                    }, {
                        key: "isMotionless",
                        get: function() {
                            return !this.isPlaying || this.isPaused
                        }
                    }]), e
                }(),
                tB = function() {
                    function e() {
                        this._nodeBlendStates = new Map, this._states = new Set
                    }
                    var t = e.prototype;
                    return t.ref = function(e, t) {
                        var n = this._nodeBlendStates.get(e);
                        n || (n = {
                            dirty: !1,
                            properties: {}
                        }, this._nodeBlendStates.set(e, n));
                        var i = n.properties[t];
                        return i || (i = n.properties[t] = new rB(n, nB(t) ? new En : new wn)), ++i.refCount, i
                    }, t.deRef = function(e, t) {
                        var n = this._nodeBlendStates.get(e);
                        if (n) {
                            var i = n.properties[t];
                            i && (--i.refCount, i.refCount > 0 || (delete n.properties[t], function(e) {
                                return !(e.properties.position || e.properties.rotation || e.properties.eulerAngles || e.properties.scale)
                            }(n) && this._nodeBlendStates.delete(e)))
                        }
                    }, t.apply = function() {
                        this._nodeBlendStates.forEach((function(e, t) {
                            if (e.dirty) {
                                e.dirty = !1;
                                var n, i, r, o = e.properties,
                                    a = o.position,
                                    s = o.scale,
                                    c = o.rotation,
                                    l = o.eulerAngles,
                                    u = !1;
                                a && 0 !== a.weight && (a.weight = 0, n = a.value, u = !0), s && 0 !== s.weight && (s.weight = 0, i = s.value, u = !0), c && 0 !== c.weight && (c.weight = 0, r = c.value, u = !0), l && 0 !== l.weight && (l.weight = 0, r = l.value, u = !0), u && t.setRTS(r, n, i)
                            }
                        })), this._states.forEach((function(e) {
                            e.onBlendFinished()
                        }))
                    }, t.bindState = function(e) {
                        this._states.add(e)
                    }, t.unbindState = function(e) {
                        this._states.delete(e)
                    }, e
                }();

            function nB(e) {
                return ! function(e) {
                    return "rotation" === e
                }(e)
            }
            var iB, rB = function() {
                function e(e, t) {
                    this.weight = 0, this.value = void 0, this.refCount = 0, this._node = void 0, this._node = e, this.value = t
                }
                return e.prototype.markAsDirty = function() {
                    this._node.dirty = !0
                }, e
            }();

            function oB(e, t, n) {
                return 0 === n.weight && En.zero(n.value), 0 === t ? n.value : 1 === t ? En.copy(n.value, e) : En.scaleAndAdd(n.value, n.value, e, t)
            }

            function aB(e, t, n) {
                if (0 === n.weight && wn.identity(n.value), 0 === t) return n.value;
                if (1 === t) return wn.copy(n.value, e);
                var i = t / (n.weight + t);
                return wn.slerp(n.value, n.value, e, i)
            }! function(e) {
                e.PLAY = "play", e.STOP = "stop", e.PAUSE = "pause", e.RESUME = "resume", e.LASTFRAME = "lastframe", e.FINISHED = "finished"
            }(iB || (iB = {})), nt(iB);
            var sB = function() {
                    function e(e, t, n) {
                        this.commonTargetIndex = void 0, this._curve = void 0, this._boundTarget = void 0, this._rootTargetProperty = void 0, this._curveDetail = void 0, this._curve = e.curve, this._curveDetail = e, this._boundTarget = n, this._shouldLerp = e.curve.hasLerp()
                    }
                    var t = e.prototype;
                    return t.applySample = function(e, t, n, i, r) {
                        var o;
                        o = this._shouldLerp && n ? this._curve.valueBetween(e, i.from, i.fromRatio, i.to, i.toRatio) : this._curve.valueAt(t), this._setValue(o, r)
                    }, t._setValue = function(e) {
                        this._boundTarget.setValue(e)
                    }, K(e, [{
                        key: "propertyName",
                        get: function() {
                            return this._rootTargetProperty || ""
                        }
                    }, {
                        key: "curveDetail",
                        get: function() {
                            return this._curveDetail
                        }
                    }]), e
                }(),
                cB = e("AnimationState", function(e) {
                    function t(t, n) {
                        var i;
                        return void 0 === n && (n = ""), (i = e.call(this) || this).duration = 1, i.speed = 1, i.time = 0, i.weight = 0, i.frameRate = 0, i._targetNode = null, i._curveLoaded = !1, i._clip = void 0, i._process = i.process, i._samplerSharedGroups = [], i._target = null, i._ignoreIndex = -1, i._commonTargetStatuses = [], i._wrapMode = uu.Normal, i._repeatCount = 1, i._delay = 0, i._delayTime = 0, i._currentFramePlayed = !1, i._name = void 0, i._lastIterations = void 0, i._lastWrapInfo = null, i._lastWrapInfoEvent = null, i._wrappedInfo = new fu, i._blendStateBuffer = null, i._blendStateWriters = [], i._allowLastFrame = !1, i._blendStateWriterHost = {
                            weight: 0,
                            enabled: !1
                        }, i._playbackRange = void 0, i._playbackDuration = 0, i._invDuration = 1, i._clip = t, i._name = n || t && t.name, i._playbackRange = {
                            min: 0,
                            max: i._clip.duration
                        }, i._playbackDuration = t.duration, t.duration || g("Clip " + t.name + " has zero duration."), i
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.initialize = function(e, t) {
                        var n, r, o = this;
                        if (!this._curveLoaded) {
                            this._curveLoaded = !0, this._destroyBlendStateWriters(), this._samplerSharedGroups.length = 0, this._blendStateBuffer = null !== (n = null === (r = i.director.getAnimationManager()) || void 0 === r ? void 0 : r.blendState) && void 0 !== n ? n : null, this._blendStateBuffer && this._blendStateBuffer.bindState(this), this._targetNode = e;
                            var a = this._clip;
                            this.duration = a.duration, this._invDuration = 1 / this.duration, this.speed = a.speed, this.wrapMode = a.wrapMode, this.frameRate = a.sample, this._playbackRange = {
                                min: 0,
                                max: a.duration
                            }, this._playbackDuration = a.duration, (this.wrapMode & lu.Loop) === lu.Loop ? this.repeatCount = 1 / 0 : this.repeatCount = 1;
                            var s = function(e, t, n, i, r) {
                                if (!(a.enableTrsBlending && function(e) {
                                        var t;
                                        if (1 === e.length && "string" == typeof e[0]) t = e[0];
                                        else if (e.length > 1) {
                                            for (var n = 0; n < e.length - 1; ++n)
                                                if (!(e[n] instanceof YM)) return !1;
                                            t = e[e.length - 1]
                                        }
                                        switch (t) {
                                            case "position":
                                            case "scale":
                                            case "rotation":
                                            case "eulerAngles":
                                                return !0;
                                            default:
                                                return !1
                                        }
                                    }(n) && o._blendStateBuffer)) return e(t, n, i);
                                var s = ZM.apply(void 0, [t].concat(n.slice(0, n.length - 1)));
                                if (null !== s && s instanceof Yv) {
                                    var c = n[n.length - 1],
                                        l = function(e, t, n, i, r) {
                                            var o = nB(n) ? oB : aB,
                                                a = e.ref(t, n),
                                                s = !1,
                                                c = -1;
                                            return {
                                                destroy: function() {
                                                    a && (e.deRef(t, n), a = null)
                                                },
                                                forTarget: function() {
                                                    return {
                                                        get: function() {
                                                            return t[n]
                                                        },
                                                        set: function(e) {
                                                            if (a && i.enabled) {
                                                                var t = i.weight;
                                                                if (r)
                                                                    if (1 !== t || t !== c) s = !1;
                                                                    else if (s) return;
                                                                o(e, t, a), a.weight += t, a.markAsDirty(), s = !0, c = t
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }(o._blendStateBuffer, s, c, o._blendStateWriterHost, r);
                                    return o._blendStateWriters.push(l), e(t, [], l)
                                }
                                return null
                            };
                            this._commonTargetStatuses = a.commonTargets.map((function(t) {
                                var n = s(QL, e, t.modifiers, t.valueAdapter, !1);
                                return null === n ? null : {
                                    target: n,
                                    changed: !1
                                }
                            })), t || (t = a.getPropertyCurves());
                            for (var c = function(n) {
                                    var i = t[n];
                                    if (i.curve.empty()) return "continue";
                                    var r = o._samplerSharedGroups.find((function(e) {
                                        return e.sampler === i.sampler
                                    }));
                                    r || (r = {
                                        sampler: i.sampler,
                                        curves: [],
                                        samplerResultCache: {
                                            from: 0,
                                            fromRatio: 0,
                                            to: 0,
                                            toRatio: 0
                                        }
                                    }, o._samplerSharedGroups.push(r));
                                    var a = void 0;
                                    if (void 0 === i.commonTarget) a = e;
                                    else {
                                        var c = o._commonTargetStatuses[i.commonTarget];
                                        if (!c) return "continue";
                                        a = c.target.peek()
                                    }
                                    var l = s(ZL, a, i.modifiers, i.valueAdapter, i.curve.constant());
                                    if (null === l);
                                    else {
                                        var u = new sB(i, a, l);
                                        u.commonTargetIndex = i.commonTarget, r.curves.push(u)
                                    }
                                }, l = 0; l < t.length; ++l) c(l)
                        }
                    }, n.destroy = function() {
                        this._destroyBlendStateWriters()
                    }, n.onBlendFinished = function() {
                        this._blendStateWriterHost.enabled = !1
                    }, n.emit = function() {
                        for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
                        i.director.getAnimationManager().pushDelayEvent(this._emit, this, t)
                    }, n.on = function(e, t, n) {
                        return this._target && this._target.isValid ? this._target.on(e, t, n) : null
                    }, n.once = function(e, t, n) {
                        return this._target && this._target.isValid ? this._target.once(e, t, n) : null
                    }, n.off = function(e, t, n) {
                        this._target && this._target.isValid && this._target.off(e, t, n)
                    }, n.allowLastFrameEvent = function(e) {
                        this._allowLastFrame = e
                    }, n._setEventTarget = function(e) {
                        this._target = e
                    }, n.setTime = function(e) {
                        this._currentFramePlayed = !1, this.time = e || 0, this._lastWrapInfoEvent = null, this._ignoreIndex = -1;
                        var t = this.getWrappedInfo(e, this._wrappedInfo),
                            n = t.direction,
                            i = this._clip.getEventGroupIndexAtRatio(t.ratio);
                        i < 0 && (i = ~i - 1, n < 0 && (i += 1), this._ignoreIndex = i)
                    }, n.update = function(e) {
                        this._delayTime > 0 && (this._delayTime -= e, this._delayTime > 0) || (this._currentFramePlayed ? this.time += e * this.speed : this._currentFramePlayed = !0, this._process())
                    }, n.sample = function() {
                        var e = this.getWrappedInfo(this.time, this._wrappedInfo);
                        return this._sampleCurves(e.ratio), this._sampleEvents(e), e
                    }, n.onPlay = function() {
                        this.setTime(0), this._delayTime = this._delay, this._onReplayOrResume(), this.emit(iB.PLAY, this)
                    }, n.onStop = function() {
                        this.isPaused || this._onPauseOrStop(), this.emit(iB.STOP, this)
                    }, n.onResume = function() {
                        this._onReplayOrResume(), this.emit(iB.RESUME, this)
                    }, n.onPause = function() {
                        this._onPauseOrStop(), this.emit(iB.PAUSE, this)
                    }, n._sampleCurves = function(e) {
                        this._blendStateWriterHost.weight = this.weight, this._blendStateWriterHost.enabled = !0;
                        for (var t = this._commonTargetStatuses, n = 0, i = t.length; n < i; ++n) {
                            var r = t[n];
                            r && (r.target.pull(), r.changed = !1)
                        }
                        for (var o = 0, a = !1, s = this._samplerSharedGroups, c = 0, l = s.length; c < l; ++c) {
                            var u = s[c],
                                h = u.sampler,
                                _ = u.samplerResultCache;
                            a = !1, h ? (o = h.sample(e)) < 0 && ((o = ~o) <= 0 ? o = 0 : o >= h.ratios.length ? o = h.ratios.length - 1 : (a = !0, _.from = o - 1, _.fromRatio = h.ratios[_.from], _.to = o, _.toRatio = h.ratios[_.to], o = _.from)) : o = 0;
                            for (var f = u.curves, d = 0, p = f.length; d < p; ++d) {
                                var m = f[d];
                                if (m.applySample(e, o, a, _, this.weight), void 0 !== m.commonTargetIndex) {
                                    var g = t[m.commonTargetIndex];
                                    g && (g.changed = !0)
                                }
                            }
                        }
                        for (var v = 0, y = t.length; v < y; ++v) {
                            var S = t[v];
                            S && S.changed && S.target.push()
                        }
                    }, n.process = function() {
                        var e, t = this.sample();
                        this._allowLastFrame && (e = this._lastWrapInfo ? this._lastWrapInfo : this._lastWrapInfo = new fu(t), this.repeatCount > 1 && (0 | t.iterations) > (0 | e.iterations) && this.emit(iB.LASTFRAME, this), e.set(t)), t.stopped && (this.stop(), this.emit(iB.FINISHED, this))
                    }, n.simpleProcess = function() {
                        var e = this._playbackRange.min,
                            t = this._playbackDuration,
                            n = this.time % t;
                        n < 0 && (n += t);
                        var i = (e + n) * this._invDuration;
                        this._sampleCurves(i), this._clip.hasEvents() && this._sampleEvents(this.getWrappedInfo(this.time, this._wrappedInfo)), this._allowLastFrame && (void 0 === this._lastIterations && (this._lastIterations = i), (this.time > 0 && this._lastIterations > i || this.time < 0 && this._lastIterations < i) && this.emit(iB.LASTFRAME, this), this._lastIterations = i)
                    }, n.cache = function() {}, n._needReverse = function(e) {
                        var t = this.wrapMode,
                            n = !1;
                        return (t & lu.PingPong) === lu.PingPong && (e - (0 | e) == 0 && e > 0 && (e -= 1), 1 & e && (n = !n)), (t & lu.Reverse) === lu.Reverse && (n = !n), n
                    }, n.getWrappedInfo = function(e, t) {
                        t = t || new fu;
                        var n = this._getPlaybackStart(),
                            i = this._getPlaybackEnd() - n,
                            r = !1,
                            o = this.repeatCount,
                            a = e > 0 ? e / i : -e / i;
                        if (a >= o) {
                            a = o, r = !0;
                            var s = o - (0 | o);
                            0 === s && (s = 1), e = s * i * (e > 0 ? 1 : -1)
                        }
                        if (e > i) {
                            var c = e % i;
                            e = 0 === c ? i : c
                        } else e < 0 && 0 != (e %= i) && (e += i);
                        var l = !1,
                            u = this._wrapMode & lu.ShouldWrap;
                        u && (l = this._needReverse(a));
                        var h = l ? -1 : 1;
                        return this.speed < 0 && (h *= -1), u && l && (e = i - e), t.time = n + e, t.ratio = t.time / this.duration, t.direction = h, t.stopped = r, t.iterations = a, t
                    }, n._getPlaybackStart = function() {
                        return this._playbackRange.min
                    }, n._getPlaybackEnd = function() {
                        return this._playbackRange.max
                    }, n._sampleEvents = function(e) {
                        var t = this._clip.eventGroups.length,
                            n = e.direction,
                            r = this._clip.getEventGroupIndexAtRatio(e.ratio);
                        if (r < 0 && (r = ~r - 1, n < 0 && (r += 1)), this._ignoreIndex !== r && (this._ignoreIndex = -1), e.frameIndex = r, !this._lastWrapInfoEvent) return this._fireEvent(r), void(this._lastWrapInfoEvent = new fu(e));
                        var o = this.wrapMode,
                            a = lB(e.iterations),
                            s = this._lastWrapInfoEvent,
                            c = lB(s.iterations),
                            l = s.frameIndex,
                            u = s.direction,
                            h = -1 !== c && a !== c;
                        if (l === r && h && 1 === t) this._fireEvent(0);
                        else if (l !== r || h) {
                            n = u;
                            do {
                                if (l !== r) {
                                    if (-1 === n && 0 === l && r > 0 ? ((o & lu.PingPong) === lu.PingPong ? n *= -1 : l = t, c++) : 1 === n && l === t - 1 && r < t - 1 && ((o & lu.PingPong) === lu.PingPong ? n *= -1 : l = -1, c++), l === r) break;
                                    if (c > a) break
                                }
                                l += n, i.director.getAnimationManager().pushDelayEvent(this._fireEvent, this, [l])
                            } while (l !== r && l > -1 && l < t)
                        }
                        this._lastWrapInfoEvent.set(e)
                    }, n._emit = function(e, t) {
                        this._target && this._target.isValid && this._target.emit(e, e, t)
                    }, n._fireEvent = function(e) {
                        if (this._targetNode && this._targetNode.isValid) {
                            var t = this._clip.eventGroups;
                            if (!(e < 0 || e >= t.length || this._ignoreIndex === e))
                                for (var n, i = t[e], r = this._targetNode.components, o = te(i.events); !(n = o()).done;)
                                    for (var a, s = n.value, c = s.functionName, l = te(r); !(a = l()).done;) {
                                        var u = a.value,
                                            h = u[c];
                                        "function" == typeof h && h.apply(u, s.parameters)
                                    }
                        }
                    }, n._onReplayOrResume = function() {
                        i.director.getAnimationManager().addAnimation(this)
                    }, n._onPauseOrStop = function() {
                        i.director.getAnimationManager().removeAnimation(this)
                    }, n._destroyBlendStateWriters = function() {
                        for (var e = 0; e < this._blendStateWriters.length; ++e) this._blendStateWriters[e].destroy();
                        this._blendStateWriters.length = 0, this._blendStateBuffer && (this._blendStateBuffer.unbindState(this), this._blendStateBuffer = null), this._blendStateWriterHost.enabled = !1
                    }, K(t, [{
                        key: "clip",
                        get: function() {
                            return this._clip
                        }
                    }, {
                        key: "name",
                        get: function() {
                            return this._name
                        }
                    }, {
                        key: "length",
                        get: function() {
                            return this.duration
                        }
                    }, {
                        key: "wrapMode",
                        get: function() {
                            return this._wrapMode
                        },
                        set: function(e) {
                            this._wrapMode = e, this.time = 0, e & lu.Loop ? this.repeatCount = 1 / 0 : this.repeatCount = 1
                        }
                    }, {
                        key: "repeatCount",
                        get: function() {
                            return this._repeatCount
                        },
                        set: function(e) {
                            this._repeatCount = e;
                            var t = this._wrapMode & lu.ShouldWrap,
                                n = (this.wrapMode & lu.Reverse) === lu.Reverse;
                            this._process = e !== 1 / 0 || t || n ? this.process : this.simpleProcess
                        }
                    }, {
                        key: "delay",
                        get: function() {
                            return this._delay
                        },
                        set: function(e) {
                            this._delayTime = this._delay = e
                        }
                    }, {
                        key: "playbackRange",
                        get: function() {
                            return this._playbackRange
                        },
                        set: function(e) {
                            e.max, e.min, this._playbackRange.min = Math.max(e.min, 0), this._playbackRange.max = Math.min(e.max, this.duration), this._playbackDuration = this._playbackRange.max - this._playbackRange.min, this.setTime(0)
                        }
                    }, {
                        key: "current",
                        get: function() {
                            return this.getWrappedInfo(this.time).time
                        }
                    }, {
                        key: "ratio",
                        get: function() {
                            return this.current / this.duration
                        }
                    }, {
                        key: "curveLoaded",
                        get: function() {
                            return this._curveLoaded
                        }
                    }]), t
                }(eB));

            function lB(e) {
                return e - (0 | e) == 0 && (e -= 1), 0 | e
            }
            i.AnimationState = cB;
            var uB, hB, _B, fB, dB, pB, mB, gB, vB, yB, SB, EB, TB, AB, xB, CB, bB, RB = function(e) {
                    function t() {
                        var t;
                        return (t = e.call(this) || this)._managedStates = [], t._fadings = [], t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.update = function(e) {
                        if (!this.isMotionless) {
                            var t = this._managedStates,
                                n = this._fadings;
                            if (1 === t.length && 1 === n.length) {
                                var i = t[0].state;
                                i && (i.weight = 1)
                            } else this._calculateWeights(e);
                            for (var r = 0; r < t.length; ++r) {
                                var o = t[r].state;
                                o && o.isMotionless && o.sample()
                            }
                        }
                    }, n.crossFade = function(e, t) {
                        var n;
                        0 === this._managedStates.length && (t = 0), 0 === t && this.clear();
                        var i = this._managedStates.find((function(t) {
                            return t.state === e
                        }));
                        i ? (null === (n = i.state) || void 0 === n ? void 0 : n.isMotionless) && i.state.play() : (i = {
                            state: e,
                            reference: 0
                        }, e && e.play(), this._managedStates.push(i)), ++i.reference, this._fadings.unshift({
                            easeDuration: t,
                            easeTime: 0,
                            target: i
                        })
                    }, n.clear = function() {
                        for (var e = 0; e < this._managedStates.length; ++e) {
                            var t = this._managedStates[e].state;
                            t && t.stop()
                        }
                        this._managedStates.length = 0, this._fadings.length = 0
                    }, n.onPlay = function() {
                        e.prototype.onPlay.call(this), i.director.getAnimationManager().addCrossFade(this)
                    }, n.onPause = function() {
                        e.prototype.onPause.call(this), i.director.getAnimationManager().removeCrossFade(this);
                        for (var t = 0; t < this._managedStates.length; ++t) {
                            var n = this._managedStates[t].state;
                            n && n.pause()
                        }
                    }, n.onResume = function() {
                        e.prototype.onResume.call(this), i.director.getAnimationManager().addCrossFade(this);
                        for (var t = 0; t < this._managedStates.length; ++t) {
                            var n = this._managedStates[t].state;
                            n && n.resume()
                        }
                    }, n.onStop = function() {
                        e.prototype.onStop.call(this), i.director.getAnimationManager().removeCrossFade(this), this.clear()
                    }, n._calculateWeights = function(e) {
                        for (var t = this._managedStates, n = (this._fadings, 0); n < t.length; ++n) {
                            var i = t[n].state;
                            i && (i.weight = 0)
                        }
                        for (var r = 1, o = this._fadings.length, a = 0; a < this._fadings.length; ++a) {
                            var s = this._fadings[a];
                            s.easeTime += e;
                            var c = 0 === s.easeDuration ? 1 : tn(s.easeTime / s.easeDuration),
                                l = c * r;
                            if (r *= 1 - c, s.target.state && (s.target.state.weight += l), s.easeTime >= s.easeDuration) {
                                o = a + 1, s.easeTime = s.easeDuration;
                                break
                            }
                        }
                        if (o !== this._fadings.length) {
                            for (var u = o; u < this._fadings.length; ++u) {
                                var h = this._fadings[u];
                                --h.target.reference, h.target.reference <= 0 && (h.target.state && h.target.state.stop(), se(this._managedStates, h.target))
                            }
                            this._fadings.splice(o)
                        }
                    }, t
                }(eB),
                wB = function(t) {
                    return e({
                        AnimationComponent: t,
                        Animation: t
                    }), t
                }((uB = A_("cc.Animation"), hB = B_(), _B = C_(99), fB = D_(), dB = ef([KL]), pB = G_(), mB = ef(KL), gB = G_(), vB = G_(), yB = ef([KL]), uB(SB = hB(SB = _B(SB = O_(SB = fB((bB = CB = function(e) {
                    function t() {
                        for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                        return ne(t = e.call.apply(e, [this].concat(i)) || this, "playOnLoad", TB, $(t)), t._crossFade = new RB, t._nameToState = Te(!0), ne(t, "_clips", AB, $(t)), ne(t, "_defaultClip", xB, $(t)), t._hasBeenPlayed = !1, t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.onLoad = function() {
                        for (var e in this.clips = this._clips, this._nameToState) this._nameToState[e].initialize(this.node)
                    }, n.start = function() {
                        this.playOnLoad && !this._hasBeenPlayed && this._defaultClip && this.crossFade(this._defaultClip.name, 0)
                    }, n.onEnable = function() {
                        this._crossFade.resume()
                    }, n.onDisable = function() {
                        this._crossFade.pause()
                    }, n.onDestroy = function() {
                        for (var e in this._crossFade.stop(), this._nameToState) this._nameToState[e].destroy();
                        this._nameToState = Te(!0)
                    }, n.play = function(e) {
                        if (this._hasBeenPlayed = !0, !e) {
                            if (!this._defaultClip) return;
                            e = this._defaultClip.name
                        }
                        this.crossFade(e, 0)
                    }, n.crossFade = function(e, t) {
                        void 0 === t && (t = .3), this._hasBeenPlayed = !0;
                        var n = this._nameToState[e];
                        n && (this._crossFade.play(), this._crossFade.crossFade(n, t))
                    }, n.pause = function() {
                        this._crossFade.pause()
                    }, n.resume = function() {
                        this._crossFade.resume()
                    }, n.stop = function() {
                        this._crossFade.stop()
                    }, n.getAnimationState = function(e) {
                        return this.getState(e)
                    }, n.getState = function(e) {
                        var t = this._nameToState[e];
                        return t && !t.curveLoaded && t.initialize(this.node), t || null
                    }, n.createState = function(e, t) {
                        return t = t || e.name, this.removeState(t), this._doCreateState(e, t)
                    }, n.removeState = function(e) {
                        var t = this._nameToState[e];
                        t && (t.allowLastFrameEvent(!1), t.stop(), delete this._nameToState[e])
                    }, n.addClip = function(e, t) {
                        return ce(this._clips, e) || this._clips.push(e), this.createState(e, t)
                    }, n.removeClip = function(e, t) {
                        var n;
                        for (var i in this._nameToState) {
                            var r = this._nameToState[i];
                            if (r.clip === e) {
                                n = r;
                                break
                            }
                        }
                        if (e === this._defaultClip) {
                            if (!t) return void x(3902);
                            this._defaultClip = null
                        }
                        if (n && n.isPlaying) {
                            if (!t) return void x(3903);
                            n.stop()
                        }
                        this._clips = this._clips.filter((function(t) {
                            return t !== e
                        })), n && delete this._nameToState[n.name]
                    }, n.on = function(t, n, i, r) {
                        var o = e.prototype.on.call(this, t, n, i, r);
                        return t === iB.LASTFRAME && this._syncAllowLastFrameEvent(), o
                    }, n.once = function(t, n, i) {
                        var r = e.prototype.once.call(this, t, n, i);
                        return t === iB.LASTFRAME && this._syncAllowLastFrameEvent(), r
                    }, n.off = function(t, n, i) {
                        e.prototype.off.call(this, t, n, i), t === iB.LASTFRAME && this._syncDisallowLastFrameEvent()
                    }, n._createState = function(e, t) {
                        return new cB(e, t)
                    }, n._doCreateState = function(e, t) {
                        var n = this._createState(e, t);
                        return n._setEventTarget(this), n.allowLastFrameEvent(this.hasEventListener(iB.LASTFRAME)), this.node && n.initialize(this.node), this._nameToState[n.name] = n, n
                    }, n._getStateByNameOrDefaultClip = function(e) {
                        if (!e) {
                            if (!this._defaultClip) return null;
                            e = this._defaultClip.name
                        }
                        return this._nameToState[e] || null
                    }, n._removeStateOfAutomaticClip = function(e) {
                        for (var t in this._nameToState) {
                            var n = this._nameToState[t];
                            IB(e, n.clip) && (n.stop(), delete this._nameToState[t])
                        }
                    }, n._syncAllowLastFrameEvent = function() {
                        if (this.hasEventListener(iB.LASTFRAME))
                            for (var e in this._nameToState) this._nameToState[e].allowLastFrameEvent(!0)
                    }, n._syncDisallowLastFrameEvent = function() {
                        if (!this.hasEventListener(iB.LASTFRAME))
                            for (var e in this._nameToState) this._nameToState[e].allowLastFrameEvent(!1)
                    }, K(t, [{
                        key: "clips",
                        get: function() {
                            return this._clips
                        },
                        set: function(e) {
                            var t = this;
                            this._crossFade && this._crossFade.clear();
                            for (var n, i = te(this._clips); !(n = i()).done;) {
                                var r = n.value;
                                r && this._removeStateOfAutomaticClip(r)
                            }
                            for (var o, a = te(e); !(o = a()).done;) {
                                var s = o.value;
                                s && this.createState(s)
                            }
                            var c = e.find((function(e) {
                                return IB(e, t._defaultClip)
                            }));
                            this._defaultClip = c || null, this._clips = e
                        }
                    }, {
                        key: "defaultClip",
                        get: function() {
                            return this._defaultClip
                        },
                        set: function(e) {
                            this._defaultClip = e, e && (this._clips.findIndex((function(t) {
                                return IB(t, e)
                            })) >= 0 || (this._clips.push(e), this.createState(e)))
                        }
                    }]), t
                }(_i(Jd)), CB.EventType = iB, ie((EB = bB).prototype, "clips", [dB, pB], Object.getOwnPropertyDescriptor(EB.prototype, "clips"), EB.prototype), ie(EB.prototype, "defaultClip", [mB, gB], Object.getOwnPropertyDescriptor(EB.prototype, "defaultClip"), EB.prototype), TB = ie(EB.prototype, "playOnLoad", [w_, vB], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return !1
                    }
                }), AB = ie(EB.prototype, "_clips", [yB], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return []
                    }
                }), xB = ie(EB.prototype, "_defaultClip", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return null
                    }
                }), SB = EB)) || SB) || SB) || SB) || SB) || SB));

            function IB(e, t) {
                return e === t || !(!e || !t || e.name !== t.name && e._uuid !== t._uuid)
            }
            U(wB.prototype, "Animation", [{
                name: "getAnimationState",
                newName: "getState"
            }, {
                name: "addClip",
                newName: "createState"
            }, {
                name: "removeClip",
                newName: "removeState",
                customFunction: function() {
                    var e = arguments.length <= 0 ? void 0 : arguments[0];
                    return wB.prototype.removeState.call(this, e.name)
                }
            }]), i.AnimationComponent = wB, Qe.setClassAlias(wB, "cc.AnimationComponent");
            var PB, OB, DB, NB = [],
                MB = new Map;

            function LB(e, t) {
                for (var n = 0, i = Bn.IDENTITY; e;) {
                    if (e.stamp === t || e.stamp + 1 === t && !e.node.hasChangedFlags) {
                        i = e.world, e.stamp = t;
                        break
                    }
                    e.stamp = t, NB[n++] = e, e = e.parent
                }
                for (; n > 0;) {
                    var r = (e = NB[--n]).node;
                    Bn.fromRTS(e.local, r.rotation, r.position, r.scale), i = Bn.multiply(e.world, i, e.local)
                }
                return i
            }

            function BB(e, t) {
                for (var n, i = null, r = 0; e !== t;) {
                    var o = e.uuid;
                    if (MB.has(o)) {
                        i = MB.get(o);
                        break
                    }
                    i = {
                        node: e,
                        local: new Bn,
                        world: new Bn,
                        stamp: -1,
                        parent: null
                    }, MB.set(o, i), NB[r++] = i, e = e.parent, i = null
                }
                for (; r > 0;)(n = NB[--r]).parent = i, i = n;
                return i
            }

            function FB(e) {
                for (var t = MB.get(e.uuid) || null; t;) MB.delete(t.node.uuid), t = t.parent
            }
            var zB = e("AnimationManager", A_((DB = OB = function(e) {
                function t() {
                    for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                    return (t = e.call.apply(e, [this].concat(i)) || this)._anims = new re([]), t._delayEvents = [], t._blendStateBuffer = new tB, t._crossFades = [], t._sockets = [], t
                }
                Q(t, e);
                var n = t.prototype;
                return n.addCrossFade = function(e) {
                    this._crossFades.push(e)
                }, n.removeCrossFade = function(e) {
                    se(this._crossFades, e)
                }, n.update = function(e) {
                    for (var t = this._delayEvents, n = this._crossFades, r = this._sockets, o = 0, a = n.length; o < a; o++) n[o].update(e);
                    var s = this._anims,
                        c = s.array;
                    for (s.i = 0; s.i < c.length; ++s.i) {
                        var l = c[s.i];
                        l.isMotionless || l.update(e)
                    }
                    this._blendStateBuffer.apply();
                    for (var u = i.director.getTotalFrames(), h = 0, _ = r.length; h < _; h++) {
                        var f = r[h],
                            d = f.target,
                            p = f.transform;
                        d.matrix = LB(p, u)
                    }
                    for (var m = 0, g = t.length; m < g; m++) {
                        var v = t[m];
                        v.fn.apply(v.thisArg, v.args)
                    }
                    t.length = 0
                }, n.destruct = function() {}, n.addAnimation = function(e) {
                    -1 === this._anims.array.indexOf(e) && this._anims.push(e)
                }, n.removeAnimation = function(e) {
                    var t = this._anims.array.indexOf(e);
                    t >= 0 ? this._anims.fastRemoveAt(t) : b(3907)
                }, n.pushDelayEvent = function(e, t, n) {
                    this._delayEvents.push({
                        fn: e,
                        thisArg: t,
                        args: n
                    })
                }, n.addSockets = function(e, t) {
                    for (var n = this, i = function(i) {
                            var r = t[i];
                            if (n._sockets.find((function(e) {
                                    return e.target === r.target
                                }))) return "continue";
                            var o = e.getChildByPath(r.path),
                                a = r.target && o && BB(o, e);
                            a && n._sockets.push({
                                target: r.target,
                                transform: a
                            })
                        }, r = 0; r < t.length; ++r) i(r)
                }, n.removeSockets = function(e, t) {
                    for (var n = 0; n < t.length; ++n)
                        for (var i = t[n], r = 0; r < this._sockets.length; ++r) {
                            var o = this._sockets[r];
                            if (o.target === i.target) {
                                FB(o.transform.node), this._sockets[r] = this._sockets[this._sockets.length - 1], this._sockets.length--;
                                break
                            }
                        }
                }, K(t, [{
                    key: "blendState",
                    get: function() {
                        return this._blendStateBuffer
                    }
                }]), t
            }(oR), OB.ID = "animation", PB = DB)) || PB);
            RO.on(bO.EVENT_INIT, (function() {
                var e = new zB;
                RO.registerSystem(zB.ID, e, hR.PRIORITY_SYSTEM)
            })), i.AnimationManager = zB;
            var UB, GB, HB, kB, VB = new Bn;

            function WB(e, t, n) {
                for (Bn.identity(n); e !== t;) Bn.fromRTS(VB, e.rotation, e.position, e.scale), Bn.multiply(n, VB, n), e = e.parent;
                return n
            }
            i.easing = nR;
            var jB = e("HierachyModifier", A_("cc.HierachyModifier")(UB = function(e) {
                function t() {
                    return e.apply(this, arguments) || this
                }
                return Q(t, e), t
            }(YM)) || UB);
            i.HierachyModifier = jB;
            var qB = e("ComponentModifier", A_("cc.ComponentModifier")(GB = function(e) {
                function t() {
                    return e.apply(this, arguments) || this
                }
                return Q(t, e), t
            }(KM)) || GB);
            i.ComponentModifier = qB;
            var XB = e("CurveValueAdapter", A_("cc.CurveValueAdapter")(HB = function() {
                function e() {}
                return e.prototype.forTarget = function() {
                    return {
                        set: function() {}
                    }
                }, e
            }()) || HB);
            i.CurveValueAdapter = XB;
            var YB = e("UniformCurveValueAdapter", A_("cc.UniformCurveValueAdapter")(kB = function(e) {
                function t() {
                    return e.apply(this, arguments) || this
                }
                return Q(t, e), t
            }(cL)) || kB);

            function KB(e) {
                return "string" == typeof e
            }

            function ZB(e) {
                return "number" == typeof e
            }

            function QB(e, t) {
                return e instanceof t
            }
            i.UniformCurveValueAdapter = YB, i.isPropertyModifier = KB, i.isElementModifier = ZB, i.isCustomTargetModifier = QB, i.math = Qn, i.geometry = wu;
            var JB = e("NodePool", function() {
                function e(e) {
                    this.poolHandlerComp = void 0, this._pool = void 0, this.poolHandlerComp = e, this._pool = []
                }
                var t = e.prototype;
                return t.size = function() {
                    return this._pool.length
                }, t.clear = function() {
                    for (var e = this._pool.length, t = 0; t < e; ++t) this._pool[t].destroy();
                    this._pool.length = 0
                }, t.put = function(e) {
                    if (e && -1 === this._pool.indexOf(e)) {
                        e.removeFromParent();
                        var t = this.poolHandlerComp ? e.getComponent(this.poolHandlerComp) : null;
                        t && t.unuse && t.unuse(), this._pool.push(e)
                    }
                }, t.get = function() {
                    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
                    var i = this._pool.length - 1;
                    if (i < 0) return null;
                    var r = this._pool[i];
                    this._pool.length = i;
                    var o = this.poolHandlerComp ? r.getComponent(this.poolHandlerComp) : null;
                    return o && o.reuse && o.reuse(arguments), r
                }, e
            }());
            i.NodePool = JB, i.renderer = xb;
            var $B, eF = function(e) {
                function t() {
                    for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                    return (t = e.call.apply(e, [this].concat(i)) || this)._gpuDescriptorSet = null, t
                }
                Q(t, e);
                var n = t.prototype;
                return n.initialize = function(e) {
                    this._layout = e.layout;
                    var t = e.layout.gpuDescriptorSetLayout,
                        n = t.bindings,
                        i = t.descriptorIndices,
                        r = t.descriptorCount;
                    this._buffers = Array(r).fill(null), this._textures = Array(r).fill(null), this._samplers = Array(r).fill(null);
                    var o = [];
                    this._gpuDescriptorSet = {
                        gpuDescriptors: o,
                        descriptorIndices: i
                    };
                    for (var a = 0; a < n.length; ++a)
                        for (var s = n[a], c = 0; c < s.count; c++) o.push({
                            type: s.descriptorType,
                            gpuBuffer: null,
                            gpuTexture: null,
                            gpuSampler: null
                        });
                    return !0
                }, n.destroy = function() {
                    this._layout = null, this._gpuDescriptorSet = null
                }, n.update = function() {
                    if (this._isDirty && this._gpuDescriptorSet) {
                        for (var e = this._gpuDescriptorSet.gpuDescriptors, t = 0; t < e.length; ++t)
                            if (e[t].type & nc) {
                                var n = this._buffers[t];
                                n && (e[t].gpuBuffer = n.gpuBuffer || n.gpuBufferView)
                            } else e[t].type & ic && (this._textures[t] && (e[t].gpuTexture = this._textures[t].gpuTexture), this._samplers[t] && (e[t].gpuSampler = this._samplers[t].gpuSampler));
                        this._isDirty = !1
                    }
                }, K(t, [{
                    key: "gpuDescriptorSet",
                    get: function() {
                        return this._gpuDescriptorSet
                    }
                }]), t
            }(Sc);

            function tF(e, t) {
                switch (e) {
                    case Ea.R8:
                        return t.UNSIGNED_BYTE;
                    case Ea.R8SN:
                        return t.BYTE;
                    case Ea.R8UI:
                        return t.UNSIGNED_BYTE;
                    case Ea.R8I:
                        return t.BYTE;
                    case Ea.R16F:
                        return $B.HALF_FLOAT_OES;
                    case Ea.R16UI:
                        return t.UNSIGNED_SHORT;
                    case Ea.R16I:
                        return t.SHORT;
                    case Ea.R32F:
                        return t.FLOAT;
                    case Ea.R32UI:
                        return t.UNSIGNED_INT;
                    case Ea.R32I:
                        return t.INT;
                    case Ea.RG8:
                        return t.UNSIGNED_BYTE;
                    case Ea.RG8SN:
                        return t.BYTE;
                    case Ea.RG8UI:
                        return t.UNSIGNED_BYTE;
                    case Ea.RG8I:
                        return t.BYTE;
                    case Ea.RG16F:
                        return $B.HALF_FLOAT_OES;
                    case Ea.RG16UI:
                        return t.UNSIGNED_SHORT;
                    case Ea.RG16I:
                        return t.SHORT;
                    case Ea.RG32F:
                        return t.FLOAT;
                    case Ea.RG32UI:
                        return t.UNSIGNED_INT;
                    case Ea.RG32I:
                        return t.INT;
                    case Ea.RGB8:
                    case Ea.SRGB8:
                        return t.UNSIGNED_BYTE;
                    case Ea.RGB8SN:
                        return t.BYTE;
                    case Ea.RGB8UI:
                        return t.UNSIGNED_BYTE;
                    case Ea.RGB8I:
                        return t.BYTE;
                    case Ea.RGB16F:
                        return $B.HALF_FLOAT_OES;
                    case Ea.RGB16UI:
                        return t.UNSIGNED_SHORT;
                    case Ea.RGB16I:
                        return t.SHORT;
                    case Ea.RGB32F:
                        return t.FLOAT;
                    case Ea.RGB32UI:
                        return t.UNSIGNED_INT;
                    case Ea.RGB32I:
                        return t.INT;
                    case Ea.BGRA8:
                    case Ea.RGBA8:
                    case Ea.SRGB8_A8:
                        return t.UNSIGNED_BYTE;
                    case Ea.RGBA8SN:
                        return t.BYTE;
                    case Ea.RGBA8UI:
                        return t.UNSIGNED_BYTE;
                    case Ea.RGBA8I:
                        return t.BYTE;
                    case Ea.RGBA16F:
                        return $B.HALF_FLOAT_OES;
                    case Ea.RGBA16UI:
                        return t.UNSIGNED_SHORT;
                    case Ea.RGBA16I:
                        return t.SHORT;
                    case Ea.RGBA32F:
                        return t.FLOAT;
                    case Ea.RGBA32UI:
                        return t.UNSIGNED_INT;
                    case Ea.RGBA32I:
                        return t.INT;
                    case Ea.R5G6B5:
                        return t.UNSIGNED_SHORT_5_6_5;
                    case Ea.R11G11B10F:
                        return t.FLOAT;
                    case Ea.RGB5A1:
                        return t.UNSIGNED_SHORT_5_5_5_1;
                    case Ea.RGBA4:
                        return t.UNSIGNED_SHORT_4_4_4_4;
                    case Ea.RGB10A2:
                        return t.UNSIGNED_BYTE;
                    case Ea.RGB10A2UI:
                        return t.UNSIGNED_INT;
                    case Ea.RGB9E5:
                        return t.UNSIGNED_BYTE;
                    case Ea.D16:
                        return t.UNSIGNED_SHORT;
                    case Ea.D16S8:
                        return $B.UNSIGNED_INT_24_8_WEBGL;
                    case Ea.D24:
                        return t.UNSIGNED_INT;
                    case Ea.D24S8:
                        return $B.UNSIGNED_INT_24_8_WEBGL;
                    case Ea.D32F:
                        return t.UNSIGNED_INT;
                    case Ea.D32F_S8:
                        return $B.UNSIGNED_INT_24_8_WEBGL;
                    case Ea.BC1:
                    case Ea.BC1_SRGB:
                    case Ea.BC2:
                    case Ea.BC2_SRGB:
                    case Ea.BC3:
                    case Ea.BC3_SRGB:
                    case Ea.BC4:
                        return t.UNSIGNED_BYTE;
                    case Ea.BC4_SNORM:
                        return t.BYTE;
                    case Ea.BC5:
                        return t.UNSIGNED_BYTE;
                    case Ea.BC5_SNORM:
                        return t.BYTE;
                    case Ea.BC6H_SF16:
                    case Ea.BC6H_UF16:
                        return t.FLOAT;
                    case Ea.BC7:
                    case Ea.BC7_SRGB:
                    case Ea.ETC_RGB8:
                    case Ea.ETC2_RGB8:
                    case Ea.ETC2_SRGB8:
                    case Ea.ETC2_RGB8_A1:
                    case Ea.ETC2_SRGB8_A1:
                    case Ea.EAC_R11:
                        return t.UNSIGNED_BYTE;
                    case Ea.EAC_R11SN:
                        return t.BYTE;
                    case Ea.EAC_RG11:
                        return t.UNSIGNED_BYTE;
                    case Ea.EAC_RG11SN:
                        return t.BYTE;
                    case Ea.PVRTC_RGB2:
                    case Ea.PVRTC_RGBA2:
                    case Ea.PVRTC_RGB4:
                    case Ea.PVRTC_RGBA4:
                    case Ea.PVRTC2_2BPP:
                    case Ea.PVRTC2_4BPP:
                        return t.UNSIGNED_BYTE;
                    case Ea.ASTC_RGBA_4x4:
                    case Ea.ASTC_RGBA_5x4:
                    case Ea.ASTC_RGBA_5x5:
                    case Ea.ASTC_RGBA_6x5:
                    case Ea.ASTC_RGBA_6x6:
                    case Ea.ASTC_RGBA_8x5:
                    case Ea.ASTC_RGBA_8x6:
                    case Ea.ASTC_RGBA_8x8:
                    case Ea.ASTC_RGBA_10x5:
                    case Ea.ASTC_RGBA_10x6:
                    case Ea.ASTC_RGBA_10x8:
                    case Ea.ASTC_RGBA_10x10:
                    case Ea.ASTC_RGBA_12x10:
                    case Ea.ASTC_RGBA_12x12:
                    case Ea.ASTC_SRGBA_4x4:
                    case Ea.ASTC_SRGBA_5x4:
                    case Ea.ASTC_SRGBA_5x5:
                    case Ea.ASTC_SRGBA_6x5:
                    case Ea.ASTC_SRGBA_6x6:
                    case Ea.ASTC_SRGBA_8x5:
                    case Ea.ASTC_SRGBA_8x6:
                    case Ea.ASTC_SRGBA_8x8:
                    case Ea.ASTC_SRGBA_10x5:
                    case Ea.ASTC_SRGBA_10x6:
                    case Ea.ASTC_SRGBA_10x8:
                    case Ea.ASTC_SRGBA_10x10:
                    case Ea.ASTC_SRGBA_12x10:
                    case Ea.ASTC_SRGBA_12x12:
                    default:
                        return t.UNSIGNED_BYTE
                }
            }

            function nF(e, t) {
                switch (e) {
                    case Ea.A8:
                        return t.ALPHA;
                    case Ea.L8:
                        return t.LUMINANCE;
                    case Ea.LA8:
                        return t.LUMINANCE_ALPHA;
                    case Ea.RGB8:
                    case Ea.RGB16F:
                    case Ea.RGB32F:
                        return t.RGB;
                    case Ea.BGRA8:
                    case Ea.RGBA8:
                    case Ea.RGBA16F:
                    case Ea.RGBA32F:
                        return t.RGBA;
                    case Ea.R5G6B5:
                        return t.RGB565;
                    case Ea.RGB5A1:
                        return t.RGB5_A1;
                    case Ea.RGBA4:
                        return t.RGBA4;
                    case Ea.D16:
                        return t.DEPTH_COMPONENT;
                    case Ea.D16S8:
                        return t.DEPTH_STENCIL;
                    case Ea.D24:
                        return t.DEPTH_COMPONENT;
                    case Ea.D24S8:
                        return t.DEPTH_STENCIL;
                    case Ea.D32F:
                        return t.DEPTH_COMPONENT;
                    case Ea.D32F_S8:
                        return t.DEPTH_STENCIL;
                    case Ea.BC1:
                        return $B.COMPRESSED_RGB_S3TC_DXT1_EXT;
                    case Ea.BC1_ALPHA:
                        return $B.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                    case Ea.BC1_SRGB:
                        return $B.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                    case Ea.BC1_SRGB_ALPHA:
                        return $B.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                    case Ea.BC2:
                        return $B.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                    case Ea.BC2_SRGB:
                        return $B.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                    case Ea.BC3:
                        return $B.COMPRESSED_RGBA_S3TC_DXT5_EXT;
                    case Ea.BC3_SRGB:
                        return $B.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
                    case Ea.ETC_RGB8:
                        return $B.COMPRESSED_RGB_ETC1_WEBGL;
                    case Ea.ETC2_RGB8:
                        return $B.COMPRESSED_RGB8_ETC2;
                    case Ea.ETC2_SRGB8:
                        return $B.COMPRESSED_SRGB8_ETC2;
                    case Ea.ETC2_RGB8_A1:
                        return $B.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2;
                    case Ea.ETC2_SRGB8_A1:
                        return $B.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2;
                    case Ea.ETC2_RGBA8:
                        return $B.COMPRESSED_RGBA8_ETC2_EAC;
                    case Ea.ETC2_SRGB8_A8:
                        return $B.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC;
                    case Ea.EAC_R11:
                        return $B.COMPRESSED_R11_EAC;
                    case Ea.EAC_R11SN:
                        return $B.COMPRESSED_SIGNED_R11_EAC;
                    case Ea.EAC_RG11:
                        return $B.COMPRESSED_RG11_EAC;
                    case Ea.EAC_RG11SN:
                        return $B.COMPRESSED_SIGNED_RG11_EAC;
                    case Ea.PVRTC_RGB2:
                        return $B.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                    case Ea.PVRTC_RGBA2:
                        return $B.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
                    case Ea.PVRTC_RGB4:
                        return $B.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                    case Ea.PVRTC_RGBA4:
                        return $B.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                    case Ea.ASTC_RGBA_4x4:
                        return $B.COMPRESSED_RGBA_ASTC_4x4_KHR;
                    case Ea.ASTC_RGBA_5x4:
                        return $B.COMPRESSED_RGBA_ASTC_5x4_KHR;
                    case Ea.ASTC_RGBA_5x5:
                        return $B.COMPRESSED_RGBA_ASTC_5x5_KHR;
                    case Ea.ASTC_RGBA_6x5:
                        return $B.COMPRESSED_RGBA_ASTC_6x5_KHR;
                    case Ea.ASTC_RGBA_6x6:
                        return $B.COMPRESSED_RGBA_ASTC_6x6_KHR;
                    case Ea.ASTC_RGBA_8x5:
                        return $B.COMPRESSED_RGBA_ASTC_8x5_KHR;
                    case Ea.ASTC_RGBA_8x6:
                        return $B.COMPRESSED_RGBA_ASTC_8x6_KHR;
                    case Ea.ASTC_RGBA_8x8:
                        return $B.COMPRESSED_RGBA_ASTC_8x8_KHR;
                    case Ea.ASTC_RGBA_10x5:
                        return $B.COMPRESSED_RGBA_ASTC_10x5_KHR;
                    case Ea.ASTC_RGBA_10x6:
                        return $B.COMPRESSED_RGBA_ASTC_10x6_KHR;
                    case Ea.ASTC_RGBA_10x8:
                        return $B.COMPRESSED_RGBA_ASTC_10x8_KHR;
                    case Ea.ASTC_RGBA_10x10:
                        return $B.COMPRESSED_RGBA_ASTC_10x10_KHR;
                    case Ea.ASTC_RGBA_12x10:
                        return $B.COMPRESSED_RGBA_ASTC_12x10_KHR;
                    case Ea.ASTC_RGBA_12x12:
                        return $B.COMPRESSED_RGBA_ASTC_12x12_KHR;
                    case Ea.ASTC_SRGBA_4x4:
                        return $B.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR;
                    case Ea.ASTC_SRGBA_5x4:
                        return $B.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR;
                    case Ea.ASTC_SRGBA_5x5:
                        return $B.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR;
                    case Ea.ASTC_SRGBA_6x5:
                        return $B.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR;
                    case Ea.ASTC_SRGBA_6x6:
                        return $B.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR;
                    case Ea.ASTC_SRGBA_8x5:
                        return $B.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR;
                    case Ea.ASTC_SRGBA_8x6:
                        return $B.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR;
                    case Ea.ASTC_SRGBA_8x8:
                        return $B.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR;
                    case Ea.ASTC_SRGBA_10x5:
                        return $B.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR;
                    case Ea.ASTC_SRGBA_10x6:
                        return $B.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR;
                    case Ea.ASTC_SRGBA_10x8:
                        return $B.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR;
                    case Ea.ASTC_SRGBA_10x10:
                        return $B.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR;
                    case Ea.ASTC_SRGBA_12x10:
                        return $B.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR;
                    case Ea.ASTC_SRGBA_12x12:
                        return $B.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR;
                    default:
                        return console.error("Unsupported Format, convert to WebGL internal format failed."), t.RGBA
                }
            }

            function iF(e, t) {
                switch (e) {
                    case Ea.A8:
                        return t.ALPHA;
                    case Ea.L8:
                        return t.LUMINANCE;
                    case Ea.LA8:
                        return t.LUMINANCE_ALPHA;
                    case Ea.RGB8:
                    case Ea.RGB16F:
                    case Ea.RGB32F:
                        return t.RGB;
                    case Ea.BGRA8:
                    case Ea.RGBA8:
                    case Ea.RGBA16F:
                    case Ea.RGBA32F:
                        return t.RGBA;
                    case Ea.R5G6B5:
                        return t.RGB;
                    case Ea.RGB5A1:
                    case Ea.RGBA4:
                        return t.RGBA;
                    case Ea.D16:
                        return t.DEPTH_COMPONENT;
                    case Ea.D16S8:
                        return t.DEPTH_STENCIL;
                    case Ea.D24:
                        return t.DEPTH_COMPONENT;
                    case Ea.D24S8:
                        return t.DEPTH_STENCIL;
                    case Ea.D32F:
                        return t.DEPTH_COMPONENT;
                    case Ea.D32F_S8:
                        return t.DEPTH_STENCIL;
                    case Ea.BC1:
                        return $B.COMPRESSED_RGB_S3TC_DXT1_EXT;
                    case Ea.BC1_ALPHA:
                        return $B.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                    case Ea.BC1_SRGB:
                        return $B.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                    case Ea.BC1_SRGB_ALPHA:
                        return $B.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                    case Ea.BC2:
                        return $B.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                    case Ea.BC2_SRGB:
                        return $B.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                    case Ea.BC3:
                        return $B.COMPRESSED_RGBA_S3TC_DXT5_EXT;
                    case Ea.BC3_SRGB:
                        return $B.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
                    case Ea.ETC_RGB8:
                        return $B.COMPRESSED_RGB_ETC1_WEBGL;
                    case Ea.ETC2_RGB8:
                        return $B.COMPRESSED_RGB8_ETC2;
                    case Ea.ETC2_SRGB8:
                        return $B.COMPRESSED_SRGB8_ETC2;
                    case Ea.ETC2_RGB8_A1:
                        return $B.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2;
                    case Ea.ETC2_SRGB8_A1:
                        return $B.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2;
                    case Ea.ETC2_RGBA8:
                        return $B.COMPRESSED_RGBA8_ETC2_EAC;
                    case Ea.ETC2_SRGB8_A8:
                        return $B.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC;
                    case Ea.EAC_R11:
                        return $B.COMPRESSED_R11_EAC;
                    case Ea.EAC_R11SN:
                        return $B.COMPRESSED_SIGNED_R11_EAC;
                    case Ea.EAC_RG11:
                        return $B.COMPRESSED_RG11_EAC;
                    case Ea.EAC_RG11SN:
                        return $B.COMPRESSED_SIGNED_RG11_EAC;
                    case Ea.PVRTC_RGB2:
                        return $B.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                    case Ea.PVRTC_RGBA2:
                        return $B.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
                    case Ea.PVRTC_RGB4:
                        return $B.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                    case Ea.PVRTC_RGBA4:
                        return $B.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                    case Ea.ASTC_RGBA_4x4:
                        return $B.COMPRESSED_RGBA_ASTC_4x4_KHR;
                    case Ea.ASTC_RGBA_5x4:
                        return $B.COMPRESSED_RGBA_ASTC_5x4_KHR;
                    case Ea.ASTC_RGBA_5x5:
                        return $B.COMPRESSED_RGBA_ASTC_5x5_KHR;
                    case Ea.ASTC_RGBA_6x5:
                        return $B.COMPRESSED_RGBA_ASTC_6x5_KHR;
                    case Ea.ASTC_RGBA_6x6:
                        return $B.COMPRESSED_RGBA_ASTC_6x6_KHR;
                    case Ea.ASTC_RGBA_8x5:
                        return $B.COMPRESSED_RGBA_ASTC_8x5_KHR;
                    case Ea.ASTC_RGBA_8x6:
                        return $B.COMPRESSED_RGBA_ASTC_8x6_KHR;
                    case Ea.ASTC_RGBA_8x8:
                        return $B.COMPRESSED_RGBA_ASTC_8x8_KHR;
                    case Ea.ASTC_RGBA_10x5:
                        return $B.COMPRESSED_RGBA_ASTC_10x5_KHR;
                    case Ea.ASTC_RGBA_10x6:
                        return $B.COMPRESSED_RGBA_ASTC_10x6_KHR;
                    case Ea.ASTC_RGBA_10x8:
                        return $B.COMPRESSED_RGBA_ASTC_10x8_KHR;
                    case Ea.ASTC_RGBA_10x10:
                        return $B.COMPRESSED_RGBA_ASTC_10x10_KHR;
                    case Ea.ASTC_RGBA_12x10:
                        return $B.COMPRESSED_RGBA_ASTC_12x10_KHR;
                    case Ea.ASTC_RGBA_12x12:
                        return $B.COMPRESSED_RGBA_ASTC_12x12_KHR;
                    case Ea.ASTC_SRGBA_4x4:
                        return $B.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR;
                    case Ea.ASTC_SRGBA_5x4:
                        return $B.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR;
                    case Ea.ASTC_SRGBA_5x5:
                        return $B.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR;
                    case Ea.ASTC_SRGBA_6x5:
                        return $B.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR;
                    case Ea.ASTC_SRGBA_6x6:
                        return $B.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR;
                    case Ea.ASTC_SRGBA_8x5:
                        return $B.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR;
                    case Ea.ASTC_SRGBA_8x6:
                        return $B.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR;
                    case Ea.ASTC_SRGBA_8x8:
                        return $B.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR;
                    case Ea.ASTC_SRGBA_10x5:
                        return $B.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR;
                    case Ea.ASTC_SRGBA_10x6:
                        return $B.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR;
                    case Ea.ASTC_SRGBA_10x8:
                        return $B.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR;
                    case Ea.ASTC_SRGBA_10x10:
                        return $B.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR;
                    case Ea.ASTC_SRGBA_12x10:
                        return $B.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR;
                    case Ea.ASTC_SRGBA_12x12:
                        return $B.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR;
                    default:
                        return console.error("Unsupported Format, convert to WebGL format failed."), t.RGBA
                }
            }

            function rF(e, t) {
                switch (e) {
                    case Aa.BOOL:
                        return t.BOOL;
                    case Aa.BOOL2:
                        return t.BOOL_VEC2;
                    case Aa.BOOL3:
                        return t.BOOL_VEC3;
                    case Aa.BOOL4:
                        return t.BOOL_VEC4;
                    case Aa.INT:
                        return t.INT;
                    case Aa.INT2:
                        return t.INT_VEC2;
                    case Aa.INT3:
                        return t.INT_VEC3;
                    case Aa.INT4:
                        return t.INT_VEC4;
                    case Aa.UINT:
                        return t.UNSIGNED_INT;
                    case Aa.FLOAT:
                        return t.FLOAT;
                    case Aa.FLOAT2:
                        return t.FLOAT_VEC2;
                    case Aa.FLOAT3:
                        return t.FLOAT_VEC3;
                    case Aa.FLOAT4:
                        return t.FLOAT_VEC4;
                    case Aa.MAT2:
                        return t.FLOAT_MAT2;
                    case Aa.MAT3:
                        return t.FLOAT_MAT3;
                    case Aa.MAT4:
                        return t.FLOAT_MAT4;
                    case Aa.SAMPLER2D:
                        return t.SAMPLER_2D;
                    case Aa.SAMPLER_CUBE:
                        return t.SAMPLER_CUBE;
                    default:
                        return console.error("Unsupported GLType, convert to GL type failed."), Aa.UNKNOWN
                }
            }

            function oF(e) {
                switch (e) {
                    case Aa.BOOL:
                    case Aa.BOOL2:
                    case Aa.BOOL3:
                    case Aa.BOOL4:
                    case Aa.INT:
                    case Aa.INT2:
                    case Aa.INT3:
                    case Aa.INT4:
                    case Aa.UINT:
                        return Int32Array;
                    case Aa.FLOAT:
                    case Aa.FLOAT2:
                    case Aa.FLOAT3:
                    case Aa.FLOAT4:
                    case Aa.MAT2:
                    case Aa.MAT3:
                    case Aa.MAT4:
                        return Float32Array;
                    default:
                        return console.error("Unsupported GLType, convert to TypedArrayConstructor failed."), Float32Array
                }
            }

            function aF(e, t) {
                switch (e) {
                    case t.BOOL:
                        return Aa.BOOL;
                    case t.BOOL_VEC2:
                        return Aa.BOOL2;
                    case t.BOOL_VEC3:
                        return Aa.BOOL3;
                    case t.BOOL_VEC4:
                        return Aa.BOOL4;
                    case t.INT:
                        return Aa.INT;
                    case t.INT_VEC2:
                        return Aa.INT2;
                    case t.INT_VEC3:
                        return Aa.INT3;
                    case t.INT_VEC4:
                        return Aa.INT4;
                    case t.UNSIGNED_INT:
                        return Aa.UINT;
                    case t.FLOAT:
                        return Aa.FLOAT;
                    case t.FLOAT_VEC2:
                        return Aa.FLOAT2;
                    case t.FLOAT_VEC3:
                        return Aa.FLOAT3;
                    case t.FLOAT_VEC4:
                        return Aa.FLOAT4;
                    case t.FLOAT_MAT2:
                        return Aa.MAT2;
                    case t.FLOAT_MAT3:
                        return Aa.MAT3;
                    case t.FLOAT_MAT4:
                        return Aa.MAT4;
                    case t.SAMPLER_2D:
                        return Aa.SAMPLER2D;
                    case t.SAMPLER_CUBE:
                        return Aa.SAMPLER_CUBE;
                    default:
                        return console.error("Unsupported GLType, convert to Type failed."), Aa.UNKNOWN
                }
            }

            function sF(e, t) {
                switch (e) {
                    case t.BOOL:
                        return 4;
                    case t.BOOL_VEC2:
                        return 8;
                    case t.BOOL_VEC3:
                        return 12;
                    case t.BOOL_VEC4:
                        return 16;
                    case t.INT:
                        return 4;
                    case t.INT_VEC2:
                        return 8;
                    case t.INT_VEC3:
                        return 12;
                    case t.INT_VEC4:
                        return 16;
                    case t.UNSIGNED_INT:
                    case t.FLOAT:
                        return 4;
                    case t.FLOAT_VEC2:
                        return 8;
                    case t.FLOAT_VEC3:
                        return 12;
                    case t.FLOAT_VEC4:
                    case t.FLOAT_MAT2:
                        return 16;
                    case t.FLOAT_MAT3:
                        return 36;
                    case t.FLOAT_MAT4:
                        return 64;
                    case t.SAMPLER_2D:
                    case t.SAMPLER_CUBE:
                        return 4;
                    default:
                        return console.error("Unsupported GLType, get type failed."), 0
                }
            }

            function cF(e, t) {
                switch (e) {
                    case t.FLOAT_MAT2:
                        return 2;
                    case t.FLOAT_MAT3:
                        return 3;
                    case t.FLOAT_MAT4:
                        return 4;
                    default:
                        return 1
                }
            }! function(e) {
                e[e.RGBA16F_EXT = 34842] = "RGBA16F_EXT", e[e.RGB16F_EXT = 34843] = "RGB16F_EXT", e[e.RGBA32F_EXT = 34836] = "RGBA32F_EXT", e[e.FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT = 33297] = "FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT", e[e.UNSIGNED_NORMALIZED_EXT = 35863] = "UNSIGNED_NORMALIZED_EXT", e[e.UNSIGNED_INT_24_8_WEBGL = 34042] = "UNSIGNED_INT_24_8_WEBGL", e[e.HALF_FLOAT_OES = 36193] = "HALF_FLOAT_OES", e[e.COMPRESSED_RGB_S3TC_DXT1_EXT = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT", e[e.COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT", e[e.COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT", e[e.COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT", e[e.COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT", e[e.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT", e[e.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT", e[e.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT", e[e.COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG", e[e.COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG", e[e.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG", e[e.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG", e[e.COMPRESSED_RGB_ETC1_WEBGL = 36196] = "COMPRESSED_RGB_ETC1_WEBGL", e[e.COMPRESSED_R11_EAC = 37488] = "COMPRESSED_R11_EAC", e[e.COMPRESSED_SIGNED_R11_EAC = 37489] = "COMPRESSED_SIGNED_R11_EAC", e[e.COMPRESSED_RG11_EAC = 37490] = "COMPRESSED_RG11_EAC", e[e.COMPRESSED_SIGNED_RG11_EAC = 37491] = "COMPRESSED_SIGNED_RG11_EAC", e[e.COMPRESSED_RGB8_ETC2 = 37492] = "COMPRESSED_RGB8_ETC2", e[e.COMPRESSED_SRGB8_ETC2 = 37493] = "COMPRESSED_SRGB8_ETC2", e[e.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37494] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2", e[e.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37495] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2", e[e.COMPRESSED_RGBA8_ETC2_EAC = 37496] = "COMPRESSED_RGBA8_ETC2_EAC", e[e.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37497] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC", e[e.COMPRESSED_RGBA_ASTC_4x4_KHR = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR", e[e.COMPRESSED_RGBA_ASTC_5x4_KHR = 37809] = "COMPRESSED_RGBA_ASTC_5x4_KHR", e[e.COMPRESSED_RGBA_ASTC_5x5_KHR = 37810] = "COMPRESSED_RGBA_ASTC_5x5_KHR", e[e.COMPRESSED_RGBA_ASTC_6x5_KHR = 37811] = "COMPRESSED_RGBA_ASTC_6x5_KHR", e[e.COMPRESSED_RGBA_ASTC_6x6_KHR = 37812] = "COMPRESSED_RGBA_ASTC_6x6_KHR", e[e.COMPRESSED_RGBA_ASTC_8x5_KHR = 37813] = "COMPRESSED_RGBA_ASTC_8x5_KHR", e[e.COMPRESSED_RGBA_ASTC_8x6_KHR = 37814] = "COMPRESSED_RGBA_ASTC_8x6_KHR", e[e.COMPRESSED_RGBA_ASTC_8x8_KHR = 37815] = "COMPRESSED_RGBA_ASTC_8x8_KHR", e[e.COMPRESSED_RGBA_ASTC_10x5_KHR = 37816] = "COMPRESSED_RGBA_ASTC_10x5_KHR", e[e.COMPRESSED_RGBA_ASTC_10x6_KHR = 37817] = "COMPRESSED_RGBA_ASTC_10x6_KHR", e[e.COMPRESSED_RGBA_ASTC_10x8_KHR = 37818] = "COMPRESSED_RGBA_ASTC_10x8_KHR", e[e.COMPRESSED_RGBA_ASTC_10x10_KHR = 37819] = "COMPRESSED_RGBA_ASTC_10x10_KHR", e[e.COMPRESSED_RGBA_ASTC_12x10_KHR = 37820] = "COMPRESSED_RGBA_ASTC_12x10_KHR", e[e.COMPRESSED_RGBA_ASTC_12x12_KHR = 37821] = "COMPRESSED_RGBA_ASTC_12x12_KHR", e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR = 37840] = "COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR", e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR = 37841] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR", e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR = 37842] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR", e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR = 37843] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR", e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR = 37844] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR", e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR = 37845] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR", e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR = 37846] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR", e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR = 37847] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR", e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR = 37848] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR", e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR = 37849] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR", e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR = 37850] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR", e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR = 37851] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR", e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR = 37852] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR", e[e.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR = 37853] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR"
            }($B || ($B = {}));
            var lF, uF = [512, 513, 514, 515, 516, 517, 518, 519],
                hF = [0, 7680, 7681, 7682, 7683, 5386, 34055, 34056],
                _F = [32774, 32778, 32779, 32775, 32776],
                fF = [0, 1, 770, 772, 771, 773, 768, 774, 769, 775, 776, 32769, 32770, 32771, 32772];
            ! function(e) {
                e[e.BEGIN_RENDER_PASS = 0] = "BEGIN_RENDER_PASS", e[e.END_RENDER_PASS = 1] = "END_RENDER_PASS", e[e.BIND_STATES = 2] = "BIND_STATES", e[e.DRAW = 3] = "DRAW", e[e.UPDATE_BUFFER = 4] = "UPDATE_BUFFER", e[e.COPY_BUFFER_TO_TEXTURE = 5] = "COPY_BUFFER_TO_TEXTURE", e[e.COUNT = 6] = "COUNT"
            }(lF || (lF = {}));
            var dF = function(e) {
                    this.cmdType = void 0, this.refCount = 0, this.cmdType = e
                },
                pF = function(e) {
                    function t() {
                        var t;
                        return (t = e.call(this, lF.BEGIN_RENDER_PASS) || this).gpuRenderPass = null, t.gpuFramebuffer = null, t.renderArea = new ss, t.clearFlag = $a.NONE, t.clearColors = [], t.clearDepth = 1, t.clearStencil = 0, t
                    }
                    return Q(t, e), t.prototype.clear = function() {
                        this.gpuFramebuffer = null, this.clearColors.length = 0
                    }, t
                }(dF),
                mF = function(e) {
                    function t() {
                        var t;
                        return (t = e.call(this, lF.BIND_STATES) || this).gpuPipelineState = null, t.gpuInputAssembler = null, t.gpuDescriptorSets = [], t.dynamicOffsets = [], t.viewport = null, t.scissor = null, t.lineWidth = null, t.depthBias = null, t.blendConstants = [], t.depthBounds = null, t.stencilWriteMask = null, t.stencilCompareMask = null, t
                    }
                    return Q(t, e), t.prototype.clear = function() {
                        this.gpuPipelineState = null, this.gpuDescriptorSets.length = 0, this.gpuInputAssembler = null, this.dynamicOffsets.length = 0, this.viewport = null, this.scissor = null, this.lineWidth = null, this.depthBias = null, this.blendConstants.length = 0, this.depthBounds = null, this.stencilWriteMask = null, this.stencilCompareMask = null
                    }, t
                }(dF),
                gF = function(e) {
                    function t() {
                        var t;
                        return (t = e.call(this, lF.DRAW) || this).drawInfo = new ys, t
                    }
                    return Q(t, e), t.prototype.clear = function() {}, t
                }(dF),
                vF = function(e) {
                    function t() {
                        var t;
                        return (t = e.call(this, lF.UPDATE_BUFFER) || this).gpuBuffer = null, t.buffer = null, t.offset = 0, t.size = 0, t
                    }
                    return Q(t, e), t.prototype.clear = function() {
                        this.gpuBuffer = null, this.buffer = null
                    }, t
                }(dF),
                yF = function(e) {
                    function t() {
                        var t;
                        return (t = e.call(this, lF.COPY_BUFFER_TO_TEXTURE) || this).gpuTexture = null, t.buffers = [], t.regions = [], t
                    }
                    return Q(t, e), t.prototype.clear = function() {
                        this.gpuTexture = null, this.buffers.length = 0, this.regions.length = 0
                    }, t
                }(dF),
                SF = function() {
                    function e() {
                        this.cmds = new ei(1), this.beginRenderPassCmds = new ei(1), this.bindStatesCmds = new ei(1), this.drawCmds = new ei(1), this.updateBufferCmds = new ei(1), this.copyBufferToTextureCmds = new ei(1)
                    }
                    return e.prototype.clearCmds = function(e) {
                        this.beginRenderPassCmds.length && (e.beginRenderPassCmdPool.freeCmds(this.beginRenderPassCmds), this.beginRenderPassCmds.clear()), this.bindStatesCmds.length && (e.bindStatesCmdPool.freeCmds(this.bindStatesCmds), this.bindStatesCmds.clear()), this.drawCmds.length && (e.drawCmdPool.freeCmds(this.drawCmds), this.drawCmds.clear()), this.updateBufferCmds.length && (e.updateBufferCmdPool.freeCmds(this.updateBufferCmds), this.updateBufferCmds.clear()), this.copyBufferToTextureCmds.length && (e.copyBufferToTextureCmdPool.freeCmds(this.copyBufferToTextureCmds), this.copyBufferToTextureCmds.clear()), this.cmds.clear()
                    }, e
                }();

            function EF(e, t, n, i, r) {
                if (t.usage & xa.UNIFORM) ArrayBuffer.isView(n) ? t.vf32.set(n, i / Float32Array.BYTES_PER_ELEMENT) : t.vf32.set(new Float32Array(n), i / Float32Array.BYTES_PER_ELEMENT);
                else if (t.usage & xa.INDIRECT) t.indirects.length = i, Array.prototype.push.apply(t.indirects, n.drawInfos);
                else {
                    var o = n,
                        a = e.gl,
                        s = e.stateCache;
                    switch (t.glTarget) {
                        case a.ARRAY_BUFFER:
                            e.useVAO && s.glVAO && (e.OES_vertex_array_object.bindVertexArrayOES(null), s.glVAO = TF.gpuInputAssembler = null), e.stateCache.glArrayBuffer !== t.glBuffer && (a.bindBuffer(a.ARRAY_BUFFER, t.glBuffer), e.stateCache.glArrayBuffer = t.glBuffer);
                            break;
                        case a.ELEMENT_ARRAY_BUFFER:
                            e.useVAO && s.glVAO && (e.OES_vertex_array_object.bindVertexArrayOES(null), s.glVAO = TF.gpuInputAssembler = null), e.stateCache.glElementArrayBuffer !== t.glBuffer && (a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, t.glBuffer), e.stateCache.glElementArrayBuffer = t.glBuffer);
                            break;
                        default:
                            return void console.error("Unsupported BufferType, update buffer failed.")
                    }
                    r === o.byteLength ? a.bufferSubData(t.glTarget, i, o) : a.bufferSubData(t.glTarget, i, o.slice(0, r))
                }
            }
            var TF = {
                gpuPipelineState: null,
                gpuInputAssembler: null,
                glPrimitive: 0
            };

            function AF(e, t, n, i, r, o, a) {
                var s = e.gl,
                    c = e.stateCache,
                    l = 0;
                if (n && t) {
                    c.glFramebuffer !== n.glFramebuffer && (s.bindFramebuffer(s.FRAMEBUFFER, n.glFramebuffer), c.glFramebuffer = n.glFramebuffer), c.viewport.left === i.x && c.viewport.top === i.y && c.viewport.width === i.width && c.viewport.height === i.height || (s.viewport(i.x, i.y, i.width, i.height), c.viewport.left = i.x, c.viewport.top = i.y, c.viewport.width = i.width, c.viewport.height = i.height), c.scissorRect.x === i.x && c.scissorRect.y === i.y && c.scissorRect.width === i.width && c.scissorRect.height === i.height || (s.scissor(i.x, i.y, i.width, i.height), c.scissorRect.x = i.x, c.scissorRect.y = i.y, c.scissorRect.width = i.width, c.scissorRect.height = i.height);
                    var u = r.length;
                    e.WEBGL_draw_buffers || (u = 1);
                    for (var h = 0; h < u; ++h) {
                        var _ = t.colorAttachments[h];
                        if (_.format !== Ea.UNKNOWN) switch (_.loadOp) {
                            case Ga.LOAD:
                                break;
                            case Ga.CLEAR:
                                c.bs.targets[0].blendColorMask !== za.ALL && s.colorMask(!0, !0, !0, !0);
                                var f = r[0];
                                s.clearColor(f.x, f.y, f.z, f.w), l |= s.COLOR_BUFFER_BIT;
                                break;
                            case Ga.DISCARD:
                        }
                    }
                    if (t.depthStencilAttachment && t.depthStencilAttachment.format !== Ea.UNKNOWN) {
                        switch (t.depthStencilAttachment.depthLoadOp) {
                            case Ga.LOAD:
                                break;
                            case Ga.CLEAR:
                                c.dss.depthWrite || s.depthMask(!0), s.clearDepth(o), l |= s.DEPTH_BUFFER_BIT;
                                break;
                            case Ga.DISCARD:
                        }
                        if (tc[t.depthStencilAttachment.format].hasStencil) switch (t.depthStencilAttachment.stencilLoadOp) {
                            case Ga.LOAD:
                                break;
                            case Ga.CLEAR:
                                c.dss.stencilWriteMaskFront || s.stencilMaskSeparate(s.FRONT, 65535), c.dss.stencilWriteMaskBack || s.stencilMaskSeparate(s.BACK, 65535), s.clearStencil(a), l |= s.STENCIL_BUFFER_BIT;
                                break;
                            case Ga.DISCARD:
                        }
                    }
                    if (l && s.clear(l), l & s.COLOR_BUFFER_BIT) {
                        var d = c.bs.targets[0].blendColorMask;
                        if (d !== za.ALL) {
                            var p = (d & za.R) !== za.NONE,
                                m = (d & za.G) !== za.NONE,
                                g = (d & za.B) !== za.NONE,
                                v = (d & za.A) !== za.NONE;
                            s.colorMask(p, m, g, v)
                        }
                    }
                    l & s.DEPTH_BUFFER_BIT && !c.dss.depthWrite && s.depthMask(!1), l & s.STENCIL_BUFFER_BIT && (c.dss.stencilWriteMaskFront || s.stencilMaskSeparate(s.FRONT, 0), c.dss.stencilWriteMaskBack || s.stencilMaskSeparate(s.BACK, 0))
                }
            }

            function xF(e, t, n, i, r, o, a, s, c, l, u, h, _) {
                var f, d, m, g = e.gl,
                    v = e.stateCache,
                    y = t && t.gpuShader,
                    S = !1;
                if (t && TF.gpuPipelineState !== t) {
                    if (TF.gpuPipelineState = t, TF.glPrimitive = t.glPrimitive, t.gpuShader) {
                        var E = t.gpuShader.glProgram;
                        v.glProgram !== E && (g.useProgram(E), v.glProgram = E, S = !0)
                    }
                    var T = t.rs;
                    if (T) {
                        if (v.rs.cullMode !== T.cullMode) {
                            switch (T.cullMode) {
                                case Xa.NONE:
                                    g.disable(g.CULL_FACE);
                                    break;
                                case Xa.FRONT:
                                    g.enable(g.CULL_FACE), g.cullFace(g.FRONT);
                                    break;
                                case Xa.BACK:
                                    g.enable(g.CULL_FACE), g.cullFace(g.BACK)
                            }
                            v.rs.cullMode = T.cullMode
                        }
                        var A = T.isFrontFaceCCW;
                        v.rs.isFrontFaceCCW !== A && (g.frontFace(A ? g.CCW : g.CW), v.rs.isFrontFaceCCW = A), v.rs.depthBias === T.depthBias && v.rs.depthBiasSlop === T.depthBiasSlop || (g.polygonOffset(T.depthBias, T.depthBiasSlop), v.rs.depthBias = T.depthBias, v.rs.depthBiasSlop = T.depthBiasSlop), v.rs.lineWidth !== T.lineWidth && (g.lineWidth(T.lineWidth), v.rs.lineWidth = T.lineWidth)
                    }
                    var x = t.dss;
                    x && (v.dss.depthTest !== x.depthTest && (x.depthTest ? g.enable(g.DEPTH_TEST) : g.disable(g.DEPTH_TEST), v.dss.depthTest = x.depthTest), v.dss.depthWrite !== x.depthWrite && (g.depthMask(x.depthWrite), v.dss.depthWrite = x.depthWrite), v.dss.depthFunc !== x.depthFunc && (g.depthFunc(uF[x.depthFunc]), v.dss.depthFunc = x.depthFunc), v.dss.stencilTestFront === x.stencilTestFront && v.dss.stencilTestBack === x.stencilTestBack || (x.stencilTestFront || x.stencilTestBack ? g.enable(g.STENCIL_TEST) : g.disable(g.STENCIL_TEST), v.dss.stencilTestFront = x.stencilTestFront, v.dss.stencilTestBack = x.stencilTestBack), v.dss.stencilFuncFront === x.stencilFuncFront && v.dss.stencilRefFront === x.stencilRefFront && v.dss.stencilReadMaskFront === x.stencilReadMaskFront || (g.stencilFuncSeparate(g.FRONT, uF[x.stencilFuncFront], x.stencilRefFront, x.stencilReadMaskFront), v.dss.stencilFuncFront = x.stencilFuncFront, v.dss.stencilRefFront = x.stencilRefFront, v.dss.stencilReadMaskFront = x.stencilReadMaskFront), v.dss.stencilFailOpFront === x.stencilFailOpFront && v.dss.stencilZFailOpFront === x.stencilZFailOpFront && v.dss.stencilPassOpFront === x.stencilPassOpFront || (g.stencilOpSeparate(g.FRONT, hF[x.stencilFailOpFront], hF[x.stencilZFailOpFront], hF[x.stencilPassOpFront]), v.dss.stencilFailOpFront = x.stencilFailOpFront, v.dss.stencilZFailOpFront = x.stencilZFailOpFront, v.dss.stencilPassOpFront = x.stencilPassOpFront), v.dss.stencilWriteMaskFront !== x.stencilWriteMaskFront && (g.stencilMaskSeparate(g.FRONT, x.stencilWriteMaskFront), v.dss.stencilWriteMaskFront = x.stencilWriteMaskFront), v.dss.stencilFuncBack === x.stencilFuncBack && v.dss.stencilRefBack === x.stencilRefBack && v.dss.stencilReadMaskBack === x.stencilReadMaskBack || (g.stencilFuncSeparate(g.BACK, uF[x.stencilFuncBack], x.stencilRefBack, x.stencilReadMaskBack), v.dss.stencilFuncBack = x.stencilFuncBack, v.dss.stencilRefBack = x.stencilRefBack, v.dss.stencilReadMaskBack = x.stencilReadMaskBack), v.dss.stencilFailOpBack === x.stencilFailOpBack && v.dss.stencilZFailOpBack === x.stencilZFailOpBack && v.dss.stencilPassOpBack === x.stencilPassOpBack || (g.stencilOpSeparate(g.BACK, hF[x.stencilFailOpBack], hF[x.stencilZFailOpBack], hF[x.stencilPassOpBack]), v.dss.stencilFailOpBack = x.stencilFailOpBack, v.dss.stencilZFailOpBack = x.stencilZFailOpBack, v.dss.stencilPassOpBack = x.stencilPassOpBack), v.dss.stencilWriteMaskBack !== x.stencilWriteMaskBack && (g.stencilMaskSeparate(g.BACK, x.stencilWriteMaskBack), v.dss.stencilWriteMaskBack = x.stencilWriteMaskBack));
                    var C = t.bs;
                    if (C) {
                        v.bs.isA2C !== C.isA2C && (C.isA2C ? g.enable(g.SAMPLE_ALPHA_TO_COVERAGE) : g.disable(g.SAMPLE_ALPHA_TO_COVERAGE), v.bs.isA2C = C.isA2C), v.bs.blendColor.x === C.blendColor.x && v.bs.blendColor.y === C.blendColor.y && v.bs.blendColor.z === C.blendColor.z && v.bs.blendColor.w === C.blendColor.w || (g.blendColor(C.blendColor.x, C.blendColor.y, C.blendColor.z, C.blendColor.w), v.bs.blendColor.x = C.blendColor.x, v.bs.blendColor.y = C.blendColor.y, v.bs.blendColor.z = C.blendColor.z, v.bs.blendColor.w = C.blendColor.w);
                        var b = C.targets[0],
                            R = v.bs.targets[0];
                        R.blend !== b.blend && (b.blend ? g.enable(g.BLEND) : g.disable(g.BLEND), R.blend = b.blend), R.blendEq === b.blendEq && R.blendAlphaEq === b.blendAlphaEq || (g.blendEquationSeparate(_F[b.blendEq], _F[b.blendAlphaEq]), R.blendEq = b.blendEq, R.blendAlphaEq = b.blendAlphaEq), R.blendSrc === b.blendSrc && R.blendDst === b.blendDst && R.blendSrcAlpha === b.blendSrcAlpha && R.blendDstAlpha === b.blendDstAlpha || (g.blendFuncSeparate(fF[b.blendSrc], fF[b.blendDst], fF[b.blendSrcAlpha], fF[b.blendDstAlpha]), R.blendSrc = b.blendSrc, R.blendDst = b.blendDst, R.blendSrcAlpha = b.blendSrcAlpha, R.blendDstAlpha = b.blendDstAlpha), R.blendColorMask !== b.blendColorMask && (g.colorMask((b.blendColorMask & za.R) !== za.NONE, (b.blendColorMask & za.G) !== za.NONE, (b.blendColorMask & za.B) !== za.NONE, (b.blendColorMask & za.A) !== za.NONE), R.blendColorMask = b.blendColorMask)
                    }
                }
                if (t && t.gpuPipelineLayout && y) {
                    for (var w = y.glBlocks.length, I = t.gpuPipelineLayout.dynamicOffsetIndices, P = 0; P < w; P++) {
                        var O = y.glBlocks[P],
                            D = i[O.set],
                            N = D && D.descriptorIndices[O.binding],
                            M = N >= 0 && D.gpuDescriptors[N],
                            L = null,
                            B = 0;
                        if (M && M.gpuBuffer) {
                            var F = M.gpuBuffer,
                                z = I[O.set],
                                U = z && z[O.binding];
                            U >= 0 && (B = r[U]), "vf32" in F ? L = F.vf32 : (B += F.offset, L = F.gpuBuffer.vf32), B >>= 2
                        }
                        if (L)
                            for (var G = O.glActiveUniforms.length, H = 0; H < G; H++) {
                                var k = O.glActiveUniforms[H];
                                switch (k.glType) {
                                    case g.BOOL:
                                    case g.INT:
                                        for (var V = 0; V < k.array.length; ++V) {
                                            var W = k.begin + B + V;
                                            if (L[W] !== k.array[V]) {
                                                for (var j = V, q = W; j < k.array.length; ++j, ++q) k.array[j] = L[q];
                                                g.uniform1iv(k.glLoc, k.array);
                                                break
                                            }
                                        }
                                        break;
                                    case g.BOOL_VEC2:
                                    case g.INT_VEC2:
                                        for (var X = 0; X < k.array.length; ++X) {
                                            var Y = k.begin + B + X;
                                            if (L[Y] !== k.array[X]) {
                                                for (var K = X, Z = Y; K < k.array.length; ++K, ++Z) k.array[K] = L[Z];
                                                g.uniform2iv(k.glLoc, k.array);
                                                break
                                            }
                                        }
                                        break;
                                    case g.BOOL_VEC3:
                                    case g.INT_VEC3:
                                        for (var Q = 0; Q < k.array.length; ++Q) {
                                            var J = k.begin + B + Q;
                                            if (L[J] !== k.array[Q]) {
                                                for (var $ = Q, ee = J; $ < k.array.length; ++$, ++ee) k.array[$] = L[ee];
                                                g.uniform3iv(k.glLoc, k.array);
                                                break
                                            }
                                        }
                                        break;
                                    case g.BOOL_VEC4:
                                    case g.INT_VEC4:
                                        for (var te = 0; te < k.array.length; ++te) {
                                            var ne = k.begin + B + te;
                                            if (L[ne] !== k.array[te]) {
                                                for (var ie = te, re = ne; ie < k.array.length; ++ie, ++re) k.array[ie] = L[re];
                                                g.uniform4iv(k.glLoc, k.array);
                                                break
                                            }
                                        }
                                        break;
                                    case g.FLOAT:
                                        for (var oe = 0; oe < k.array.length; ++oe) {
                                            var ae = k.begin + B + oe;
                                            if (L[ae] !== k.array[oe]) {
                                                for (var se = oe, ce = ae; se < k.array.length; ++se, ++ce) k.array[se] = L[ce];
                                                g.uniform1fv(k.glLoc, k.array);
                                                break
                                            }
                                        }
                                        break;
                                    case g.FLOAT_VEC2:
                                        for (var le = 0; le < k.array.length; ++le) {
                                            var ue = k.begin + B + le;
                                            if (L[ue] !== k.array[le]) {
                                                for (var he = le, _e = ue; he < k.array.length; ++he, ++_e) k.array[he] = L[_e];
                                                g.uniform2fv(k.glLoc, k.array);
                                                break
                                            }
                                        }
                                        break;
                                    case g.FLOAT_VEC3:
                                        for (var fe = 0; fe < k.array.length; ++fe) {
                                            var de = k.begin + B + fe;
                                            if (L[de] !== k.array[fe]) {
                                                for (var pe = fe, me = de; pe < k.array.length; ++pe, ++me) k.array[pe] = L[me];
                                                g.uniform3fv(k.glLoc, k.array);
                                                break
                                            }
                                        }
                                        break;
                                    case g.FLOAT_VEC4:
                                        for (var ge = 0; ge < k.array.length; ++ge) {
                                            var ve = k.begin + B + ge;
                                            if (L[ve] !== k.array[ge]) {
                                                for (var ye = ge, Se = ve; ye < k.array.length; ++ye, ++Se) k.array[ye] = L[Se];
                                                g.uniform4fv(k.glLoc, k.array);
                                                break
                                            }
                                        }
                                        break;
                                    case g.FLOAT_MAT2:
                                        for (var Ee = 0; Ee < k.array.length; ++Ee) {
                                            var Te = k.begin + B + Ee;
                                            if (L[Te] !== k.array[Ee]) {
                                                for (var Ae = Ee, xe = Te; Ae < k.array.length; ++Ae, ++xe) k.array[Ae] = L[xe];
                                                g.uniformMatrix2fv(k.glLoc, !1, k.array);
                                                break
                                            }
                                        }
                                        break;
                                    case g.FLOAT_MAT3:
                                        for (var Ce = 0; Ce < k.array.length; ++Ce) {
                                            var be = k.begin + B + Ce;
                                            if (L[be] !== k.array[Ce]) {
                                                for (var Re = Ce, we = be; Re < k.array.length; ++Re, ++we) k.array[Re] = L[we];
                                                g.uniformMatrix3fv(k.glLoc, !1, k.array);
                                                break
                                            }
                                        }
                                        break;
                                    case g.FLOAT_MAT4:
                                        for (var Ie = 0; Ie < k.array.length; ++Ie) {
                                            var Pe = k.begin + B + Ie;
                                            if (L[Pe] !== k.array[Ie]) {
                                                for (var Oe = Ie, De = Pe; Oe < k.array.length; ++Oe, ++De) k.array[Oe] = L[De];
                                                g.uniformMatrix4fv(k.glLoc, !1, k.array);
                                                break
                                            }
                                        }
                                }
                            } else p("Buffer binding '" + O.name + "' at set " + O.set + " binding " + O.binding + " is not bounded")
                    }
                    for (var Ne = y.glSamplerTextures.length, Me = 0; Me < Ne; Me++)
                        for (var Le = y.glSamplerTextures[Me], Be = i[Le.set], Fe = Be && Be.descriptorIndices[Le.binding], ze = Fe >= 0 && Be.gpuDescriptors[Fe], Ue = Le.units.length, Ge = 0; Ge < Ue; Ge++) {
                            var He = Le.units[Ge];
                            if (ze && ze.gpuSampler) {
                                if (ze.gpuTexture && ze.gpuTexture.size > 0) {
                                    var ke = ze.gpuTexture,
                                        Ve = v.glTexUnits[He];
                                    Ve.glTexture !== ke.glTexture && (v.texUnit !== He && (g.activeTexture(g.TEXTURE0 + He), v.texUnit = He), ke.glTexture ? g.bindTexture(ke.glTarget, ke.glTexture) : g.bindTexture(ke.glTarget, e.nullTex2D.gpuTexture.glTexture), Ve.glTexture = ke.glTexture);
                                    var We = ze.gpuSampler;
                                    ke.isPowerOf2 ? (f = We.glWrapS, d = We.glWrapT) : (f = g.CLAMP_TO_EDGE, d = g.CLAMP_TO_EDGE), m = ke.isPowerOf2 ? ke.mipLevel <= 1 && (We.glMinFilter === g.LINEAR_MIPMAP_NEAREST || We.glMinFilter === g.LINEAR_MIPMAP_LINEAR) ? g.LINEAR : We.glMinFilter : We.glMinFilter === g.LINEAR || We.glMinFilter === g.LINEAR_MIPMAP_NEAREST || We.glMinFilter === g.LINEAR_MIPMAP_LINEAR ? g.LINEAR : g.NEAREST, ke.glWrapS !== f && (v.texUnit !== He && (g.activeTexture(g.TEXTURE0 + He), v.texUnit = He), g.texParameteri(ke.glTarget, g.TEXTURE_WRAP_S, f), ke.glWrapS = f), ke.glWrapT !== d && (v.texUnit !== He && (g.activeTexture(g.TEXTURE0 + He), v.texUnit = He), g.texParameteri(ke.glTarget, g.TEXTURE_WRAP_T, d), ke.glWrapT = d), ke.glMinFilter !== m && (v.texUnit !== He && (g.activeTexture(g.TEXTURE0 + He), v.texUnit = He), g.texParameteri(ke.glTarget, g.TEXTURE_MIN_FILTER, m), ke.glMinFilter = m), ke.glMagFilter !== We.glMagFilter && (v.texUnit !== He && (g.activeTexture(g.TEXTURE0 + He), v.texUnit = He), g.texParameteri(ke.glTarget, g.TEXTURE_MAG_FILTER, We.glMagFilter), ke.glMagFilter = We.glMagFilter)
                                }
                                ze = Be.gpuDescriptors[++Fe]
                            } else p("Sampler binding '" + Le.name + "' at set " + Le.set + " binding " + Le.binding + " index " + Ge + " is not bounded")
                        }
                }
                if (n && y && (S || TF.gpuInputAssembler !== n)) {
                    TF.gpuInputAssembler = n;
                    var je = e.ANGLE_instanced_arrays;
                    if (e.useVAO) {
                        var qe = e.OES_vertex_array_object,
                            Xe = n.glVAOs.get(y.glProgram);
                        if (!Xe) {
                            var Ye;
                            Xe = qe.createVertexArrayOES(), n.glVAOs.set(y.glProgram, Xe), qe.bindVertexArrayOES(Xe), g.bindBuffer(g.ARRAY_BUFFER, null), g.bindBuffer(g.ELEMENT_ARRAY_BUFFER, null), v.glArrayBuffer = null, v.glElementArrayBuffer = null;
                            for (var Ke = y.glInputs.length, Ze = 0; Ze < Ke; Ze++) {
                                var Qe = y.glInputs[Ze];
                                Ye = null;
                                for (var Je = n.glAttribs.length, $e = 0; $e < Je; $e++) {
                                    var et = n.glAttribs[$e];
                                    if (et.name === Qe.name) {
                                        Ye = et;
                                        break
                                    }
                                }
                                if (Ye) {
                                    v.glArrayBuffer !== Ye.glBuffer && (g.bindBuffer(g.ARRAY_BUFFER, Ye.glBuffer), v.glArrayBuffer = Ye.glBuffer);
                                    for (var tt = 0; tt < Ye.componentCount; ++tt) {
                                        var nt = Qe.glLoc + tt,
                                            it = Ye.offset + Ye.size * tt;
                                        g.enableVertexAttribArray(nt), v.glCurrentAttribLocs[nt] = !0, g.vertexAttribPointer(nt, Ye.count, Ye.glType, Ye.isNormalized, Ye.stride, it), je && je.vertexAttribDivisorANGLE(nt, Ye.isInstanced ? 1 : 0)
                                    }
                                }
                            }
                            var rt = n.gpuIndexBuffer;
                            rt && g.bindBuffer(g.ELEMENT_ARRAY_BUFFER, rt.glBuffer), qe.bindVertexArrayOES(null), g.bindBuffer(g.ARRAY_BUFFER, null), g.bindBuffer(g.ELEMENT_ARRAY_BUFFER, null), v.glArrayBuffer = null, v.glElementArrayBuffer = null
                        }
                        v.glVAO !== Xe && (qe.bindVertexArrayOES(Xe), v.glVAO = Xe)
                    } else {
                        for (var ot = 0; ot < e.capabilities.maxVertexAttributes; ++ot) v.glCurrentAttribLocs[ot] = !1;
                        for (var at = y.glInputs.length, st = 0; st < at; st++) {
                            for (var ct = y.glInputs[st], lt = null, ut = n.glAttribs.length, ht = 0; ht < ut; ht++) {
                                var _t = n.glAttribs[ht];
                                if (_t.name === ct.name) {
                                    lt = _t;
                                    break
                                }
                            }
                            if (lt) {
                                v.glArrayBuffer !== lt.glBuffer && (g.bindBuffer(g.ARRAY_BUFFER, lt.glBuffer), v.glArrayBuffer = lt.glBuffer);
                                for (var ft = 0; ft < lt.componentCount; ++ft) {
                                    var dt = ct.glLoc + ft,
                                        pt = lt.offset + lt.size * ft;
                                    !v.glEnabledAttribLocs[dt] && dt >= 0 && (g.enableVertexAttribArray(dt), v.glEnabledAttribLocs[dt] = !0), v.glCurrentAttribLocs[dt] = !0, g.vertexAttribPointer(dt, lt.count, lt.glType, lt.isNormalized, lt.stride, pt), je && je.vertexAttribDivisorANGLE(dt, lt.isInstanced ? 1 : 0)
                                }
                            }
                        }
                        var mt = n.gpuIndexBuffer;
                        mt && v.glElementArrayBuffer !== mt.glBuffer && (g.bindBuffer(g.ELEMENT_ARRAY_BUFFER, mt.glBuffer), v.glElementArrayBuffer = mt.glBuffer);
                        for (var gt = 0; gt < e.capabilities.maxVertexAttributes; ++gt) v.glEnabledAttribLocs[gt] !== v.glCurrentAttribLocs[gt] && (g.disableVertexAttribArray(gt), v.glEnabledAttribLocs[gt] = !1)
                    }
                }
                if (t && t.dynamicStates.length)
                    for (var vt = t.dynamicStates.length, yt = 0; yt < vt; yt++) switch (t.dynamicStates[yt]) {
                        case Ya.VIEWPORT:
                            o && (v.viewport.left === o.left && v.viewport.top === o.top && v.viewport.width === o.width && v.viewport.height === o.height || (g.viewport(o.left, o.top, o.width, o.height), v.viewport.left = o.left, v.viewport.top = o.top, v.viewport.width = o.width, v.viewport.height = o.height));
                            break;
                        case Ya.SCISSOR:
                            a && (v.scissorRect.x === a.x && v.scissorRect.y === a.y && v.scissorRect.width === a.width && v.scissorRect.height === a.height || (g.scissor(a.x, a.y, a.width, a.height), v.scissorRect.x = a.x, v.scissorRect.y = a.y, v.scissorRect.width = a.width, v.scissorRect.height = a.height));
                            break;
                        case Ya.LINE_WIDTH:
                            s && v.rs.lineWidth !== s && (g.lineWidth(s), v.rs.lineWidth = s);
                            break;
                        case Ya.DEPTH_BIAS:
                            c && (v.rs.depthBias === c.constantFactor && v.rs.depthBiasSlop === c.slopeFactor || (g.polygonOffset(c.constantFactor, c.slopeFactor), v.rs.depthBias = c.constantFactor, v.rs.depthBiasSlop = c.slopeFactor));
                            break;
                        case Ya.BLEND_CONSTANTS:
                            v.bs.blendColor.x === l[0] && v.bs.blendColor.y === l[1] && v.bs.blendColor.z === l[2] && v.bs.blendColor.w === l[3] || (g.blendColor(l[0], l[1], l[2], l[3]), v.bs.blendColor.x = l[0], v.bs.blendColor.y = l[1], v.bs.blendColor.z = l[2], v.bs.blendColor.w = l[3]);
                            break;
                        case Ya.STENCIL_WRITE_MASK:
                            if (h) switch (h.face) {
                                case Ka.FRONT:
                                    v.dss.stencilWriteMaskFront !== h.writeMask && (g.stencilMaskSeparate(g.FRONT, h.writeMask), v.dss.stencilWriteMaskFront = h.writeMask);
                                    break;
                                case Ka.BACK:
                                    v.dss.stencilWriteMaskBack !== h.writeMask && (g.stencilMaskSeparate(g.BACK, h.writeMask), v.dss.stencilWriteMaskBack = h.writeMask);
                                    break;
                                case Ka.ALL:
                                    v.dss.stencilWriteMaskFront === h.writeMask && v.dss.stencilWriteMaskBack === h.writeMask || (g.stencilMask(h.writeMask), v.dss.stencilWriteMaskFront = h.writeMask, v.dss.stencilWriteMaskBack = h.writeMask)
                            }
                            break;
                        case Ya.STENCIL_COMPARE_MASK:
                            if (_) switch (_.face) {
                                case Ka.FRONT:
                                    v.dss.stencilRefFront === _.reference && v.dss.stencilReadMaskFront === _.compareMask || (g.stencilFuncSeparate(g.FRONT, uF[v.dss.stencilFuncFront], _.reference, _.compareMask), v.dss.stencilRefFront = _.reference, v.dss.stencilReadMaskFront = _.compareMask);
                                    break;
                                case Ka.BACK:
                                    v.dss.stencilRefBack === _.reference && v.dss.stencilReadMaskBack === _.compareMask || (g.stencilFuncSeparate(g.BACK, uF[v.dss.stencilFuncBack], _.reference, _.compareMask), v.dss.stencilRefBack = _.reference, v.dss.stencilReadMaskBack = _.compareMask);
                                    break;
                                case Ka.ALL:
                                    v.dss.stencilRefFront === _.reference && v.dss.stencilReadMaskFront === _.compareMask && v.dss.stencilRefBack === _.reference && v.dss.stencilReadMaskBack === _.compareMask || (g.stencilFunc(uF[v.dss.stencilFuncBack], _.reference, _.compareMask), v.dss.stencilRefFront = _.reference, v.dss.stencilReadMaskFront = _.compareMask, v.dss.stencilRefBack = _.reference, v.dss.stencilReadMaskBack = _.compareMask)
                            }
                    }
            }

            function CF(e, t) {
                var n = e.gl,
                    i = e.ANGLE_instanced_arrays,
                    r = TF.gpuInputAssembler,
                    o = TF.glPrimitive;
                if (r)
                    if (r.gpuIndirectBuffer)
                        for (var a = r.gpuIndirectBuffer.indirects.length, s = 0; s < a; s++) {
                            var c = r.gpuIndirectBuffer.indirects[s],
                                l = r.gpuIndexBuffer;
                            if (c.instanceCount && i)
                                if (l) {
                                    if (c.indexCount > 0) {
                                        var u = c.firstIndex * l.stride;
                                        i.drawElementsInstancedANGLE(o, c.indexCount, r.glIndexType, u, c.instanceCount)
                                    }
                                } else c.vertexCount > 0 && i.drawArraysInstancedANGLE(o, c.firstVertex, c.vertexCount, c.instanceCount);
                            else if (l) {
                                if (c.indexCount > 0) {
                                    var h = c.firstIndex * l.stride;
                                    n.drawElements(o, c.indexCount, r.glIndexType, h)
                                }
                            } else c.vertexCount > 0 && n.drawArrays(o, c.firstVertex, c.vertexCount)
                        } else {
                            var _ = r.gpuIndexBuffer;
                            if (t.instanceCount && i)
                                if (_) {
                                    if (t.indexCount > 0) {
                                        var f = t.firstIndex * _.stride;
                                        i.drawElementsInstancedANGLE(o, t.indexCount, r.glIndexType, f, t.instanceCount)
                                    }
                                } else t.vertexCount > 0 && i.drawArraysInstancedANGLE(o, t.firstVertex, t.vertexCount, t.instanceCount);
                            else if (_) {
                                if (t.indexCount > 0) {
                                    var d = t.firstIndex * _.stride;
                                    n.drawElements(o, t.indexCount, r.glIndexType, d)
                                }
                            } else t.vertexCount > 0 && n.drawArrays(o, t.firstVertex, t.vertexCount)
                        }
            }
            var bF = new Array(lF.COUNT);

            function RF(e, t) {
                bF.fill(0);
                for (var n = 0; n < t.cmds.length; ++n) {
                    var i = t.cmds.array[n],
                        r = bF[i]++;
                    switch (i) {
                        case lF.BEGIN_RENDER_PASS:
                            var o = t.beginRenderPassCmds.array[r];
                            AF(e, o.gpuRenderPass, o.gpuFramebuffer, o.renderArea, o.clearColors, o.clearDepth, o.clearStencil);
                            break;
                        case lF.BIND_STATES:
                            var a = t.bindStatesCmds.array[r];
                            xF(e, a.gpuPipelineState, a.gpuInputAssembler, a.gpuDescriptorSets, a.dynamicOffsets, a.viewport, a.scissor, a.lineWidth, a.depthBias, a.blendConstants, a.depthBounds, a.stencilWriteMask, a.stencilCompareMask);
                            break;
                        case lF.DRAW:
                            CF(e, t.drawCmds.array[r].drawInfo);
                            break;
                        case lF.UPDATE_BUFFER:
                            var s = t.updateBufferCmds.array[r];
                            EF(e, s.gpuBuffer, s.buffer, s.offset, s.size);
                            break;
                        case lF.COPY_BUFFER_TO_TEXTURE:
                            var c = t.copyBufferToTextureCmds.array[r];
                            wF(e, c.buffers, c.gpuTexture, c.regions)
                    }
                }
            }

            function wF(e, t, n, i) {
                var r = e.gl,
                    o = e.stateCache.glTexUnits[e.stateCache.texUnit];
                o.glTexture !== n.glTexture && (r.bindTexture(n.glTarget, n.glTexture), o.glTexture = n.glTexture);
                var a = 0,
                    s = 1,
                    c = 1,
                    l = 0,
                    u = tc[n.format].isCompressed;
                switch (n.glTarget) {
                    case r.TEXTURE_2D:
                        for (var h = 0; h < i.length; h++) {
                            var _ = i[h];
                            s = _.texExtent.width, c = _.texExtent.height;
                            var f = t[a++];
                            u ? n.glInternalFmt === $B.COMPRESSED_RGB_ETC1_WEBGL || e.noCompressedTexSubImage2D ? r.compressedTexImage2D(r.TEXTURE_2D, _.texSubres.mipLevel, n.glInternalFmt, s, c, 0, f) : r.compressedTexSubImage2D(r.TEXTURE_2D, _.texSubres.mipLevel, _.texOffset.x, _.texOffset.y, s, c, n.glFormat, f) : r.texSubImage2D(r.TEXTURE_2D, _.texSubres.mipLevel, _.texOffset.x, _.texOffset.y, s, c, n.glFormat, n.glType, f)
                        }
                        break;
                    case r.TEXTURE_CUBE_MAP:
                        for (var d = 0; d < i.length; d++) {
                            var p = i[d],
                                m = p.texSubres.baseArrayLayer + p.texSubres.layerCount;
                            for (l = p.texSubres.baseArrayLayer; l < m; ++l) {
                                s = p.texExtent.width, c = p.texExtent.height;
                                var g = t[a++];
                                u ? n.glInternalFmt === $B.COMPRESSED_RGB_ETC1_WEBGL || e.noCompressedTexSubImage2D ? r.compressedTexImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + l, p.texSubres.mipLevel, n.glInternalFmt, s, c, 0, g) : r.compressedTexSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + l, p.texSubres.mipLevel, p.texOffset.x, p.texOffset.y, s, c, n.glFormat, g) : r.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + l, p.texSubres.mipLevel, p.texOffset.x, p.texOffset.y, s, c, n.glFormat, n.glType, g)
                            }
                        }
                        break;
                    default:
                        console.error("Unsupported GL texture type, copy buffer to texture failed.")
                }
                n.flags & Pa.GEN_MIPMAP && r.generateMipmap(n.glTarget)
            }
            var IF = function(e) {
                    function t() {
                        for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                        return (t = e.call.apply(e, [this].concat(i)) || this)._gpuBuffer = null, t._gpuBufferView = null, t._uniformBuffer = null, t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.initialize = function(e) {
                        if ("buffer" in e) {
                            this._isBufferView = !0;
                            var t = e.buffer;
                            this._usage = t.usage, this._memUsage = t.memUsage, this._size = this._stride = e.range, this._count = 1, this._flags = t.flags, this._gpuBufferView = {
                                gpuBuffer: t.gpuBuffer,
                                offset: e.offset,
                                range: e.range
                            }
                        } else this._usage = e.usage, this._memUsage = e.memUsage, this._size = e.size, this._stride = Math.max(e.stride || this._size, 1), this._count = this._size / this._stride, this._flags = e.flags, this._usage & xa.INDIRECT && (this._indirectBuffer = new Es), this._usage & xa.UNIFORM && this._size > 0 && (this._uniformBuffer = new Uint8Array(this._size)), this._gpuBuffer = {
                                usage: this._usage,
                                memUsage: this._memUsage,
                                size: this._size,
                                stride: this._stride,
                                buffer: null,
                                vf32: null,
                                indirects: [],
                                glTarget: 0,
                                glBuffer: null
                            }, e.usage & xa.INDIRECT && (this._gpuBuffer.indirects = this._indirectBuffer.drawInfos), this._usage & xa.UNIFORM && (this._gpuBuffer.buffer = this._uniformBuffer),
                            function(e, t) {
                                var n = e.gl,
                                    i = e.stateCache,
                                    r = t.memUsage & Ra.HOST ? n.DYNAMIC_DRAW : n.STATIC_DRAW;
                                if (t.usage & xa.VERTEX) {
                                    t.glTarget = n.ARRAY_BUFFER;
                                    var o = n.createBuffer();
                                    o && (t.glBuffer = o, t.size > 0 && (e.useVAO && i.glVAO && (e.OES_vertex_array_object.bindVertexArrayOES(null), i.glVAO = TF.gpuInputAssembler = null), e.stateCache.glArrayBuffer !== t.glBuffer && (n.bindBuffer(n.ARRAY_BUFFER, t.glBuffer), e.stateCache.glArrayBuffer = t.glBuffer), n.bufferData(n.ARRAY_BUFFER, t.size, r), n.bindBuffer(n.ARRAY_BUFFER, null), e.stateCache.glArrayBuffer = null))
                                } else if (t.usage & xa.INDEX) {
                                    t.glTarget = n.ELEMENT_ARRAY_BUFFER;
                                    var a = n.createBuffer();
                                    a && (t.glBuffer = a, t.size > 0 && (e.useVAO && i.glVAO && (e.OES_vertex_array_object.bindVertexArrayOES(null), i.glVAO = TF.gpuInputAssembler = null), e.stateCache.glElementArrayBuffer !== t.glBuffer && (n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, t.glBuffer), e.stateCache.glElementArrayBuffer = t.glBuffer), n.bufferData(n.ELEMENT_ARRAY_BUFFER, t.size, r), n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, null), e.stateCache.glElementArrayBuffer = null))
                                } else t.usage & xa.UNIFORM ? (t.glTarget = n.NONE, t.buffer && (t.vf32 = new Float32Array(t.buffer.buffer))) : (t.usage & xa.INDIRECT || t.usage & xa.TRANSFER_DST || t.usage & xa.TRANSFER_SRC || console.error("Unsupported BufferType, create buffer failed."), t.glTarget = n.NONE)
                            }(this._device, this._gpuBuffer), this._device.memoryStatus.bufferSize += this._size;
                        return !0
                    }, n.destroy = function() {
                        var e, t;
                        this._gpuBuffer && (e = this._device, (t = this._gpuBuffer).glBuffer && (e.gl.deleteBuffer(t.glBuffer), t.glBuffer = null), this._device.memoryStatus.bufferSize -= this._size, this._gpuBuffer = null), this._gpuBufferView && (this._gpuBufferView = null)
                    }, n.resize = function(e) {
                        if (this._isBufferView) console.warn("cannot resize buffer views!");
                        else {
                            var t = this._size;
                            t !== e && (this._size = e, this._count = this._size / this._stride, this._uniformBuffer && (this._uniformBuffer = new Uint8Array(e)), this._gpuBuffer && (this._uniformBuffer && (this._gpuBuffer.buffer = this._uniformBuffer), this._gpuBuffer.size = e, e > 0 && (function(e, t) {
                                var n = e.gl,
                                    i = e.stateCache,
                                    r = t.memUsage & Ra.HOST ? n.DYNAMIC_DRAW : n.STATIC_DRAW;
                                t.usage & xa.VERTEX ? (e.useVAO && i.glVAO && (e.OES_vertex_array_object.bindVertexArrayOES(null), i.glVAO = TF.gpuInputAssembler = null), e.stateCache.glArrayBuffer !== t.glBuffer && n.bindBuffer(n.ARRAY_BUFFER, t.glBuffer), t.buffer ? n.bufferData(n.ARRAY_BUFFER, t.buffer, r) : n.bufferData(n.ARRAY_BUFFER, t.size, r), n.bindBuffer(n.ARRAY_BUFFER, null), e.stateCache.glArrayBuffer = null) : t.usage & xa.INDEX ? (e.useVAO && i.glVAO && (e.OES_vertex_array_object.bindVertexArrayOES(null), i.glVAO = TF.gpuInputAssembler = null), e.stateCache.glElementArrayBuffer !== t.glBuffer && n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, t.glBuffer), t.buffer ? n.bufferData(n.ELEMENT_ARRAY_BUFFER, t.buffer, r) : n.bufferData(n.ELEMENT_ARRAY_BUFFER, t.size, r), n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, null), e.stateCache.glElementArrayBuffer = null) : t.usage & xa.UNIFORM ? t.buffer && (t.vf32 = new Float32Array(t.buffer.buffer)) : (t.usage & xa.INDIRECT || t.usage & xa.TRANSFER_DST || t.usage & xa.TRANSFER_SRC || console.error("Unsupported BufferType, create buffer failed."), t.glTarget = n.NONE)
                            }(this._device, this._gpuBuffer), this._device.memoryStatus.bufferSize -= t, this._device.memoryStatus.bufferSize += e)))
                        }
                    }, n.update = function(e, t) {
                        var n;
                        this._isBufferView ? console.warn("cannot update through buffer views!") : (n = void 0 !== t ? t : this._usage & xa.INDIRECT ? 0 : e.byteLength, EF(this._device, this._gpuBuffer, e, 0, n))
                    }, K(t, [{
                        key: "gpuBuffer",
                        get: function() {
                            return this._gpuBuffer
                        }
                    }, {
                        key: "gpuBufferView",
                        get: function() {
                            return this._gpuBufferView
                        }
                    }]), t
                }(_c),
                PF = function() {
                    function e(e, t) {
                        this._frees = void 0, this._freeIdx = 0, this._freeCmds = void 0, this._frees = new Array(t), this._freeCmds = new ei(t);
                        for (var n = 0; n < t; ++n) this._frees[n] = new e;
                        this._freeIdx = t - 1
                    }
                    var t = e.prototype;
                    return t.alloc = function(e) {
                        if (this._freeIdx < 0) {
                            var t = 2 * this._frees.length,
                                n = this._frees;
                            this._frees = new Array(t);
                            for (var i = t - n.length, r = 0; r < i; ++r) this._frees[r] = new e;
                            for (var o = i, a = 0; o < t; ++o, ++a) this._frees[o] = n[a];
                            this._freeIdx += i
                        }
                        var s = this._frees[this._freeIdx];
                        return this._frees[this._freeIdx--] = null, ++s.refCount, s
                    }, t.free = function(e) {
                        0 == --e.refCount && this._freeCmds.push(e)
                    }, t.freeCmds = function(e) {
                        for (var t = 0; t < e.length; ++t) 0 == --e.array[t].refCount && this._freeCmds.push(e.array[t])
                    }, t.release = function() {
                        for (var e = 0; e < this._freeCmds.length; ++e) {
                            var t = this._freeCmds.array[e];
                            t.clear(), this._frees[++this._freeIdx] = t
                        }
                        this._freeCmds.clear()
                    }, e
                }(),
                OF = function() {
                    function e() {
                        this.beginRenderPassCmdPool = void 0, this.bindStatesCmdPool = void 0, this.drawCmdPool = void 0, this.updateBufferCmdPool = void 0, this.copyBufferToTextureCmdPool = void 0, this.beginRenderPassCmdPool = new PF(pF, 1), this.bindStatesCmdPool = new PF(mF, 1), this.drawCmdPool = new PF(gF, 1), this.updateBufferCmdPool = new PF(vF, 1), this.copyBufferToTextureCmdPool = new PF(yF, 1)
                    }
                    var t = e.prototype;
                    return t.clearCmds = function(e) {
                        e.beginRenderPassCmds.length && (this.beginRenderPassCmdPool.freeCmds(e.beginRenderPassCmds), e.beginRenderPassCmds.clear()), e.bindStatesCmds.length && (this.bindStatesCmdPool.freeCmds(e.bindStatesCmds), e.bindStatesCmds.clear()), e.drawCmds.length && (this.drawCmdPool.freeCmds(e.drawCmds), e.drawCmds.clear()), e.updateBufferCmds.length && (this.updateBufferCmdPool.freeCmds(e.updateBufferCmds), e.updateBufferCmds.clear()), e.copyBufferToTextureCmds.length && (this.copyBufferToTextureCmdPool.freeCmds(e.copyBufferToTextureCmds), e.copyBufferToTextureCmds.clear()), e.cmds.clear()
                    }, t.releaseCmds = function() {
                        this.beginRenderPassCmdPool.release(), this.bindStatesCmdPool.release(), this.drawCmdPool.release(), this.updateBufferCmdPool.release(), this.copyBufferToTextureCmdPool.release()
                    }, e
                }(),
                DF = function(e) {
                    function t() {
                        for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                        return (t = e.call.apply(e, [this].concat(i)) || this).cmdPackage = new SF, t._webGLAllocator = null, t._isInRenderPass = !1, t._curGPUPipelineState = null, t._curGPUInputAssembler = null, t._curGPUDescriptorSets = [], t._curDynamicOffsets = [], t._curViewport = null, t._curScissor = null, t._curLineWidth = null, t._curDepthBias = null, t._curBlendConstants = [], t._curDepthBounds = null, t._curStencilWriteMask = null, t._curStencilCompareMask = null, t._isStateInvalied = !1, t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.initialize = function(e) {
                        this._type = e.type, this._queue = e.queue, this._webGLAllocator = this._device.cmdAllocator;
                        for (var t = this._device.bindingMappingInfo.bufferOffsets.length, n = 0; n < t; n++) this._curGPUDescriptorSets.push(null), this._curDynamicOffsets.push([]);
                        return !0
                    }, n.destroy = function() {
                        this._webGLAllocator && (this._webGLAllocator.clearCmds(this.cmdPackage), this._webGLAllocator = null)
                    }, n.begin = function() {
                        this._webGLAllocator.clearCmds(this.cmdPackage), this._curGPUPipelineState = null, this._curGPUInputAssembler = null, this._curGPUDescriptorSets.length = 0;
                        for (var e = 0; e < this._curDynamicOffsets.length; e++) this._curDynamicOffsets[e].length = 0;
                        this._curViewport = null, this._curScissor = null, this._curLineWidth = null, this._curDepthBias = null, this._curBlendConstants.length = 0, this._curDepthBounds = null, this._curStencilWriteMask = null, this._curStencilCompareMask = null, this._numDrawCalls = 0, this._numInstances = 0, this._numTris = 0
                    }, n.end = function() {
                        this._isStateInvalied && this.bindStates(), this._isInRenderPass = !1
                    }, n.beginRenderPass = function(e, t, n, i, r, o) {
                        var a = this._webGLAllocator.beginRenderPassCmdPool.alloc(pF);
                        a.gpuRenderPass = e.gpuRenderPass, a.gpuFramebuffer = t.gpuFramebuffer, a.renderArea = n, a.clearColors.length = i.length;
                        for (var s = 0; s < i.length; ++s) a.clearColors[s] = i[s];
                        a.clearDepth = r, a.clearStencil = o, this.cmdPackage.beginRenderPassCmds.push(a), this.cmdPackage.cmds.push(lF.BEGIN_RENDER_PASS), this._isInRenderPass = !0
                    }, n.endRenderPass = function() {
                        this._isInRenderPass = !1
                    }, n.bindPipelineState = function(e) {
                        var t = e.gpuPipelineState;
                        t !== this._curGPUPipelineState && (this._curGPUPipelineState = t, this._isStateInvalied = !0)
                    }, n.bindDescriptorSet = function(e, t, n) {
                        var i = t.gpuDescriptorSet;
                        if (i !== this._curGPUDescriptorSets[e] && (this._curGPUDescriptorSets[e] = i, this._isStateInvalied = !0), n) {
                            for (var r = this._curDynamicOffsets[e], o = 0; o < n.length; o++) r[o] = n[o];
                            r.length = n.length, this._isStateInvalied = !0
                        }
                    }, n.bindInputAssembler = function(e) {
                        var t = e.gpuInputAssembler;
                        this._curGPUInputAssembler = t, this._isStateInvalied = !0
                    }, n.setViewport = function(e) {
                        this._curViewport ? this._curViewport.left === e.left && this._curViewport.top === e.top && this._curViewport.width === e.width && this._curViewport.height === e.height && this._curViewport.minDepth === e.minDepth && this._curViewport.maxDepth === e.maxDepth || (this._curViewport.left = e.left, this._curViewport.top = e.top, this._curViewport.width = e.width, this._curViewport.height = e.height, this._curViewport.minDepth = e.minDepth, this._curViewport.maxDepth = e.maxDepth, this._isStateInvalied = !0) : this._curViewport = new ds(e.left, e.top, e.width, e.height, e.minDepth, e.maxDepth)
                    }, n.setScissor = function(e) {
                        this._curScissor ? this._curScissor.x === e.x && this._curScissor.y === e.y && this._curScissor.width === e.width && this._curScissor.height === e.height || (this._curScissor.x = e.x, this._curScissor.y = e.y, this._curScissor.width = e.width, this._curScissor.height = e.height, this._isStateInvalied = !0) : this._curScissor = new ss(e.x, e.y, e.width, e.height)
                    }, n.setLineWidth = function(e) {
                        this._curLineWidth !== e && (this._curLineWidth = e, this._isStateInvalied = !0)
                    }, n.setDepthBias = function(e, t, n) {
                        this._curDepthBias ? this._curDepthBias.constantFactor === e && this._curDepthBias.clamp === t && this._curDepthBias.slopeFactor === n || (this._curDepthBias.constantFactor = e, this._curDepthBias.clamp = t, this._curDepthBias.slopeFactor = n, this._isStateInvalied = !0) : (this._curDepthBias = {
                            constantFactor: e,
                            clamp: t,
                            slopeFactor: n
                        }, this._isStateInvalied = !0)
                    }, n.setBlendConstants = function(e) {
                        4 !== e.length || this._curBlendConstants[0] === e[0] && this._curBlendConstants[1] === e[1] && this._curBlendConstants[2] === e[2] && this._curBlendConstants[3] === e[3] || (this._curBlendConstants.length = 0, Array.prototype.push.apply(this._curBlendConstants, e), this._isStateInvalied = !0)
                    }, n.setDepthBound = function(e, t) {
                        this._curDepthBounds && this._curDepthBounds.minBounds === e && this._curDepthBounds.maxBounds === t || (this._curDepthBounds = {
                            minBounds: e,
                            maxBounds: t
                        }, this._isStateInvalied = !0)
                    }, n.setStencilWriteMask = function(e, t) {
                        this._curStencilWriteMask ? this._curStencilWriteMask.face === e && this._curStencilWriteMask.writeMask === t || (this._curStencilWriteMask.face = e, this._curStencilWriteMask.writeMask = t, this._isStateInvalied = !0) : (this._curStencilWriteMask = {
                            face: e,
                            writeMask: t
                        }, this._isStateInvalied = !0)
                    }, n.setStencilCompareMask = function(e, t, n) {
                        this._curStencilCompareMask ? this._curStencilCompareMask.face === e && this._curStencilCompareMask.reference === t && this._curStencilCompareMask.compareMask === n || (this._curStencilCompareMask.face = e, this._curStencilCompareMask.reference = t, this._curStencilCompareMask.compareMask = n, this._isStateInvalied = !0) : (this._curStencilCompareMask = {
                            face: e,
                            reference: t,
                            compareMask: n
                        }, this._isStateInvalied = !0)
                    }, n.draw = function(e) {
                        if (this._type === Ja.PRIMARY && this._isInRenderPass || this._type === Ja.SECONDARY) {
                            this._isStateInvalied && this.bindStates();
                            var t = this._webGLAllocator.drawCmdPool.alloc(gF);
                            t.drawInfo.vertexCount = e.vertexCount, t.drawInfo.firstVertex = e.firstVertex, t.drawInfo.indexCount = e.indexCount, t.drawInfo.firstIndex = e.firstIndex, t.drawInfo.vertexOffset = e.vertexOffset, t.drawInfo.instanceCount = e.instanceCount, t.drawInfo.firstInstance = e.firstInstance, this.cmdPackage.drawCmds.push(t), this.cmdPackage.cmds.push(lF.DRAW), ++this._numDrawCalls, this._numInstances += e.instanceCount;
                            var n = e.indexCount || e.vertexCount;
                            if (this._curGPUPipelineState) switch (this._curGPUPipelineState.glPrimitive) {
                                case 4:
                                    this._numTris += n / 3 * Math.max(e.instanceCount, 1);
                                    break;
                                case 5:
                                case 6:
                                    this._numTris += (n - 2) * Math.max(e.instanceCount, 1)
                            }
                        } else console.error("Command 'draw' must be recorded inside a render pass.")
                    }, n.updateBuffer = function(e, t, n) {
                        if (this._type === Ja.PRIMARY && !this._isInRenderPass || this._type === Ja.SECONDARY) {
                            var i = e.gpuBuffer;
                            if (i) {
                                var r, o = this._webGLAllocator.updateBufferCmdPool.alloc(vF),
                                    a = 0;
                                e.usage & xa.INDIRECT || (a = void 0 !== n ? n : t.byteLength), r = t, o.gpuBuffer = i, o.buffer = r, o.offset = 0, o.size = a, this.cmdPackage.updateBufferCmds.push(o), this.cmdPackage.cmds.push(lF.UPDATE_BUFFER)
                            }
                        } else console.error("Command 'updateBuffer' must be recorded outside a render pass.")
                    }, n.copyBuffersToTexture = function(e, t, n) {
                        if (this._type === Ja.PRIMARY && !this._isInRenderPass || this._type === Ja.SECONDARY) {
                            var i = t.gpuTexture;
                            if (i) {
                                var r = this._webGLAllocator.copyBufferToTextureCmdPool.alloc(yF);
                                r && (r.gpuTexture = i, r.regions = n, r.buffers = e, this.cmdPackage.copyBufferToTextureCmds.push(r), this.cmdPackage.cmds.push(lF.COPY_BUFFER_TO_TEXTURE))
                            }
                        } else console.error("Command 'copyBufferToTexture' must be recorded outside a render pass.")
                    }, n.execute = function(e, t) {
                        for (var n = 0; n < t; ++n) {
                            for (var i = e[n], r = 0; r < i.cmdPackage.beginRenderPassCmds.length; ++r) {
                                var o = i.cmdPackage.beginRenderPassCmds.array[r];
                                ++o.refCount, this.cmdPackage.beginRenderPassCmds.push(o)
                            }
                            for (var a = 0; a < i.cmdPackage.bindStatesCmds.length; ++a) {
                                var s = i.cmdPackage.bindStatesCmds.array[a];
                                ++s.refCount, this.cmdPackage.bindStatesCmds.push(s)
                            }
                            for (var c = 0; c < i.cmdPackage.drawCmds.length; ++c) {
                                var l = i.cmdPackage.drawCmds.array[c];
                                ++l.refCount, this.cmdPackage.drawCmds.push(l)
                            }
                            for (var u = 0; u < i.cmdPackage.updateBufferCmds.length; ++u) {
                                var h = i.cmdPackage.updateBufferCmds.array[u];
                                ++h.refCount, this.cmdPackage.updateBufferCmds.push(h)
                            }
                            for (var _ = 0; _ < i.cmdPackage.copyBufferToTextureCmds.length; ++_) {
                                var f = i.cmdPackage.copyBufferToTextureCmds.array[_];
                                ++f.refCount, this.cmdPackage.copyBufferToTextureCmds.push(f)
                            }
                            this.cmdPackage.cmds.concat(i.cmdPackage.cmds.array), this._numDrawCalls += i._numDrawCalls, this._numInstances += i._numInstances, this._numTris += i._numTris
                        }
                    }, n.pipelineBarrier = function() {}, n.bindStates = function() {
                        var e = this._webGLAllocator.bindStatesCmdPool.alloc(mF);
                        if (e) {
                            e.gpuPipelineState = this._curGPUPipelineState, Array.prototype.push.apply(e.gpuDescriptorSets, this._curGPUDescriptorSets);
                            for (var t = 0; t < this._curDynamicOffsets.length; t++) Array.prototype.push.apply(e.dynamicOffsets, this._curDynamicOffsets[t]);
                            e.gpuInputAssembler = this._curGPUInputAssembler, e.viewport = this._curViewport, e.scissor = this._curScissor, e.lineWidth = this._curLineWidth, e.depthBias = this._curDepthBias, Array.prototype.push.apply(e.blendConstants, this._curBlendConstants), e.depthBounds = this._curDepthBounds, e.stencilWriteMask = this._curStencilWriteMask, e.stencilCompareMask = this._curStencilCompareMask, this.cmdPackage.bindStatesCmds.push(e), this.cmdPackage.cmds.push(lF.BIND_STATES), this._isStateInvalied = !1
                        }
                    }, K(t, [{
                        key: "webGLDevice",
                        get: function() {
                            return this._device
                        }
                    }]), t
                }(fc),
                NF = function(e) {
                    function t() {
                        for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                        return (t = e.call.apply(e, [this].concat(i)) || this)._gpuFramebuffer = null, t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.initialize = function(e) {
                        this._renderPass = e.renderPass, this._colorTextures = e.colorTextures || [], this._depthStencilTexture = e.depthStencilTexture || null, 0 !== e.depthStencilMipmapLevel && console.warn("The mipmap level of th texture image to be attached of depth stencil attachment should be 0. Convert to 0.");
                        for (var t = 0; t < e.colorMipmapLevels.length; ++t) 0 !== e.colorMipmapLevels[t] && console.warn("The mipmap level of th texture image to be attached of color attachment " + t + " should be 0. Convert to 0.");
                        for (var n = [], i = 0; i < e.colorTextures.length; ++i) {
                            var r = e.colorTextures[i];
                            r && n.push(r.gpuTexture)
                        }
                        var o = null;
                        return e.depthStencilTexture && (o = e.depthStencilTexture.gpuTexture), this._gpuFramebuffer = {
                                gpuRenderPass: e.renderPass.gpuRenderPass,
                                gpuColorTextures: n,
                                gpuDepthStencilTexture: o,
                                glFramebuffer: null
                            },
                            function(e, t) {
                                if (t.gpuColorTextures.length || t.gpuDepthStencilTexture) {
                                    var n = e.gl,
                                        i = [],
                                        r = n.createFramebuffer();
                                    if (r) {
                                        t.glFramebuffer = r, e.stateCache.glFramebuffer !== t.glFramebuffer && n.bindFramebuffer(n.FRAMEBUFFER, t.glFramebuffer);
                                        for (var o = 0; o < t.gpuColorTextures.length; ++o) {
                                            var a = t.gpuColorTextures[o];
                                            a && (a.glTexture ? n.framebufferTexture2D(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + o, a.glTarget, a.glTexture, 0) : n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + o, n.RENDERBUFFER, a.glRenderbuffer), i.push(n.COLOR_ATTACHMENT0 + o))
                                        }
                                        var s = t.gpuDepthStencilTexture;
                                        if (s) {
                                            var c = tc[s.format].hasStencil ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT;
                                            s.glTexture ? n.framebufferTexture2D(n.FRAMEBUFFER, c, s.glTarget, s.glTexture, 0) : n.framebufferRenderbuffer(n.FRAMEBUFFER, c, n.RENDERBUFFER, s.glRenderbuffer)
                                        }
                                        e.WEBGL_draw_buffers && e.WEBGL_draw_buffers.drawBuffersWEBGL(i);
                                        var l = n.checkFramebufferStatus(n.FRAMEBUFFER);
                                        if (l !== n.FRAMEBUFFER_COMPLETE) switch (l) {
                                            case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                                                console.error("glCheckFramebufferStatus() - FRAMEBUFFER_INCOMPLETE_ATTACHMENT");
                                                break;
                                            case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                                                console.error("glCheckFramebufferStatus() - FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT");
                                                break;
                                            case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                                                console.error("glCheckFramebufferStatus() - FRAMEBUFFER_INCOMPLETE_DIMENSIONS");
                                                break;
                                            case n.FRAMEBUFFER_UNSUPPORTED:
                                                console.error("glCheckFramebufferStatus() - FRAMEBUFFER_UNSUPPORTED")
                                        }
                                        e.stateCache.glFramebuffer !== t.glFramebuffer && n.bindFramebuffer(n.FRAMEBUFFER, e.stateCache.glFramebuffer)
                                    }
                                }
                            }(this._device, this._gpuFramebuffer), !0
                    }, n.destroy = function() {
                        var e, t;
                        this._gpuFramebuffer && (e = this._device, (t = this._gpuFramebuffer).glFramebuffer && (e.gl.deleteFramebuffer(t.glFramebuffer), t.glFramebuffer = null), this._gpuFramebuffer = null)
                    }, K(t, [{
                        key: "gpuFramebuffer",
                        get: function() {
                            return this._gpuFramebuffer
                        }
                    }]), t
                }(pc),
                MF = function(e) {
                    function t() {
                        for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                        return (t = e.call.apply(e, [this].concat(i)) || this)._gpuInputAssembler = null, t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.initialize = function(e) {
                        if (0 === e.vertexBuffers.length) return console.error("InputAssemblerInfo.vertexBuffers is null."), !1;
                        if (this._attributes = e.attributes, this._attributesHash = this.computeAttributesHash(), this._vertexBuffers = e.vertexBuffers, e.indexBuffer) this._indexBuffer = e.indexBuffer, this._indexCount = this._indexBuffer.size / this._indexBuffer.stride, this._firstIndex = 0;
                        else {
                            var t = this._vertexBuffers[0];
                            this._vertexCount = t.size / t.stride, this._firstVertex = 0, this._vertexOffset = 0
                        }
                        this._instanceCount = 0, this._firstInstance = 0, this._indirectBuffer = e.indirectBuffer || null;
                        for (var n = new Array(e.vertexBuffers.length), i = 0; i < e.vertexBuffers.length; ++i) {
                            var r = e.vertexBuffers[i];
                            r.gpuBuffer && (n[i] = r.gpuBuffer)
                        }
                        var o = null,
                            a = 0;
                        if (e.indexBuffer && (o = e.indexBuffer.gpuBuffer)) switch (o.stride) {
                            case 1:
                                a = 5121;
                                break;
                            case 2:
                                a = 5123;
                                break;
                            case 4:
                                a = 5125;
                                break;
                            default:
                                console.error("Error index buffer stride.")
                        }
                        var s = null;
                        return e.indirectBuffer && (s = e.indirectBuffer.gpuBuffer), this._gpuInputAssembler = {
                                attributes: e.attributes,
                                gpuVertexBuffers: n,
                                gpuIndexBuffer: o,
                                gpuIndirectBuffer: s,
                                glAttribs: [],
                                glIndexType: a,
                                glVAOs: new Map
                            },
                            function(e, t) {
                                var n = e.gl;
                                t.glAttribs = new Array(t.attributes.length);
                                for (var i = [0, 0, 0, 0, 0, 0, 0, 0], r = 0; r < t.attributes.length; ++r) {
                                    var o = t.attributes[r],
                                        a = void 0 !== o.stream ? o.stream : 0,
                                        s = t.gpuVertexBuffers[a],
                                        c = tF(o.format, n),
                                        l = tc[o.format].size;
                                    t.glAttribs[r] = {
                                        name: o.name,
                                        glBuffer: s.glBuffer,
                                        glType: c,
                                        size: l,
                                        count: tc[o.format].count,
                                        stride: s.stride,
                                        componentCount: cF(c, n),
                                        isNormalized: void 0 !== o.isNormalized && o.isNormalized,
                                        isInstanced: void 0 !== o.isInstanced && o.isInstanced,
                                        offset: i[a]
                                    }, i[a] += l
                                }
                            }(this._device, this._gpuInputAssembler), !0
                    }, n.destroy = function() {
                        var e = this._device;
                        this._gpuInputAssembler && e.useVAO && function(e, t) {
                            for (var n = t.glVAOs.values(), i = n.next(); !i.done;) e.OES_vertex_array_object.deleteVertexArrayOES(i.value), i = n.next();
                            t.glVAOs.clear()
                        }(e, this._gpuInputAssembler), this._gpuInputAssembler = null
                    }, K(t, [{
                        key: "gpuInputAssembler",
                        get: function() {
                            return this._gpuInputAssembler
                        }
                    }]), t
                }(yc),
                LF = function(e) {
                    function t() {
                        for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                        return (t = e.call.apply(e, [this].concat(i)) || this)._gpuDescriptorSetLayout = null, t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.initialize = function(e) {
                        Array.prototype.push.apply(this._bindings, e.bindings);
                        for (var t = 0, n = -1, i = [], r = 0; r < this._bindings.length; r++) {
                            var o = this._bindings[r];
                            i.push(t), t += o.count, o.binding > n && (n = o.binding)
                        }
                        this._bindingIndices = Array(n + 1).fill(-1);
                        for (var a = this._descriptorIndices = Array(n + 1).fill(-1), s = 0; s < this._bindings.length; s++) {
                            var c = this._bindings[s];
                            this._bindingIndices[c.binding] = s, a[c.binding] = i[s]
                        }
                        for (var l = [], u = 0; u < this._bindings.length; u++) {
                            var h = this._bindings[u];
                            if (h.descriptorType & rc)
                                for (var _ = 0; _ < h.count; _++) l.push(h.binding)
                        }
                        return this._gpuDescriptorSetLayout = {
                            bindings: this._bindings,
                            dynamicBindings: l,
                            descriptorIndices: a,
                            descriptorCount: t
                        }, !0
                    }, n.destroy = function() {
                        this._bindings.length = 0
                    }, K(t, [{
                        key: "gpuDescriptorSetLayout",
                        get: function() {
                            return this._gpuDescriptorSetLayout
                        }
                    }]), t
                }(Ec),
                BF = function(e) {
                    function t() {
                        for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                        return (t = e.call.apply(e, [this].concat(i)) || this)._gpuPipelineLayout = null, t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.initialize = function(e) {
                        Array.prototype.push.apply(this._setLayouts, e.setLayouts);
                        for (var t = [], n = [], i = 0, r = 0; r < this._setLayouts.length; r++) {
                            for (var o = this._setLayouts[r], a = o.gpuDescriptorSetLayout.dynamicBindings, s = Array(o.bindingIndices.length).fill(-1), c = 0; c < a.length; c++) {
                                var l = a[c];
                                s[l] < 0 && (s[l] = i + c)
                            }
                            n.push(o.gpuDescriptorSetLayout), t.push(s), i += a.length
                        }
                        return this._gpuPipelineLayout = {
                            gpuSetLayouts: n,
                            dynamicOffsetIndices: t,
                            dynamicOffsetCount: i
                        }, !0
                    }, n.destroy = function() {
                        this._setLayouts.length = 0
                    }, K(t, [{
                        key: "gpuPipelineLayout",
                        get: function() {
                            return this._gpuPipelineLayout
                        }
                    }]), t
                }(Tc),
                FF = [0, 1, 3, 2, 0, 0, 0, 4, 5, 6, 0, 0, 0, 0],
                zF = function(e) {
                    function t() {
                        for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                        return (t = e.call.apply(e, [this].concat(i)) || this)._gpuPipelineState = null, t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.initialize = function(e) {
                        this._primitive = e.primitive, this._shader = e.shader, this._pipelineLayout = e.pipelineLayout;
                        var t = this._bs;
                        if (e.blendState) {
                            var n = e.blendState,
                                i = n.targets;
                            i && i.forEach((function(e, n) {
                                t.setTarget(n, e)
                            })), void 0 !== n.isA2C && (t.isA2C = n.isA2C), void 0 !== n.isIndepend && (t.isIndepend = n.isIndepend), void 0 !== n.blendColor && (t.blendColor = n.blendColor)
                        }
                        Object.assign(this._rs, e.rasterizerState), Object.assign(this._dss, e.depthStencilState), this._is = e.inputState, this._renderPass = e.renderPass, this._dynamicStates = e.dynamicStates;
                        for (var r = [], o = 0; o < 31; o++) this._dynamicStates & 1 << o && r.push(1 << o);
                        return this._gpuPipelineState = {
                            glPrimitive: FF[e.primitive],
                            gpuShader: e.shader.gpuShader,
                            gpuPipelineLayout: e.pipelineLayout.gpuPipelineLayout,
                            rs: e.rasterizerState,
                            dss: e.depthStencilState,
                            bs: e.blendState,
                            gpuRenderPass: e.renderPass.gpuRenderPass,
                            dynamicStates: r
                        }, !0
                    }, n.destroy = function() {
                        this._gpuPipelineState = null
                    }, K(t, [{
                        key: "gpuPipelineState",
                        get: function() {
                            return this._gpuPipelineState
                        }
                    }]), t
                }(wc),
                UF = [],
                GF = function(e) {
                    function t() {
                        return e.apply(this, arguments) || this
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.beginRenderPass = function(e, t, n, i, r, o) {
                        AF(this._device, e.gpuRenderPass, t.gpuFramebuffer, n, i, r, o), this._isInRenderPass = !0
                    }, n.draw = function(e) {
                        if (this._isInRenderPass) {
                            this._isStateInvalied && this.bindStates(), CF(this._device, e), ++this._numDrawCalls, this._numInstances += e.instanceCount;
                            var t = e.indexCount || e.vertexCount;
                            if (this._curGPUPipelineState) switch (this._curGPUPipelineState.glPrimitive) {
                                case 4:
                                    this._numTris += t / 3 * Math.max(e.instanceCount, 1);
                                    break;
                                case 5:
                                case 6:
                                    this._numTris += (t - 2) * Math.max(e.instanceCount, 1)
                            }
                        } else console.error("Command 'draw' must be recorded inside a render pass.")
                    }, n.updateBuffer = function(e, t, n) {
                        if (this._isInRenderPass) console.error("Command 'updateBuffer' must be recorded outside a render pass.");
                        else {
                            var i, r = e.gpuBuffer;
                            r && (i = void 0 !== n ? n : e.usage & xa.INDIRECT ? 0 : t.byteLength, EF(this._device, r, t, 0, i))
                        }
                    }, n.copyBuffersToTexture = function(e, t, n) {
                        if (this._isInRenderPass) console.error("Command 'copyBufferToTexture' must be recorded outside a render pass.");
                        else {
                            var i = t.gpuTexture;
                            i && wF(this._device, e, i, n)
                        }
                    }, n.execute = function(e, t) {
                        for (var n = 0; n < t; ++n) {
                            var i = e[n];
                            RF(this._device, i.cmdPackage), this._numDrawCalls += i._numDrawCalls, this._numInstances += i._numInstances, this._numTris += i._numTris
                        }
                    }, n.bindStates = function() {
                        UF.length = 0;
                        for (var e = 0; e < this._curDynamicOffsets.length; e++) Array.prototype.push.apply(UF, this._curDynamicOffsets[e]);
                        xF(this._device, this._curGPUPipelineState, this._curGPUInputAssembler, this._curGPUDescriptorSets, UF, this._curViewport, this._curScissor, this._curLineWidth, this._curDepthBias, this._curBlendConstants, this._curDepthBounds, this._curStencilWriteMask, this._curStencilCompareMask), this._isStateInvalied = !1
                    }, t
                }(DF),
                HF = function(e) {
                    function t() {
                        for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                        return (t = e.call.apply(e, [this].concat(i)) || this).numDrawCalls = 0, t.numInstances = 0, t.numTris = 0, t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.initialize = function(e) {
                        return this._type = e.type, !0
                    }, n.destroy = function() {}, n.submit = function(e) {
                        if (!this._isAsync)
                            for (var t = e.length, n = 0; n < t; n++) {
                                var i = e[n];
                                this.numDrawCalls += i.numDrawCalls, this.numInstances += i.numInstances, this.numTris += i.numTris
                            }
                    }, n.clear = function() {
                        this.numDrawCalls = 0, this.numInstances = 0, this.numTris = 0
                    }, t
                }(Ic),
                kF = function(e) {
                    function t() {
                        for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                        return (t = e.call.apply(e, [this].concat(i)) || this)._gpuRenderPass = null, t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.initialize = function(e) {
                        return this._colorInfos = e.colorAttachments, this._depthStencilInfo = e.depthStencilAttachment, e.subpasses && (this._subpasses = e.subpasses), this._gpuRenderPass = {
                            colorAttachments: this._colorInfos,
                            depthStencilAttachment: this._depthStencilInfo
                        }, this._hash = this.computeHash(), !0
                    }, n.destroy = function() {
                        this._gpuRenderPass = null
                    }, K(t, [{
                        key: "gpuRenderPass",
                        get: function() {
                            return this._gpuRenderPass
                        }
                    }]), t
                }(Pc),
                VF = [10497, 33648, 33071, 33071],
                WF = function(e) {
                    function t() {
                        for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                        return (t = e.call.apply(e, [this].concat(i)) || this)._gpuSampler = null, t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.initialize = function(e) {
                        this._minFilter = e.minFilter, this._magFilter = e.magFilter, this._mipFilter = e.mipFilter, this._addressU = e.addressU, this._addressV = e.addressV, this._addressW = e.addressW, this._maxAnisotropy = e.maxAnisotropy, this._cmpFunc = e.cmpFunc, this._borderColor = e.borderColor, this._mipLODBias = e.mipLODBias;
                        var t, n, i = this._minFilter,
                            r = this._magFilter,
                            o = this._mipFilter;
                        t = i === Da.LINEAR || i === Da.ANISOTROPIC ? o === Da.LINEAR || o === Da.ANISOTROPIC ? 9987 : o === Da.POINT ? 9985 : 9729 : o === Da.LINEAR || o === Da.ANISOTROPIC ? 9986 : o === Da.POINT ? 9984 : 9728, n = r === Da.LINEAR || r === Da.ANISOTROPIC ? 9729 : 9728;
                        var a = VF[this._addressU],
                            s = VF[this._addressV],
                            c = VF[this._addressW];
                        return this._gpuSampler = {
                            glMinFilter: t,
                            glMagFilter: n,
                            glWrapS: a,
                            glWrapT: s,
                            glWrapR: c
                        }, !0
                    }, n.destroy = function() {
                        this._gpuSampler = null
                    }, K(t, [{
                        key: "gpuSampler",
                        get: function() {
                            return this._gpuSampler
                        }
                    }]), t
                }(Oc),
                jF = function(e) {
                    function t() {
                        for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                        return (t = e.call.apply(e, [this].concat(i)) || this)._gpuShader = null, t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.initialize = function(e) {
                        this._name = e.name, this._stages = e.stages, this._attributes = e.attributes, this._blocks = e.blocks, this._samplers = e.samplers, this._gpuShader = {
                            name: e.name,
                            blocks: e.blocks,
                            samplerTextures: e.samplerTextures,
                            gpuStages: new Array(e.stages.length),
                            glProgram: null,
                            glInputs: [],
                            glUniforms: [],
                            glBlocks: [],
                            glSamplerTextures: []
                        };
                        for (var t = 0; t < e.stages.length; ++t) {
                            var n = e.stages[t];
                            this._gpuShader.gpuStages[t] = {
                                type: n.stage,
                                source: n.source,
                                glShader: null
                            }
                        }
                        return function(e, t) {
                            for (var n = e.gl, i = function(e) {
                                    var i = t.gpuStages[e],
                                        r = 0,
                                        o = "",
                                        a = 1;
                                    switch (i.type) {
                                        case Ua.VERTEX:
                                            o = "VertexShader", r = n.VERTEX_SHADER;
                                            break;
                                        case Ua.FRAGMENT:
                                            o = "FragmentShader", r = n.FRAGMENT_SHADER;
                                            break;
                                        default:
                                            return console.error("Unsupported ShaderType."), {
                                                v: void 0
                                            }
                                    }
                                    var s = n.createShader(r);
                                    if (s && (i.glShader = s, n.shaderSource(i.glShader, i.source), n.compileShader(i.glShader), !n.getShaderParameter(i.glShader, n.COMPILE_STATUS))) {
                                        console.error(o + " in '" + t.name + "' compilation failed."), console.error("Shader source dump:", i.source.replace(/^|\n/g, (function() {
                                            return "\n" + a++ + " "
                                        }))), console.error(n.getShaderInfoLog(i.glShader));
                                        for (var c = 0; c < t.gpuStages.length; c++) {
                                            var l = t.gpuStages[e];
                                            l.glShader && (n.deleteShader(l.glShader), l.glShader = null)
                                        }
                                        return {
                                            v: void 0
                                        }
                                    }
                                }, r = 0; r < t.gpuStages.length; r++) {
                                var o = i(r);
                                if ("object" == typeof o) return o.v
                            }
                            var a = n.createProgram();
                            if (a) {
                                t.glProgram = a;
                                for (var s = 0; s < t.gpuStages.length; s++) {
                                    var c = t.gpuStages[s];
                                    n.attachShader(t.glProgram, c.glShader)
                                }
                                if (n.linkProgram(t.glProgram), e.destroyShadersImmediately)
                                    for (var l = 0; l < t.gpuStages.length; l++) {
                                        var u = t.gpuStages[l];
                                        u.glShader && (n.detachShader(t.glProgram, u.glShader), n.deleteShader(u.glShader), u.glShader = null)
                                    }
                                if (!n.getProgramParameter(t.glProgram, n.LINK_STATUS)) return console.error("Failed to link shader '" + t.name + "'."), void console.error(n.getProgramInfoLog(t.glProgram));
                                console.info("Shader '" + t.name + "' compilation succeeded.");
                                var h = n.getProgramParameter(t.glProgram, n.ACTIVE_ATTRIBUTES);
                                t.glInputs = new Array(h);
                                for (var _ = 0; _ < h; ++_) {
                                    var f = n.getActiveAttrib(t.glProgram, _);
                                    if (f) {
                                        var d, p = f.name.indexOf("[");
                                        d = -1 !== p ? f.name.substr(0, p) : f.name;
                                        var m = n.getAttribLocation(t.glProgram, d),
                                            g = aF(f.type, n),
                                            v = sF(f.type, n);
                                        t.glInputs[_] = {
                                            binding: m,
                                            name: d,
                                            type: g,
                                            stride: v,
                                            count: f.size,
                                            size: v * f.size,
                                            glType: f.type,
                                            glLoc: m
                                        }
                                    }
                                }
                                if (t.blocks.length > 0) {
                                    t.glBlocks = new Array(t.blocks.length);
                                    for (var y = 0; y < t.blocks.length; ++y) {
                                        var S = t.blocks[y],
                                            E = {
                                                set: S.set,
                                                binding: S.binding,
                                                name: S.name,
                                                size: 0,
                                                glUniforms: new Array(S.members.length),
                                                glActiveUniforms: []
                                            };
                                        t.glBlocks[y] = E;
                                        for (var T = 0; T < S.members.length; ++T) {
                                            var A = S.members[T],
                                                x = rF(A.type, n),
                                                C = oF(A.type),
                                                b = sF(x, n),
                                                R = b * A.count,
                                                w = E.size / 4,
                                                I = new C(R / 4);
                                            E.glUniforms[T] = {
                                                binding: -1,
                                                name: A.name,
                                                type: A.type,
                                                stride: b,
                                                count: A.count,
                                                size: R,
                                                offset: E.size,
                                                glType: x,
                                                glLoc: -1,
                                                array: I,
                                                begin: w
                                            }, E.size += R
                                        }
                                    }
                                }
                                if (t.samplerTextures.length > 0) {
                                    t.glSamplerTextures = new Array(t.samplerTextures.length);
                                    for (var P = 0; P < t.samplerTextures.length; ++P) {
                                        var O = t.samplerTextures[P];
                                        t.glSamplerTextures[P] = {
                                            set: O.set,
                                            binding: O.binding,
                                            name: O.name,
                                            type: O.type,
                                            count: O.count,
                                            units: [],
                                            glUnits: null,
                                            glType: rF(O.type, n),
                                            glLoc: null
                                        }
                                    }
                                }
                                for (var D = n.getProgramParameter(t.glProgram, n.ACTIVE_UNIFORMS), N = 0; N < D; ++N) {
                                    var M = n.getActiveUniform(t.glProgram, N);
                                    if (M && M.type !== n.SAMPLER_2D && M.type !== n.SAMPLER_CUBE) {
                                        var L = n.getUniformLocation(t.glProgram, M.name);
                                        if (null !== L && ("number" == typeof L || -1 !== L.id)) {
                                            var B, F = M.name.indexOf("[");
                                            B = -1 !== F ? M.name.substr(0, F) : M.name;
                                            for (var z = 0; z < t.glBlocks.length; z++)
                                                for (var U = t.glBlocks[z], G = 0; G < U.glUniforms.length; G++) {
                                                    var H = U.glUniforms[G];
                                                    if (H.name === B) {
                                                        H.glLoc = L, U.glActiveUniforms.push(H);
                                                        break
                                                    }
                                                }
                                        }
                                    }
                                }
                                for (var k = [], V = [], W = e.bindingMappingInfo, j = e.stateCache.texUnitCacheMap, q = 0, X = 0; X < t.blocks.length; ++X) t.blocks[X].set === W.flexibleSet && q++;
                                for (var Y = 0, K = 0; K < t.samplerTextures.length; ++K) {
                                    var Z = t.samplerTextures[K],
                                        Q = n.getUniformLocation(t.glProgram, Z.name);
                                    if (null === Q || "number" != typeof Q && -1 === Q.id || (k.push(t.glSamplerTextures[K]), V.push(Q)), void 0 === j[Z.name]) {
                                        var J = Z.binding + W.samplerOffsets[Z.set] + Y;
                                        Z.set === W.flexibleSet && (J -= q), j[Z.name] = J % e.capabilities.maxTextureUnits, Y += Z.count - 1
                                    }
                                }
                                if (k.length) {
                                    for (var $ = [], ee = 0; ee < k.length; ++ee) {
                                        var te = k[ee],
                                            ne = j[te.name];
                                        if (void 0 !== ne) {
                                            te.glLoc = V[ee];
                                            for (var ie = 0; ie < te.count; ++ie) {
                                                for (; $[ne];) ne = (ne + 1) % e.capabilities.maxTextureUnits;
                                                te.units.push(ne), $[ne] = !0
                                            }
                                        }
                                    }
                                    for (var re = 0, oe = 0; oe < k.length; ++oe) {
                                        var ae = k[oe];
                                        if (!ae.glLoc) {
                                            ae.glLoc = V[oe];
                                            for (var se = 0; se < ae.count; ++se) {
                                                for (; $[re];) re = (re + 1) % e.capabilities.maxTextureUnits;
                                                void 0 === j[ae.name] && (j[ae.name] = re), ae.units.push(re), $[re] = !0
                                            }
                                        }
                                    }
                                    e.stateCache.glProgram !== t.glProgram && n.useProgram(t.glProgram);
                                    for (var ce = 0; ce < k.length; ce++) {
                                        var le = k[ce];
                                        le.glUnits = new Int32Array(le.units), n.uniform1iv(le.glLoc, le.glUnits)
                                    }
                                    e.stateCache.glProgram !== t.glProgram && n.useProgram(e.stateCache.glProgram)
                                }
                                for (var ue = 0; ue < t.glBlocks.length;) t.glBlocks[ue].glActiveUniforms.length ? ue++ : (t.glBlocks[ue] = t.glBlocks[t.glBlocks.length - 1], t.glBlocks.length--);
                                t.glSamplerTextures = k
                            }
                        }(this._device, this._gpuShader), !0
                    }, n.destroy = function() {
                        this._gpuShader && (function(e, t) {
                            if (t.glProgram) {
                                var n = e.gl;
                                if (!e.destroyShadersImmediately)
                                    for (var i = 0; i < t.gpuStages.length; i++) {
                                        var r = t.gpuStages[i];
                                        r.glShader && (n.detachShader(t.glProgram, r.glShader), n.deleteShader(r.glShader), r.glShader = null)
                                    }
                                n.deleteProgram(t.glProgram), t.glProgram = null
                            }
                        }(this._device, this._gpuShader), this._gpuShader = null)
                    }, K(t, [{
                        key: "gpuShader",
                        get: function() {
                            return this._gpuShader
                        }
                    }]), t
                }(Dc),
                qF = function() {
                    function e() {
                        this.glArrayBuffer = null, this.glElementArrayBuffer = null, this.glVAO = null, this.texUnit = 0, this.glTexUnits = [], this.glRenderbuffer = null, this.glFramebuffer = null, this.viewport = new ds, this.scissorRect = new ss(0, 0, 0, 0), this.rs = new Ac, this.dss = new xc, this.bs = new bc, this.glProgram = null, this.glEnabledAttribLocs = [], this.glCurrentAttribLocs = [], this.texUnitCacheMap = {}
                    }
                    return e.prototype.initialize = function(e, t) {
                        for (var n = 0; n < e; ++n) this.glTexUnits.push({
                            glTexture: null
                        });
                        this.glEnabledAttribLocs.length = t, this.glEnabledAttribLocs.fill(!1), this.glCurrentAttribLocs.length = t, this.glCurrentAttribLocs.fill(!1)
                    }, e
                }(),
                XF = function(e) {
                    function t() {
                        for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                        return (t = e.call.apply(e, [this].concat(i)) || this)._gpuTexture = null, t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.initialize = function(e) {
                        return "texture" in e ? (console.log("WebGL does not support texture view."), !1) : (this._type = e.type, this._usage = e.usage, this._format = e.format, this._width = e.width, this._height = e.height, this._depth = e.depth, this._layerCount = e.layerCount, this._levelCount = e.levelCount, this._samples = e.samples, this._flags = e.flags, this._isPowerOf2 = oc(this._width) && oc(this._height), this._size = sc(this._format, this.width, this.height, this.depth, this._levelCount) * this._layerCount, this._gpuTexture = {
                            type: this._type,
                            format: this._format,
                            usage: this._usage,
                            width: this._width,
                            height: this._height,
                            depth: this._depth,
                            size: this._size,
                            arrayLayer: this._layerCount,
                            mipLevel: this._levelCount,
                            samples: this._samples,
                            flags: this._flags,
                            isPowerOf2: this._isPowerOf2,
                            glTarget: 0,
                            glInternalFmt: 0,
                            glFormat: 0,
                            glType: 0,
                            glUsage: 0,
                            glTexture: null,
                            glRenderbuffer: null,
                            glWrapS: 0,
                            glWrapT: 0,
                            glMinFilter: 0,
                            glMagFilter: 0
                        }, function(e, t) {
                            var n = e.gl;
                            t.glInternalFmt = nF(t.format, n), t.glFormat = iF(t.format, n), t.glType = tF(t.format, n);
                            var i = t.width,
                                r = t.height;
                            switch (t.type) {
                                case wa.TEX2D:
                                    t.glTarget = n.TEXTURE_2D;
                                    var o = Math.max(i, r);
                                    if (o > e.capabilities.maxTextureSize && b(9100, o, e.capabilities.maxTextureSize), !e.WEBGL_depth_texture && tc[t.format].hasDepth) {
                                        var a = n.createRenderbuffer();
                                        a && t.size > 0 && (t.glRenderbuffer = a, e.stateCache.glRenderbuffer !== t.glRenderbuffer && (n.bindRenderbuffer(n.RENDERBUFFER, t.glRenderbuffer), e.stateCache.glRenderbuffer = t.glRenderbuffer), t.glInternalFmt === n.DEPTH_COMPONENT && (t.glInternalFmt = n.DEPTH_COMPONENT16), n.renderbufferStorage(n.RENDERBUFFER, t.glInternalFmt, i, r))
                                    } else if (t.samples === Oa.X1) {
                                        var s = n.createTexture();
                                        if (s && t.size > 0) {
                                            t.glTexture = s;
                                            var c = e.stateCache.glTexUnits[e.stateCache.texUnit];
                                            if (c.glTexture !== t.glTexture && (n.bindTexture(n.TEXTURE_2D, t.glTexture), c.glTexture = t.glTexture), tc[t.format].isCompressed)
                                                if (t.glInternalFmt !== $B.COMPRESSED_RGB_ETC1_WEBGL)
                                                    for (var l = 0; l < t.mipLevel; ++l) {
                                                        var u = ac(t.format, i, r, 1),
                                                            h = new Uint8Array(u);
                                                        n.compressedTexImage2D(n.TEXTURE_2D, l, t.glInternalFmt, i, r, 0, h), i = Math.max(1, i >> 1), r = Math.max(1, r >> 1)
                                                    } else {
                                                        var _ = ac(t.format, 2, 2, 1),
                                                            f = new Uint8Array(_);
                                                        n.compressedTexImage2D(n.TEXTURE_2D, 0, t.glInternalFmt, 2, 2, 0, f)
                                                    } else
                                                        for (var d = 0; d < t.mipLevel; ++d) n.texImage2D(n.TEXTURE_2D, d, t.glInternalFmt, i, r, 0, t.glFormat, t.glType, null), i = Math.max(1, i >> 1), r = Math.max(1, r >> 1);
                                            t.isPowerOf2 ? (t.glWrapS = n.REPEAT, t.glWrapT = n.REPEAT) : (t.glWrapS = n.CLAMP_TO_EDGE, t.glWrapT = n.CLAMP_TO_EDGE), t.glMinFilter = n.LINEAR, t.glMagFilter = n.LINEAR, n.texParameteri(t.glTarget, n.TEXTURE_WRAP_S, t.glWrapS), n.texParameteri(t.glTarget, n.TEXTURE_WRAP_T, t.glWrapT), n.texParameteri(t.glTarget, n.TEXTURE_MIN_FILTER, t.glMinFilter), n.texParameteri(t.glTarget, n.TEXTURE_MAG_FILTER, t.glMagFilter)
                                        } else n.deleteTexture(s)
                                    }
                                    break;
                                case wa.CUBE:
                                    t.glTarget = n.TEXTURE_CUBE_MAP;
                                    var p = Math.max(i, r);
                                    p > e.capabilities.maxCubeMapTextureSize && b(9100, p, e.capabilities.maxTextureSize);
                                    var m = n.createTexture();
                                    if (m && t.size > 0) {
                                        t.glTexture = m;
                                        var g = e.stateCache.glTexUnits[e.stateCache.texUnit];
                                        if (g.glTexture !== t.glTexture && (n.bindTexture(n.TEXTURE_CUBE_MAP, t.glTexture), g.glTexture = t.glTexture), tc[t.format].isCompressed)
                                            if (t.glInternalFmt !== $B.COMPRESSED_RGB_ETC1_WEBGL)
                                                for (var v = 0; v < 6; ++v) {
                                                    i = t.width, r = t.height;
                                                    for (var y = 0; y < t.mipLevel; ++y) {
                                                        var S = ac(t.format, i, r, 1),
                                                            E = new Uint8Array(S);
                                                        n.compressedTexImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + v, y, t.glInternalFmt, i, r, 0, E), i = Math.max(1, i >> 1), r = Math.max(1, r >> 1)
                                                    }
                                                } else
                                                    for (var T = 0; T < 6; ++T) {
                                                        var A = ac(t.format, 2, 2, 1),
                                                            x = new Uint8Array(A);
                                                        n.compressedTexImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + T, 0, t.glInternalFmt, 2, 2, 0, x)
                                                    } else
                                                        for (var C = 0; C < 6; ++C) {
                                                            i = t.width, r = t.height;
                                                            for (var R = 0; R < t.mipLevel; ++R) n.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + C, R, t.glInternalFmt, i, r, 0, t.glFormat, t.glType, null), i = Math.max(1, i >> 1), r = Math.max(1, r >> 1)
                                                        }
                                        t.isPowerOf2 ? (t.glWrapS = n.REPEAT, t.glWrapT = n.REPEAT) : (t.glWrapS = n.CLAMP_TO_EDGE, t.glWrapT = n.CLAMP_TO_EDGE), t.glMinFilter = n.LINEAR, t.glMagFilter = n.LINEAR, n.texParameteri(t.glTarget, n.TEXTURE_WRAP_S, t.glWrapS), n.texParameteri(t.glTarget, n.TEXTURE_WRAP_T, t.glWrapT), n.texParameteri(t.glTarget, n.TEXTURE_MIN_FILTER, t.glMinFilter), n.texParameteri(t.glTarget, n.TEXTURE_MAG_FILTER, t.glMagFilter)
                                    }
                                    break;
                                default:
                                    console.error("Unsupported TextureType, create texture failed."), t.type = wa.TEX2D, t.glTarget = n.TEXTURE_2D
                            }
                        }(this._device, this._gpuTexture), this._device.memoryStatus.textureSize += this._size, !0)
                    }, n.destroy = function() {
                        var e, t;
                        this._gpuTexture && (e = this._device, (t = this._gpuTexture).glTexture && (e.gl.deleteTexture(t.glTexture), t.glTexture = null), t.glRenderbuffer && (e.gl.deleteRenderbuffer(t.glRenderbuffer), t.glRenderbuffer = null), this._device.memoryStatus.textureSize -= this._size, this._gpuTexture = null)
                    }, n.resize = function(e, t) {
                        var n = this._size;
                        this._width = e, this._height = t, this._size = sc(this._format, this.width, this.height, this.depth, this._levelCount) * this._layerCount, this._gpuTexture && (this._gpuTexture.width = e, this._gpuTexture.height = t, this._gpuTexture.size = this._size, function(e, t) {
                            var n = e.gl;
                            t.glInternalFmt = nF(t.format, n), t.glFormat = iF(t.format, n), t.glType = tF(t.format, n);
                            var i = t.width,
                                r = t.height;
                            switch (t.type) {
                                case wa.TEX2D:
                                    t.glTarget = n.TEXTURE_2D;
                                    var o = Math.max(i, r);
                                    if (o > e.capabilities.maxTextureSize && b(9100, o, e.capabilities.maxTextureSize), t.glRenderbuffer) e.stateCache.glRenderbuffer !== t.glRenderbuffer && (n.bindRenderbuffer(n.RENDERBUFFER, t.glRenderbuffer), e.stateCache.glRenderbuffer = t.glRenderbuffer), n.renderbufferStorage(n.RENDERBUFFER, t.glInternalFmt, i, r);
                                    else if (t.glTexture) {
                                        var a = e.stateCache.glTexUnits[e.stateCache.texUnit];
                                        if (a.glTexture !== t.glTexture && (n.bindTexture(n.TEXTURE_2D, t.glTexture), a.glTexture = t.glTexture), tc[t.format].isCompressed) {
                                            if (t.glInternalFmt !== $B.COMPRESSED_RGB_ETC1_WEBGL)
                                                for (var s = 0; s < t.mipLevel; ++s) {
                                                    var c = ac(t.format, i, r, 1),
                                                        l = new Uint8Array(c);
                                                    n.compressedTexImage2D(n.TEXTURE_2D, s, t.glInternalFmt, i, r, 0, l), i = Math.max(1, i >> 1), r = Math.max(1, r >> 1)
                                                }
                                        } else
                                            for (var u = 0; u < t.mipLevel; ++u) n.texImage2D(n.TEXTURE_2D, u, t.glInternalFmt, i, r, 0, t.glFormat, t.glType, null), i = Math.max(1, i >> 1), r = Math.max(1, r >> 1)
                                    }
                                    break;
                                case wa.CUBE:
                                    t.glTarget = n.TEXTURE_CUBE_MAP;
                                    var h = Math.max(i, r);
                                    h > e.capabilities.maxCubeMapTextureSize && b(9100, h, e.capabilities.maxTextureSize);
                                    var _ = e.stateCache.glTexUnits[e.stateCache.texUnit];
                                    if (_.glTexture !== t.glTexture && (n.bindTexture(n.TEXTURE_CUBE_MAP, t.glTexture), _.glTexture = t.glTexture), tc[t.format].isCompressed) {
                                        if (t.glInternalFmt !== $B.COMPRESSED_RGB_ETC1_WEBGL)
                                            for (var f = 0; f < 6; ++f) {
                                                i = t.width, r = t.height;
                                                for (var d = 0; d < t.mipLevel; ++d) {
                                                    var p = ac(t.format, i, r, 1),
                                                        m = new Uint8Array(p);
                                                    n.compressedTexImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + f, d, t.glInternalFmt, i, r, 0, m), i = Math.max(1, i >> 1), r = Math.max(1, r >> 1)
                                                }
                                            }
                                    } else
                                        for (var g = 0; g < 6; ++g) {
                                            i = t.width, r = t.height;
                                            for (var v = 0; v < t.mipLevel; ++v) n.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + g, v, t.glInternalFmt, i, r, 0, t.glFormat, t.glType, null), i = Math.max(1, i >> 1), r = Math.max(1, r >> 1)
                                        }
                                    break;
                                default:
                                    console.error("Unsupported TextureType, create texture failed."), t.type = wa.TEX2D, t.glTarget = n.TEXTURE_2D
                            }
                        }(this._device, this._gpuTexture), this._device.memoryStatus.textureSize -= n, this._device.memoryStatus.textureSize += this._size)
                    }, K(t, [{
                        key: "gpuTexture",
                        get: function() {
                            return this._gpuTexture
                        }
                    }]), t
                }(Nc),
                YF = "webglcontextlost",
                KF = e("WebGLDevice", function(e) {
                    function t() {
                        for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                        return (t = e.call.apply(e, [this].concat(i)) || this).stateCache = new qF, t.cmdAllocator = new OF, t.nullTex2D = null, t.nullTexCube = null, t._webGLRC = null, t._isAntialias = !0, t._isPremultipliedAlpha = !0, t._useVAO = !1, t._destroyShadersImmediately = !0, t._noCompressedTexSubImage2D = !1, t._bindingMappingInfo = new ms, t._webGLContextLostHandler = null, t._extensions = null, t._EXT_texture_filter_anisotropic = null, t._EXT_blend_minmax = null, t._EXT_frag_depth = null, t._EXT_shader_texture_lod = null, t._EXT_sRGB = null, t._OES_vertex_array_object = null, t._EXT_color_buffer_half_float = null, t._WEBGL_color_buffer_float = null, t._WEBGL_compressed_texture_etc1 = null, t._WEBGL_compressed_texture_etc = null, t._WEBGL_compressed_texture_pvrtc = null, t._WEBGL_compressed_texture_astc = null, t._WEBGL_compressed_texture_s3tc = null, t._WEBGL_compressed_texture_s3tc_srgb = null, t._WEBGL_debug_shaders = null, t._WEBGL_draw_buffers = null, t._WEBGL_lose_context = null, t._WEBGL_depth_texture = null, t._WEBGL_debug_renderer_info = null, t._OES_texture_half_float = null, t._OES_texture_half_float_linear = null, t._OES_texture_float = null, t._OES_texture_float_linear = null, t._OES_standard_derivatives = null, t._OES_element_index_uint = null, t._ANGLE_instanced_arrays = null, t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.initialize = function(e) {
                        this._canvas = e.canvasElm, this._isAntialias = e.isAntialias, this._isPremultipliedAlpha = e.isPremultipliedAlpha, this._bindingMappingInfo = e.bindingMappingInfo, this._bindingMappingInfo.bufferOffsets.length || this._bindingMappingInfo.bufferOffsets.push(0), this._bindingMappingInfo.samplerOffsets.length || this._bindingMappingInfo.samplerOffsets.push(0);
                        try {
                            var t = {
                                alpha: rt.ENABLE_TRANSPARENT_CANVAS,
                                antialias: this._isAntialias,
                                depth: !0,
                                stencil: !0,
                                premultipliedAlpha: this._isPremultipliedAlpha,
                                preserveDrawingBuffer: !1,
                                powerPreference: "default",
                                failIfMajorPerformanceCaveat: !1
                            };
                            this._webGLRC = this._canvas.getContext("webgl", t)
                        } catch (e) {
                            return console.error(e), !1
                        }
                        if (!this._webGLRC) return console.error("This device does not support WebGL."), !1;
                        this._webGLContextLostHandler = this._onWebGLContextLost.bind(this), this._canvas.addEventListener(YF, this._onWebGLContextLost), this._canvas2D = document.createElement("canvas"), console.info("WebGL device initialized."), this._gfxAPI = va.WEBGL, this._deviceName = "WebGL";
                        var n = this._webGLRC;
                        this._WEBGL_debug_renderer_info = this.getExtension("WEBGL_debug_renderer_info"), this._WEBGL_debug_renderer_info ? (this._renderer = n.getParameter(this._WEBGL_debug_renderer_info.UNMASKED_RENDERER_WEBGL), this._vendor = n.getParameter(this._WEBGL_debug_renderer_info.UNMASKED_VENDOR_WEBGL)) : (this._renderer = n.getParameter(n.RENDERER), this._vendor = n.getParameter(n.VENDOR)), this._version = n.getParameter(n.VERSION), this._caps.maxVertexAttributes = n.getParameter(n.MAX_VERTEX_ATTRIBS), this._caps.maxVertexUniformVectors = n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS), this._caps.maxFragmentUniformVectors = n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS), this._caps.maxTextureUnits = n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS), this._caps.maxVertexTextureUnits = n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS), this._caps.maxTextureSize = n.getParameter(n.MAX_TEXTURE_SIZE), this._caps.maxCubeMapTextureSize = n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE), this._caps.depthBits = n.getParameter(n.DEPTH_BITS), this._caps.stencilBits = n.getParameter(n.STENCIL_BITS), this.stateCache.initialize(this._caps.maxTextureUnits, this._caps.maxVertexAttributes), this._devicePixelRatio = e.devicePixelRatio || 1, this._width = this._canvas.width, this._height = this._canvas.height, this._nativeWidth = Math.max(e.nativeWidth || this._width, 0), this._nativeHeight = Math.max(e.nativeHeight || this._height, 0), this._colorFmt = Ea.RGBA8, 24 === this._caps.depthBits ? 8 === this._caps.stencilBits ? this._depthStencilFmt = Ea.D24S8 : this._depthStencilFmt = Ea.D24 : 8 === this._caps.stencilBits ? this._depthStencilFmt = Ea.D16S8 : this._depthStencilFmt = Ea.D16, this._extensions = n.getSupportedExtensions();
                        var i = "";
                        if (this._extensions) {
                            for (var r, o = te(this._extensions); !(r = o()).done;) i += r.value + " ";
                            console.debug("EXTENSIONS: " + i)
                        }
                        this._EXT_texture_filter_anisotropic = this.getExtension("EXT_texture_filter_anisotropic"), this._EXT_blend_minmax = this.getExtension("EXT_blend_minmax"), this._EXT_frag_depth = this.getExtension("EXT_frag_depth"), this._EXT_shader_texture_lod = this.getExtension("EXT_shader_texture_lod"), this._EXT_sRGB = this.getExtension("EXT_sRGB"), this._OES_vertex_array_object = this.getExtension("OES_vertex_array_object"), this._EXT_color_buffer_half_float = this.getExtension("EXT_color_buffer_half_float"), this._WEBGL_color_buffer_float = this.getExtension("WEBGL_color_buffer_float"), this._WEBGL_compressed_texture_etc1 = this.getExtension("WEBGL_compressed_texture_etc1"), this._WEBGL_compressed_texture_etc = this.getExtension("WEBGL_compressed_texture_etc"), this._WEBGL_compressed_texture_pvrtc = this.getExtension("WEBGL_compressed_texture_pvrtc"), this._WEBGL_compressed_texture_s3tc = this.getExtension("WEBGL_compressed_texture_s3tc"), this._WEBGL_compressed_texture_s3tc_srgb = this.getExtension("WEBGL_compressed_texture_s3tc_srgb"), this._WEBGL_debug_shaders = this.getExtension("WEBGL_debug_shaders"), this._WEBGL_draw_buffers = this.getExtension("WEBGL_draw_buffers"), this._WEBGL_lose_context = this.getExtension("WEBGL_lose_context"), this._WEBGL_depth_texture = this.getExtension("WEBGL_depth_texture"), this._OES_texture_half_float = this.getExtension("OES_texture_half_float"), this._OES_texture_half_float_linear = this.getExtension("OES_texture_half_float_linear"), this._OES_texture_float = this.getExtension("OES_texture_float"), this._OES_texture_float_linear = this.getExtension("OES_texture_float_linear"), this._OES_standard_derivatives = this.getExtension("OES_standard_derivatives"), this._OES_element_index_uint = this.getExtension("OES_element_index_uint"), this._ANGLE_instanced_arrays = this.getExtension("ANGLE_instanced_arrays"), Ei.os === gi.IOS && 14 === oS.osMainVersion && oS.isBrowser || (this._WEBGL_compressed_texture_astc = this.getExtension("WEBGL_compressed_texture_astc")), Ei.browserType === fi.UC && (this._ANGLE_instanced_arrays = null), Ei.os === gi.IOS && oS.osMainVersion <= 10 && (this._destroyShadersImmediately = !1), this._features.fill(!1), this._EXT_blend_minmax && (this._features[Sa.BLEND_MINMAX] = !0), this._WEBGL_color_buffer_float && (this._features[Sa.COLOR_FLOAT] = !0), this._EXT_color_buffer_half_float && (this._features[Sa.COLOR_HALF_FLOAT] = !0), this._OES_texture_float && (this._features[Sa.TEXTURE_FLOAT] = !0), this._OES_texture_half_float && (this._features[Sa.TEXTURE_HALF_FLOAT] = !0), this._OES_texture_float_linear && (this._features[Sa.TEXTURE_FLOAT_LINEAR] = !0), this._OES_texture_half_float_linear && (this._features[Sa.TEXTURE_HALF_FLOAT_LINEAR] = !0), this._features[Sa.FORMAT_RGB8] = !0, this._WEBGL_depth_texture && (this._features[Sa.FORMAT_D16] = !0, this._features[Sa.FORMAT_D24] = !0, this._features[Sa.FORMAT_D24S8] = !0), this._OES_element_index_uint && (this._features[Sa.ELEMENT_INDEX_UINT] = !0), this._ANGLE_instanced_arrays && (this._features[Sa.INSTANCED_ARRAYS] = !0), this._WEBGL_draw_buffers && (this._features[Sa.MULTIPLE_RENDER_TARGETS] = !0);
                        var a = "";
                        this._WEBGL_compressed_texture_etc1 && (this._features[Sa.FORMAT_ETC1] = !0, a += "etc1 "), this._WEBGL_compressed_texture_etc && (this._features[Sa.FORMAT_ETC2] = !0, a += "etc2 "), this._WEBGL_compressed_texture_s3tc && (this._features[Sa.FORMAT_DXT] = !0, a += "dxt "), this._WEBGL_compressed_texture_pvrtc && (this._features[Sa.FORMAT_PVRTC] = !0, a += "pvrtc "), this._WEBGL_compressed_texture_astc && (this._features[Sa.FORMAT_ASTC] = !0, a += "astc "), this._OES_vertex_array_object && (this._useVAO = !0), console.info("RENDERER: " + this._renderer), console.info("VENDOR: " + this._vendor), console.info("VERSION: " + this._version), console.info("DPR: " + this._devicePixelRatio), console.info("SCREEN_SIZE: " + this._width + " x " + this._height), console.info("NATIVE_SIZE: " + this._nativeWidth + " x " + this._nativeHeight), console.info("MAX_VERTEX_UNIFORM_VECTORS: " + this._caps.maxVertexUniformVectors), console.info("DEPTH_BITS: " + this._caps.depthBits), console.info("STENCIL_BITS: " + this._caps.stencilBits), this._EXT_texture_filter_anisotropic && console.info("MAX_TEXTURE_MAX_ANISOTROPY_EXT: " + this._EXT_texture_filter_anisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT), console.info("USE_VAO: " + this._useVAO), console.info("COMPRESSED_FORMAT: " + a), this.initStates(n), this._queue = this.createQueue(new Zs(Qa.GRAPHICS)), this._cmdBuff = this.createCommandBuffer(new Ks(this._queue)), this.nullTex2D = this.createTexture(new Ts(wa.TEX2D, Ia.SAMPLED, Ea.RGBA8, 2, 2, Pa.GEN_MIPMAP)), this.nullTexCube = this.createTexture(new Ts(wa.CUBE, Ia.SAMPLED, Ea.RGBA8, 2, 2, Pa.GEN_MIPMAP, 6));
                        var s = new fs;
                        s.texExtent.width = 2, s.texExtent.height = 2;
                        var c = new Uint8Array(this.nullTex2D.size);
                        return c.fill(0), this.copyBuffersToTexture([c], this.nullTex2D, [s]), s.texSubres.layerCount = 6, this.copyBuffersToTexture([c, c, c, c, c, c], this.nullTexCube, [s]), !0
                    }, n.destroy = function() {
                        this._canvas && this._webGLContextLostHandler && (this._canvas.removeEventListener(YF, this._webGLContextLostHandler), this._webGLContextLostHandler = null), this.nullTex2D && (this.nullTex2D.destroy(), this.nullTex2D = null), this.nullTexCube && (this.nullTexCube.destroy(), this.nullTexCube = null), this._queue && (this._queue.destroy(), this._queue = null), this._cmdBuff && (this._cmdBuff.destroy(), this._cmdBuff = null), this._extensions = null, this._webGLRC = null
                    }, n.resize = function(e, t) {
                        this._width === e && this._height === t || (console.info("Resizing device: " + e + "x" + t), this._canvas.width = e, this._canvas.height = t, this._width = e, this._height = t)
                    }, n.flushCommands = function() {}, n.acquire = function() {
                        this.cmdAllocator.releaseCmds()
                    }, n.present = function() {
                        var e = this._queue;
                        this._numDrawCalls = e.numDrawCalls, this._numInstances = e.numInstances, this._numTris = e.numTris, e.clear()
                    }, n.createCommandBuffer = function(e) {
                        var t = new(e.type === Ja.PRIMARY ? GF : DF)(this);
                        return t.initialize(e), t
                    }, n.createBuffer = function(e) {
                        var t = new IF(this);
                        return t.initialize(e) ? t : null
                    }, n.createTexture = function(e) {
                        var t = new XF(this);
                        return t.initialize(e) ? t : null
                    }, n.createSampler = function(e) {
                        var t = new WF(this);
                        return t.initialize(e) ? t : null
                    }, n.createDescriptorSet = function(e) {
                        var t = new eF(this);
                        return t.initialize(e) ? t : null
                    }, n.createShader = function(e) {
                        var t = new jF(this);
                        return t.initialize(e) ? t : null
                    }, n.createInputAssembler = function(e) {
                        var t = new MF(this);
                        return t.initialize(e) ? t : null
                    }, n.createRenderPass = function(e) {
                        var t = new kF(this);
                        return t.initialize(e) ? t : null
                    }, n.createFramebuffer = function(e) {
                        var t = new NF(this);
                        return t.initialize(e) ? t : null
                    }, n.createDescriptorSetLayout = function(e) {
                        var t = new LF(this);
                        return t.initialize(e) ? t : null
                    }, n.createPipelineLayout = function(e) {
                        var t = new BF(this);
                        return t.initialize(e) ? t : null
                    }, n.createPipelineState = function(e) {
                        var t = new zF(this);
                        return t.initialize(e) ? t : null
                    }, n.createQueue = function(e) {
                        var t = new HF(this);
                        return t.initialize(e) ? t : null
                    }, n.createGlobalBarrier = function(e) {
                        var t = new Mc(this);
                        return t.initialize(e) ? t : null
                    }, n.createTextureBarrier = function(e) {
                        var t = new Lc(this);
                        return t.initialize(e) ? t : null
                    }, n.copyBuffersToTexture = function(e, t, n) {
                        wF(this, e, t.gpuTexture, n)
                    }, n.copyTexImagesToTexture = function(e, t, n) {
                        ! function(e, t, n, i) {
                            var r = e.gl,
                                o = e.stateCache.glTexUnits[e.stateCache.texUnit];
                            o.glTexture !== n.glTexture && (r.bindTexture(n.glTarget, n.glTexture), o.glTexture = n.glTexture);
                            var a = 0,
                                s = 0;
                            switch (n.glTarget) {
                                case r.TEXTURE_2D:
                                    for (var c = 0; c < i.length; c++) {
                                        var l = i[c];
                                        r.texSubImage2D(r.TEXTURE_2D, l.texSubres.mipLevel, l.texOffset.x, l.texOffset.y, n.glFormat, n.glType, t[a++])
                                    }
                                    break;
                                case r.TEXTURE_CUBE_MAP:
                                    for (var u = 0; u < i.length; u++) {
                                        var h = i[u],
                                            _ = h.texSubres.baseArrayLayer + h.texSubres.layerCount;
                                        for (s = h.texSubres.baseArrayLayer; s < _; ++s) r.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + s, h.texSubres.mipLevel, h.texOffset.x, h.texOffset.y, n.glFormat, n.glType, t[a++])
                                    }
                                    break;
                                default:
                                    console.error("Unsupported GL texture type, copy buffer to texture failed.")
                            }
                            n.flags & Pa.GEN_MIPMAP && n.isPowerOf2 && r.generateMipmap(n.glTarget)
                        }(this, e, t.gpuTexture, n)
                    }, n.copyFramebufferToBuffer = function(e, t, n) {
                        var i = this._webGLRC,
                            r = e.gpuFramebuffer,
                            o = r.gpuColorTextures[0].format,
                            a = iF(o, i),
                            s = tF(o, i),
                            c = uc(tc[o]),
                            l = this.stateCache.glFramebuffer;
                        this.stateCache.glFramebuffer !== r.glFramebuffer && (i.bindFramebuffer(i.FRAMEBUFFER, r.glFramebuffer), this.stateCache.glFramebuffer = r.glFramebuffer);
                        for (var u, h = new c(t), _ = te(n); !(u = _()).done;) {
                            var f = u.value,
                                d = f.texExtent.width,
                                p = f.texExtent.height;
                            i.readPixels(f.texOffset.x, f.texOffset.y, d, p, a, s, h)
                        }
                        this.stateCache.glFramebuffer !== l && (i.bindFramebuffer(i.FRAMEBUFFER, l), this.stateCache.glFramebuffer = l)
                    }, n.blitFramebuffer = function() {}, n.getExtension = function(e) {
                        for (var t = ["", "WEBKIT_", "MOZ_"], n = 0; n < t.length; ++n) {
                            var i = this.gl.getExtension(t[n] + e);
                            if (i) return i
                        }
                        return null
                    }, n.initStates = function(e) {
                        e.activeTexture(e.TEXTURE0), e.pixelStorei(e.PACK_ALIGNMENT, 1), e.pixelStorei(e.UNPACK_ALIGNMENT, 1), e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, !1), e.bindFramebuffer(e.FRAMEBUFFER, null), e.enable(e.SCISSOR_TEST), e.enable(e.CULL_FACE), e.cullFace(e.BACK), e.frontFace(e.CCW), e.disable(e.POLYGON_OFFSET_FILL), e.polygonOffset(0, 0), e.enable(e.DEPTH_TEST), e.depthMask(!0), e.depthFunc(e.LESS), e.depthRange(0, 1), e.stencilFuncSeparate(e.FRONT, e.ALWAYS, 1, 65535), e.stencilOpSeparate(e.FRONT, e.KEEP, e.KEEP, e.KEEP), e.stencilMaskSeparate(e.FRONT, 65535), e.stencilFuncSeparate(e.BACK, e.ALWAYS, 1, 65535), e.stencilOpSeparate(e.BACK, e.KEEP, e.KEEP, e.KEEP), e.stencilMaskSeparate(e.BACK, 65535), e.disable(e.STENCIL_TEST), e.disable(e.SAMPLE_ALPHA_TO_COVERAGE), e.disable(e.BLEND), e.blendEquationSeparate(e.FUNC_ADD, e.FUNC_ADD), e.blendFuncSeparate(e.ONE, e.ZERO, e.ONE, e.ZERO), e.colorMask(!0, !0, !0, !0), e.blendColor(0, 0, 0, 0)
                    }, n._onWebGLContextLost = function(e) {
                        x(11e3), d(e)
                    }, K(t, [{
                        key: "gl",
                        get: function() {
                            return this._webGLRC
                        }
                    }, {
                        key: "webGLQueue",
                        get: function() {
                            return this._queue
                        }
                    }, {
                        key: "isAntialias",
                        get: function() {
                            return this._isAntialias
                        }
                    }, {
                        key: "isPremultipliedAlpha",
                        get: function() {
                            return this._isPremultipliedAlpha
                        }
                    }, {
                        key: "useVAO",
                        get: function() {
                            return this._useVAO
                        }
                    }, {
                        key: "destroyShadersImmediately",
                        get: function() {
                            return this._destroyShadersImmediately
                        }
                    }, {
                        key: "noCompressedTexSubImage2D",
                        get: function() {
                            return this._noCompressedTexSubImage2D
                        }
                    }, {
                        key: "bindingMappingInfo",
                        get: function() {
                            return this._bindingMappingInfo
                        }
                    }, {
                        key: "EXT_texture_filter_anisotropic",
                        get: function() {
                            return this._EXT_texture_filter_anisotropic
                        }
                    }, {
                        key: "EXT_blend_minmax",
                        get: function() {
                            return this._EXT_blend_minmax
                        }
                    }, {
                        key: "EXT_frag_depth",
                        get: function() {
                            return this._EXT_frag_depth
                        }
                    }, {
                        key: "EXT_shader_texture_lod",
                        get: function() {
                            return this._EXT_shader_texture_lod
                        }
                    }, {
                        key: "EXT_sRGB",
                        get: function() {
                            return this._EXT_sRGB
                        }
                    }, {
                        key: "OES_vertex_array_object",
                        get: function() {
                            return this._OES_vertex_array_object
                        }
                    }, {
                        key: "WEBGL_color_buffer_float",
                        get: function() {
                            return this._WEBGL_color_buffer_float
                        }
                    }, {
                        key: "WEBGL_compressed_texture_etc1",
                        get: function() {
                            return this._WEBGL_compressed_texture_etc1
                        }
                    }, {
                        key: "WEBGL_compressed_texture_pvrtc",
                        get: function() {
                            return this._WEBGL_compressed_texture_pvrtc
                        }
                    }, {
                        key: "WEBGL_compressed_texture_astc",
                        get: function() {
                            return this._WEBGL_compressed_texture_astc
                        }
                    }, {
                        key: "WEBGL_compressed_texture_s3tc",
                        get: function() {
                            return this._WEBGL_compressed_texture_s3tc
                        }
                    }, {
                        key: "WEBGL_compressed_texture_s3tc_srgb",
                        get: function() {
                            return this._WEBGL_compressed_texture_s3tc_srgb
                        }
                    }, {
                        key: "WEBGL_debug_shaders",
                        get: function() {
                            return this._WEBGL_debug_shaders
                        }
                    }, {
                        key: "WEBGL_draw_buffers",
                        get: function() {
                            return this._WEBGL_draw_buffers
                        }
                    }, {
                        key: "WEBGL_lose_context",
                        get: function() {
                            return this._WEBGL_lose_context
                        }
                    }, {
                        key: "WEBGL_depth_texture",
                        get: function() {
                            return this._WEBGL_depth_texture
                        }
                    }, {
                        key: "WEBGL_debug_renderer_info",
                        get: function() {
                            return this._WEBGL_debug_renderer_info
                        }
                    }, {
                        key: "OES_texture_half_float",
                        get: function() {
                            return this._OES_texture_half_float
                        }
                    }, {
                        key: "OES_texture_half_float_linear",
                        get: function() {
                            return this._OES_texture_half_float_linear
                        }
                    }, {
                        key: "OES_texture_float",
                        get: function() {
                            return this._OES_texture_float
                        }
                    }, {
                        key: "OES_standard_derivatives",
                        get: function() {
                            return this._OES_standard_derivatives
                        }
                    }, {
                        key: "OES_element_index_uint",
                        get: function() {
                            return this._OES_element_index_uint
                        }
                    }, {
                        key: "ANGLE_instanced_arrays",
                        get: function() {
                            return this._ANGLE_instanced_arrays
                        }
                    }]), t
                }(dc));
            i.WebGLDevice = KF;
            var ZF = function(e) {
                    function t() {
                        for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                        return (t = e.call.apply(e, [this].concat(i)) || this)._gpuDescriptorSet = null, t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.initialize = function(e) {
                        this._layout = e.layout;
                        var t = e.layout.gpuDescriptorSetLayout,
                            n = t.bindings,
                            i = t.descriptorIndices,
                            r = t.descriptorCount;
                        this._buffers = Array(r).fill(null), this._textures = Array(r).fill(null), this._samplers = Array(r).fill(null);
                        var o = [];
                        this._gpuDescriptorSet = {
                            gpuDescriptors: o,
                            descriptorIndices: i
                        };
                        for (var a = 0; a < n.length; ++a)
                            for (var s = n[a], c = 0; c < s.count; c++) o.push({
                                type: s.descriptorType,
                                gpuBuffer: null,
                                gpuTexture: null,
                                gpuSampler: null
                            });
                        return !0
                    }, n.destroy = function() {
                        this._layout = null, this._gpuDescriptorSet = null
                    }, n.update = function() {
                        if (this._isDirty && this._gpuDescriptorSet) {
                            for (var e = this._gpuDescriptorSet.gpuDescriptors, t = 0; t < e.length; ++t) e[t].type & nc ? this._buffers[t] && (e[t].gpuBuffer = this._buffers[t].gpuBuffer) : e[t].type & ic && (this._textures[t] && (e[t].gpuTexture = this._textures[t].gpuTexture), this._samplers[t] && (e[t].gpuSampler = this._samplers[t].gpuSampler));
                            this._isDirty = !1
                        }
                    }, K(t, [{
                        key: "gpuDescriptorSet",
                        get: function() {
                            return this._gpuDescriptorSet
                        }
                    }]), t
                }(Sc),
                QF = [10497, 33648, 33071, 33071],
                JF = [1, 2, 4, 8, 16, 32, 64],
                $F = new Float32Array(4);

            function ez(e, t) {
                switch (e) {
                    case Ea.R8:
                        return t.UNSIGNED_BYTE;
                    case Ea.R8SN:
                        return t.BYTE;
                    case Ea.R8UI:
                        return t.UNSIGNED_BYTE;
                    case Ea.R8I:
                        return t.BYTE;
                    case Ea.R16F:
                        return t.HALF_FLOAT;
                    case Ea.R16UI:
                        return t.UNSIGNED_SHORT;
                    case Ea.R16I:
                        return t.SHORT;
                    case Ea.R32F:
                        return t.FLOAT;
                    case Ea.R32UI:
                        return t.UNSIGNED_INT;
                    case Ea.R32I:
                        return t.INT;
                    case Ea.RG8:
                        return t.UNSIGNED_BYTE;
                    case Ea.RG8SN:
                        return t.BYTE;
                    case Ea.RG8UI:
                        return t.UNSIGNED_BYTE;
                    case Ea.RG8I:
                        return t.BYTE;
                    case Ea.RG16F:
                        return t.HALF_FLOAT;
                    case Ea.RG16UI:
                        return t.UNSIGNED_SHORT;
                    case Ea.RG16I:
                        return t.SHORT;
                    case Ea.RG32F:
                        return t.FLOAT;
                    case Ea.RG32UI:
                        return t.UNSIGNED_INT;
                    case Ea.RG32I:
                        return t.INT;
                    case Ea.RGB8:
                    case Ea.SRGB8:
                        return t.UNSIGNED_BYTE;
                    case Ea.RGB8SN:
                        return t.BYTE;
                    case Ea.RGB8UI:
                        return t.UNSIGNED_BYTE;
                    case Ea.RGB8I:
                        return t.BYTE;
                    case Ea.RGB16F:
                        return t.HALF_FLOAT;
                    case Ea.RGB16UI:
                        return t.UNSIGNED_SHORT;
                    case Ea.RGB16I:
                        return t.SHORT;
                    case Ea.RGB32F:
                        return t.FLOAT;
                    case Ea.RGB32UI:
                        return t.UNSIGNED_INT;
                    case Ea.RGB32I:
                        return t.INT;
                    case Ea.BGRA8:
                    case Ea.RGBA8:
                    case Ea.SRGB8_A8:
                        return t.UNSIGNED_BYTE;
                    case Ea.RGBA8SN:
                        return t.BYTE;
                    case Ea.RGBA8UI:
                        return t.UNSIGNED_BYTE;
                    case Ea.RGBA8I:
                        return t.BYTE;
                    case Ea.RGBA16F:
                        return t.HALF_FLOAT;
                    case Ea.RGBA16UI:
                        return t.UNSIGNED_SHORT;
                    case Ea.RGBA16I:
                        return t.SHORT;
                    case Ea.RGBA32F:
                        return t.FLOAT;
                    case Ea.RGBA32UI:
                        return t.UNSIGNED_INT;
                    case Ea.RGBA32I:
                        return t.INT;
                    case Ea.R5G6B5:
                        return t.UNSIGNED_SHORT_5_6_5;
                    case Ea.R11G11B10F:
                        return t.UNSIGNED_INT_10F_11F_11F_REV;
                    case Ea.RGB5A1:
                        return t.UNSIGNED_SHORT_5_5_5_1;
                    case Ea.RGBA4:
                        return t.UNSIGNED_SHORT_4_4_4_4;
                    case Ea.RGB10A2:
                    case Ea.RGB10A2UI:
                        return t.UNSIGNED_INT_2_10_10_10_REV;
                    case Ea.RGB9E5:
                        return t.FLOAT;
                    case Ea.D16:
                        return t.UNSIGNED_SHORT;
                    case Ea.D16S8:
                        return t.UNSIGNED_INT_24_8;
                    case Ea.D24:
                        return t.UNSIGNED_INT;
                    case Ea.D24S8:
                        return t.UNSIGNED_INT_24_8;
                    case Ea.D32F:
                        return t.FLOAT;
                    case Ea.D32F_S8:
                        return t.FLOAT_32_UNSIGNED_INT_24_8_REV;
                    case Ea.BC1:
                    case Ea.BC1_SRGB:
                    case Ea.BC2:
                    case Ea.BC2_SRGB:
                    case Ea.BC3:
                    case Ea.BC3_SRGB:
                    case Ea.BC4:
                        return t.UNSIGNED_BYTE;
                    case Ea.BC4_SNORM:
                        return t.BYTE;
                    case Ea.BC5:
                        return t.UNSIGNED_BYTE;
                    case Ea.BC5_SNORM:
                        return t.BYTE;
                    case Ea.BC6H_SF16:
                    case Ea.BC6H_UF16:
                        return t.FLOAT;
                    case Ea.BC7:
                    case Ea.BC7_SRGB:
                    case Ea.ETC_RGB8:
                    case Ea.ETC2_RGB8:
                    case Ea.ETC2_SRGB8:
                    case Ea.ETC2_RGB8_A1:
                    case Ea.ETC2_SRGB8_A1:
                    case Ea.EAC_R11:
                        return t.UNSIGNED_BYTE;
                    case Ea.EAC_R11SN:
                        return t.BYTE;
                    case Ea.EAC_RG11:
                        return t.UNSIGNED_BYTE;
                    case Ea.EAC_RG11SN:
                        return t.BYTE;
                    case Ea.PVRTC_RGB2:
                    case Ea.PVRTC_RGBA2:
                    case Ea.PVRTC_RGB4:
                    case Ea.PVRTC_RGBA4:
                    case Ea.PVRTC2_2BPP:
                    case Ea.PVRTC2_4BPP:
                        return t.UNSIGNED_BYTE;
                    case Ea.ASTC_RGBA_4x4:
                    case Ea.ASTC_RGBA_5x4:
                    case Ea.ASTC_RGBA_5x5:
                    case Ea.ASTC_RGBA_6x5:
                    case Ea.ASTC_RGBA_6x6:
                    case Ea.ASTC_RGBA_8x5:
                    case Ea.ASTC_RGBA_8x6:
                    case Ea.ASTC_RGBA_8x8:
                    case Ea.ASTC_RGBA_10x5:
                    case Ea.ASTC_RGBA_10x6:
                    case Ea.ASTC_RGBA_10x8:
                    case Ea.ASTC_RGBA_10x10:
                    case Ea.ASTC_RGBA_12x10:
                    case Ea.ASTC_RGBA_12x12:
                    case Ea.ASTC_SRGBA_4x4:
                    case Ea.ASTC_SRGBA_5x4:
                    case Ea.ASTC_SRGBA_5x5:
                    case Ea.ASTC_SRGBA_6x5:
                    case Ea.ASTC_SRGBA_6x6:
                    case Ea.ASTC_SRGBA_8x5:
                    case Ea.ASTC_SRGBA_8x6:
                    case Ea.ASTC_SRGBA_8x8:
                    case Ea.ASTC_SRGBA_10x5:
                    case Ea.ASTC_SRGBA_10x6:
                    case Ea.ASTC_SRGBA_10x8:
                    case Ea.ASTC_SRGBA_10x10:
                    case Ea.ASTC_SRGBA_12x10:
                    case Ea.ASTC_SRGBA_12x12:
                    default:
                        return t.UNSIGNED_BYTE
                }
            }

            function tz(e, t) {
                switch (e) {
                    case Ea.A8:
                        return t.ALPHA;
                    case Ea.L8:
                        return t.LUMINANCE;
                    case Ea.LA8:
                        return t.LUMINANCE_ALPHA;
                    case Ea.R8:
                        return t.R8;
                    case Ea.R8SN:
                        return t.R8_SNORM;
                    case Ea.R8UI:
                        return t.R8UI;
                    case Ea.R8I:
                        return t.R8I;
                    case Ea.RG8:
                        return t.RG8;
                    case Ea.RG8SN:
                        return t.RG8_SNORM;
                    case Ea.RG8UI:
                        return t.RG8UI;
                    case Ea.RG8I:
                        return t.RG8I;
                    case Ea.RGB8:
                        return t.RGB8;
                    case Ea.RGB8SN:
                        return t.RGB8_SNORM;
                    case Ea.RGB8UI:
                        return t.RGB8UI;
                    case Ea.RGB8I:
                        return t.RGB8I;
                    case Ea.BGRA8:
                    case Ea.RGBA8:
                        return t.RGBA8;
                    case Ea.RGBA8SN:
                        return t.RGBA8_SNORM;
                    case Ea.RGBA8UI:
                        return t.RGBA8UI;
                    case Ea.RGBA8I:
                        return t.RGBA8I;
                    case Ea.R16I:
                        return t.R16I;
                    case Ea.R16UI:
                        return t.R16UI;
                    case Ea.R16F:
                        return t.R16F;
                    case Ea.RG16I:
                        return t.RG16I;
                    case Ea.RG16UI:
                        return t.RG16UI;
                    case Ea.RG16F:
                        return t.RG16F;
                    case Ea.RGB16I:
                        return t.RGB16I;
                    case Ea.RGB16UI:
                        return t.RGB16UI;
                    case Ea.RGB16F:
                        return t.RGB16F;
                    case Ea.RGBA16I:
                        return t.RGBA16I;
                    case Ea.RGBA16UI:
                        return t.RGBA16UI;
                    case Ea.RGBA16F:
                        return t.RGBA16F;
                    case Ea.R32I:
                        return t.R32I;
                    case Ea.R32UI:
                        return t.R32UI;
                    case Ea.R32F:
                        return t.R32F;
                    case Ea.RG32I:
                        return t.RG32I;
                    case Ea.RG32UI:
                        return t.RG32UI;
                    case Ea.RG32F:
                        return t.RG32F;
                    case Ea.RGB32I:
                        return t.RGB32I;
                    case Ea.RGB32UI:
                        return t.RGB32UI;
                    case Ea.RGB32F:
                        return t.RGB32F;
                    case Ea.RGBA32I:
                        return t.RGBA32I;
                    case Ea.RGBA32UI:
                        return t.RGBA32UI;
                    case Ea.RGBA32F:
                        return t.RGBA32F;
                    case Ea.R5G6B5:
                        return t.RGB565;
                    case Ea.RGB5A1:
                        return t.RGB5_A1;
                    case Ea.RGBA4:
                        return t.RGBA4;
                    case Ea.RGB10A2:
                        return t.RGB10_A2;
                    case Ea.RGB10A2UI:
                        return t.RGB10_A2UI;
                    case Ea.R11G11B10F:
                        return t.R11F_G11F_B10F;
                    case Ea.D16:
                        return t.DEPTH_COMPONENT16;
                    case Ea.D16S8:
                        return t.DEPTH24_STENCIL8;
                    case Ea.D24:
                        return t.DEPTH_COMPONENT24;
                    case Ea.D24S8:
                        return t.DEPTH24_STENCIL8;
                    case Ea.D32F:
                        return t.DEPTH_COMPONENT32F;
                    case Ea.D32F_S8:
                        return t.DEPTH32F_STENCIL8;
                    case Ea.BC1:
                        return $B.COMPRESSED_RGB_S3TC_DXT1_EXT;
                    case Ea.BC1_ALPHA:
                        return $B.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                    case Ea.BC1_SRGB:
                        return $B.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                    case Ea.BC1_SRGB_ALPHA:
                        return $B.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                    case Ea.BC2:
                        return $B.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                    case Ea.BC2_SRGB:
                        return $B.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                    case Ea.BC3:
                        return $B.COMPRESSED_RGBA_S3TC_DXT5_EXT;
                    case Ea.BC3_SRGB:
                        return $B.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
                    case Ea.ETC_RGB8:
                        return $B.COMPRESSED_RGB_ETC1_WEBGL;
                    case Ea.ETC2_RGB8:
                        return $B.COMPRESSED_RGB8_ETC2;
                    case Ea.ETC2_SRGB8:
                        return $B.COMPRESSED_SRGB8_ETC2;
                    case Ea.ETC2_RGB8_A1:
                        return $B.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2;
                    case Ea.ETC2_SRGB8_A1:
                        return $B.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2;
                    case Ea.ETC2_RGBA8:
                        return $B.COMPRESSED_RGBA8_ETC2_EAC;
                    case Ea.ETC2_SRGB8_A8:
                        return $B.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC;
                    case Ea.EAC_R11:
                        return $B.COMPRESSED_R11_EAC;
                    case Ea.EAC_R11SN:
                        return $B.COMPRESSED_SIGNED_R11_EAC;
                    case Ea.EAC_RG11:
                        return $B.COMPRESSED_RG11_EAC;
                    case Ea.EAC_RG11SN:
                        return $B.COMPRESSED_SIGNED_RG11_EAC;
                    case Ea.PVRTC_RGB2:
                        return $B.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                    case Ea.PVRTC_RGBA2:
                        return $B.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
                    case Ea.PVRTC_RGB4:
                        return $B.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                    case Ea.PVRTC_RGBA4:
                        return $B.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                    case Ea.ASTC_RGBA_4x4:
                        return $B.COMPRESSED_RGBA_ASTC_4x4_KHR;
                    case Ea.ASTC_RGBA_5x4:
                        return $B.COMPRESSED_RGBA_ASTC_5x4_KHR;
                    case Ea.ASTC_RGBA_5x5:
                        return $B.COMPRESSED_RGBA_ASTC_5x5_KHR;
                    case Ea.ASTC_RGBA_6x5:
                        return $B.COMPRESSED_RGBA_ASTC_6x5_KHR;
                    case Ea.ASTC_RGBA_6x6:
                        return $B.COMPRESSED_RGBA_ASTC_6x6_KHR;
                    case Ea.ASTC_RGBA_8x5:
                        return $B.COMPRESSED_RGBA_ASTC_8x5_KHR;
                    case Ea.ASTC_RGBA_8x6:
                        return $B.COMPRESSED_RGBA_ASTC_8x6_KHR;
                    case Ea.ASTC_RGBA_8x8:
                        return $B.COMPRESSED_RGBA_ASTC_8x8_KHR;
                    case Ea.ASTC_RGBA_10x5:
                        return $B.COMPRESSED_RGBA_ASTC_10x5_KHR;
                    case Ea.ASTC_RGBA_10x6:
                        return $B.COMPRESSED_RGBA_ASTC_10x6_KHR;
                    case Ea.ASTC_RGBA_10x8:
                        return $B.COMPRESSED_RGBA_ASTC_10x8_KHR;
                    case Ea.ASTC_RGBA_10x10:
                        return $B.COMPRESSED_RGBA_ASTC_10x10_KHR;
                    case Ea.ASTC_RGBA_12x10:
                        return $B.COMPRESSED_RGBA_ASTC_12x10_KHR;
                    case Ea.ASTC_RGBA_12x12:
                        return $B.COMPRESSED_RGBA_ASTC_12x12_KHR;
                    case Ea.ASTC_SRGBA_4x4:
                        return $B.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR;
                    case Ea.ASTC_SRGBA_5x4:
                        return $B.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR;
                    case Ea.ASTC_SRGBA_5x5:
                        return $B.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR;
                    case Ea.ASTC_SRGBA_6x5:
                        return $B.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR;
                    case Ea.ASTC_SRGBA_6x6:
                        return $B.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR;
                    case Ea.ASTC_SRGBA_8x5:
                        return $B.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR;
                    case Ea.ASTC_SRGBA_8x6:
                        return $B.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR;
                    case Ea.ASTC_SRGBA_8x8:
                        return $B.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR;
                    case Ea.ASTC_SRGBA_10x5:
                        return $B.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR;
                    case Ea.ASTC_SRGBA_10x6:
                        return $B.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR;
                    case Ea.ASTC_SRGBA_10x8:
                        return $B.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR;
                    case Ea.ASTC_SRGBA_10x10:
                        return $B.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR;
                    case Ea.ASTC_SRGBA_12x10:
                        return $B.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR;
                    case Ea.ASTC_SRGBA_12x12:
                        return $B.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR;
                    default:
                        return console.error("Unsupported Format, convert to WebGL internal format failed."), t.RGBA
                }
            }

            function nz(e, t) {
                switch (e) {
                    case Ea.A8:
                        return t.ALPHA;
                    case Ea.L8:
                        return t.LUMINANCE;
                    case Ea.LA8:
                        return t.LUMINANCE_ALPHA;
                    case Ea.R8:
                    case Ea.R8SN:
                        return t.RED;
                    case Ea.R8UI:
                    case Ea.R8I:
                        return t.RED;
                    case Ea.RG8:
                    case Ea.RG8SN:
                    case Ea.RG8UI:
                    case Ea.RG8I:
                        return t.RG;
                    case Ea.RGB8:
                    case Ea.RGB8SN:
                    case Ea.RGB8UI:
                    case Ea.RGB8I:
                        return t.RGB;
                    case Ea.BGRA8:
                    case Ea.RGBA8:
                    case Ea.RGBA8SN:
                    case Ea.RGBA8UI:
                    case Ea.RGBA8I:
                        return t.RGBA;
                    case Ea.R16UI:
                    case Ea.R16I:
                    case Ea.R16F:
                        return t.RED;
                    case Ea.RG16UI:
                    case Ea.RG16I:
                    case Ea.RG16F:
                        return t.RG;
                    case Ea.RGB16UI:
                    case Ea.RGB16I:
                    case Ea.RGB16F:
                        return t.RGB;
                    case Ea.RGBA16UI:
                    case Ea.RGBA16I:
                    case Ea.RGBA16F:
                        return t.RGBA;
                    case Ea.R32UI:
                    case Ea.R32I:
                    case Ea.R32F:
                        return t.RED;
                    case Ea.RG32UI:
                    case Ea.RG32I:
                    case Ea.RG32F:
                        return t.RG;
                    case Ea.RGB32UI:
                    case Ea.RGB32I:
                    case Ea.RGB32F:
                        return t.RGB;
                    case Ea.RGBA32UI:
                    case Ea.RGBA32I:
                    case Ea.RGBA32F:
                    case Ea.RGB10A2:
                        return t.RGBA;
                    case Ea.R11G11B10F:
                    case Ea.R5G6B5:
                        return t.RGB;
                    case Ea.RGB5A1:
                    case Ea.RGBA4:
                        return t.RGBA;
                    case Ea.D16:
                        return t.DEPTH_COMPONENT;
                    case Ea.D16S8:
                        return t.DEPTH_STENCIL;
                    case Ea.D24:
                        return t.DEPTH_COMPONENT;
                    case Ea.D24S8:
                        return t.DEPTH_STENCIL;
                    case Ea.D32F:
                        return t.DEPTH_COMPONENT;
                    case Ea.D32F_S8:
                        return t.DEPTH_STENCIL;
                    case Ea.BC1:
                        return $B.COMPRESSED_RGB_S3TC_DXT1_EXT;
                    case Ea.BC1_ALPHA:
                        return $B.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                    case Ea.BC1_SRGB:
                        return $B.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                    case Ea.BC1_SRGB_ALPHA:
                        return $B.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                    case Ea.BC2:
                        return $B.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                    case Ea.BC2_SRGB:
                        return $B.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                    case Ea.BC3:
                        return $B.COMPRESSED_RGBA_S3TC_DXT5_EXT;
                    case Ea.BC3_SRGB:
                        return $B.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
                    case Ea.ETC_RGB8:
                        return $B.COMPRESSED_RGB_ETC1_WEBGL;
                    case Ea.ETC2_RGB8:
                        return $B.COMPRESSED_RGB8_ETC2;
                    case Ea.ETC2_SRGB8:
                        return $B.COMPRESSED_SRGB8_ETC2;
                    case Ea.ETC2_RGB8_A1:
                        return $B.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2;
                    case Ea.ETC2_SRGB8_A1:
                        return $B.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2;
                    case Ea.ETC2_RGBA8:
                        return $B.COMPRESSED_RGBA8_ETC2_EAC;
                    case Ea.ETC2_SRGB8_A8:
                        return $B.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC;
                    case Ea.EAC_R11:
                        return $B.COMPRESSED_R11_EAC;
                    case Ea.EAC_R11SN:
                        return $B.COMPRESSED_SIGNED_R11_EAC;
                    case Ea.EAC_RG11:
                        return $B.COMPRESSED_RG11_EAC;
                    case Ea.EAC_RG11SN:
                        return $B.COMPRESSED_SIGNED_RG11_EAC;
                    case Ea.PVRTC_RGB2:
                        return $B.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                    case Ea.PVRTC_RGBA2:
                        return $B.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
                    case Ea.PVRTC_RGB4:
                        return $B.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                    case Ea.PVRTC_RGBA4:
                        return $B.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                    case Ea.ASTC_RGBA_4x4:
                        return $B.COMPRESSED_RGBA_ASTC_4x4_KHR;
                    case Ea.ASTC_RGBA_5x4:
                        return $B.COMPRESSED_RGBA_ASTC_5x4_KHR;
                    case Ea.ASTC_RGBA_5x5:
                        return $B.COMPRESSED_RGBA_ASTC_5x5_KHR;
                    case Ea.ASTC_RGBA_6x5:
                        return $B.COMPRESSED_RGBA_ASTC_6x5_KHR;
                    case Ea.ASTC_RGBA_6x6:
                        return $B.COMPRESSED_RGBA_ASTC_6x6_KHR;
                    case Ea.ASTC_RGBA_8x5:
                        return $B.COMPRESSED_RGBA_ASTC_8x5_KHR;
                    case Ea.ASTC_RGBA_8x6:
                        return $B.COMPRESSED_RGBA_ASTC_8x6_KHR;
                    case Ea.ASTC_RGBA_8x8:
                        return $B.COMPRESSED_RGBA_ASTC_8x8_KHR;
                    case Ea.ASTC_RGBA_10x5:
                        return $B.COMPRESSED_RGBA_ASTC_10x5_KHR;
                    case Ea.ASTC_RGBA_10x6:
                        return $B.COMPRESSED_RGBA_ASTC_10x6_KHR;
                    case Ea.ASTC_RGBA_10x8:
                        return $B.COMPRESSED_RGBA_ASTC_10x8_KHR;
                    case Ea.ASTC_RGBA_10x10:
                        return $B.COMPRESSED_RGBA_ASTC_10x10_KHR;
                    case Ea.ASTC_RGBA_12x10:
                        return $B.COMPRESSED_RGBA_ASTC_12x10_KHR;
                    case Ea.ASTC_RGBA_12x12:
                        return $B.COMPRESSED_RGBA_ASTC_12x12_KHR;
                    case Ea.ASTC_SRGBA_4x4:
                        return $B.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR;
                    case Ea.ASTC_SRGBA_5x4:
                        return $B.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR;
                    case Ea.ASTC_SRGBA_5x5:
                        return $B.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR;
                    case Ea.ASTC_SRGBA_6x5:
                        return $B.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR;
                    case Ea.ASTC_SRGBA_6x6:
                        return $B.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR;
                    case Ea.ASTC_SRGBA_8x5:
                        return $B.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR;
                    case Ea.ASTC_SRGBA_8x6:
                        return $B.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR;
                    case Ea.ASTC_SRGBA_8x8:
                        return $B.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR;
                    case Ea.ASTC_SRGBA_10x5:
                        return $B.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR;
                    case Ea.ASTC_SRGBA_10x6:
                        return $B.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR;
                    case Ea.ASTC_SRGBA_10x8:
                        return $B.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR;
                    case Ea.ASTC_SRGBA_10x10:
                        return $B.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR;
                    case Ea.ASTC_SRGBA_12x10:
                        return $B.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR;
                    case Ea.ASTC_SRGBA_12x12:
                        return $B.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR;
                    default:
                        return console.error("Unsupported Format, convert to WebGL format failed."), t.RGBA
                }
            }

            function iz(e, t) {
                switch (e) {
                    case Aa.BOOL:
                        return t.BOOL;
                    case Aa.BOOL2:
                        return t.BOOL_VEC2;
                    case Aa.BOOL3:
                        return t.BOOL_VEC3;
                    case Aa.BOOL4:
                        return t.BOOL_VEC4;
                    case Aa.INT:
                        return t.INT;
                    case Aa.INT2:
                        return t.INT_VEC2;
                    case Aa.INT3:
                        return t.INT_VEC3;
                    case Aa.INT4:
                        return t.INT_VEC4;
                    case Aa.UINT:
                        return t.UNSIGNED_INT;
                    case Aa.FLOAT:
                        return t.FLOAT;
                    case Aa.FLOAT2:
                        return t.FLOAT_VEC2;
                    case Aa.FLOAT3:
                        return t.FLOAT_VEC3;
                    case Aa.FLOAT4:
                        return t.FLOAT_VEC4;
                    case Aa.MAT2:
                        return t.FLOAT_MAT2;
                    case Aa.MAT2X3:
                        return t.FLOAT_MAT2x3;
                    case Aa.MAT2X4:
                        return t.FLOAT_MAT2x4;
                    case Aa.MAT3X2:
                        return t.FLOAT_MAT3x2;
                    case Aa.MAT3:
                        return t.FLOAT_MAT3;
                    case Aa.MAT3X4:
                        return t.FLOAT_MAT3x4;
                    case Aa.MAT4X2:
                        return t.FLOAT_MAT4x2;
                    case Aa.MAT4X3:
                        return t.FLOAT_MAT4x3;
                    case Aa.MAT4:
                        return t.FLOAT_MAT4;
                    case Aa.SAMPLER2D:
                        return t.SAMPLER_2D;
                    case Aa.SAMPLER2D_ARRAY:
                        return t.SAMPLER_2D_ARRAY;
                    case Aa.SAMPLER3D:
                        return t.SAMPLER_3D;
                    case Aa.SAMPLER_CUBE:
                        return t.SAMPLER_CUBE;
                    default:
                        return console.error("Unsupported GLType, convert to GL type failed."), Aa.UNKNOWN
                }
            }

            function rz(e, t) {
                switch (e) {
                    case t.BOOL:
                        return Aa.BOOL;
                    case t.BOOL_VEC2:
                        return Aa.BOOL2;
                    case t.BOOL_VEC3:
                        return Aa.BOOL3;
                    case t.BOOL_VEC4:
                        return Aa.BOOL4;
                    case t.INT:
                        return Aa.INT;
                    case t.INT_VEC2:
                        return Aa.INT2;
                    case t.INT_VEC3:
                        return Aa.INT3;
                    case t.INT_VEC4:
                        return Aa.INT4;
                    case t.UNSIGNED_INT:
                        return Aa.UINT;
                    case t.UNSIGNED_INT_VEC2:
                        return Aa.UINT2;
                    case t.UNSIGNED_INT_VEC3:
                        return Aa.UINT3;
                    case t.UNSIGNED_INT_VEC4:
                        return Aa.UINT4;
                    case t.FLOAT:
                        return Aa.FLOAT;
                    case t.FLOAT_VEC2:
                        return Aa.FLOAT2;
                    case t.FLOAT_VEC3:
                        return Aa.FLOAT3;
                    case t.FLOAT_VEC4:
                        return Aa.FLOAT4;
                    case t.FLOAT_MAT2:
                        return Aa.MAT2;
                    case t.FLOAT_MAT2x3:
                        return Aa.MAT2X3;
                    case t.FLOAT_MAT2x4:
                        return Aa.MAT2X4;
                    case t.FLOAT_MAT3x2:
                        return Aa.MAT3X2;
                    case t.FLOAT_MAT3:
                        return Aa.MAT3;
                    case t.FLOAT_MAT3x4:
                        return Aa.MAT3X4;
                    case t.FLOAT_MAT4x2:
                        return Aa.MAT4X2;
                    case t.FLOAT_MAT4x3:
                        return Aa.MAT4X3;
                    case t.FLOAT_MAT4:
                        return Aa.MAT4;
                    case t.SAMPLER_2D:
                        return Aa.SAMPLER2D;
                    case t.SAMPLER_2D_ARRAY:
                        return Aa.SAMPLER2D_ARRAY;
                    case t.SAMPLER_3D:
                        return Aa.SAMPLER3D;
                    case t.SAMPLER_CUBE:
                        return Aa.SAMPLER_CUBE;
                    default:
                        return console.error("Unsupported GLType, convert to Type failed."), Aa.UNKNOWN
                }
            }

            function oz(e, t) {
                switch (e) {
                    case t.BOOL:
                        return 4;
                    case t.BOOL_VEC2:
                        return 8;
                    case t.BOOL_VEC3:
                        return 12;
                    case t.BOOL_VEC4:
                        return 16;
                    case t.INT:
                        return 4;
                    case t.INT_VEC2:
                        return 8;
                    case t.INT_VEC3:
                        return 12;
                    case t.INT_VEC4:
                        return 16;
                    case t.UNSIGNED_INT:
                        return 4;
                    case t.UNSIGNED_INT_VEC2:
                        return 8;
                    case t.UNSIGNED_INT_VEC3:
                        return 12;
                    case t.UNSIGNED_INT_VEC4:
                        return 16;
                    case t.FLOAT:
                        return 4;
                    case t.FLOAT_VEC2:
                        return 8;
                    case t.FLOAT_VEC3:
                        return 12;
                    case t.FLOAT_VEC4:
                    case t.FLOAT_MAT2:
                        return 16;
                    case t.FLOAT_MAT2x3:
                        return 24;
                    case t.FLOAT_MAT2x4:
                        return 32;
                    case t.FLOAT_MAT3x2:
                        return 24;
                    case t.FLOAT_MAT3:
                        return 36;
                    case t.FLOAT_MAT3x4:
                        return 48;
                    case t.FLOAT_MAT4x2:
                        return 32;
                    case t.FLOAT_MAT4x3:
                        return 48;
                    case t.FLOAT_MAT4:
                        return 64;
                    case t.SAMPLER_2D:
                    case t.SAMPLER_2D_ARRAY:
                    case t.SAMPLER_2D_ARRAY_SHADOW:
                    case t.SAMPLER_3D:
                    case t.SAMPLER_CUBE:
                    case t.INT_SAMPLER_2D:
                    case t.INT_SAMPLER_2D_ARRAY:
                    case t.INT_SAMPLER_3D:
                    case t.INT_SAMPLER_CUBE:
                    case t.UNSIGNED_INT_SAMPLER_2D:
                    case t.UNSIGNED_INT_SAMPLER_2D_ARRAY:
                    case t.UNSIGNED_INT_SAMPLER_3D:
                    case t.UNSIGNED_INT_SAMPLER_CUBE:
                        return 4;
                    default:
                        return console.error("Unsupported GLType, get type failed."), 0
                }
            }

            function az(e, t) {
                switch (e) {
                    case t.FLOAT_MAT2:
                    case t.FLOAT_MAT2x3:
                    case t.FLOAT_MAT2x4:
                        return 2;
                    case t.FLOAT_MAT3x2:
                    case t.FLOAT_MAT3:
                    case t.FLOAT_MAT3x4:
                        return 3;
                    case t.FLOAT_MAT4x2:
                    case t.FLOAT_MAT4x3:
                    case t.FLOAT_MAT4:
                        return 4;
                    default:
                        return 1
                }
            }
            var sz, cz = [512, 513, 514, 515, 516, 517, 518, 519],
                lz = [0, 7680, 7681, 7682, 7683, 5386, 34055, 34056],
                uz = [32774, 32778, 32779, 32775, 32776],
                hz = [0, 1, 770, 772, 771, 773, 768, 774, 769, 775, 776, 32769, 32770, 32771, 32772];
            ! function(e) {
                e[e.BEGIN_RENDER_PASS = 0] = "BEGIN_RENDER_PASS", e[e.END_RENDER_PASS = 1] = "END_RENDER_PASS", e[e.BIND_STATES = 2] = "BIND_STATES", e[e.DRAW = 3] = "DRAW", e[e.UPDATE_BUFFER = 4] = "UPDATE_BUFFER", e[e.COPY_BUFFER_TO_TEXTURE = 5] = "COPY_BUFFER_TO_TEXTURE", e[e.COUNT = 6] = "COUNT"
            }(sz || (sz = {}));
            var _z = function(e) {
                    this.cmdType = void 0, this.refCount = 0, this.cmdType = e
                },
                fz = function(e) {
                    function t() {
                        var t;
                        return (t = e.call(this, sz.BEGIN_RENDER_PASS) || this).gpuRenderPass = null, t.gpuFramebuffer = null, t.renderArea = new ss, t.clearColors = [], t.clearDepth = 1, t.clearStencil = 0, t
                    }
                    return Q(t, e), t.prototype.clear = function() {
                        this.gpuFramebuffer = null, this.clearColors.length = 0
                    }, t
                }(_z),
                dz = function(e) {
                    function t() {
                        var t;
                        return (t = e.call(this, sz.BIND_STATES) || this).gpuPipelineState = null, t.gpuInputAssembler = null, t.gpuDescriptorSets = [], t.dynamicOffsets = [], t.viewport = null, t.scissor = null, t.lineWidth = null, t.depthBias = null, t.blendConstants = [], t.depthBounds = null, t.stencilWriteMask = null, t.stencilCompareMask = null, t
                    }
                    return Q(t, e), t.prototype.clear = function() {
                        this.gpuPipelineState = null, this.gpuInputAssembler = null, this.gpuDescriptorSets.length = 0, this.dynamicOffsets.length = 0, this.viewport = null, this.scissor = null, this.lineWidth = null, this.depthBias = null, this.blendConstants.length = 0, this.depthBounds = null, this.stencilWriteMask = null, this.stencilCompareMask = null
                    }, t
                }(_z),
                pz = function(e) {
                    function t() {
                        var t;
                        return (t = e.call(this, sz.DRAW) || this).drawInfo = new ys, t
                    }
                    return Q(t, e), t.prototype.clear = function() {}, t
                }(_z),
                mz = function(e) {
                    function t() {
                        var t;
                        return (t = e.call(this, sz.UPDATE_BUFFER) || this).gpuBuffer = null, t.buffer = null, t.offset = 0, t.size = 0, t
                    }
                    return Q(t, e), t.prototype.clear = function() {
                        this.gpuBuffer = null, this.buffer = null
                    }, t
                }(_z),
                gz = function(e) {
                    function t() {
                        var t;
                        return (t = e.call(this, sz.COPY_BUFFER_TO_TEXTURE) || this).gpuTexture = null, t.buffers = [], t.regions = [], t
                    }
                    return Q(t, e), t.prototype.clear = function() {
                        this.gpuTexture = null, this.buffers.length = 0, this.regions.length = 0
                    }, t
                }(_z),
                vz = function() {
                    function e() {
                        this.cmds = new ei(1), this.beginRenderPassCmds = new ei(1), this.bindStatesCmds = new ei(1), this.drawCmds = new ei(1), this.updateBufferCmds = new ei(1), this.copyBufferToTextureCmds = new ei(1)
                    }
                    return e.prototype.clearCmds = function(e) {
                        this.beginRenderPassCmds.length && (e.beginRenderPassCmdPool.freeCmds(this.beginRenderPassCmds), this.beginRenderPassCmds.clear()), this.bindStatesCmds.length && (e.bindStatesCmdPool.freeCmds(this.bindStatesCmds), this.bindStatesCmds.clear()), this.drawCmds.length && (e.drawCmdPool.freeCmds(this.drawCmds), this.drawCmds.clear()), this.updateBufferCmds.length && (e.updateBufferCmdPool.freeCmds(this.updateBufferCmds), this.updateBufferCmds.clear()), this.copyBufferToTextureCmds.length && (e.copyBufferToTextureCmdPool.freeCmds(this.copyBufferToTextureCmds), this.copyBufferToTextureCmds.clear()), this.cmds.clear()
                    }, e
                }();

            function yz(e, t, n, i, r) {
                if (t.usage & xa.INDIRECT) t.indirects.length = i, Array.prototype.push.apply(t.indirects, n.drawInfos);
                else {
                    var o = n,
                        a = e.gl,
                        s = e.stateCache;
                    switch (t.glTarget) {
                        case a.ARRAY_BUFFER:
                            s.glVAO && (a.bindVertexArray(null), s.glVAO = Sz.gpuInputAssembler = null), s.glArrayBuffer !== t.glBuffer && (a.bindBuffer(a.ARRAY_BUFFER, t.glBuffer), s.glArrayBuffer = t.glBuffer), r === o.byteLength ? a.bufferSubData(t.glTarget, i, o) : a.bufferSubData(t.glTarget, i, o.slice(0, r));
                            break;
                        case a.ELEMENT_ARRAY_BUFFER:
                            s.glVAO && (a.bindVertexArray(null), s.glVAO = Sz.gpuInputAssembler = null), s.glElementArrayBuffer !== t.glBuffer && (a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, t.glBuffer), s.glElementArrayBuffer = t.glBuffer), r === o.byteLength ? a.bufferSubData(t.glTarget, i, o) : a.bufferSubData(t.glTarget, i, o.slice(0, r));
                            break;
                        case a.UNIFORM_BUFFER:
                            s.glUniformBuffer !== t.glBuffer && (a.bindBuffer(a.UNIFORM_BUFFER, t.glBuffer), s.glUniformBuffer = t.glBuffer), r === o.byteLength ? a.bufferSubData(t.glTarget, i, o) : a.bufferSubData(t.glTarget, i, new Float32Array(o, 0, r / 4));
                            break;
                        default:
                            console.error("Unsupported BufferType, update buffer failed.")
                    }
                }
            }
            var Sz = {
                gpuPipelineState: null,
                gpuInputAssembler: null,
                glPrimitive: 0,
                invalidateAttachments: []
            };

            function Ez(e, t, n, i, r, o, a) {
                var s = e.gl,
                    c = e.stateCache,
                    l = 0;
                if (n && t) {
                    c.glFramebuffer !== n.glFramebuffer && (s.bindFramebuffer(s.FRAMEBUFFER, n.glFramebuffer), c.glFramebuffer = n.glFramebuffer), c.viewport.left === i.x && c.viewport.top === i.y && c.viewport.width === i.width && c.viewport.height === i.height || (s.viewport(i.x, i.y, i.width, i.height), c.viewport.left = i.x, c.viewport.top = i.y, c.viewport.width = i.width, c.viewport.height = i.height), c.scissorRect.x === i.x && c.scissorRect.y === i.y && c.scissorRect.width === i.width && c.scissorRect.height === i.height || (s.scissor(i.x, i.y, i.width, i.height), c.scissorRect.x = i.x, c.scissorRect.y = i.y, c.scissorRect.width = i.width, c.scissorRect.height = i.height), Sz.invalidateAttachments.length = 0;
                    for (var u = 0; u < r.length; ++u) {
                        var h = t.colorAttachments[u];
                        if (h.format !== Ea.UNKNOWN) switch (h.loadOp) {
                            case Ga.LOAD:
                                break;
                            case Ga.CLEAR:
                                if (c.bs.targets[0].blendColorMask !== za.ALL && s.colorMask(!0, !0, !0, !0), n.isOffscreen) $F[0] = r[u].x, $F[1] = r[u].y, $F[2] = r[u].z, $F[3] = r[u].w, s.clearBufferfv(s.COLOR, u, $F);
                                else {
                                    var _ = r[0];
                                    s.clearColor(_.x, _.y, _.z, _.w), l |= s.COLOR_BUFFER_BIT
                                }
                                break;
                            case Ga.DISCARD:
                                Sz.invalidateAttachments.push(s.COLOR_ATTACHMENT0 + u)
                        }
                    }
                    if (t.depthStencilAttachment && t.depthStencilAttachment.format !== Ea.UNKNOWN) {
                        switch (t.depthStencilAttachment.depthLoadOp) {
                            case Ga.LOAD:
                                break;
                            case Ga.CLEAR:
                                c.dss.depthWrite || s.depthMask(!0), s.clearDepth(o), l |= s.DEPTH_BUFFER_BIT;
                                break;
                            case Ga.DISCARD:
                                Sz.invalidateAttachments.push(s.DEPTH_ATTACHMENT)
                        }
                        if (tc[t.depthStencilAttachment.format].hasStencil) switch (t.depthStencilAttachment.stencilLoadOp) {
                            case Ga.LOAD:
                                break;
                            case Ga.CLEAR:
                                c.dss.stencilWriteMaskFront || s.stencilMaskSeparate(s.FRONT, 65535), c.dss.stencilWriteMaskBack || s.stencilMaskSeparate(s.BACK, 65535), s.clearStencil(a), l |= s.STENCIL_BUFFER_BIT;
                                break;
                            case Ga.DISCARD:
                                Sz.invalidateAttachments.push(s.STENCIL_ATTACHMENT)
                        }
                    }
                    if (n.glFramebuffer && Sz.invalidateAttachments.length && s.invalidateFramebuffer(s.FRAMEBUFFER, Sz.invalidateAttachments), l && s.clear(l), l & s.COLOR_BUFFER_BIT) {
                        var f = c.bs.targets[0].blendColorMask;
                        if (f !== za.ALL) {
                            var d = (f & za.R) !== za.NONE,
                                p = (f & za.G) !== za.NONE,
                                m = (f & za.B) !== za.NONE,
                                g = (f & za.A) !== za.NONE;
                            s.colorMask(d, p, m, g)
                        }
                    }
                    l & s.DEPTH_BUFFER_BIT && !c.dss.depthWrite && s.depthMask(!1), l & s.STENCIL_BUFFER_BIT && (c.dss.stencilWriteMaskFront || s.stencilMaskSeparate(s.FRONT, 0), c.dss.stencilWriteMaskBack || s.stencilMaskSeparate(s.BACK, 0))
                }
            }

            function Tz(e, t, n, i, r, o, a, s, c, l, u, h, _) {
                var f = e.gl,
                    d = e.stateCache,
                    m = t && t.gpuShader,
                    g = !1;
                if (t && Sz.gpuPipelineState !== t) {
                    if (Sz.gpuPipelineState = t, Sz.glPrimitive = t.glPrimitive, m) {
                        var v = m.glProgram;
                        d.glProgram !== v && (f.useProgram(v), d.glProgram = v, g = !0)
                    }
                    var y = t.rs;
                    if (y) {
                        if (d.rs.cullMode !== y.cullMode) {
                            switch (y.cullMode) {
                                case Xa.NONE:
                                    f.disable(f.CULL_FACE);
                                    break;
                                case Xa.FRONT:
                                    f.enable(f.CULL_FACE), f.cullFace(f.FRONT);
                                    break;
                                case Xa.BACK:
                                    f.enable(f.CULL_FACE), f.cullFace(f.BACK)
                            }
                            e.stateCache.rs.cullMode = y.cullMode
                        }
                        var S = y.isFrontFaceCCW;
                        e.stateCache.rs.isFrontFaceCCW !== S && (f.frontFace(S ? f.CCW : f.CW), e.stateCache.rs.isFrontFaceCCW = S), e.stateCache.rs.depthBias === y.depthBias && e.stateCache.rs.depthBiasSlop === y.depthBiasSlop || (f.polygonOffset(y.depthBias, y.depthBiasSlop), e.stateCache.rs.depthBias = y.depthBias, e.stateCache.rs.depthBiasSlop = y.depthBiasSlop), e.stateCache.rs.lineWidth !== y.lineWidth && (f.lineWidth(y.lineWidth), e.stateCache.rs.lineWidth = y.lineWidth)
                    }
                    var E = t.dss;
                    E && (d.dss.depthTest !== E.depthTest && (E.depthTest ? f.enable(f.DEPTH_TEST) : f.disable(f.DEPTH_TEST), d.dss.depthTest = E.depthTest), d.dss.depthWrite !== E.depthWrite && (f.depthMask(E.depthWrite), d.dss.depthWrite = E.depthWrite), d.dss.depthFunc !== E.depthFunc && (f.depthFunc(cz[E.depthFunc]), d.dss.depthFunc = E.depthFunc), d.dss.stencilTestFront === E.stencilTestFront && d.dss.stencilTestBack === E.stencilTestBack || (E.stencilTestFront || E.stencilTestBack ? f.enable(f.STENCIL_TEST) : f.disable(f.STENCIL_TEST), d.dss.stencilTestFront = E.stencilTestFront, d.dss.stencilTestBack = E.stencilTestBack), d.dss.stencilFuncFront === E.stencilFuncFront && d.dss.stencilRefFront === E.stencilRefFront && d.dss.stencilReadMaskFront === E.stencilReadMaskFront || (f.stencilFuncSeparate(f.FRONT, cz[E.stencilFuncFront], E.stencilRefFront, E.stencilReadMaskFront), d.dss.stencilFuncFront = E.stencilFuncFront, d.dss.stencilRefFront = E.stencilRefFront, d.dss.stencilReadMaskFront = E.stencilReadMaskFront), d.dss.stencilFailOpFront === E.stencilFailOpFront && d.dss.stencilZFailOpFront === E.stencilZFailOpFront && d.dss.stencilPassOpFront === E.stencilPassOpFront || (f.stencilOpSeparate(f.FRONT, lz[E.stencilFailOpFront], lz[E.stencilZFailOpFront], lz[E.stencilPassOpFront]), d.dss.stencilFailOpFront = E.stencilFailOpFront, d.dss.stencilZFailOpFront = E.stencilZFailOpFront, d.dss.stencilPassOpFront = E.stencilPassOpFront), d.dss.stencilWriteMaskFront !== E.stencilWriteMaskFront && (f.stencilMaskSeparate(f.FRONT, E.stencilWriteMaskFront), d.dss.stencilWriteMaskFront = E.stencilWriteMaskFront), d.dss.stencilFuncBack === E.stencilFuncBack && d.dss.stencilRefBack === E.stencilRefBack && d.dss.stencilReadMaskBack === E.stencilReadMaskBack || (f.stencilFuncSeparate(f.BACK, cz[E.stencilFuncBack], E.stencilRefBack, E.stencilReadMaskBack), d.dss.stencilFuncBack = E.stencilFuncBack, d.dss.stencilRefBack = E.stencilRefBack, d.dss.stencilReadMaskBack = E.stencilReadMaskBack), d.dss.stencilFailOpBack === E.stencilFailOpBack && d.dss.stencilZFailOpBack === E.stencilZFailOpBack && d.dss.stencilPassOpBack === E.stencilPassOpBack || (f.stencilOpSeparate(f.BACK, lz[E.stencilFailOpBack], lz[E.stencilZFailOpBack], lz[E.stencilPassOpBack]), d.dss.stencilFailOpBack = E.stencilFailOpBack, d.dss.stencilZFailOpBack = E.stencilZFailOpBack, d.dss.stencilPassOpBack = E.stencilPassOpBack), d.dss.stencilWriteMaskBack !== E.stencilWriteMaskBack && (f.stencilMaskSeparate(f.BACK, E.stencilWriteMaskBack), d.dss.stencilWriteMaskBack = E.stencilWriteMaskBack));
                    var T = t.bs;
                    if (T) {
                        d.bs.isA2C !== T.isA2C && (T.isA2C ? f.enable(f.SAMPLE_ALPHA_TO_COVERAGE) : f.disable(f.SAMPLE_ALPHA_TO_COVERAGE), d.bs.isA2C = T.isA2C), d.bs.blendColor.x === T.blendColor.x && d.bs.blendColor.y === T.blendColor.y && d.bs.blendColor.z === T.blendColor.z && d.bs.blendColor.w === T.blendColor.w || (f.blendColor(T.blendColor.x, T.blendColor.y, T.blendColor.z, T.blendColor.w), d.bs.blendColor.x = T.blendColor.x, d.bs.blendColor.y = T.blendColor.y, d.bs.blendColor.z = T.blendColor.z, d.bs.blendColor.w = T.blendColor.w);
                        var A = T.targets[0],
                            x = d.bs.targets[0];
                        x.blend !== A.blend && (A.blend ? f.enable(f.BLEND) : f.disable(f.BLEND), x.blend = A.blend), x.blendEq === A.blendEq && x.blendAlphaEq === A.blendAlphaEq || (f.blendEquationSeparate(uz[A.blendEq], uz[A.blendAlphaEq]), x.blendEq = A.blendEq, x.blendAlphaEq = A.blendAlphaEq), x.blendSrc === A.blendSrc && x.blendDst === A.blendDst && x.blendSrcAlpha === A.blendSrcAlpha && x.blendDstAlpha === A.blendDstAlpha || (f.blendFuncSeparate(hz[A.blendSrc], hz[A.blendDst], hz[A.blendSrcAlpha], hz[A.blendDstAlpha]), x.blendSrc = A.blendSrc, x.blendDst = A.blendDst, x.blendSrcAlpha = A.blendSrcAlpha, x.blendDstAlpha = A.blendDstAlpha), x.blendColorMask !== A.blendColorMask && (f.colorMask((A.blendColorMask & za.R) !== za.NONE, (A.blendColorMask & za.G) !== za.NONE, (A.blendColorMask & za.B) !== za.NONE, (A.blendColorMask & za.A) !== za.NONE), x.blendColorMask = A.blendColorMask)
                    }
                }
                if (t && t.gpuPipelineLayout && m) {
                    for (var C = m.glBlocks.length, b = t.gpuPipelineLayout.dynamicOffsetIndices, R = 0; R < C; R++) {
                        var w = m.glBlocks[R],
                            I = i[w.set],
                            P = I && I.descriptorIndices[w.binding],
                            O = P >= 0 && I.gpuDescriptors[P];
                        if (O && O.gpuBuffer) {
                            var D = b[w.set],
                                N = D && D[w.binding],
                                M = O.gpuBuffer.glOffset;
                            N >= 0 && (M += r[N]), d.glBindUBOs[w.glBinding] === O.gpuBuffer.glBuffer && d.glBindUBOOffsets[w.glBinding] === M || (M ? f.bindBufferRange(f.UNIFORM_BUFFER, w.glBinding, O.gpuBuffer.glBuffer, M, O.gpuBuffer.size) : f.bindBufferBase(f.UNIFORM_BUFFER, w.glBinding, O.gpuBuffer.glBuffer), d.glUniformBuffer = d.glBindUBOs[w.glBinding] = O.gpuBuffer.glBuffer, d.glBindUBOOffsets[w.glBinding] = M)
                        } else p("Buffer binding '" + w.name + "' at set " + w.set + " binding " + w.binding + " is not bounded")
                    }
                    for (var L = m.glSamplerTextures.length, B = 0; B < L; B++)
                        for (var F = m.glSamplerTextures[B], z = i[F.set], U = z && z.descriptorIndices[F.binding], G = U >= 0 && z.gpuDescriptors[U], H = 0; H < F.units.length; H++) {
                            var k = F.units[H],
                                V = d.glTexUnits[k];
                            if (G && G.gpuTexture && G.gpuSampler) {
                                if (G.gpuTexture && G.gpuTexture.size > 0) {
                                    var W = G.gpuTexture;
                                    V.glTexture !== W.glTexture && (d.texUnit !== k && (f.activeTexture(f.TEXTURE0 + k), d.texUnit = k), W.glTexture ? f.bindTexture(W.glTarget, W.glTexture) : f.bindTexture(W.glTarget, e.nullTex2D.gpuTexture.glTexture), V.glTexture = W.glTexture);
                                    var j = G.gpuSampler;
                                    d.glSamplerUnits[k] !== j.glSampler && (f.bindSampler(k, j.glSampler), d.glSamplerUnits[k] = j.glSampler)
                                }
                                G = z.gpuDescriptors[++U]
                            } else p("Sampler binding '" + F.name + "' at set " + F.set + " binding " + F.binding + " index " + H + " is not bounded")
                        }
                }
                if (n && m && (g || Sz.gpuInputAssembler !== n))
                    if (Sz.gpuInputAssembler = n, e.useVAO) {
                        var q = n.glVAOs.get(m.glProgram);
                        if (!q) {
                            var X;
                            q = f.createVertexArray(), n.glVAOs.set(m.glProgram, q), f.bindVertexArray(q), f.bindBuffer(f.ARRAY_BUFFER, null), f.bindBuffer(f.ELEMENT_ARRAY_BUFFER, null), d.glArrayBuffer = null, d.glElementArrayBuffer = null;
                            for (var Y = 0; Y < m.glInputs.length; Y++) {
                                var K = m.glInputs[Y];
                                X = null;
                                for (var Z = 0; Z < n.glAttribs.length; Z++) {
                                    var Q = n.glAttribs[Z];
                                    if (Q.name === K.name) {
                                        X = Q;
                                        break
                                    }
                                }
                                if (X) {
                                    d.glArrayBuffer !== X.glBuffer && (f.bindBuffer(f.ARRAY_BUFFER, X.glBuffer), d.glArrayBuffer = X.glBuffer);
                                    for (var J = 0; J < X.componentCount; ++J) {
                                        var $ = K.glLoc + J,
                                            ee = X.offset + X.size * J;
                                        f.enableVertexAttribArray($), d.glCurrentAttribLocs[$] = !0, f.vertexAttribPointer($, X.count, X.glType, X.isNormalized, X.stride, ee), f.vertexAttribDivisor($, X.isInstanced ? 1 : 0)
                                    }
                                }
                            }
                            var te = n.gpuIndexBuffer;
                            te && f.bindBuffer(f.ELEMENT_ARRAY_BUFFER, te.glBuffer), f.bindVertexArray(null), f.bindBuffer(f.ARRAY_BUFFER, null), f.bindBuffer(f.ELEMENT_ARRAY_BUFFER, null), d.glArrayBuffer = null, d.glElementArrayBuffer = null
                        }
                        d.glVAO !== q && (f.bindVertexArray(q), d.glVAO = q)
                    } else {
                        for (var ne = 0; ne < e.capabilities.maxVertexAttributes; ++ne) d.glCurrentAttribLocs[ne] = !1;
                        for (var ie = 0; ie < m.glInputs.length; ie++) {
                            for (var re = m.glInputs[ie], oe = null, ae = 0; ae < n.glAttribs.length; ae++) {
                                var se = n.glAttribs[ae];
                                if (se.name === re.name) {
                                    oe = se;
                                    break
                                }
                            }
                            if (oe) {
                                d.glArrayBuffer !== oe.glBuffer && (f.bindBuffer(f.ARRAY_BUFFER, oe.glBuffer), d.glArrayBuffer = oe.glBuffer);
                                for (var ce = 0; ce < oe.componentCount; ++ce) {
                                    var le = re.glLoc + ce,
                                        ue = oe.offset + oe.size * ce;
                                    !d.glEnabledAttribLocs[le] && le >= 0 && (f.enableVertexAttribArray(le), d.glEnabledAttribLocs[le] = !0), d.glCurrentAttribLocs[le] = !0, f.vertexAttribPointer(le, oe.count, oe.glType, oe.isNormalized, oe.stride, ue), f.vertexAttribDivisor(le, oe.isInstanced ? 1 : 0)
                                }
                            }
                        }
                        var he = n.gpuIndexBuffer;
                        he && d.glElementArrayBuffer !== he.glBuffer && (f.bindBuffer(f.ELEMENT_ARRAY_BUFFER, he.glBuffer), d.glElementArrayBuffer = he.glBuffer);
                        for (var _e = 0; _e < e.capabilities.maxVertexAttributes; ++_e) d.glEnabledAttribLocs[_e] !== d.glCurrentAttribLocs[_e] && (f.disableVertexAttribArray(_e), d.glEnabledAttribLocs[_e] = !1)
                    }
                if (t && t.dynamicStates.length)
                    for (var fe = t.dynamicStates.length, de = 0; de < fe; de++) switch (t.dynamicStates[de]) {
                        case Ya.VIEWPORT:
                            o && (d.viewport.left === o.left && d.viewport.top === o.top && d.viewport.width === o.width && d.viewport.height === o.height || (f.viewport(o.left, o.top, o.width, o.height), d.viewport.left = o.left, d.viewport.top = o.top, d.viewport.width = o.width, d.viewport.height = o.height));
                            break;
                        case Ya.SCISSOR:
                            a && (d.scissorRect.x === a.x && d.scissorRect.y === a.y && d.scissorRect.width === a.width && d.scissorRect.height === a.height || (f.scissor(a.x, a.y, a.width, a.height), d.scissorRect.x = a.x, d.scissorRect.y = a.y, d.scissorRect.width = a.width, d.scissorRect.height = a.height));
                            break;
                        case Ya.LINE_WIDTH:
                            s && d.rs.lineWidth !== s && (f.lineWidth(s), d.rs.lineWidth = s);
                            break;
                        case Ya.DEPTH_BIAS:
                            c && (d.rs.depthBias === c.constantFactor && d.rs.depthBiasSlop === c.slopeFactor || (f.polygonOffset(c.constantFactor, c.slopeFactor), d.rs.depthBias = c.constantFactor, d.rs.depthBiasSlop = c.slopeFactor));
                            break;
                        case Ya.BLEND_CONSTANTS:
                            d.bs.blendColor.x === l[0] && d.bs.blendColor.y === l[1] && d.bs.blendColor.z === l[2] && d.bs.blendColor.w === l[3] || (f.blendColor(l[0], l[1], l[2], l[3]), d.bs.blendColor.x = l[0], d.bs.blendColor.y = l[1], d.bs.blendColor.z = l[2], d.bs.blendColor.w = l[3]);
                            break;
                        case Ya.STENCIL_WRITE_MASK:
                            if (h) switch (h.face) {
                                case Ka.FRONT:
                                    d.dss.stencilWriteMaskFront !== h.writeMask && (f.stencilMaskSeparate(f.FRONT, h.writeMask), d.dss.stencilWriteMaskFront = h.writeMask);
                                    break;
                                case Ka.BACK:
                                    d.dss.stencilWriteMaskBack !== h.writeMask && (f.stencilMaskSeparate(f.BACK, h.writeMask), d.dss.stencilWriteMaskBack = h.writeMask);
                                    break;
                                case Ka.ALL:
                                    d.dss.stencilWriteMaskFront === h.writeMask && d.dss.stencilWriteMaskBack === h.writeMask || (f.stencilMask(h.writeMask), d.dss.stencilWriteMaskFront = h.writeMask, d.dss.stencilWriteMaskBack = h.writeMask)
                            }
                            break;
                        case Ya.STENCIL_COMPARE_MASK:
                            if (_) switch (_.face) {
                                case Ka.FRONT:
                                    d.dss.stencilRefFront === _.reference && d.dss.stencilReadMaskFront === _.compareMask || (f.stencilFuncSeparate(f.FRONT, cz[d.dss.stencilFuncFront], _.reference, _.compareMask), d.dss.stencilRefFront = _.reference, d.dss.stencilReadMaskFront = _.compareMask);
                                    break;
                                case Ka.BACK:
                                    d.dss.stencilRefBack === _.reference && d.dss.stencilReadMaskBack === _.compareMask || (f.stencilFuncSeparate(f.BACK, cz[d.dss.stencilFuncBack], _.reference, _.compareMask), d.dss.stencilRefBack = _.reference, d.dss.stencilReadMaskBack = _.compareMask);
                                    break;
                                case Ka.ALL:
                                    d.dss.stencilRefFront === _.reference && d.dss.stencilReadMaskFront === _.compareMask && d.dss.stencilRefBack === _.reference && d.dss.stencilReadMaskBack === _.compareMask || (f.stencilFunc(cz[d.dss.stencilFuncBack], _.reference, _.compareMask), d.dss.stencilRefFront = _.reference, d.dss.stencilReadMaskFront = _.compareMask, d.dss.stencilRefBack = _.reference, d.dss.stencilReadMaskBack = _.compareMask)
                            }
                    }
            }

            function Az(e, t) {
                var n = e.gl,
                    i = Sz.gpuInputAssembler,
                    r = Sz.glPrimitive;
                if (i)
                    if (i.gpuIndirectBuffer)
                        for (var o = i.gpuIndirectBuffer.indirects, a = 0; a < o.length; a++) {
                            var s = o[a],
                                c = i.gpuIndexBuffer;
                            if (s.instanceCount)
                                if (c) {
                                    if (s.indexCount > 0) {
                                        var l = s.firstIndex * c.stride;
                                        n.drawElementsInstanced(r, s.indexCount, i.glIndexType, l, s.instanceCount)
                                    }
                                } else s.vertexCount > 0 && n.drawArraysInstanced(r, s.firstVertex, s.vertexCount, s.instanceCount);
                            else if (c) {
                                if (s.indexCount > 0) {
                                    var u = s.firstIndex * c.stride;
                                    n.drawElements(r, s.indexCount, i.glIndexType, u)
                                }
                            } else s.vertexCount > 0 && n.drawArrays(r, s.firstVertex, s.vertexCount)
                        } else if (t.instanceCount)
                            if (i.gpuIndexBuffer) {
                                if (t.indexCount > 0) {
                                    var h = t.firstIndex * i.gpuIndexBuffer.stride;
                                    n.drawElementsInstanced(r, t.indexCount, i.glIndexType, h, t.instanceCount)
                                }
                            } else t.vertexCount > 0 && n.drawArraysInstanced(r, t.firstVertex, t.vertexCount, t.instanceCount);
                else if (i.gpuIndexBuffer) {
                    if (t.indexCount > 0) {
                        var _ = t.firstIndex * i.gpuIndexBuffer.stride;
                        n.drawElements(r, t.indexCount, i.glIndexType, _)
                    }
                } else t.vertexCount > 0 && n.drawArrays(r, t.firstVertex, t.vertexCount)
            }
            var xz = new Array(sz.COUNT);

            function Cz(e, t) {
                xz.fill(0);
                for (var n = 0; n < t.cmds.length; ++n) {
                    var i = t.cmds.array[n],
                        r = xz[i]++;
                    switch (i) {
                        case sz.BEGIN_RENDER_PASS:
                            var o = t.beginRenderPassCmds.array[r];
                            Ez(e, o.gpuRenderPass, o.gpuFramebuffer, o.renderArea, o.clearColors, o.clearDepth, o.clearStencil);
                            break;
                        case sz.BIND_STATES:
                            var a = t.bindStatesCmds.array[r];
                            Tz(e, a.gpuPipelineState, a.gpuInputAssembler, a.gpuDescriptorSets, a.dynamicOffsets, a.viewport, a.scissor, a.lineWidth, a.depthBias, a.blendConstants, a.depthBounds, a.stencilWriteMask, a.stencilCompareMask);
                            break;
                        case sz.DRAW:
                            Az(e, t.drawCmds.array[r].drawInfo);
                            break;
                        case sz.UPDATE_BUFFER:
                            var s = t.updateBufferCmds.array[r];
                            yz(e, s.gpuBuffer, s.buffer, s.offset, s.size);
                            break;
                        case sz.COPY_BUFFER_TO_TEXTURE:
                            var c = t.copyBufferToTextureCmds.array[r];
                            bz(e, c.buffers, c.gpuTexture, c.regions)
                    }
                }
            }

            function bz(e, t, n, i) {
                var r = e.gl,
                    o = e.stateCache.glTexUnits[e.stateCache.texUnit];
                o.glTexture !== n.glTexture && (r.bindTexture(n.glTarget, n.glTexture), o.glTexture = n.glTexture);
                var a = 0,
                    s = 1,
                    c = 1,
                    l = 0,
                    u = tc[n.format].isCompressed;
                switch (n.glTarget) {
                    case r.TEXTURE_2D:
                        for (var h = 0; h < i.length; h++) {
                            var _ = i[h];
                            s = _.texExtent.width, c = _.texExtent.height;
                            var f = t[a++];
                            u ? n.glInternalFmt !== $B.COMPRESSED_RGB_ETC1_WEBGL ? r.compressedTexSubImage2D(r.TEXTURE_2D, _.texSubres.mipLevel, _.texOffset.x, _.texOffset.y, s, c, n.glFormat, f) : r.compressedTexImage2D(r.TEXTURE_2D, _.texSubres.mipLevel, n.glInternalFmt, s, c, 0, f) : r.texSubImage2D(r.TEXTURE_2D, _.texSubres.mipLevel, _.texOffset.x, _.texOffset.y, s, c, n.glFormat, n.glType, f)
                        }
                        break;
                    case r.TEXTURE_CUBE_MAP:
                        for (var d = 0; d < i.length; d++) {
                            var p = i[d],
                                m = p.texSubres.baseArrayLayer + p.texSubres.layerCount;
                            for (l = p.texSubres.baseArrayLayer; l < m; ++l) {
                                s = p.texExtent.width, c = p.texExtent.height;
                                var g = t[a++];
                                u ? n.glInternalFmt !== $B.COMPRESSED_RGB_ETC1_WEBGL ? r.compressedTexSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + l, p.texSubres.mipLevel, p.texOffset.x, p.texOffset.y, s, c, n.glFormat, g) : r.compressedTexImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + l, p.texSubres.mipLevel, n.glInternalFmt, s, c, 0, g) : r.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + l, p.texSubres.mipLevel, p.texOffset.x, p.texOffset.y, s, c, n.glFormat, n.glType, g)
                            }
                        }
                        break;
                    default:
                        console.error("Unsupported GL texture type, copy buffer to texture failed.")
                }
                n.flags & Pa.GEN_MIPMAP && r.generateMipmap(n.glTarget)
            }
            var Rz, wz = function(e) {
                    function t() {
                        for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                        return (t = e.call.apply(e, [this].concat(i)) || this)._gpuBuffer = null, t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.initialize = function(e) {
                        if ("buffer" in e) {
                            this._isBufferView = !0;
                            var t = e.buffer;
                            this._usage = t.usage, this._memUsage = t.memUsage, this._size = this._stride = e.range, this._count = 1, this._flags = t.flags, this._gpuBuffer = {
                                usage: this._usage,
                                memUsage: this._memUsage,
                                size: this._size,
                                stride: this._stride,
                                buffer: null,
                                indirects: t.gpuBuffer.indirects,
                                glTarget: t.gpuBuffer.glTarget,
                                glBuffer: t.gpuBuffer.glBuffer,
                                glOffset: e.offset
                            }
                        } else this._usage = e.usage, this._memUsage = e.memUsage, this._size = e.size, this._stride = Math.max(e.stride || this._size, 1), this._count = this._size / this._stride, this._flags = e.flags, this._usage & xa.INDIRECT && (this._indirectBuffer = new Es), this._gpuBuffer = {
                                usage: this._usage,
                                memUsage: this._memUsage,
                                size: this._size,
                                stride: this._stride,
                                buffer: null,
                                indirects: [],
                                glTarget: 0,
                                glBuffer: null,
                                glOffset: 0
                            }, e.usage & xa.INDIRECT && (this._gpuBuffer.indirects = this._indirectBuffer.drawInfos),
                            function(e, t) {
                                var n = e.gl,
                                    i = e.stateCache,
                                    r = t.memUsage & Ra.HOST ? n.DYNAMIC_DRAW : n.STATIC_DRAW;
                                if (t.usage & xa.VERTEX) {
                                    t.glTarget = n.ARRAY_BUFFER;
                                    var o = n.createBuffer();
                                    o && (t.glBuffer = o, t.size > 0 && (e.useVAO && i.glVAO && (n.bindVertexArray(null), i.glVAO = Sz.gpuInputAssembler = null), e.stateCache.glArrayBuffer !== t.glBuffer && (n.bindBuffer(n.ARRAY_BUFFER, t.glBuffer), e.stateCache.glArrayBuffer = t.glBuffer), n.bufferData(n.ARRAY_BUFFER, t.size, r), n.bindBuffer(n.ARRAY_BUFFER, null), e.stateCache.glArrayBuffer = null))
                                } else if (t.usage & xa.INDEX) {
                                    t.glTarget = n.ELEMENT_ARRAY_BUFFER;
                                    var a = n.createBuffer();
                                    a && (t.glBuffer = a, t.size > 0 && (e.useVAO && i.glVAO && (n.bindVertexArray(null), i.glVAO = Sz.gpuInputAssembler = null), e.stateCache.glElementArrayBuffer !== t.glBuffer && (n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, t.glBuffer), e.stateCache.glElementArrayBuffer = t.glBuffer), n.bufferData(n.ELEMENT_ARRAY_BUFFER, t.size, r), n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, null), e.stateCache.glElementArrayBuffer = null))
                                } else if (t.usage & xa.UNIFORM) {
                                    t.glTarget = n.UNIFORM_BUFFER;
                                    var s = n.createBuffer();
                                    s && t.size > 0 && (t.glBuffer = s, e.stateCache.glUniformBuffer !== t.glBuffer && (n.bindBuffer(n.UNIFORM_BUFFER, t.glBuffer), e.stateCache.glUniformBuffer = t.glBuffer), n.bufferData(n.UNIFORM_BUFFER, t.size, r), n.bindBuffer(n.UNIFORM_BUFFER, null), e.stateCache.glUniformBuffer = null)
                                } else t.usage & xa.INDIRECT || t.usage & xa.TRANSFER_DST || t.usage & xa.TRANSFER_SRC || console.error("Unsupported BufferType, create buffer failed."), t.glTarget = n.NONE
                            }(this._device, this._gpuBuffer), this._device.memoryStatus.bufferSize += this._size;
                        return !0
                    }, n.destroy = function() {
                        this._gpuBuffer && (this._isBufferView || (function(e, t) {
                            var n = e.gl;
                            if (t.glBuffer) {
                                switch (t.glTarget) {
                                    case n.ARRAY_BUFFER:
                                        e.useVAO && e.stateCache.glVAO && (n.bindVertexArray(null), e.stateCache.glVAO = Sz.gpuInputAssembler = null), n.bindBuffer(n.ARRAY_BUFFER, null), e.stateCache.glArrayBuffer = null;
                                        break;
                                    case n.ELEMENT_ARRAY_BUFFER:
                                        e.useVAO && e.stateCache.glVAO && (n.bindVertexArray(null), e.stateCache.glVAO = Sz.gpuInputAssembler = null), n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, null), e.stateCache.glElementArrayBuffer = null;
                                        break;
                                    case n.UNIFORM_BUFFER:
                                        n.bindBuffer(n.UNIFORM_BUFFER, null), e.stateCache.glUniformBuffer = null
                                }
                                n.deleteBuffer(t.glBuffer), t.glBuffer = null
                            }
                        }(this._device, this._gpuBuffer), this._device.memoryStatus.bufferSize -= this._size), this._gpuBuffer = null)
                    }, n.resize = function(e) {
                        if (this._isBufferView) console.warn("cannot resize buffer views!");
                        else {
                            var t = this._size;
                            t !== e && (this._size = e, this._count = this._size / this._stride, this._gpuBuffer && (this._gpuBuffer.size = e, e > 0 && (function(e, t) {
                                var n = e.gl,
                                    i = e.stateCache,
                                    r = t.memUsage & Ra.HOST ? n.DYNAMIC_DRAW : n.STATIC_DRAW;
                                t.usage & xa.VERTEX ? (e.useVAO && i.glVAO && (n.bindVertexArray(null), i.glVAO = Sz.gpuInputAssembler = null), i.glArrayBuffer !== t.glBuffer && n.bindBuffer(n.ARRAY_BUFFER, t.glBuffer), t.buffer ? n.bufferData(n.ARRAY_BUFFER, t.buffer, r) : n.bufferData(n.ARRAY_BUFFER, t.size, r), n.bindBuffer(n.ARRAY_BUFFER, null), i.glArrayBuffer = null) : t.usage & xa.INDEX ? (e.useVAO && i.glVAO && (n.bindVertexArray(null), i.glVAO = Sz.gpuInputAssembler = null), e.stateCache.glElementArrayBuffer !== t.glBuffer && n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, t.glBuffer), t.buffer ? n.bufferData(n.ELEMENT_ARRAY_BUFFER, t.buffer, r) : n.bufferData(n.ELEMENT_ARRAY_BUFFER, t.size, r), n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, null), e.stateCache.glElementArrayBuffer = null) : t.usage & xa.UNIFORM ? (e.stateCache.glUniformBuffer !== t.glBuffer && n.bindBuffer(n.UNIFORM_BUFFER, t.glBuffer), n.bufferData(n.UNIFORM_BUFFER, t.size, r), n.bindBuffer(n.UNIFORM_BUFFER, null), e.stateCache.glUniformBuffer = null) : (t.usage & xa.INDIRECT || t.usage & xa.TRANSFER_DST || t.usage & xa.TRANSFER_SRC || console.error("Unsupported BufferType, create buffer failed."), t.glTarget = n.NONE)
                            }(this._device, this._gpuBuffer), this._device.memoryStatus.bufferSize -= t, this._device.memoryStatus.bufferSize += e)))
                        }
                    }, n.update = function(e, t) {
                        var n;
                        this._isBufferView ? console.warn("cannot update through buffer views!") : (n = void 0 !== t ? t : this._usage & xa.INDIRECT ? 0 : e.byteLength, yz(this._device, this._gpuBuffer, e, 0, n))
                    }, K(t, [{
                        key: "gpuBuffer",
                        get: function() {
                            return this._gpuBuffer
                        }
                    }]), t
                }(_c),
                Iz = function() {
                    function e(e, t) {
                        this._frees = void 0, this._freeIdx = 0, this._freeCmds = void 0, this._frees = new Array(t), this._freeCmds = new ei(t);
                        for (var n = 0; n < t; ++n) this._frees[n] = new e;
                        this._freeIdx = t - 1
                    }
                    var t = e.prototype;
                    return t.alloc = function(e) {
                        if (this._freeIdx < 0) {
                            var t = 2 * this._frees.length,
                                n = this._frees;
                            this._frees = new Array(t);
                            for (var i = t - n.length, r = 0; r < i; ++r) this._frees[r] = new e;
                            for (var o = i, a = 0; o < t; ++o, ++a) this._frees[o] = n[a];
                            this._freeIdx += i
                        }
                        var s = this._frees[this._freeIdx];
                        return this._frees[this._freeIdx--] = null, ++s.refCount, s
                    }, t.free = function(e) {
                        0 == --e.refCount && this._freeCmds.push(e)
                    }, t.freeCmds = function(e) {
                        for (var t = 0; t < e.length; ++t) 0 == --e.array[t].refCount && this._freeCmds.push(e.array[t])
                    }, t.release = function() {
                        for (var e = 0; e < this._freeCmds.length; ++e) {
                            var t = this._freeCmds.array[e];
                            t.clear(), this._frees[++this._freeIdx] = t
                        }
                        this._freeCmds.clear()
                    }, e
                }(),
                Pz = function() {
                    function e() {
                        this.beginRenderPassCmdPool = void 0, this.bindStatesCmdPool = void 0, this.drawCmdPool = void 0, this.updateBufferCmdPool = void 0, this.copyBufferToTextureCmdPool = void 0, this.beginRenderPassCmdPool = new Iz(fz, 1), this.bindStatesCmdPool = new Iz(dz, 1), this.drawCmdPool = new Iz(pz, 1), this.updateBufferCmdPool = new Iz(mz, 1), this.copyBufferToTextureCmdPool = new Iz(gz, 1)
                    }
                    var t = e.prototype;
                    return t.clearCmds = function(e) {
                        e.beginRenderPassCmds.length && (this.beginRenderPassCmdPool.freeCmds(e.beginRenderPassCmds), e.beginRenderPassCmds.clear()), e.bindStatesCmds.length && (this.bindStatesCmdPool.freeCmds(e.bindStatesCmds), e.bindStatesCmds.clear()), e.drawCmds.length && (this.drawCmdPool.freeCmds(e.drawCmds), e.drawCmds.clear()), e.updateBufferCmds.length && (this.updateBufferCmdPool.freeCmds(e.updateBufferCmds), e.updateBufferCmds.clear()), e.copyBufferToTextureCmds.length && (this.copyBufferToTextureCmdPool.freeCmds(e.copyBufferToTextureCmds), e.copyBufferToTextureCmds.clear()), e.cmds.clear()
                    }, t.releaseCmds = function() {
                        this.beginRenderPassCmdPool.release(), this.bindStatesCmdPool.release(), this.drawCmdPool.release(), this.updateBufferCmdPool.release(), this.copyBufferToTextureCmdPool.release()
                    }, e
                }(),
                Oz = function(e) {
                    function t() {
                        for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                        return (t = e.call.apply(e, [this].concat(i)) || this).cmdPackage = new vz, t._webGLAllocator = null, t._isInRenderPass = !1, t._curGPUPipelineState = null, t._curGPUDescriptorSets = [], t._curGPUInputAssembler = null, t._curDynamicOffsets = [], t._curViewport = null, t._curScissor = null, t._curLineWidth = null, t._curDepthBias = null, t._curBlendConstants = [], t._curDepthBounds = null, t._curStencilWriteMask = null, t._curStencilCompareMask = null, t._isStateInvalied = !1, t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.initialize = function(e) {
                        this._type = e.type, this._queue = e.queue, this._webGLAllocator = this._device.cmdAllocator;
                        for (var t = this._device.bindingMappingInfo.bufferOffsets.length, n = 0; n < t; n++) this._curGPUDescriptorSets.push(null), this._curDynamicOffsets.push([]);
                        return !0
                    }, n.destroy = function() {
                        this._webGLAllocator && (this._webGLAllocator.clearCmds(this.cmdPackage), this._webGLAllocator = null)
                    }, n.begin = function() {
                        this._webGLAllocator.clearCmds(this.cmdPackage), this._curGPUPipelineState = null, this._curGPUInputAssembler = null, this._curGPUDescriptorSets.length = 0;
                        for (var e = 0; e < this._curDynamicOffsets.length; e++) this._curDynamicOffsets[e].length = 0;
                        this._curViewport = null, this._curScissor = null, this._curLineWidth = null, this._curDepthBias = null, this._curBlendConstants.length = 0, this._curDepthBounds = null, this._curStencilWriteMask = null, this._curStencilCompareMask = null, this._numDrawCalls = 0, this._numInstances = 0, this._numTris = 0
                    }, n.end = function() {
                        this._isStateInvalied && this.bindStates(), this._isInRenderPass = !1
                    }, n.beginRenderPass = function(e, t, n, i, r, o) {
                        var a = this._webGLAllocator.beginRenderPassCmdPool.alloc(fz);
                        a.gpuRenderPass = e.gpuRenderPass, a.gpuFramebuffer = t.gpuFramebuffer, a.renderArea = n;
                        for (var s = 0; s < i.length; ++s) a.clearColors[s] = i[s];
                        a.clearDepth = r, a.clearStencil = o, this.cmdPackage.beginRenderPassCmds.push(a), this.cmdPackage.cmds.push(sz.BEGIN_RENDER_PASS), this._isInRenderPass = !0
                    }, n.endRenderPass = function() {
                        this._isInRenderPass = !1
                    }, n.bindPipelineState = function(e) {
                        var t = e.gpuPipelineState;
                        t !== this._curGPUPipelineState && (this._curGPUPipelineState = t, this._isStateInvalied = !0)
                    }, n.bindDescriptorSet = function(e, t, n) {
                        var i = t.gpuDescriptorSet;
                        if (i !== this._curGPUDescriptorSets[e] && (this._curGPUDescriptorSets[e] = i, this._isStateInvalied = !0), n) {
                            for (var r = this._curDynamicOffsets[e], o = 0; o < n.length; o++) r[o] = n[o];
                            r.length = n.length, this._isStateInvalied = !0
                        }
                    }, n.bindInputAssembler = function(e) {
                        var t = e.gpuInputAssembler;
                        this._curGPUInputAssembler = t, this._isStateInvalied = !0
                    }, n.setViewport = function(e) {
                        this._curViewport ? this._curViewport.left === e.left && this._curViewport.top === e.top && this._curViewport.width === e.width && this._curViewport.height === e.height && this._curViewport.minDepth === e.minDepth && this._curViewport.maxDepth === e.maxDepth || (this._curViewport.left = e.left, this._curViewport.top = e.top, this._curViewport.width = e.width, this._curViewport.height = e.height, this._curViewport.minDepth = e.minDepth, this._curViewport.maxDepth = e.maxDepth, this._isStateInvalied = !0) : this._curViewport = new ds(e.left, e.top, e.width, e.height, e.minDepth, e.maxDepth)
                    }, n.setScissor = function(e) {
                        this._curScissor ? this._curScissor.x === e.x && this._curScissor.y === e.y && this._curScissor.width === e.width && this._curScissor.height === e.height || (this._curScissor.x = e.x, this._curScissor.y = e.y, this._curScissor.width = e.width, this._curScissor.height = e.height, this._isStateInvalied = !0) : this._curScissor = new ss(e.x, e.y, e.width, e.height)
                    }, n.setLineWidth = function(e) {
                        this._curLineWidth !== e && (this._curLineWidth = e, this._isStateInvalied = !0)
                    }, n.setDepthBias = function(e, t, n) {
                        this._curDepthBias ? this._curDepthBias.constantFactor === e && this._curDepthBias.clamp === t && this._curDepthBias.slopeFactor === n || (this._curDepthBias.constantFactor = e, this._curDepthBias.clamp = t, this._curDepthBias.slopeFactor = n, this._isStateInvalied = !0) : (this._curDepthBias = {
                            constantFactor: e,
                            clamp: t,
                            slopeFactor: n
                        }, this._isStateInvalied = !0)
                    }, n.setBlendConstants = function(e) {
                        4 !== e.length || this._curBlendConstants[0] === e[0] && this._curBlendConstants[1] === e[1] && this._curBlendConstants[2] === e[2] && this._curBlendConstants[3] === e[3] || (this._curBlendConstants.length = 0, Array.prototype.push.apply(this._curBlendConstants, e), this._isStateInvalied = !0)
                    }, n.setDepthBound = function(e, t) {
                        this._curDepthBounds && this._curDepthBounds.minBounds === e && this._curDepthBounds.maxBounds === t || (this._curDepthBounds = {
                            minBounds: e,
                            maxBounds: t
                        }, this._isStateInvalied = !0)
                    }, n.setStencilWriteMask = function(e, t) {
                        this._curStencilWriteMask ? this._curStencilWriteMask.face === e && this._curStencilWriteMask.writeMask === t || (this._curStencilWriteMask.face = e, this._curStencilWriteMask.writeMask = t, this._isStateInvalied = !0) : (this._curStencilWriteMask = {
                            face: e,
                            writeMask: t
                        }, this._isStateInvalied = !0)
                    }, n.setStencilCompareMask = function(e, t, n) {
                        this._curStencilCompareMask ? this._curStencilCompareMask.face === e && this._curStencilCompareMask.reference === t && this._curStencilCompareMask.compareMask === n || (this._curStencilCompareMask.face = e, this._curStencilCompareMask.reference = t, this._curStencilCompareMask.compareMask = n, this._isStateInvalied = !0) : (this._curStencilCompareMask = {
                            face: e,
                            reference: t,
                            compareMask: n
                        }, this._isStateInvalied = !0)
                    }, n.draw = function(e) {
                        if (this._type === Ja.PRIMARY && this._isInRenderPass || this._type === Ja.SECONDARY) {
                            this._isStateInvalied && this.bindStates();
                            var t = this._webGLAllocator.drawCmdPool.alloc(pz);
                            t.drawInfo.vertexCount = e.vertexCount, t.drawInfo.firstVertex = e.firstVertex, t.drawInfo.indexCount = e.indexCount, t.drawInfo.firstIndex = e.firstIndex, t.drawInfo.vertexOffset = e.vertexOffset, t.drawInfo.instanceCount = e.instanceCount, t.drawInfo.firstInstance = e.firstInstance, this.cmdPackage.drawCmds.push(t), this.cmdPackage.cmds.push(sz.DRAW), ++this._numDrawCalls, this._numInstances += e.instanceCount;
                            var n = e.indexCount || e.vertexCount;
                            if (this._curGPUPipelineState) switch (this._curGPUPipelineState.glPrimitive) {
                                case 4:
                                    this._numTris += n / 3 * Math.max(e.instanceCount, 1);
                                    break;
                                case 5:
                                case 6:
                                    this._numTris += (n - 2) * Math.max(e.instanceCount, 1)
                            }
                        } else console.error("Command 'draw' must be recorded inside a render pass.")
                    }, n.updateBuffer = function(e, t, n) {
                        if (this._type === Ja.PRIMARY && !this._isInRenderPass || this._type === Ja.SECONDARY) {
                            var i = e.gpuBuffer;
                            if (i) {
                                var r, o = this._webGLAllocator.updateBufferCmdPool.alloc(mz),
                                    a = 0;
                                e.usage & xa.INDIRECT || (a = void 0 !== n ? n : t.byteLength), r = t, o.gpuBuffer = i, o.buffer = r, o.offset = 0, o.size = a, this.cmdPackage.updateBufferCmds.push(o), this.cmdPackage.cmds.push(sz.UPDATE_BUFFER)
                            }
                        } else console.error("Command 'updateBuffer' must be recorded outside a render pass.")
                    }, n.copyBuffersToTexture = function(e, t, n) {
                        if (this._type === Ja.PRIMARY && !this._isInRenderPass || this._type === Ja.SECONDARY) {
                            var i = t.gpuTexture;
                            if (i) {
                                var r = this._webGLAllocator.copyBufferToTextureCmdPool.alloc(gz);
                                r.gpuTexture = i, r.regions = n, r.buffers = e, this.cmdPackage.copyBufferToTextureCmds.push(r), this.cmdPackage.cmds.push(sz.COPY_BUFFER_TO_TEXTURE)
                            }
                        } else console.error("Command 'copyBufferToTexture' must be recorded outside a render pass.")
                    }, n.execute = function(e, t) {
                        for (var n = 0; n < t; ++n) {
                            for (var i = e[n], r = 0; r < i.cmdPackage.beginRenderPassCmds.length; ++r) {
                                var o = i.cmdPackage.beginRenderPassCmds.array[r];
                                ++o.refCount, this.cmdPackage.beginRenderPassCmds.push(o)
                            }
                            for (var a = 0; a < i.cmdPackage.bindStatesCmds.length; ++a) {
                                var s = i.cmdPackage.bindStatesCmds.array[a];
                                ++s.refCount, this.cmdPackage.bindStatesCmds.push(s)
                            }
                            for (var c = 0; c < i.cmdPackage.drawCmds.length; ++c) {
                                var l = i.cmdPackage.drawCmds.array[c];
                                ++l.refCount, this.cmdPackage.drawCmds.push(l)
                            }
                            for (var u = 0; u < i.cmdPackage.updateBufferCmds.length; ++u) {
                                var h = i.cmdPackage.updateBufferCmds.array[u];
                                ++h.refCount, this.cmdPackage.updateBufferCmds.push(h)
                            }
                            for (var _ = 0; _ < i.cmdPackage.copyBufferToTextureCmds.length; ++_) {
                                var f = i.cmdPackage.copyBufferToTextureCmds.array[_];
                                ++f.refCount, this.cmdPackage.copyBufferToTextureCmds.push(f)
                            }
                            this.cmdPackage.cmds.concat(i.cmdPackage.cmds.array), this._numDrawCalls += i._numDrawCalls, this._numInstances += i._numInstances, this._numTris += i._numTris
                        }
                    }, n.pipelineBarrier = function() {}, n.bindStates = function() {
                        var e = this._webGLAllocator.bindStatesCmdPool.alloc(dz);
                        e.gpuPipelineState = this._curGPUPipelineState, Array.prototype.push.apply(e.gpuDescriptorSets, this._curGPUDescriptorSets);
                        for (var t = 0; t < this._curDynamicOffsets.length; t++) Array.prototype.push.apply(e.dynamicOffsets, this._curDynamicOffsets[t]);
                        e.gpuInputAssembler = this._curGPUInputAssembler, e.viewport = this._curViewport, e.scissor = this._curScissor, e.lineWidth = this._curLineWidth, e.depthBias = this._curDepthBias, Array.prototype.push.apply(e.blendConstants, this._curBlendConstants), e.depthBounds = this._curDepthBounds, e.stencilWriteMask = this._curStencilWriteMask, e.stencilCompareMask = this._curStencilCompareMask, this.cmdPackage.bindStatesCmds.push(e), this.cmdPackage.cmds.push(sz.BIND_STATES), this._isStateInvalied = !1
                    }, K(t, [{
                        key: "webGLDevice",
                        get: function() {
                            return this._device
                        }
                    }]), t
                }(fc),
                Dz = function(e) {
                    function t() {
                        for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                        return (t = e.call.apply(e, [this].concat(i)) || this)._gpuFramebuffer = null, t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.initialize = function(e) {
                        this._renderPass = e.renderPass, this._colorTextures = e.colorTextures || [], this._depthStencilTexture = e.depthStencilTexture || null, 0 !== e.depthStencilMipmapLevel && console.warn("The mipmap level of th texture image to be attached of depth stencil attachment should be 0. Convert to 0.");
                        for (var t = 0; t < e.colorMipmapLevels.length; ++t) 0 !== e.colorMipmapLevels[t] && console.warn("The mipmap level of th texture image to be attached of color attachment " + t + " should be 0. Convert to 0.");
                        for (var n = [], i = 0; i < e.colorTextures.length; i++) {
                            var r = e.colorTextures[i];
                            r && n.push(r.gpuTexture)
                        }
                        var o = null;
                        return e.depthStencilTexture && (o = e.depthStencilTexture.gpuTexture), this._gpuFramebuffer = {
                                gpuRenderPass: e.renderPass.gpuRenderPass,
                                gpuColorTextures: n,
                                gpuDepthStencilTexture: o,
                                glFramebuffer: null
                            },
                            function(e, t) {
                                if (t.gpuColorTextures.length || t.gpuDepthStencilTexture) {
                                    var n = e.gl,
                                        i = [],
                                        r = n.createFramebuffer();
                                    if (r) {
                                        t.glFramebuffer = r, e.stateCache.glFramebuffer !== t.glFramebuffer && n.bindFramebuffer(n.FRAMEBUFFER, t.glFramebuffer);
                                        for (var o = 0; o < t.gpuColorTextures.length; ++o) {
                                            var a = t.gpuColorTextures[o];
                                            a && (a.glTexture ? n.framebufferTexture2D(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + o, a.glTarget, a.glTexture, 0) : n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + o, n.RENDERBUFFER, a.glRenderbuffer), i.push(n.COLOR_ATTACHMENT0 + o))
                                        }
                                        var s = t.gpuDepthStencilTexture;
                                        if (s) {
                                            var c = tc[s.format].hasStencil ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT;
                                            s.glTexture ? n.framebufferTexture2D(n.FRAMEBUFFER, c, s.glTarget, s.glTexture, 0) : n.framebufferRenderbuffer(n.FRAMEBUFFER, c, n.RENDERBUFFER, s.glRenderbuffer)
                                        }
                                        n.drawBuffers(i);
                                        var l = n.checkFramebufferStatus(n.FRAMEBUFFER);
                                        if (l !== n.FRAMEBUFFER_COMPLETE) switch (l) {
                                            case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                                                console.error("glCheckFramebufferStatus() - FRAMEBUFFER_INCOMPLETE_ATTACHMENT");
                                                break;
                                            case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                                                console.error("glCheckFramebufferStatus() - FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT");
                                                break;
                                            case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                                                console.error("glCheckFramebufferStatus() - FRAMEBUFFER_INCOMPLETE_DIMENSIONS");
                                                break;
                                            case n.FRAMEBUFFER_UNSUPPORTED:
                                                console.error("glCheckFramebufferStatus() - FRAMEBUFFER_UNSUPPORTED")
                                        }
                                        e.stateCache.glFramebuffer !== t.glFramebuffer && n.bindFramebuffer(n.FRAMEBUFFER, e.stateCache.glFramebuffer)
                                    }
                                }
                            }(this._device, this._gpuFramebuffer), !0
                    }, n.destroy = function() {
                        var e, t;
                        this._gpuFramebuffer && (e = this._device, (t = this._gpuFramebuffer).glFramebuffer && (e.gl.deleteFramebuffer(t.glFramebuffer), t.glFramebuffer = null), this._gpuFramebuffer = null)
                    }, K(t, [{
                        key: "gpuFramebuffer",
                        get: function() {
                            return this._gpuFramebuffer
                        }
                    }]), t
                }(pc),
                Nz = function(e) {
                    function t() {
                        for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                        return (t = e.call.apply(e, [this].concat(i)) || this)._gpuInputAssembler = null, t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.initialize = function(e) {
                        if (0 === e.vertexBuffers.length) return console.error("InputAssemblerInfo.vertexBuffers is null."), !1;
                        if (this._attributes = e.attributes, this._attributesHash = this.computeAttributesHash(), this._vertexBuffers = e.vertexBuffers, e.indexBuffer) this._indexBuffer = e.indexBuffer, this._indexCount = this._indexBuffer.size / this._indexBuffer.stride, this._firstIndex = 0;
                        else {
                            var t = this._vertexBuffers[0];
                            this._vertexCount = t.size / t.stride, this._firstVertex = 0, this._vertexOffset = 0
                        }
                        this._instanceCount = 0, this._firstInstance = 0, this._indirectBuffer = e.indirectBuffer || null;
                        for (var n = new Array(e.vertexBuffers.length), i = 0; i < e.vertexBuffers.length; ++i) {
                            var r = e.vertexBuffers[i];
                            r.gpuBuffer && (n[i] = r.gpuBuffer)
                        }
                        var o = null,
                            a = 0;
                        if (e.indexBuffer && (o = e.indexBuffer.gpuBuffer)) switch (o.stride) {
                            case 1:
                                a = 5121;
                                break;
                            case 2:
                                a = 5123;
                                break;
                            case 4:
                                a = 5125;
                                break;
                            default:
                                console.error("Illegal index buffer stride.")
                        }
                        var s = null;
                        return e.indirectBuffer && (s = e.indirectBuffer.gpuBuffer), this._gpuInputAssembler = {
                                attributes: e.attributes,
                                gpuVertexBuffers: n,
                                gpuIndexBuffer: o,
                                gpuIndirectBuffer: s,
                                glAttribs: [],
                                glIndexType: a,
                                glVAOs: new Map
                            },
                            function(e, t) {
                                var n = e.gl;
                                t.glAttribs = new Array(t.attributes.length);
                                for (var i = [0, 0, 0, 0, 0, 0, 0, 0], r = 0; r < t.attributes.length; ++r) {
                                    var o = t.attributes[r],
                                        a = void 0 !== o.stream ? o.stream : 0,
                                        s = t.gpuVertexBuffers[a],
                                        c = ez(o.format, n),
                                        l = tc[o.format].size;
                                    t.glAttribs[r] = {
                                        name: o.name,
                                        glBuffer: s.glBuffer,
                                        glType: c,
                                        size: l,
                                        count: tc[o.format].count,
                                        stride: s.stride,
                                        componentCount: az(c, n),
                                        isNormalized: void 0 !== o.isNormalized && o.isNormalized,
                                        isInstanced: void 0 !== o.isInstanced && o.isInstanced,
                                        offset: i[a]
                                    }, i[a] += l
                                }
                            }(this._device, this._gpuInputAssembler), !0
                    }, n.destroy = function() {
                        var e = this._device;
                        this._gpuInputAssembler && e.useVAO && function(e, t) {
                            for (var n = t.glVAOs.values(), i = n.next(); !i.done;) e.gl.deleteVertexArray(i.value), i = n.next();
                            t.glVAOs.clear()
                        }(e, this._gpuInputAssembler), this._gpuInputAssembler = null
                    }, K(t, [{
                        key: "gpuInputAssembler",
                        get: function() {
                            return this._gpuInputAssembler
                        }
                    }]), t
                }(yc),
                Mz = function(e) {
                    function t() {
                        for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                        return (t = e.call.apply(e, [this].concat(i)) || this)._gpuDescriptorSetLayout = null, t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.initialize = function(e) {
                        Array.prototype.push.apply(this._bindings, e.bindings);
                        for (var t = 0, n = -1, i = [], r = 0; r < this._bindings.length; r++) {
                            var o = this._bindings[r];
                            i.push(t), t += o.count, o.binding > n && (n = o.binding)
                        }
                        this._bindingIndices = Array(n + 1).fill(-1);
                        for (var a = this._descriptorIndices = Array(n + 1).fill(-1), s = 0; s < this._bindings.length; s++) {
                            var c = this._bindings[s];
                            this._bindingIndices[c.binding] = s, a[c.binding] = i[s]
                        }
                        for (var l = [], u = 0; u < this._bindings.length; u++) {
                            var h = this._bindings[u];
                            if (h.descriptorType & rc)
                                for (var _ = 0; _ < h.count; _++) l.push(h.binding)
                        }
                        return this._gpuDescriptorSetLayout = {
                            bindings: this._bindings,
                            dynamicBindings: l,
                            descriptorIndices: a,
                            descriptorCount: t
                        }, !0
                    }, n.destroy = function() {
                        this._bindings.length = 0
                    }, K(t, [{
                        key: "gpuDescriptorSetLayout",
                        get: function() {
                            return this._gpuDescriptorSetLayout
                        }
                    }]), t
                }(Ec),
                Lz = function(e) {
                    function t() {
                        for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                        return (t = e.call.apply(e, [this].concat(i)) || this)._gpuPipelineLayout = null, t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.initialize = function(e) {
                        Array.prototype.push.apply(this._setLayouts, e.setLayouts);
                        for (var t = [], n = [], i = 0, r = 0; r < this._setLayouts.length; r++) {
                            for (var o = this._setLayouts[r], a = o.gpuDescriptorSetLayout.dynamicBindings, s = Array(o.bindingIndices.length).fill(-1), c = 0; c < a.length; c++) {
                                var l = a[c];
                                s[l] < 0 && (s[l] = i + c)
                            }
                            n.push(o.gpuDescriptorSetLayout), t.push(s), i += a.length
                        }
                        return this._gpuPipelineLayout = {
                            gpuSetLayouts: n,
                            dynamicOffsetIndices: t,
                            dynamicOffsetCount: i
                        }, !0
                    }, n.destroy = function() {
                        this._setLayouts.length = 0
                    }, K(t, [{
                        key: "gpuPipelineLayout",
                        get: function() {
                            return this._gpuPipelineLayout
                        }
                    }]), t
                }(Tc),
                Bz = [0, 1, 3, 2, 0, 0, 0, 4, 5, 6, 0, 0, 0, 0],
                Fz = function(e) {
                    function t() {
                        for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                        return (t = e.call.apply(e, [this].concat(i)) || this)._gpuPipelineState = null, t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.initialize = function(e) {
                        this._primitive = e.primitive, this._shader = e.shader, this._pipelineLayout = e.pipelineLayout;
                        var t = this._bs;
                        if (e.blendState) {
                            var n = e.blendState,
                                i = n.targets;
                            i && i.forEach((function(e, n) {
                                t.setTarget(n, e)
                            })), void 0 !== n.isA2C && (t.isA2C = n.isA2C), void 0 !== n.isIndepend && (t.isIndepend = n.isIndepend), void 0 !== n.blendColor && (t.blendColor = n.blendColor)
                        }
                        Object.assign(this._rs, e.rasterizerState), Object.assign(this._dss, e.depthStencilState), this._is = e.inputState, this._renderPass = e.renderPass, this._dynamicStates = e.dynamicStates;
                        for (var r = [], o = 0; o < 31; o++) this._dynamicStates & 1 << o && r.push(1 << o);
                        return this._gpuPipelineState = {
                            glPrimitive: Bz[e.primitive],
                            gpuShader: e.shader.gpuShader,
                            gpuPipelineLayout: e.pipelineLayout.gpuPipelineLayout,
                            rs: e.rasterizerState,
                            dss: e.depthStencilState,
                            bs: e.blendState,
                            gpuRenderPass: e.renderPass.gpuRenderPass,
                            dynamicStates: r
                        }, !0
                    }, n.destroy = function() {
                        this._gpuPipelineState = null
                    }, K(t, [{
                        key: "gpuPipelineState",
                        get: function() {
                            return this._gpuPipelineState
                        }
                    }]), t
                }(wc),
                zz = [],
                Uz = function(e) {
                    function t() {
                        return e.apply(this, arguments) || this
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.beginRenderPass = function(e, t, n, i, r, o) {
                        Ez(this._device, e.gpuRenderPass, t.gpuFramebuffer, n, i, r, o), this._isInRenderPass = !0
                    }, n.draw = function(e) {
                        if (this._isInRenderPass) {
                            this._isStateInvalied && this.bindStates(), Az(this._device, e), ++this._numDrawCalls, this._numInstances += e.instanceCount;
                            var t = e.indexCount || e.vertexCount;
                            if (this._curGPUPipelineState) switch (this._curGPUPipelineState.glPrimitive) {
                                case 4:
                                    this._numTris += t / 3 * Math.max(e.instanceCount, 1);
                                    break;
                                case 5:
                                case 6:
                                    this._numTris += (t - 2) * Math.max(e.instanceCount, 1)
                            }
                        } else console.error("Command 'draw' must be recorded inside a render pass.")
                    }, n.updateBuffer = function(e, t, n) {
                        if (this._isInRenderPass) console.error("Command 'updateBuffer' must be recorded outside a render pass.");
                        else {
                            var i, r = e.gpuBuffer;
                            r && (i = void 0 !== n ? n : e.usage & xa.INDIRECT ? 0 : t.byteLength, yz(this._device, r, t, 0, i))
                        }
                    }, n.copyBuffersToTexture = function(e, t, n) {
                        if (this._isInRenderPass) console.error("Command 'copyBufferToTexture' must be recorded outside a render pass.");
                        else {
                            var i = t.gpuTexture;
                            i && bz(this._device, e, i, n)
                        }
                    }, n.execute = function(e, t) {
                        for (var n = 0; n < t; ++n) {
                            var i = e[n];
                            Cz(this._device, i.cmdPackage), this._numDrawCalls += i._numDrawCalls, this._numInstances += i._numInstances, this._numTris += i._numTris
                        }
                    }, n.bindStates = function() {
                        zz.length = 0;
                        for (var e = 0; e < this._curDynamicOffsets.length; e++) Array.prototype.push.apply(zz, this._curDynamicOffsets[e]);
                        Tz(this._device, this._curGPUPipelineState, this._curGPUInputAssembler, this._curGPUDescriptorSets, zz, this._curViewport, this._curScissor, this._curLineWidth, this._curDepthBias, this._curBlendConstants, this._curDepthBounds, this._curStencilWriteMask, this._curStencilCompareMask), this._isStateInvalied = !1
                    }, t
                }(Oz),
                Gz = function(e) {
                    function t() {
                        for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                        return (t = e.call.apply(e, [this].concat(i)) || this).numDrawCalls = 0, t.numInstances = 0, t.numTris = 0, t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.initialize = function(e) {
                        return this._type = e.type, !0
                    }, n.destroy = function() {}, n.submit = function(e) {
                        if (!this._isAsync)
                            for (var t = 0; t < e.length; t++) {
                                var n = e[t];
                                this.numDrawCalls += n.numDrawCalls, this.numInstances += n.numInstances, this.numTris += n.numTris
                            }
                    }, n.clear = function() {
                        this.numDrawCalls = 0, this.numInstances = 0, this.numTris = 0
                    }, t
                }(Ic),
                Hz = function(e) {
                    function t() {
                        for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                        return (t = e.call.apply(e, [this].concat(i)) || this)._gpuRenderPass = null, t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.initialize = function(e) {
                        return this._colorInfos = e.colorAttachments, this._depthStencilInfo = e.depthStencilAttachment, e.subpasses && (this._subpasses = e.subpasses), this._gpuRenderPass = {
                            colorAttachments: this._colorInfos,
                            depthStencilAttachment: this._depthStencilInfo
                        }, this._hash = this.computeHash(), !0
                    }, n.destroy = function() {
                        this._gpuRenderPass = null
                    }, K(t, [{
                        key: "gpuRenderPass",
                        get: function() {
                            return this._gpuRenderPass
                        }
                    }]), t
                }(Pc),
                kz = function(e) {
                    function t() {
                        for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                        return (t = e.call.apply(e, [this].concat(i)) || this)._gpuSampler = null, t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.initialize = function(e) {
                        var t, n, i, r;
                        return this._minFilter = e.minFilter, this._magFilter = e.magFilter, this._mipFilter = e.mipFilter, this._addressU = e.addressU, this._addressV = e.addressV, this._addressW = e.addressW, this._maxAnisotropy = e.maxAnisotropy, this._cmpFunc = e.cmpFunc, this._borderColor = e.borderColor, this._mipLODBias = e.mipLODBias, this._gpuSampler = {
                            glSampler: null,
                            minFilter: this._minFilter,
                            magFilter: this._magFilter,
                            mipFilter: this._mipFilter,
                            addressU: this._addressU,
                            addressV: this._addressV,
                            addressW: this._addressW,
                            glMinFilter: 0,
                            glMagFilter: 0,
                            glWrapS: 0,
                            glWrapT: 0,
                            glWrapR: 0
                        }, t = this._device, n = this._gpuSampler, (r = (i = t.gl).createSampler()) && (n.minFilter === Da.LINEAR || n.minFilter === Da.ANISOTROPIC ? n.mipFilter === Da.LINEAR || n.mipFilter === Da.ANISOTROPIC ? n.glMinFilter = i.LINEAR_MIPMAP_LINEAR : n.mipFilter === Da.POINT ? n.glMinFilter = i.LINEAR_MIPMAP_NEAREST : n.glMinFilter = i.LINEAR : n.mipFilter === Da.LINEAR || n.mipFilter === Da.ANISOTROPIC ? n.glMinFilter = i.NEAREST_MIPMAP_LINEAR : n.mipFilter === Da.POINT ? n.glMinFilter = i.NEAREST_MIPMAP_NEAREST : n.glMinFilter = i.NEAREST, n.magFilter === Da.LINEAR || n.magFilter === Da.ANISOTROPIC ? n.glMagFilter = i.LINEAR : n.glMagFilter = i.NEAREST, n.glWrapS = QF[n.addressU], n.glWrapT = QF[n.addressV], n.glWrapR = QF[n.addressW], n.glSampler = r, i.samplerParameteri(r, i.TEXTURE_MIN_FILTER, n.glMinFilter), i.samplerParameteri(r, i.TEXTURE_MAG_FILTER, n.glMagFilter), i.samplerParameteri(r, i.TEXTURE_WRAP_S, n.glWrapS), i.samplerParameteri(r, i.TEXTURE_WRAP_T, n.glWrapT), i.samplerParameteri(r, i.TEXTURE_WRAP_R, n.glWrapR), i.samplerParameterf(r, i.TEXTURE_MIN_LOD, 0), i.samplerParameterf(r, i.TEXTURE_MAX_LOD, 1e3)), !0
                    }, n.destroy = function() {
                        var e, t;
                        this._gpuSampler && (e = this._device, (t = this._gpuSampler).glSampler && (e.gl.deleteSampler(t.glSampler), t.glSampler = null), this._gpuSampler = null)
                    }, K(t, [{
                        key: "gpuSampler",
                        get: function() {
                            return this._gpuSampler
                        }
                    }]), t
                }(Oc),
                Vz = function(e) {
                    function t() {
                        for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                        return (t = e.call.apply(e, [this].concat(i)) || this)._gpuShader = null, t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.initialize = function(e) {
                        this._name = e.name, this._stages = e.stages, this._attributes = e.attributes, this._blocks = e.blocks, this._samplers = e.samplers, this._gpuShader = {
                            name: e.name,
                            blocks: e.blocks,
                            samplerTextures: e.samplerTextures,
                            gpuStages: new Array(e.stages.length),
                            glProgram: null,
                            glInputs: [],
                            glUniforms: [],
                            glBlocks: [],
                            glSamplerTextures: []
                        };
                        for (var t = 0; t < e.stages.length; ++t) {
                            var n = e.stages[t];
                            this._gpuShader.gpuStages[t] = {
                                type: n.stage,
                                source: n.source,
                                glShader: null
                            }
                        }
                        return function(e, t) {
                            for (var n = e.gl, i = function(e) {
                                    var i = t.gpuStages[e],
                                        r = 0,
                                        o = "",
                                        a = 1;
                                    switch (i.type) {
                                        case Ua.VERTEX:
                                            o = "VertexShader", r = n.VERTEX_SHADER;
                                            break;
                                        case Ua.FRAGMENT:
                                            o = "FragmentShader", r = n.FRAGMENT_SHADER;
                                            break;
                                        default:
                                            return console.error("Unsupported ShaderType."), {
                                                v: void 0
                                            }
                                    }
                                    var s = n.createShader(r);
                                    if (s && (i.glShader = s, n.shaderSource(i.glShader, "#version 300 es\n" + i.source), n.compileShader(i.glShader), !n.getShaderParameter(i.glShader, n.COMPILE_STATUS))) {
                                        console.error(o + " in '" + t.name + "' compilation failed."), console.error("Shader source dump:", i.source.replace(/^|\n/g, (function() {
                                            return "\n" + a++ + " "
                                        }))), console.error(n.getShaderInfoLog(i.glShader));
                                        for (var c = 0; c < t.gpuStages.length; c++) {
                                            var l = t.gpuStages[e];
                                            l.glShader && (n.deleteShader(l.glShader), l.glShader = null)
                                        }
                                        return {
                                            v: void 0
                                        }
                                    }
                                }, r = 0; r < t.gpuStages.length; r++) {
                                var o = i(r);
                                if ("object" == typeof o) return o.v
                            }
                            var a = n.createProgram();
                            if (a) {
                                t.glProgram = a;
                                for (var s = 0; s < t.gpuStages.length; s++) {
                                    var c = t.gpuStages[s];
                                    n.attachShader(t.glProgram, c.glShader)
                                }
                                n.linkProgram(t.glProgram);
                                for (var l = 0; l < t.gpuStages.length; l++) {
                                    var u = t.gpuStages[l];
                                    u.glShader && (n.detachShader(t.glProgram, u.glShader), n.deleteShader(u.glShader), u.glShader = null)
                                }
                                if (!n.getProgramParameter(t.glProgram, n.LINK_STATUS)) return console.error("Failed to link shader '" + t.name + "'."), void console.error(n.getProgramInfoLog(t.glProgram));
                                console.info("Shader '" + t.name + "' compilation succeeded.");
                                var h = n.getProgramParameter(t.glProgram, n.ACTIVE_ATTRIBUTES);
                                t.glInputs = new Array(h);
                                for (var _ = 0; _ < h; ++_) {
                                    var f = n.getActiveAttrib(t.glProgram, _);
                                    if (f) {
                                        var d, m = f.name.indexOf("[");
                                        d = -1 !== m ? f.name.substr(0, m) : f.name;
                                        var g = n.getAttribLocation(t.glProgram, d),
                                            v = rz(f.type, n),
                                            y = oz(f.type, n);
                                        t.glInputs[_] = {
                                            name: d,
                                            type: v,
                                            stride: y,
                                            count: f.size,
                                            size: y * f.size,
                                            glType: f.type,
                                            glLoc: g
                                        }
                                    }
                                }
                                var S, E, T, A, x = n.getProgramParameter(t.glProgram, n.ACTIVE_UNIFORM_BLOCKS);
                                if (x) {
                                    t.glBlocks = new Array(x);
                                    for (var C = 0; C < x; ++C) {
                                        var b = (S = n.getActiveUniformBlockName(t.glProgram, C)).indexOf("["); - 1 !== b && (S = S.substr(0, b)), A = null;
                                        for (var R = 0; R < t.blocks.length; R++)
                                            if (t.blocks[R].name === S) {
                                                A = t.blocks[R];
                                                break
                                            }
                                        if (A) {
                                            E = C, T = n.getActiveUniformBlockParameter(t.glProgram, E, n.UNIFORM_BLOCK_DATA_SIZE);
                                            var w = A.binding + (e.bindingMappingInfo.bufferOffsets[A.set] || 0);
                                            n.uniformBlockBinding(t.glProgram, E, w), t.glBlocks[C] = {
                                                set: A.set,
                                                binding: A.binding,
                                                idx: E,
                                                name: S,
                                                size: T,
                                                glBinding: w
                                            }
                                        } else p("Block '" + S + "' does not bound")
                                    }
                                }
                                if (t.samplerTextures.length > 0) {
                                    t.glSamplerTextures = new Array(t.samplerTextures.length);
                                    for (var I = 0; I < t.samplerTextures.length; ++I) {
                                        var P = t.samplerTextures[I];
                                        t.glSamplerTextures[I] = {
                                            set: P.set,
                                            binding: P.binding,
                                            name: P.name,
                                            type: P.type,
                                            count: P.count,
                                            units: [],
                                            glUnits: null,
                                            glType: iz(P.type, n),
                                            glLoc: null
                                        }
                                    }
                                }
                                for (var O = [], D = [], N = e.stateCache.texUnitCacheMap, M = 0, L = 0; L < t.blocks.length; ++L) t.blocks[L].set === e.bindingMappingInfo.flexibleSet && M++;
                                for (var B = 0, F = 0; F < t.samplerTextures.length; ++F) {
                                    var z = t.samplerTextures[F],
                                        U = n.getUniformLocation(t.glProgram, z.name);
                                    if (null === U || "number" != typeof U && -1 === U.id || (O.push(t.glSamplerTextures[F]), D.push(U)), void 0 === N[z.name]) {
                                        var G = z.binding + e.bindingMappingInfo.samplerOffsets[z.set] + B;
                                        z.set === e.bindingMappingInfo.flexibleSet && (G -= M), N[z.name] = G % e.capabilities.maxTextureUnits, B += z.count - 1
                                    }
                                }
                                if (O.length) {
                                    for (var H = [], k = 0; k < O.length; ++k) {
                                        var V = O[k],
                                            W = N[V.name];
                                        if (void 0 !== W) {
                                            V.glLoc = D[k];
                                            for (var j = 0; j < V.count; ++j) {
                                                for (; H[W];) W = (W + 1) % e.capabilities.maxTextureUnits;
                                                V.units.push(W), H[W] = !0
                                            }
                                        }
                                    }
                                    for (var q = 0, X = 0; X < O.length; ++X) {
                                        var Y = O[X];
                                        if (!Y.glLoc) {
                                            for (Y.glLoc = D[X]; H[q];) q++;
                                            for (var K = 0; K < Y.count; ++K) {
                                                for (; H[q];) q = (q + 1) % e.capabilities.maxTextureUnits;
                                                void 0 === N[Y.name] && (N[Y.name] = q), Y.units.push(q), H[q] = !0
                                            }
                                        }
                                    }
                                    e.stateCache.glProgram !== t.glProgram && n.useProgram(t.glProgram);
                                    for (var Z = 0; Z < O.length; Z++) {
                                        var Q = O[Z];
                                        Q.glUnits = new Int32Array(Q.units), n.uniform1iv(Q.glLoc, Q.glUnits)
                                    }
                                    e.stateCache.glProgram !== t.glProgram && n.useProgram(e.stateCache.glProgram)
                                }
                                t.glSamplerTextures = O
                            }
                        }(this._device, this._gpuShader), !0
                    }, n.destroy = function() {
                        var e, t;
                        this._gpuShader && (e = this._device, (t = this._gpuShader).glProgram && (e.gl.deleteProgram(t.glProgram), t.glProgram = null), this._gpuShader = null)
                    }, K(t, [{
                        key: "gpuShader",
                        get: function() {
                            return this._gpuShader
                        }
                    }]), t
                }(Dc),
                Wz = function() {
                    function e() {
                        this.glArrayBuffer = null, this.glElementArrayBuffer = null, this.glUniformBuffer = null, this.glBindUBOs = [], this.glBindUBOOffsets = [], this.glVAO = null, this.texUnit = 0, this.glTexUnits = [], this.glSamplerUnits = [], this.glRenderbuffer = null, this.glFramebuffer = null, this.glReadFramebuffer = null, this.viewport = new ds, this.scissorRect = new ss(0, 0, 0, 0), this.rs = new Ac, this.dss = new xc, this.bs = new bc, this.glProgram = null, this.glEnabledAttribLocs = [], this.glCurrentAttribLocs = [], this.texUnitCacheMap = {}
                    }
                    return e.prototype.initialize = function(e, t, n) {
                        for (var i = 0; i < e; ++i) this.glTexUnits.push({
                            glTexture: null
                        });
                        this.glSamplerUnits.length = e, this.glSamplerUnits.fill(null), this.glBindUBOs.length = t, this.glBindUBOs.fill(null), this.glBindUBOOffsets.length = t, this.glBindUBOOffsets.fill(0), this.glEnabledAttribLocs.length = n, this.glEnabledAttribLocs.fill(!1), this.glCurrentAttribLocs.length = n, this.glCurrentAttribLocs.fill(!1)
                    }, e
                }(),
                jz = function(e) {
                    function t() {
                        for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                        return (t = e.call.apply(e, [this].concat(i)) || this)._gpuTexture = null, t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.initialize = function(e) {
                        return "texture" in e ? (console.log("WebGL2 does not support texture view."), !1) : (this._type = e.type, this._usage = e.usage, this._format = e.format, this._width = e.width, this._height = e.height, this._depth = e.depth, this._layerCount = e.layerCount, this._levelCount = e.levelCount, this._samples = e.samples, this._flags = e.flags, this._isPowerOf2 = oc(this._width) && oc(this._height), this._size = sc(this._format, this.width, this.height, this.depth, this._levelCount) * this._layerCount, this._gpuTexture = {
                            type: this._type,
                            format: this._format,
                            usage: this._usage,
                            width: this._width,
                            height: this._height,
                            depth: this._depth,
                            size: this._size,
                            arrayLayer: this._layerCount,
                            mipLevel: this._levelCount,
                            samples: this._samples,
                            flags: this._flags,
                            isPowerOf2: this._isPowerOf2,
                            glTarget: 0,
                            glInternalFmt: 0,
                            glFormat: 0,
                            glType: 0,
                            glUsage: 0,
                            glTexture: null,
                            glRenderbuffer: null,
                            glWrapS: 0,
                            glWrapT: 0,
                            glMinFilter: 0,
                            glMagFilter: 0
                        }, function(e, t) {
                            var n = e.gl;
                            t.glInternalFmt = tz(t.format, n), t.glFormat = nz(t.format, n), t.glType = ez(t.format, n);
                            var i = t.width,
                                r = t.height;
                            switch (t.type) {
                                case wa.TEX2D:
                                    t.glTarget = n.TEXTURE_2D;
                                    var o = Math.max(i, r);
                                    if (o > e.capabilities.maxTextureSize && b(9100, o, e.capabilities.maxTextureSize), t.samples === Oa.X1) {
                                        var a = n.createTexture();
                                        if (a && t.size > 0) {
                                            t.glTexture = a;
                                            var s = e.stateCache.glTexUnits[e.stateCache.texUnit];
                                            if (s.glTexture !== t.glTexture && (n.bindTexture(n.TEXTURE_2D, t.glTexture), s.glTexture = t.glTexture), t.glInternalFmt === $B.COMPRESSED_RGB_ETC1_WEBGL) {
                                                var c = ac(t.format, 2, 2, 1),
                                                    l = new Uint8Array(c);
                                                n.compressedTexImage2D(n.TEXTURE_2D, 0, t.glInternalFmt, 2, 2, 0, l)
                                            } else if (t.flags & Pa.IMMUTABLE) n.texStorage2D(n.TEXTURE_2D, t.mipLevel, t.glInternalFmt, i, r);
                                            else if (tc[t.format].isCompressed)
                                                for (var u = 0; u < t.mipLevel; ++u) {
                                                    var h = ac(t.format, i, r, 1),
                                                        _ = new Uint8Array(h);
                                                    n.compressedTexImage2D(n.TEXTURE_2D, u, t.glInternalFmt, i, r, 0, _), i = Math.max(1, i >> 1), r = Math.max(1, r >> 1)
                                                } else
                                                    for (var f = 0; f < t.mipLevel; ++f) n.texImage2D(n.TEXTURE_2D, f, t.glInternalFmt, i, r, 0, t.glFormat, t.glType, null), i = Math.max(1, i >> 1), r = Math.max(1, r >> 1)
                                        } else n.deleteTexture(a)
                                    } else {
                                        var d = n.createRenderbuffer();
                                        d && t.size > 0 && (t.glRenderbuffer = d, e.stateCache.glRenderbuffer !== t.glRenderbuffer && (n.bindRenderbuffer(n.RENDERBUFFER, t.glRenderbuffer), e.stateCache.glRenderbuffer = t.glRenderbuffer), n.renderbufferStorageMultisample(n.RENDERBUFFER, JF[t.samples], t.glInternalFmt, t.width, t.height))
                                    }
                                    break;
                                case wa.CUBE:
                                    t.glTarget = n.TEXTURE_CUBE_MAP;
                                    var p = Math.max(i, r);
                                    p > e.capabilities.maxCubeMapTextureSize && b(9100, p, e.capabilities.maxTextureSize);
                                    var m = n.createTexture();
                                    if (m && t.size > 0) {
                                        t.glTexture = m;
                                        var g = e.stateCache.glTexUnits[e.stateCache.texUnit];
                                        if (g.glTexture !== t.glTexture && (n.bindTexture(n.TEXTURE_CUBE_MAP, t.glTexture), g.glTexture = t.glTexture), t.glInternalFmt === $B.COMPRESSED_RGB_ETC1_WEBGL)
                                            for (var v = 0; v < 6; ++v) {
                                                var y = ac(t.format, 2, 2, 1),
                                                    S = new Uint8Array(y);
                                                n.compressedTexImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + v, 0, t.glInternalFmt, 2, 2, 0, S)
                                            } else if (t.flags & Pa.IMMUTABLE) n.texStorage2D(n.TEXTURE_CUBE_MAP, t.mipLevel, t.glInternalFmt, i, r);
                                            else if (tc[t.format].isCompressed)
                                            for (var E = 0; E < t.mipLevel; ++E) {
                                                for (var T = ac(t.format, i, r, 1), A = new Uint8Array(T), x = 0; x < 6; ++x) n.compressedTexImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + x, E, t.glInternalFmt, i, r, 0, A);
                                                i = Math.max(1, i >> 1), r = Math.max(1, r >> 1)
                                            } else
                                                for (var C = 0; C < t.mipLevel; ++C) {
                                                    for (var R = 0; R < 6; ++R) n.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + R, C, t.glInternalFmt, i, r, 0, t.glFormat, t.glType, null);
                                                    i = Math.max(1, i >> 1), r = Math.max(1, r >> 1)
                                                }
                                    }
                                    break;
                                default:
                                    console.error("Unsupported TextureType, create texture failed."), t.type = wa.TEX2D, t.glTarget = n.TEXTURE_2D
                            }
                        }(this._device, this._gpuTexture), this._device.memoryStatus.textureSize += this._size, !0)
                    }, n.destroy = function() {
                        var e, t;
                        this._gpuTexture && (e = this._device, (t = this._gpuTexture).glTexture && (e.gl.deleteTexture(t.glTexture), t.glTexture = null), t.glRenderbuffer && (e.gl.deleteRenderbuffer(t.glRenderbuffer), t.glRenderbuffer = null), this._device.memoryStatus.textureSize -= this._size, this._gpuTexture = null)
                    }, n.resize = function(e, t) {
                        var n = this._size;
                        this._width = e, this._height = t, this._size = sc(this._format, this.width, this.height, this.depth, this._levelCount) * this._layerCount, this._gpuTexture && (this._gpuTexture.width = e, this._gpuTexture.height = t, this._gpuTexture.size = this._size, function(e, t) {
                            var n = e.gl;
                            t.glInternalFmt = tz(t.format, n), t.glFormat = nz(t.format, n), t.glType = ez(t.format, n);
                            var i = t.width,
                                r = t.height;
                            switch (t.type) {
                                case wa.TEX2D:
                                    t.glTarget = n.TEXTURE_2D;
                                    var o = Math.max(i, r);
                                    if (o > e.capabilities.maxTextureSize && b(9100, o, e.capabilities.maxTextureSize), t.samples === Oa.X1) {
                                        var a = e.stateCache.glTexUnits[e.stateCache.texUnit];
                                        if (a.glTexture !== t.glTexture && (n.bindTexture(n.TEXTURE_2D, t.glTexture), a.glTexture = t.glTexture), tc[t.format].isCompressed) {
                                            if (t.glInternalFmt !== $B.COMPRESSED_RGB_ETC1_WEBGL)
                                                for (var s = 0; s < t.mipLevel; ++s) {
                                                    var c = ac(t.format, i, r, 1),
                                                        l = new Uint8Array(c);
                                                    n.compressedTexImage2D(n.TEXTURE_2D, s, t.glInternalFmt, i, r, 0, l), i = Math.max(1, i >> 1), r = Math.max(1, r >> 1)
                                                }
                                        } else
                                            for (var u = 0; u < t.mipLevel; ++u) n.texImage2D(n.TEXTURE_2D, u, t.glInternalFmt, i, r, 0, t.glFormat, t.glType, null), i = Math.max(1, i >> 1), r = Math.max(1, r >> 1)
                                    } else {
                                        var h = n.createRenderbuffer();
                                        h && t.size > 0 && (t.glRenderbuffer = h, e.stateCache.glRenderbuffer !== t.glRenderbuffer && (n.bindRenderbuffer(n.RENDERBUFFER, t.glRenderbuffer), e.stateCache.glRenderbuffer = t.glRenderbuffer), n.renderbufferStorageMultisample(n.RENDERBUFFER, JF[t.samples], t.glInternalFmt, t.width, t.height))
                                    }
                                    break;
                                case wa.CUBE:
                                    t.type = wa.CUBE, t.glTarget = n.TEXTURE_CUBE_MAP;
                                    var _ = Math.max(i, r);
                                    _ > e.capabilities.maxCubeMapTextureSize && b(9100, _, e.capabilities.maxTextureSize);
                                    var f = e.stateCache.glTexUnits[e.stateCache.texUnit];
                                    if (f.glTexture !== t.glTexture && (n.bindTexture(n.TEXTURE_CUBE_MAP, t.glTexture), f.glTexture = t.glTexture), tc[t.format].isCompressed) {
                                        if (t.glInternalFmt !== $B.COMPRESSED_RGB_ETC1_WEBGL)
                                            for (var d = 0; d < 6; ++d) {
                                                i = t.width, r = t.height;
                                                for (var p = 0; p < t.mipLevel; ++p) {
                                                    var m = ac(t.format, i, r, 1),
                                                        g = new Uint8Array(m);
                                                    n.compressedTexImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + d, p, t.glInternalFmt, i, r, 0, g), i = Math.max(1, i >> 1), r = Math.max(1, r >> 1)
                                                }
                                            }
                                    } else
                                        for (var v = 0; v < 6; ++v) {
                                            i = t.width, r = t.height;
                                            for (var y = 0; y < t.mipLevel; ++y) n.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + v, y, t.glInternalFmt, i, r, 0, t.glFormat, t.glType, null), i = Math.max(1, i >> 1), r = Math.max(1, r >> 1)
                                        }
                                    break;
                                default:
                                    console.error("Unsupported TextureType, create texture failed."), t.type = wa.TEX2D, t.glTarget = n.TEXTURE_2D
                            }
                        }(this._device, this._gpuTexture), this._device.memoryStatus.textureSize -= n, this._device.memoryStatus.textureSize += this._size)
                    }, K(t, [{
                        key: "gpuTexture",
                        get: function() {
                            return this._gpuTexture
                        }
                    }]), t
                }(Nc),
                qz = "webglcontextlost",
                Xz = e("WebGL2Device", function(e) {
                    function t() {
                        for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                        return (t = e.call.apply(e, [this].concat(i)) || this).stateCache = new Wz, t.cmdAllocator = new Pz, t.nullTex2D = null, t.nullTexCube = null, t._webGL2RC = null, t._isAntialias = !0, t._isPremultipliedAlpha = !0, t._useVAO = !0, t._bindingMappingInfo = new ms, t._webGLContextLostHandler = null, t._extensions = null, t._EXT_texture_filter_anisotropic = null, t._OES_texture_float_linear = null, t._OES_texture_half_float_linear = null, t._EXT_color_buffer_float = null, t._EXT_disjoint_timer_query_webgl2 = null, t._WEBGL_compressed_texture_etc1 = null, t._WEBGL_compressed_texture_etc = null, t._WEBGL_compressed_texture_pvrtc = null, t._WEBGL_compressed_texture_astc = null, t._WEBGL_compressed_texture_s3tc = null, t._WEBGL_compressed_texture_s3tc_srgb = null, t._WEBGL_debug_renderer_info = null, t._WEBGL_texture_storage_multisample = null, t._WEBGL_debug_shaders = null, t._WEBGL_lose_context = null, t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.initialize = function(e) {
                        this._canvas = e.canvasElm, this._isAntialias = e.isAntialias, this._isPremultipliedAlpha = e.isPremultipliedAlpha, this._bindingMappingInfo = e.bindingMappingInfo, this._bindingMappingInfo.bufferOffsets.length || this._bindingMappingInfo.bufferOffsets.push(0), this._bindingMappingInfo.samplerOffsets.length || this._bindingMappingInfo.samplerOffsets.push(0);
                        try {
                            var t = {
                                alpha: rt.ENABLE_TRANSPARENT_CANVAS,
                                antialias: this._isAntialias,
                                depth: !0,
                                stencil: !0,
                                premultipliedAlpha: this._isPremultipliedAlpha,
                                preserveDrawingBuffer: !1,
                                powerPreference: "default",
                                failIfMajorPerformanceCaveat: !1
                            };
                            this._webGL2RC = this._canvas.getContext("webgl2", t)
                        } catch (e) {
                            return console.warn(e), !1
                        }
                        if (!this._webGL2RC) return console.warn("This device does not support WebGL2."), !1;
                        this._webGLContextLostHandler = this._onWebGLContextLost.bind(this), this._canvas.addEventListener(qz, this._onWebGLContextLost), this._canvas2D = document.createElement("canvas"), console.info("WebGL2 device initialized."), this._gfxAPI = va.WEBGL2, this._deviceName = "WebGL2";
                        var n = this._webGL2RC;
                        this._WEBGL_debug_renderer_info = this.getExtension("WEBGL_debug_renderer_info"), this._WEBGL_debug_renderer_info ? (this._renderer = n.getParameter(this._WEBGL_debug_renderer_info.UNMASKED_RENDERER_WEBGL), this._vendor = n.getParameter(this._WEBGL_debug_renderer_info.UNMASKED_VENDOR_WEBGL)) : (this._renderer = n.getParameter(n.RENDERER), this._vendor = n.getParameter(n.VENDOR)), this._version = n.getParameter(n.VERSION), this._caps.maxVertexAttributes = n.getParameter(n.MAX_VERTEX_ATTRIBS), this._caps.maxVertexUniformVectors = n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS), this._caps.maxFragmentUniformVectors = n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS), this._caps.maxTextureUnits = n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS), this._caps.maxVertexTextureUnits = n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS), this._caps.maxUniformBufferBindings = n.getParameter(n.MAX_UNIFORM_BUFFER_BINDINGS), this._caps.maxUniformBlockSize = n.getParameter(n.MAX_UNIFORM_BLOCK_SIZE), this._caps.maxTextureSize = n.getParameter(n.MAX_TEXTURE_SIZE), this._caps.maxCubeMapTextureSize = n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE), this._caps.uboOffsetAlignment = n.getParameter(n.UNIFORM_BUFFER_OFFSET_ALIGNMENT), this._caps.depthBits = n.getParameter(n.DEPTH_BITS), this._caps.stencilBits = n.getParameter(n.STENCIL_BITS), this.stateCache.initialize(this._caps.maxTextureUnits, this._caps.maxUniformBufferBindings, this._caps.maxVertexAttributes), this._devicePixelRatio = e.devicePixelRatio || 1, this._width = this._canvas.width, this._height = this._canvas.height, this._nativeWidth = Math.max(e.nativeWidth || this._width, 0), this._nativeHeight = Math.max(e.nativeHeight || this._height, 0), this._colorFmt = Ea.RGBA8, 32 === this._caps.depthBits ? 8 === this._caps.stencilBits ? this._depthStencilFmt = Ea.D32F_S8 : this._depthStencilFmt = Ea.D32F : 24 === this._caps.depthBits ? 8 === this._caps.stencilBits ? this._depthStencilFmt = Ea.D24S8 : this._depthStencilFmt = Ea.D24 : 8 === this._caps.stencilBits ? this._depthStencilFmt = Ea.D16S8 : this._depthStencilFmt = Ea.D16, this._extensions = n.getSupportedExtensions();
                        var i = "";
                        if (this._extensions) {
                            for (var r, o = te(this._extensions); !(r = o()).done;) i += r.value + " ";
                            console.debug("EXTENSIONS: " + i)
                        }
                        this._EXT_texture_filter_anisotropic = this.getExtension("EXT_texture_filter_anisotropic"), this._EXT_color_buffer_float = this.getExtension("EXT_color_buffer_float"), this._EXT_disjoint_timer_query_webgl2 = this.getExtension("EXT_disjoint_timer_query_webgl2"), this._OES_texture_float_linear = this.getExtension("OES_texture_float_linear"), this._OES_texture_half_float_linear = this.getExtension("OES_texture_half_float_linear"), this._WEBGL_compressed_texture_etc1 = this.getExtension("WEBGL_compressed_texture_etc1"), this._WEBGL_compressed_texture_etc = this.getExtension("WEBGL_compressed_texture_etc"), this._WEBGL_compressed_texture_pvrtc = this.getExtension("WEBGL_compressed_texture_pvrtc"), this._WEBGL_compressed_texture_astc = this.getExtension("WEBGL_compressed_texture_astc"), this._WEBGL_compressed_texture_s3tc = this.getExtension("WEBGL_compressed_texture_s3tc"), this._WEBGL_compressed_texture_s3tc_srgb = this.getExtension("WEBGL_compressed_texture_s3tc_srgb"), this._WEBGL_texture_storage_multisample = this.getExtension("WEBGL_texture_storage_multisample"), this._WEBGL_debug_shaders = this.getExtension("WEBGL_debug_shaders"), this._WEBGL_lose_context = this.getExtension("WEBGL_lose_context"), this._features.fill(!1), this._features[Sa.TEXTURE_FLOAT] = !0, this._features[Sa.TEXTURE_HALF_FLOAT] = !0, this._features[Sa.FORMAT_R11G11B10F] = !0, this._features[Sa.FORMAT_RGB8] = !0, this._features[Sa.FORMAT_D16] = !0, this._features[Sa.FORMAT_D24] = !0, this._features[Sa.FORMAT_D32F] = !0, this._features[Sa.FORMAT_D24S8] = !0, this._features[Sa.FORMAT_D32FS8] = !0, this._features[Sa.MSAA] = !0, this._features[Sa.ELEMENT_INDEX_UINT] = !0, this._features[Sa.INSTANCED_ARRAYS] = !0, this._features[Sa.MULTIPLE_RENDER_TARGETS] = !0, this._features[Sa.BLEND_MINMAX] = !0, this._EXT_color_buffer_float && (this._features[Sa.COLOR_FLOAT] = !0, this._features[Sa.COLOR_HALF_FLOAT] = !0), this._OES_texture_float_linear && (this._features[Sa.TEXTURE_FLOAT_LINEAR] = !0), this._OES_texture_half_float_linear && (this._features[Sa.TEXTURE_HALF_FLOAT_LINEAR] = !0);
                        var a = "";
                        this._WEBGL_compressed_texture_etc1 && (this._features[Sa.FORMAT_ETC1] = !0, a += "etc1 "), this._WEBGL_compressed_texture_etc && (this._features[Sa.FORMAT_ETC2] = !0, a += "etc2 "), this._WEBGL_compressed_texture_s3tc && (this._features[Sa.FORMAT_DXT] = !0, a += "dxt "), this._WEBGL_compressed_texture_pvrtc && (this._features[Sa.FORMAT_PVRTC] = !0, a += "pvrtc "), this._WEBGL_compressed_texture_astc && (this._features[Sa.FORMAT_ASTC] = !0, a += "astc "), console.info("RENDERER: " + this._renderer), console.info("VENDOR: " + this._vendor), console.info("VERSION: " + this._version), console.info("DPR: " + this._devicePixelRatio), console.info("SCREEN_SIZE: " + this._width + " x " + this._height), console.info("NATIVE_SIZE: " + this._nativeWidth + " x " + this._nativeHeight), console.info("MAX_VERTEX_ATTRIBS: " + this._caps.maxVertexAttributes), console.info("MAX_VERTEX_UNIFORM_VECTORS: " + this._caps.maxVertexUniformVectors), console.info("MAX_FRAGMENT_UNIFORM_VECTORS: " + this._caps.maxFragmentUniformVectors), console.info("MAX_TEXTURE_IMAGE_UNITS: " + this._caps.maxTextureUnits), console.info("MAX_VERTEX_TEXTURE_IMAGE_UNITS: " + this._caps.maxVertexTextureUnits), console.info("MAX_UNIFORM_BUFFER_BINDINGS: " + this._caps.maxUniformBufferBindings), console.info("MAX_UNIFORM_BLOCK_SIZE: " + this._caps.maxUniformBlockSize), console.info("DEPTH_BITS: " + this._caps.depthBits), console.info("STENCIL_BITS: " + this._caps.stencilBits), console.info("UNIFORM_BUFFER_OFFSET_ALIGNMENT: " + this._caps.uboOffsetAlignment), this._EXT_texture_filter_anisotropic && console.info("MAX_TEXTURE_MAX_ANISOTROPY_EXT: " + this._EXT_texture_filter_anisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT), console.info("USE_VAO: " + this._useVAO), console.info("COMPRESSED_FORMAT: " + a), this.initStates(n), this._queue = this.createQueue(new Zs(Qa.GRAPHICS)), this._cmdBuff = this.createCommandBuffer(new Ks(this._queue)), this.nullTex2D = this.createTexture(new Ts(wa.TEX2D, Ia.SAMPLED, Ea.RGBA8, 2, 2, Pa.GEN_MIPMAP)), this.nullTexCube = new jz(this), this.nullTexCube.initialize(new Ts(wa.CUBE, Ia.SAMPLED, Ea.RGBA8, 2, 2, Pa.GEN_MIPMAP, 6));
                        var s = new fs;
                        s.texExtent.width = 2, s.texExtent.height = 2;
                        var c = new Uint8Array(this.nullTex2D.size);
                        return c.fill(0), this.copyBuffersToTexture([c], this.nullTex2D, [s]), s.texSubres.layerCount = 6, this.copyBuffersToTexture([c, c, c, c, c, c], this.nullTexCube, [s]), !0
                    }, n.destroy = function() {
                        this._canvas && this._webGLContextLostHandler && (this._canvas.removeEventListener(qz, this._webGLContextLostHandler), this._webGLContextLostHandler = null), this.nullTex2D && (this.nullTex2D.destroy(), this.nullTex2D = null), this.nullTexCube && (this.nullTexCube.destroy(), this.nullTexCube = null), this._queue && (this._queue.destroy(), this._queue = null), this._cmdBuff && (this._cmdBuff.destroy(), this._cmdBuff = null), this._extensions = null, this._webGL2RC = null
                    }, n.resize = function(e, t) {
                        this._width === e && this._height === t || (console.info("Resizing device: " + e + "x" + t), this._canvas.width = e, this._canvas.height = t, this._width = e, this._height = t)
                    }, n.flushCommands = function() {}, n.acquire = function() {
                        this.cmdAllocator.releaseCmds()
                    }, n.present = function() {
                        var e = this._queue;
                        this._numDrawCalls = e.numDrawCalls, this._numInstances = e.numInstances, this._numTris = e.numTris, e.clear()
                    }, n.createCommandBuffer = function(e) {
                        var t = new(e.type === Ja.PRIMARY ? Uz : Oz)(this);
                        return t.initialize(e) ? t : null
                    }, n.createBuffer = function(e) {
                        var t = new wz(this);
                        return t.initialize(e) ? t : null
                    }, n.createTexture = function(e) {
                        var t = new jz(this);
                        return t.initialize(e) ? t : null
                    }, n.createSampler = function(e) {
                        var t = new kz(this);
                        return t.initialize(e) ? t : null
                    }, n.createDescriptorSet = function(e) {
                        var t = new ZF(this);
                        return t.initialize(e) ? t : null
                    }, n.createShader = function(e) {
                        var t = new Vz(this);
                        return t.initialize(e) ? t : null
                    }, n.createInputAssembler = function(e) {
                        var t = new Nz(this);
                        return t.initialize(e) ? t : null
                    }, n.createRenderPass = function(e) {
                        var t = new Hz(this);
                        return t.initialize(e) ? t : null
                    }, n.createFramebuffer = function(e) {
                        var t = new Dz(this);
                        return t.initialize(e) ? t : null
                    }, n.createDescriptorSetLayout = function(e) {
                        var t = new Mz(this);
                        return t.initialize(e) ? t : null
                    }, n.createPipelineLayout = function(e) {
                        var t = new Lz(this);
                        return t.initialize(e) ? t : null
                    }, n.createPipelineState = function(e) {
                        var t = new Fz(this);
                        return t.initialize(e) ? t : null
                    }, n.createQueue = function(e) {
                        var t = new Gz(this);
                        return t.initialize(e) ? t : null
                    }, n.createGlobalBarrier = function(e) {
                        var t = new Mc(this);
                        return t.initialize(e) ? t : null
                    }, n.createTextureBarrier = function(e) {
                        var t = new Lc(this);
                        return t.initialize(e) ? t : null
                    }, n.copyBuffersToTexture = function(e, t, n) {
                        bz(this, e, t.gpuTexture, n)
                    }, n.copyTexImagesToTexture = function(e, t, n) {
                        ! function(e, t, n, i) {
                            var r = e.gl,
                                o = e.stateCache.glTexUnits[e.stateCache.texUnit];
                            o.glTexture !== n.glTexture && (r.bindTexture(n.glTarget, n.glTexture), o.glTexture = n.glTexture);
                            var a = 0,
                                s = 0;
                            switch (n.glTarget) {
                                case r.TEXTURE_2D:
                                    for (var c = 0; c < i.length; c++) {
                                        var l = i[c];
                                        r.texSubImage2D(r.TEXTURE_2D, l.texSubres.mipLevel, l.texOffset.x, l.texOffset.y, n.glFormat, n.glType, t[a++])
                                    }
                                    break;
                                case r.TEXTURE_CUBE_MAP:
                                    for (var u = 0; u < i.length; u++) {
                                        var h = i[u],
                                            _ = h.texSubres.baseArrayLayer + h.texSubres.layerCount;
                                        for (s = h.texSubres.baseArrayLayer; s < _; ++s) r.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + s, h.texSubres.mipLevel, h.texOffset.x, h.texOffset.y, n.glFormat, n.glType, t[a++])
                                    }
                                    break;
                                default:
                                    console.error("Unsupported GL texture type, copy buffer to texture failed.")
                            }
                            n.flags & Pa.GEN_MIPMAP && r.generateMipmap(n.glTarget)
                        }(this, e, t.gpuTexture, n)
                    }, n.copyFramebufferToBuffer = function(e, t, n) {
                        var i = this._webGL2RC,
                            r = e.gpuFramebuffer,
                            o = r.gpuColorTextures[0].format,
                            a = nz(o, i),
                            s = ez(o, i),
                            c = uc(tc[o]),
                            l = this.stateCache.glFramebuffer;
                        this.stateCache.glFramebuffer !== r.glFramebuffer && (i.bindFramebuffer(i.FRAMEBUFFER, r.glFramebuffer), this.stateCache.glFramebuffer = r.glFramebuffer);
                        for (var u, h = new c(t), _ = te(n); !(u = _()).done;) {
                            var f = u.value,
                                d = f.texExtent.width,
                                p = f.texExtent.height;
                            i.readPixels(f.texOffset.x, f.texOffset.y, d, p, a, s, h)
                        }
                        this.stateCache.glFramebuffer !== l && (i.bindFramebuffer(i.FRAMEBUFFER, l), this.stateCache.glFramebuffer = l)
                    }, n.blitFramebuffer = function(e, t, n, i, r) {
                        ! function(e, t, n, i, r, o) {
                            var a = e.gl;
                            e.stateCache.glReadFramebuffer !== t.glFramebuffer && (a.bindFramebuffer(a.READ_FRAMEBUFFER, t.glFramebuffer), e.stateCache.glReadFramebuffer = t.glFramebuffer);
                            var s = n.glFramebuffer !== e.stateCache.glFramebuffer;
                            s && a.bindFramebuffer(a.DRAW_FRAMEBUFFER, n.glFramebuffer);
                            var c = 0;
                            t.gpuColorTextures.length > 0 && (c |= a.COLOR_BUFFER_BIT), t.gpuDepthStencilTexture && (c |= a.DEPTH_BUFFER_BIT, tc[t.gpuDepthStencilTexture.format].hasStencil && (c |= a.STENCIL_BUFFER_BIT));
                            var l = o === Da.LINEAR || o === Da.ANISOTROPIC ? a.LINEAR : a.NEAREST;
                            a.blitFramebuffer(i.x, i.y, i.x + i.width, i.y + i.height, r.x, r.y, r.x + r.width, r.y + r.height, c, l), s && a.bindFramebuffer(a.FRAMEBUFFER, e.stateCache.glFramebuffer)
                        }(this, e.gpuFramebuffer, t.gpuFramebuffer, n, i, r)
                    }, n.getExtension = function(e) {
                        for (var t = ["", "WEBKIT_", "MOZ_"], n = 0; n < t.length; ++n) {
                            var i = this.gl.getExtension(t[n] + e);
                            if (i) return i
                        }
                        return null
                    }, n.initStates = function(e) {
                        e.activeTexture(e.TEXTURE0), e.pixelStorei(e.PACK_ALIGNMENT, 1), e.pixelStorei(e.UNPACK_ALIGNMENT, 1), e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, !1), e.bindFramebuffer(e.FRAMEBUFFER, null), e.enable(e.SCISSOR_TEST), e.enable(e.CULL_FACE), e.cullFace(e.BACK), e.frontFace(e.CCW), e.polygonOffset(0, 0), e.enable(e.DEPTH_TEST), e.depthMask(!0), e.depthFunc(e.LESS), e.stencilFuncSeparate(e.FRONT, e.ALWAYS, 1, 65535), e.stencilOpSeparate(e.FRONT, e.KEEP, e.KEEP, e.KEEP), e.stencilMaskSeparate(e.FRONT, 65535), e.stencilFuncSeparate(e.BACK, e.ALWAYS, 1, 65535), e.stencilOpSeparate(e.BACK, e.KEEP, e.KEEP, e.KEEP), e.stencilMaskSeparate(e.BACK, 65535), e.disable(e.STENCIL_TEST), e.disable(e.SAMPLE_ALPHA_TO_COVERAGE), e.disable(e.BLEND), e.blendEquationSeparate(e.FUNC_ADD, e.FUNC_ADD), e.blendFuncSeparate(e.ONE, e.ZERO, e.ONE, e.ZERO), e.colorMask(!0, !0, !0, !0), e.blendColor(0, 0, 0, 0)
                    }, n._onWebGLContextLost = function(e) {
                        x(11e3), d(e)
                    }, K(t, [{
                        key: "gl",
                        get: function() {
                            return this._webGL2RC
                        }
                    }, {
                        key: "isAntialias",
                        get: function() {
                            return this._isAntialias
                        }
                    }, {
                        key: "isPremultipliedAlpha",
                        get: function() {
                            return this._isPremultipliedAlpha
                        }
                    }, {
                        key: "useVAO",
                        get: function() {
                            return this._useVAO
                        }
                    }, {
                        key: "bindingMappingInfo",
                        get: function() {
                            return this._bindingMappingInfo
                        }
                    }, {
                        key: "EXT_texture_filter_anisotropic",
                        get: function() {
                            return this._EXT_texture_filter_anisotropic
                        }
                    }, {
                        key: "OES_texture_float_linear",
                        get: function() {
                            return this._OES_texture_float_linear
                        }
                    }, {
                        key: "EXT_color_buffer_float",
                        get: function() {
                            return this._EXT_color_buffer_float
                        }
                    }, {
                        key: "EXT_disjoint_timer_query_webgl2",
                        get: function() {
                            return this._EXT_disjoint_timer_query_webgl2
                        }
                    }, {
                        key: "WEBGL_compressed_texture_etc1",
                        get: function() {
                            return this._WEBGL_compressed_texture_etc1
                        }
                    }, {
                        key: "WEBGL_compressed_texture_etc",
                        get: function() {
                            return this._WEBGL_compressed_texture_etc
                        }
                    }, {
                        key: "WEBGL_compressed_texture_pvrtc",
                        get: function() {
                            return this._WEBGL_compressed_texture_pvrtc
                        }
                    }, {
                        key: "WEBGL_compressed_texture_s3tc",
                        get: function() {
                            return this._WEBGL_compressed_texture_s3tc
                        }
                    }, {
                        key: "WEBGL_compressed_texture_s3tc_srgb",
                        get: function() {
                            return this._WEBGL_compressed_texture_s3tc_srgb
                        }
                    }, {
                        key: "WEBGL_texture_storage_multisample",
                        get: function() {
                            return this._WEBGL_texture_storage_multisample
                        }
                    }, {
                        key: "WEBGL_debug_shaders",
                        get: function() {
                            return this._WEBGL_debug_shaders
                        }
                    }, {
                        key: "WEBGL_lose_context",
                        get: function() {
                            return this._WEBGL_lose_context
                        }
                    }]), t
                }(dc));
            i.WebGL2Device = Xz,
                function(e) {
                    e[e.positions = is.ATTR_POSITION] = "positions", e[e.normals = is.ATTR_NORMAL] = "normals", e[e.uvs = is.ATTR_TEX_COORD] = "uvs", e[e.colors = is.ATTR_COLOR] = "colors"
                }(Rz || (Rz = {}));
            var Yz, Kz, Zz, Qz, Jz, $z, eU = function() {
                    function e() {
                        this._arrayBufferOrPaddings = [], this._length = 0
                    }
                    var t = e.prototype;
                    return t.setNextAlignment = function(e) {
                        if (0 !== e) {
                            var t = this._length % e;
                            if (0 !== t) {
                                var n = e - t;
                                this._arrayBufferOrPaddings.push(n), this._length += n
                            }
                        }
                    }, t.addBuffer = function(e) {
                        var t = this._length;
                        return this._arrayBufferOrPaddings.push(e), this._length += e.byteLength, t
                    }, t.getLength = function() {
                        return this._length
                    }, t.getCombined = function() {
                        var e = new Uint8Array(this._length),
                            t = 0;
                        return this._arrayBufferOrPaddings.forEach((function(n) {
                            "number" == typeof n ? t += n : (e.set(new Uint8Array(n), t), t += n.byteLength)
                        })), e.buffer
                    }, e
                }(),
                tU = function() {
                    function e(e, t) {
                        if (this._mesh = void 0, this._subMeshRenderings = [], this._mesh = e, this._mesh.struct.morph) {
                            var n = this._mesh.struct.primitives.length;
                            this._subMeshRenderings = new Array(n).fill(null);
                            for (var i = 0; i < n; ++i) {
                                var r = this._mesh.struct.morph.subMeshMorphs[i];
                                r && (r.targets.length > Ih.MAX_MORPH_TARGET_COUNT ? this._subMeshRenderings[i] = new iU(this._mesh, i, this._mesh.struct.morph, t) : this._subMeshRenderings[i] = new nU(this._mesh, i, this._mesh.struct.morph, t))
                            }
                        }
                    }
                    return e.prototype.createInstance = function() {
                        for (var e = this, t = this._mesh.struct.primitives.length, n = new Array(t), i = 0; i < t; ++i) {
                            var r, o;
                            n[i] = null !== (r = null === (o = this._subMeshRenderings[i]) || void 0 === o ? void 0 : o.createInstance()) && void 0 !== r ? r : null
                        }
                        return {
                            setWeights: function(e, t) {
                                var i;
                                null === (i = n[e]) || void 0 === i || i.setWeights(t)
                            },
                            requiredPatches: function(t) {
                                e._mesh.struct.morph;
                                var i = e._mesh.struct.morph.subMeshMorphs[t],
                                    r = n[t];
                                if (null === r) return null;
                                var o = [{
                                    name: "CC_USE_MORPH",
                                    value: !0
                                }, {
                                    name: "CC_MORPH_TARGET_COUNT",
                                    value: i.targets.length
                                }];
                                return i.attributes.includes(is.ATTR_POSITION) && o.push({
                                    name: "CC_MORPH_TARGET_HAS_POSITION",
                                    value: !0
                                }), i.attributes.includes(is.ATTR_NORMAL) && o.push({
                                    name: "CC_MORPH_TARGET_HAS_NORMAL",
                                    value: !0
                                }), i.attributes.includes(is.ATTR_TANGENT) && o.push({
                                    name: "CC_MORPH_TARGET_HAS_TANGENT",
                                    value: !0
                                }), o.push.apply(o, r.requiredPatches()), o
                            },
                            adaptPipelineState: function(e, t) {
                                var i;
                                null === (i = n[e]) || void 0 === i || i.adaptPipelineState(t)
                            },
                            destroy: function() {
                                for (var e, t = te(n); !(e = t()).done;) {
                                    var i = e.value;
                                    null == i || i.destroy()
                                }
                            }
                        }
                    }, e
                }(),
                nU = function() {
                    function e(e, t, n, i) {
                        this._gfxDevice = void 0, this._subMeshMorph = void 0, this._textureInfo = void 0, this._attributes = void 0, this._verticesCount = void 0, this._gfxDevice = i;
                        var r = n.subMeshMorphs[t];
                        this._subMeshMorph = r, sU(e, t, i);
                        var o = e.struct.vertexBundles[e.struct.primitives[t].vertexBundelIndices[0]].view.count;
                        this._verticesCount = o;
                        var a = r.targets.length,
                            s = aU(i, o * a);
                        this._textureInfo = {
                            width: s.width,
                            height: s.height
                        }, this._attributes = r.attributes.map((function(t, n) {
                            var i = s.create(),
                                a = i.valueView;
                            return r.targets.forEach((function(t, i) {
                                for (var r = t.displacements[n], s = new Float32Array(e.data.buffer, e.data.byteOffset + r.offset, r.count), c = o * i * 4, l = 0; l < o; ++l) a[c + 4 * l + 0] = s[3 * l + 0], a[c + 4 * l + 1] = s[3 * l + 1], a[c + 4 * l + 2] = s[3 * l + 2]
                            })), i.updatePixels(), {
                                name: t,
                                morphTexture: i
                            }
                        }))
                    }
                    var t = e.prototype;
                    return t.destroy = function() {
                        for (var e, t = te(this._attributes); !(e = t()).done;) e.value.morphTexture.destroy()
                    }, t.createInstance = function() {
                        var e = this,
                            t = new oU(this._gfxDevice, this._subMeshMorph.targets.length);
                        return t.setMorphTextureInfo(this._textureInfo.width, this._textureInfo.height), t.setVerticesCount(this._verticesCount), t.commit(), {
                            setWeights: function(e) {
                                t.setWeights(e), t.commit()
                            },
                            requiredPatches: function() {
                                return [{
                                    name: "CC_MORPH_TARGET_USE_TEXTURE",
                                    value: !0
                                }]
                            },
                            adaptPipelineState: function(n) {
                                for (var i, r = te(e._attributes); !(i = r()).done;) {
                                    var o = i.value,
                                        a = void 0;
                                    switch (o.name) {
                                        case is.ATTR_POSITION:
                                            a = Nh;
                                            break;
                                        case is.ATTR_NORMAL:
                                            a = Bh;
                                            break;
                                        case is.ATTR_TANGENT:
                                            a = Uh;
                                            break;
                                        default:
                                            d("Unexpected attribute!")
                                    }
                                    void 0 !== a && (n.bindSampler(a, o.morphTexture.sampler), n.bindTexture(a, o.morphTexture.texture))
                                }
                                n.bindBuffer(Ih.BINDING, t.buffer), n.update()
                            },
                            destroy: function() {}
                        }
                    }, e
                }(),
                iU = function() {
                    function e(e, t, n, i) {
                        this._gfxDevice = void 0, this._attributes = [], this._gfxDevice = i;
                        var r = n.subMeshMorphs[t];
                        sU(e, t, i), this._attributes = r.attributes.map((function(t, n) {
                            return {
                                name: t,
                                targets: r.targets.map((function(t) {
                                    return {
                                        displacements: new Float32Array(e.data.buffer, e.data.byteOffset + t.displacements[n].offset, t.displacements[n].count)
                                    }
                                }))
                            }
                        }))
                    }
                    return e.prototype.createInstance = function() {
                        return new rU(this, this._attributes[0].targets[0].displacements.length / 3, this._gfxDevice)
                    }, K(e, [{
                        key: "data",
                        get: function() {
                            return this._attributes
                        }
                    }]), e
                }(),
                rU = function() {
                    function e(e, t, n) {
                        this._attributes = void 0, this._owner = void 0, this._morphUniforms = void 0, this._owner = e, this._morphUniforms = new oU(n, 0);
                        var i = aU(n, t);
                        this._morphUniforms.setMorphTextureInfo(i.width, i.height), this._morphUniforms.commit(), this._attributes = this._owner.data.map((function(e) {
                            var t = i.create();
                            return {
                                attributeName: e.name,
                                morphTexture: t
                            }
                        }))
                    }
                    var t = e.prototype;
                    return t.setWeights = function(e) {
                        for (var t = 0; t < this._attributes.length; ++t) {
                            var n = this._attributes[t],
                                i = n.morphTexture.valueView,
                                r = this._owner.data[t];
                            e.length, r.targets.length;
                            for (var o = 0; o < r.targets.length; ++o) {
                                var a = r.targets[o].displacements,
                                    s = e[o],
                                    c = a.length / 3;
                                if (0 === o)
                                    for (var l = 0; l < c; ++l) i[4 * l + 0] = a[3 * l + 0] * s, i[4 * l + 1] = a[3 * l + 1] * s, i[4 * l + 2] = a[3 * l + 2] * s;
                                else if (0 !== s)
                                    for (var u = 0; u < c; ++u) i[4 * u + 0] += a[3 * u + 0] * s, i[4 * u + 1] += a[3 * u + 1] * s, i[4 * u + 2] += a[3 * u + 2] * s
                            }
                            n.morphTexture.updatePixels()
                        }
                    }, t.requiredPatches = function() {
                        return [{
                            name: "CC_MORPH_TARGET_USE_TEXTURE",
                            value: !0
                        }, {
                            name: "CC_MORPH_PRECOMPUTED",
                            value: !0
                        }]
                    }, t.adaptPipelineState = function(e) {
                        for (var t, n = te(this._attributes); !(t = n()).done;) {
                            var i = t.value,
                                r = void 0;
                            switch (i.attributeName) {
                                case is.ATTR_POSITION:
                                    r = Nh;
                                    break;
                                case is.ATTR_NORMAL:
                                    r = Bh;
                                    break;
                                case is.ATTR_TANGENT:
                                    r = Uh;
                                    break;
                                default:
                                    d("Unexpected attribute!")
                            }
                            void 0 !== r && (e.bindSampler(r, i.morphTexture.sampler), e.bindTexture(r, i.morphTexture.texture))
                        }
                        e.bindBuffer(Ih.BINDING, this._morphUniforms.buffer), e.update()
                    }, t.destroy = function() {
                        this._morphUniforms.destroy();
                        for (var e = 0; e < this._attributes.length; ++e) this._attributes[e].morphTexture.destroy()
                    }, e
                }(),
                oU = function() {
                    function e(e, t) {
                        this._targetCount = void 0, this._localBuffer = void 0, this._remoteBuffer = void 0, this._targetCount = t, this._localBuffer = new DataView(new ArrayBuffer(Ih.SIZE)), this._remoteBuffer = e.createBuffer(new gs(xa.UNIFORM | xa.TRANSFER_DST, Ra.HOST | Ra.DEVICE, Ih.SIZE, Ih.SIZE))
                    }
                    var t = e.prototype;
                    return t.destroy = function() {
                        this._remoteBuffer.destroy()
                    }, t.setWeights = function(e) {
                        e.length, this._targetCount;
                        for (var t = 0; t < e.length; ++t) this._localBuffer.setFloat32(Ih.OFFSET_OF_WEIGHTS + 4 * t, e[t], i.sys.isLittleEndian)
                    }, t.setMorphTextureInfo = function(e, t) {
                        this._localBuffer.setFloat32(Ih.OFFSET_OF_DISPLACEMENT_TEXTURE_WIDTH, e, i.sys.isLittleEndian), this._localBuffer.setFloat32(Ih.OFFSET_OF_DISPLACEMENT_TEXTURE_HEIGHT, t, i.sys.isLittleEndian)
                    }, t.setVerticesCount = function(e) {
                        this._localBuffer.setFloat32(Ih.OFFSET_OF_VERTICES_COUNT, e, i.sys.isLittleEndian)
                    }, t.commit = function() {
                        this._remoteBuffer.update(this._localBuffer.buffer)
                    }, K(e, [{
                        key: "buffer",
                        get: function() {
                            return this._remoteBuffer
                        }
                    }]), e
                }();

            function aU(e, t) {
                var n, i, r, o;
                e.hasFeature(Sa.TEXTURE_FLOAT) ? (n = t, r = 16, i = yp.PixelFormat.RGBA32F, o = Float32Array) : (n = 4 * t, r = 4, i = yp.PixelFormat.RGBA8888, o = Uint8Array);
                var a = function(e) {
                        e < 5 && (e = 5);
                        var t = M(B(e)),
                            n = t >> 1;
                        return {
                            width: 1 << (1 & t ? n + 1 : n),
                            height: 1 << n
                        }
                    }(n),
                    s = a.width,
                    c = a.height;
                return {
                    width: s,
                    height: c,
                    create: function() {
                        var t = new ArrayBuffer(s * c * r),
                            n = new Float32Array(t),
                            a = o === Float32Array ? n : new o(t),
                            l = new Wf({
                                width: s,
                                height: c,
                                _data: a,
                                _compressed: !1,
                                format: i
                            }),
                            u = new yp;
                        u.setFilters(yp.Filter.NEAREST, yp.Filter.NEAREST), u.setMipFilter(yp.Filter.NONE), u.setWrapMode(yp.WrapMode.CLAMP_TO_EDGE, yp.WrapMode.CLAMP_TO_EDGE, yp.WrapMode.CLAMP_TO_EDGE), u.image = l, u.getGFXTexture() || d("Unexpected: failed to create morph texture?");
                        var h = cd.getSampler(e, u.getSamplerHash());
                        return {
                            get texture() {
                                return u.getGFXTexture()
                            },
                            get sampler() {
                                return h
                            },
                            get valueView() {
                                return n
                            },
                            destroy: function() {
                                u.destroy()
                            },
                            updatePixels: function() {
                                u.uploadData(a)
                            }
                        }
                    }
                }
            }

            function sU(e, t, n) {
                e.renderingSubMeshes[t].enableVertexIdChannel(n)
            }

            function cU(e) {
                switch (e) {
                    case 1:
                        return Uint8Array;
                    case 2:
                        return Uint16Array;
                    case 4:
                        return Uint32Array;
                    default:
                        return Uint8Array
                }
            }
            var lU = new En,
                uU = new En,
                hU = new Uint8Array,
                _U = e("Mesh", A_("cc.Mesh")(($z = function(e) {
                    function t() {
                        var t;
                        return (t = e.call(this) || this).morphRendering = null, ne(t, "_struct", Zz, $(t)), ne(t, "_dataLength", Qz, $(t)), ne(t, "_hash", Jz, $(t)), t._data = hU, t._initialized = !1, t._renderingSubMeshes = null, t._boneSpaceBounds = new Map, t._jointBufferIndices = null, t.loaded = !1, t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.initialize = function() {
                        var e = this;
                        if (!this._initialized) {
                            this._initialized = !0, this._data.byteLength !== this._dataLength && (this._data = new Uint8Array(this._dataLength), i.assetManager.postLoadNative(this));
                            for (var t = this._data.buffer, n = i.director.root.device, r = this._createVertexBuffers(n, t), o = [], a = function(i) {
                                    var a = e._struct.primitives[i];
                                    if (0 === a.vertexBundelIndices.length) return "continue";
                                    var s = null,
                                        c = null;
                                    if (a.indexView) {
                                        var l = a.indexView,
                                            u = l.stride,
                                            h = l.length;
                                        if (4 === u && !n.hasFeature(Sa.ELEMENT_INDEX_UINT)) {
                                            var _ = e._struct.vertexBundles[a.vertexBundelIndices[0]].view.count;
                                            if (_ >= 65536) return x(10001, _, 65536), "continue";
                                            u >>= 1, h >>= 1
                                        }
                                        s = n.createBuffer(new gs(xa.INDEX, Ra.DEVICE, h, u)), c = new(cU(l.stride))(t, l.offset, l.count), l.stride !== u && (c = cU(u).from(c)), e.loaded ? s.update(c) : e.once("load", (function() {
                                            s.update(c)
                                        }))
                                    }
                                    var f = a.vertexBundelIndices.map((function(e) {
                                            return r[e]
                                        })),
                                        d = [];
                                    if (a.vertexBundelIndices.length > 0)
                                        for (var p = a.vertexBundelIndices[0], m = e._struct.vertexBundles[p].attributes, g = 0; g < m.length; ++g) {
                                            var v = m[g];
                                            d[g] = new Ms(v.name, v.format, v.isInstanced, v.stream, v.isInstanced, v.location)
                                        }
                                    var y = new YR(f, d, a.primitiveMode, s);
                                    y.mesh = e, y.subMeshIdx = i, o.push(y)
                                }, s = 0; s < this._struct.primitives.length; s++) a(s);
                            this._renderingSubMeshes = o, this._struct.morph && (this.morphRendering = function(e, t) {
                                return new tU(e, t)
                            }(this, n))
                        }
                    }, n.destroy = function() {
                        return this.destroyRenderingMesh(), e.prototype.destroy.call(this)
                    }, n.destroyRenderingMesh = function() {
                        if (this._renderingSubMeshes) {
                            for (var e = 0; e < this._renderingSubMeshes.length; e++) this._renderingSubMeshes[e].destroy();
                            this._renderingSubMeshes = null, this._initialized = !1
                        }
                    }, n.assign = function(e, t) {
                        this.reset({
                            struct: e,
                            data: t
                        })
                    }, n.reset = function(e) {
                        this.destroyRenderingMesh(), this._struct = e.struct, this._data = e.data, this._dataLength = this.data.byteLength, this._hash = 0, this.loaded = !0, this.emit("load")
                    }, n.getBoneSpaceBounds = function(e) {
                        if (this._boneSpaceBounds.has(e.hash)) return this._boneSpaceBounds.get(e.hash);
                        var t = [];
                        this._boneSpaceBounds.set(e.hash, t);
                        for (var n = [], i = e.bindposes, r = 0; r < i.length; r++) t.push(new tu(1 / 0, 1 / 0, 1 / 0, -1 / 0, -1 / 0, -1 / 0)), n.push(!1);
                        for (var o = this._struct.primitives, a = 0; a < o.length; a++) {
                            var s = this.readAttribute(a, is.ATTR_JOINTS),
                                c = this.readAttribute(a, is.ATTR_WEIGHTS),
                                l = this.readAttribute(a, is.ATTR_POSITION);
                            if (s && c && l)
                                for (var u = Math.min(s.length / 4, c.length / 4, l.length / 3), h = 0; h < u; h++) {
                                    En.set(lU, l[3 * h + 0], l[3 * h + 1], l[3 * h + 2]);
                                    for (var _ = 0; _ < 4; ++_) {
                                        var f = 4 * h + _,
                                            d = s[f];
                                        if (!(0 === c[f] || d >= i.length)) {
                                            En.transformMat4(uU, lU, i[d]), n[d] = !0;
                                            var p = t[d];
                                            En.min(p.center, p.center, uU), En.max(p.halfExtents, p.halfExtents, uU)
                                        }
                                    }
                                }
                        }
                        for (var m = 0; m < i.length; m++) {
                            var g = t[m];
                            n[m] ? tu.fromPoints(g, g.center, g.halfExtents) : t[m] = null
                        }
                        return t
                    }, n.merge = function(e, t, n) {
                        if (n && (!this.loaded || !e.loaded || !this.validateMergingMesh(e))) return !1;
                        var i = new En,
                            r = t && new wn,
                            o = t && new tu;
                        if (r && t.getRotation(r), !this._initialized) {
                            var a = JSON.parse(JSON.stringify(e._struct)),
                                s = e._data.slice();
                            if (t) {
                                a.maxPosition && a.minPosition && (En.add(o.center, a.maxPosition, a.minPosition), En.multiplyScalar(o.center, o.center, .5), En.subtract(o.halfExtents, a.maxPosition, a.minPosition), En.multiplyScalar(o.halfExtents, o.halfExtents, .5), tu.transform(o, o, t), En.add(a.maxPosition, o.center, o.halfExtents), En.subtract(a.minPosition, o.center, o.halfExtents));
                                for (var c = 0; c < a.vertexBundles.length; c++)
                                    for (var l = a.vertexBundles[c], u = 0; u < l.attributes.length; u++)
                                        if (l.attributes[u].name === is.ATTR_POSITION || l.attributes[u].name === is.ATTR_NORMAL) {
                                            var h = l.attributes[u].format,
                                                _ = new DataView(s.buffer, l.view.offset + fU(l.attributes, u)),
                                                f = mU(_, h),
                                                d = gU(_, h);
                                            if (!f || !d) continue;
                                            for (var p = l.view.count, m = l.view.stride, g = pU(h), v = 0; v < p; v++) {
                                                var y = v * m,
                                                    S = y + g,
                                                    E = S + g;
                                                switch (i.set(f(y), f(S), f(E)), l.attributes[u].name) {
                                                    case is.ATTR_POSITION:
                                                        i.transformMat4(t);
                                                        break;
                                                    case is.ATTR_NORMAL:
                                                        En.transformQuat(i, i, r)
                                                }
                                                d(y, i.x), d(S, i.y), d(E, i.z)
                                            }
                                        }
                            }
                            return this.reset({
                                struct: a,
                                data: s
                            }), this.initialize(), !0
                        }
                        for (var T, A, x, C, b, R = new eU, w = 0, I = 0, P = 0, O = 0, D = 0, N = 0, M = 0, L = 0, B = !1, F = new Array(this._struct.vertexBundles.length), z = 0; z < this._struct.vertexBundles.length; ++z) {
                            var U = this._struct.vertexBundles[z],
                                G = e._struct.vertexBundles[z];
                            P = U.view.offset, O = G.view.offset, I = U.view.stride, w = U.view.count + G.view.count, T = new ArrayBuffer(w * I), A = new Uint8Array(T), P += (x = this._data.subarray(P, P + U.view.length)).length, O += (C = e._data.subarray(O, O + G.view.length)).length, A.set(x), D = 0;
                            for (var H, k = te(U.attributes); !(H = k()).done;) {
                                var V = H.value;
                                M = 0, B = !1;
                                for (var W, j = te(G.attributes); !(W = j()).done;) {
                                    var q = W.value;
                                    if (V.name === q.name && V.format === q.format) {
                                        B = !0;
                                        break
                                    }
                                    M += tc[q.format].size
                                }
                                if (B) {
                                    L = tc[V.format].size, N = U.view.length + D;
                                    for (var X = 0; X < G.view.count; ++X) {
                                        if (b = C.subarray(M, M + L), A.set(b, N), (V.name === is.ATTR_POSITION || V.name === is.ATTR_NORMAL) && t) {
                                            var Y = new Float32Array(A.buffer, N, 3);
                                            switch (i.set(Y[0], Y[1], Y[2]), V.name) {
                                                case is.ATTR_POSITION:
                                                    i.transformMat4(t);
                                                    break;
                                                case is.ATTR_NORMAL:
                                                    En.transformQuat(i, i, r)
                                            }
                                            Y[0] = i.x, Y[1] = i.y, Y[2] = i.z
                                        }
                                        N += U.view.stride, M += G.view.stride
                                    }
                                }
                                D += tc[V.format].size
                            }
                            F[z] = {
                                attributes: U.attributes,
                                view: {
                                    offset: R.getLength(),
                                    length: T.byteLength,
                                    count: w,
                                    stride: I
                                }
                            }, R.addBuffer(T)
                        }
                        for (var K, Z, Q, J = 0, $ = 2, ee = 0, ne = new Array(this._struct.primitives.length), ie = 0; ie < this._struct.primitives.length; ++ie) {
                            var re = this._struct.primitives[ie],
                                oe = e._struct.primitives[ie];
                            ne[ie] = {
                                primitiveMode: re.primitiveMode,
                                vertexBundelIndices: re.vertexBundelIndices
                            };
                            for (var ae, se = te(re.vertexBundelIndices); !(ae = se()).done;) {
                                var ce = ae.value;
                                ee = Math.max(ee, this._struct.vertexBundles[ce].view.count)
                            }
                            if (re.indexView && oe.indexView) {
                                J = re.indexView.count, J += oe.indexView.count, P = re.indexView.offset, O = oe.indexView.offset, $ = J < 256 ? 1 : J < 65536 ? 2 : 4;
                                var le = new ArrayBuffer(J * $);
                                if (K = 2 === $ ? new Uint16Array(le) : 1 === $ ? new Uint8Array(le) : new Uint32Array(le), Z = 2 === re.indexView.stride ? new Uint16Array(this._data.buffer, P, re.indexView.count) : 1 === re.indexView.stride ? new Uint8Array(this._data.buffer, P, re.indexView.count) : new Uint32Array(this._data.buffer, P, re.indexView.count), $ === re.indexView.stride) K.set(Z);
                                else
                                    for (var ue = 0; ue < re.indexView.count; ++ue) K[ue] = Z[ue];
                                P += re.indexView.length, Q = 2 === oe.indexView.stride ? new Uint16Array(e._data.buffer, O, oe.indexView.count) : 1 === oe.indexView.stride ? new Uint8Array(e._data.buffer, O, oe.indexView.count) : new Uint32Array(e._data.buffer, O, oe.indexView.count);
                                for (var he = 0; he < oe.indexView.count; ++he) K[re.indexView.count + he] = ee + Q[he];
                                O += oe.indexView.length, ne[ie].indexView = {
                                    offset: R.getLength(),
                                    length: le.byteLength,
                                    count: J,
                                    stride: $
                                }, R.setNextAlignment($), R.addBuffer(le)
                            }
                        }
                        var _e = {
                            vertexBundles: F,
                            primitives: ne,
                            minPosition: this._struct.minPosition,
                            maxPosition: this._struct.maxPosition
                        };
                        return _e.minPosition && e._struct.minPosition && _e.maxPosition && e._struct.maxPosition && (t ? (En.add(o.center, e._struct.maxPosition, e._struct.minPosition), En.multiplyScalar(o.center, o.center, .5), En.subtract(o.halfExtents, e._struct.maxPosition, e._struct.minPosition), En.multiplyScalar(o.halfExtents, o.halfExtents, .5), tu.transform(o, o, t), En.add(i, o.center, o.halfExtents), En.max(_e.maxPosition, _e.maxPosition, i), En.subtract(i, o.center, o.halfExtents), En.min(_e.minPosition, _e.minPosition, i)) : (En.min(_e.minPosition, _e.minPosition, e._struct.minPosition), En.max(_e.maxPosition, _e.maxPosition, e._struct.maxPosition))), this.reset({
                            struct: _e,
                            data: new Uint8Array(R.getCombined())
                        }), this.initialize(), !0
                    }, n.validateMergingMesh = function(e) {
                        if (this._struct.vertexBundles.length !== e._struct.vertexBundles.length) return !1;
                        for (var t = 0; t < this._struct.vertexBundles.length; ++t) {
                            var n = this._struct.vertexBundles[t],
                                i = e._struct.vertexBundles[t];
                            if (n.attributes.length !== i.attributes.length) return !1;
                            for (var r = 0; r < n.attributes.length; ++r)
                                if (n.attributes[r].format !== i.attributes[r].format) return !1
                        }
                        if (this._struct.primitives.length !== e._struct.primitives.length) return !1;
                        for (var o = 0; o < this._struct.primitives.length; ++o) {
                            var a = this._struct.primitives[o],
                                s = e._struct.primitives[o];
                            if (a.vertexBundelIndices.length !== s.vertexBundelIndices.length) return !1;
                            for (var c = 0; c < a.vertexBundelIndices.length; ++c)
                                if (a.vertexBundelIndices[c] !== s.vertexBundelIndices[c]) return !1;
                            if (a.primitiveMode !== s.primitiveMode) return !1;
                            if (a.indexView) {
                                if (void 0 === s.indexView) return !1
                            } else if (s.indexView) return !1
                        }
                        return !0
                    }, n.readAttribute = function(e, t) {
                        var n = this,
                            i = null;
                        return this._accessAttribute(e, t, (function(e, t) {
                            var r = e.view.count,
                                o = e.attributes[t].format,
                                a = uc(tc[o]);
                            if (0 !== r) {
                                var s = new DataView(n._data.buffer, e.view.offset + fU(e.attributes, t)),
                                    c = tc[o],
                                    l = mU(s, o);
                                if (a && l) {
                                    for (var u = c.count, h = new a(r * u), _ = e.view.stride, f = 0; f < r; ++f)
                                        for (var d = 0; d < u; ++d) h[u * f + d] = l(_ * f + h.BYTES_PER_ELEMENT * d);
                                    i = h
                                }
                            }
                        })), i
                    }, n.copyAttribute = function(e, t, n, i, r) {
                        var o = this,
                            a = !1;
                        return this._accessAttribute(e, t, (function(e, t) {
                            var s = e.view.count;
                            if (0 !== s) {
                                var c = e.attributes[t].format,
                                    l = new DataView(o._data.buffer, e.view.offset + fU(e.attributes, t)),
                                    u = new DataView(n, r),
                                    h = tc[c],
                                    _ = mU(l, c),
                                    f = gU(u, c);
                                if (_ && f) {
                                    for (var d = h.count, p = e.view.stride, m = pU(c), g = i, v = m, y = 0; y < s; ++y)
                                        for (var S = 0; S < d; ++S) f(g * y + v * S, _(p * y + m * S));
                                    a = !0
                                }
                            } else a = !0
                        })), a
                    }, n.readIndices = function(e) {
                        if (e >= this._struct.primitives.length) return null;
                        var t = this._struct.primitives[e];
                        if (!t.indexView) return null;
                        var n = t.indexView.stride;
                        return new(1 === n ? Uint8Array : 2 === n ? Uint16Array : Uint32Array)(this._data.buffer, t.indexView.offset, t.indexView.count)
                    }, n.copyIndices = function(e, t) {
                        if (e >= this._struct.primitives.length) return !1;
                        var n = this._struct.primitives[e];
                        if (!n.indexView) return !1;
                        for (var i = n.indexView.count, r = 1 === n.indexView.stride ? Ea.R8UI : 2 === n.indexView.stride ? Ea.R16UI : Ea.R32UI, o = mU(new DataView(this._data.buffer), r), a = 0; a < i; ++a) t[a] = o(n.indexView.offset + tc[r].size * a);
                        return !0
                    }, n._accessAttribute = function(e, t, n) {
                        if (!(e >= this._struct.primitives.length))
                            for (var i, r = te(this._struct.primitives[e].vertexBundelIndices); !(i = r()).done;) {
                                var o = i.value,
                                    a = this._struct.vertexBundles[o],
                                    s = a.attributes.findIndex((function(e) {
                                        return e.name === t
                                    }));
                                if (!(s < 0)) {
                                    n(a, s);
                                    break
                                }
                            }
                    }, n._createVertexBuffers = function(e, t) {
                        var n = this;
                        return this._struct.vertexBundles.map((function(i) {
                            var r = e.createBuffer(new gs(xa.VERTEX, Ra.DEVICE, i.view.length, i.view.stride)),
                                o = new Uint8Array(t, i.view.offset, i.view.length);
                            return n.loaded ? r.update(o) : n.once("load", (function() {
                                r.update(o)
                            })), r
                        }))
                    }, n.initDefault = function(t) {
                        e.prototype.initDefault.call(this, t), this.reset({
                            struct: {
                                vertexBundles: [],
                                primitives: []
                            },
                            data: hU
                        })
                    }, n.validate = function() {
                        return this.renderingSubMeshes.length > 0 && this.data.byteLength > 0
                    }, K(t, [{
                        key: "_nativeAsset",
                        get: function() {
                            return this._data.buffer
                        },
                        set: function(e) {
                            this._data.byteLength === e.byteLength ? this._data.set(new Uint8Array(e)) : this._data = new Uint8Array(e), this.loaded = !0, this.emit("load")
                        }
                    }, {
                        key: "subMeshCount",
                        get: function() {
                            var e = this.renderingSubMeshes;
                            return e ? e.length : 0
                        }
                    }, {
                        key: "minPosition",
                        get: function() {
                            return this.struct.minPosition
                        }
                    }, {
                        key: "maxPosition",
                        get: function() {
                            return this.struct.maxPosition
                        }
                    }, {
                        key: "struct",
                        get: function() {
                            return this._struct
                        }
                    }, {
                        key: "data",
                        get: function() {
                            return this._data
                        }
                    }, {
                        key: "hash",
                        get: function() {
                            return this._hash || (this._hash = vc(this._data, 666)), this._hash
                        }
                    }, {
                        key: "jointBufferIndices",
                        get: function() {
                            return this._jointBufferIndices ? this._jointBufferIndices : this._jointBufferIndices = this._struct.primitives.map((function(e) {
                                return e.jointMapIndex || 0
                            }))
                        }
                    }, {
                        key: "renderingSubMeshes",
                        get: function() {
                            return this.initialize(), this._renderingSubMeshes
                        }
                    }]), t
                }(Nf), Zz = ie((Kz = $z).prototype, "_struct", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return {
                            vertexBundles: [],
                            primitives: []
                        }
                    }
                }), Qz = ie(Kz.prototype, "_dataLength", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 0
                    }
                }), Jz = ie(Kz.prototype, "_hash", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 0
                    }
                }), Yz = Kz)) || Yz);

            function fU(e, t) {
                for (var n = 0, i = 0; i < t; ++i) {
                    var r = e[i];
                    n += tc[r.format].size
                }
                return n
            }
            i.Mesh = _U;
            var dU = oS.isLittleEndian;

            function pU(e) {
                var t = tc[e];
                return t.size / t.count
            }

            function mU(e, t) {
                var n = tc[t],
                    i = n.size / n.count;
                switch (n.type) {
                    case Ta.UNORM:
                        switch (i) {
                            case 1:
                                return function(t) {
                                    return e.getUint8(t)
                                };
                            case 2:
                                return function(t) {
                                    return e.getUint16(t, dU)
                                };
                            case 4:
                                return function(t) {
                                    return e.getUint32(t, dU)
                                }
                        }
                        break;
                    case Ta.SNORM:
                    case Ta.INT:
                        switch (i) {
                            case 1:
                                return function(t) {
                                    return e.getInt8(t)
                                };
                            case 2:
                                return function(t) {
                                    return e.getInt16(t, dU)
                                };
                            case 4:
                                return function(t) {
                                    return e.getInt32(t, dU)
                                }
                        }
                        break;
                    case Ta.UINT:
                        switch (i) {
                            case 1:
                                return function(t) {
                                    return e.getUint8(t)
                                };
                            case 2:
                                return function(t) {
                                    return e.getUint16(t, dU)
                                };
                            case 4:
                                return function(t) {
                                    return e.getUint32(t, dU)
                                }
                        }
                        break;
                    case Ta.FLOAT:
                        return function(t) {
                            return e.getFloat32(t, dU)
                        }
                }
                return null
            }

            function gU(e, t) {
                var n = tc[t],
                    i = n.size / n.count;
                switch (n.type) {
                    case Ta.UNORM:
                        switch (i) {
                            case 1:
                                return function(t, n) {
                                    return e.setUint8(t, n)
                                };
                            case 2:
                                return function(t, n) {
                                    return e.setUint16(t, n, dU)
                                };
                            case 4:
                                return function(t, n) {
                                    return e.setUint32(t, n, dU)
                                }
                        }
                        break;
                    case Ta.SNORM:
                    case Ta.INT:
                        switch (i) {
                            case 1:
                                return function(t, n) {
                                    return e.setInt8(t, n)
                                };
                            case 2:
                                return function(t, n) {
                                    return e.setInt16(t, n, dU)
                                };
                            case 4:
                                return function(t, n) {
                                    return e.setInt32(t, n, dU)
                                }
                        }
                        break;
                    case Ta.UINT:
                        switch (i) {
                            case 1:
                                return function(t, n) {
                                    return e.setUint8(t, n)
                                };
                            case 2:
                                return function(t, n) {
                                    return e.setUint16(t, n, dU)
                                };
                            case 4:
                                return function(t, n) {
                                    return e.setUint32(t, n, dU)
                                }
                        }
                        break;
                    case Ta.FLOAT:
                        return function(t, n) {
                            return e.setFloat32(t, n, dU)
                        }
                }
                return null
            }
            var vU = [new Ms(is.ATTR_POSITION, Ea.RGB32F), new Ms(is.ATTR_NORMAL, Ea.RGB32F), new Ms(is.ATTR_TEX_COORD, Ea.RG32F), new Ms(is.ATTR_TANGENT, Ea.RGBA32F), new Ms(is.ATTR_COLOR, Ea.RGBA32F)],
                yU = new En;

            function SU(e, t, n) {
                n = n || {};
                var i, r = [],
                    o = 0,
                    a = [],
                    s = 0,
                    c = e.positions.slice();
                if (c.length > 0) {
                    if (i = null, e.attributes)
                        for (var l, u = te(e.attributes); !(l = u()).done;) {
                            var h = l.value;
                            if (h.name === is.ATTR_POSITION) {
                                i = h;
                                break
                            }
                        }
                    i || (i = vU[0]), r.push(i);
                    var _ = tc[i.format];
                    s = Math.max(s, Math.floor(c.length / _.count)), a.push({
                        offset: o,
                        data: c,
                        attribute: i
                    }), o += _.size
                }
                if (e.normals && e.normals.length > 0) {
                    if (i = null, e.attributes)
                        for (var f, d = te(e.attributes); !(f = d()).done;) {
                            var p = f.value;
                            if (p.name === is.ATTR_NORMAL) {
                                i = p;
                                break
                            }
                        }
                    i || (i = vU[1]);
                    var m = tc[i.format];
                    r.push(i), s = Math.max(s, Math.floor(e.normals.length / m.count)), a.push({
                        offset: o,
                        data: e.normals,
                        attribute: i
                    }), o += m.size
                }
                if (e.uvs && e.uvs.length > 0) {
                    if (i = null, e.attributes)
                        for (var g, v = te(e.attributes); !(g = v()).done;) {
                            var y = g.value;
                            if (y.name === is.ATTR_TEX_COORD) {
                                i = y;
                                break
                            }
                        }
                    i || (i = vU[2]);
                    var S = tc[i.format];
                    r.push(i), s = Math.max(s, Math.floor(e.uvs.length / S.count)), a.push({
                        offset: o,
                        data: e.uvs,
                        attribute: i
                    }), o += S.size
                }
                if (e.tangents && e.tangents.length > 0) {
                    if (i = null, e.attributes)
                        for (var E, T = te(e.attributes); !(E = T()).done;) {
                            var A = E.value;
                            if (A.name === is.ATTR_TANGENT) {
                                i = A;
                                break
                            }
                        }
                    i || (i = vU[3]);
                    var x = tc[i.format];
                    r.push(i), s = Math.max(s, Math.floor(e.tangents.length / x.count)), a.push({
                        offset: o,
                        data: e.tangents,
                        attribute: i
                    }), o += x.size
                }
                if (e.colors && e.colors.length > 0) {
                    if (i = null, e.attributes)
                        for (var C, b = te(e.attributes); !(C = b()).done;) {
                            var R = C.value;
                            if (R.name === is.ATTR_COLOR) {
                                i = R;
                                break
                            }
                        }
                    i || (i = vU[4]);
                    var w = tc[i.format];
                    r.push(i), s = Math.max(s, Math.floor(e.colors.length / w.count)), a.push({
                        offset: o,
                        data: e.colors,
                        attribute: i
                    }), o += w.size
                }
                if (e.customAttributes)
                    for (var I, P = te(e.customAttributes); !(I = P()).done;) {
                        var O = I.value,
                            D = tc[O.attr.format];
                        r.push(O.attr), s = Math.max(s, Math.floor(O.values.length / D.count)), a.push({
                            offset: o,
                            data: O.values,
                            attribute: O.attr
                        }), o += D.size
                    }
                for (var N = new eU, M = new ArrayBuffer(s * o), L = new DataView(M), B = 0, F = a; B < F.length; B++) {
                    var z = F[B];
                    jR(L, z.data, z.attribute.format, z.offset, o)
                }
                N.setNextAlignment(0);
                var U = {
                    attributes: r,
                    view: {
                        offset: N.getLength(),
                        length: M.byteLength,
                        count: s,
                        stride: o
                    }
                };
                N.addBuffer(M);
                var G = null,
                    H = 0;
                if (e.indices) {
                    var k = e.indices;
                    H = k.length, G = new ArrayBuffer(2 * H), jR(new DataView(G), k, Ea.R16UI)
                }
                var V = {
                    primitiveMode: e.primitiveMode || Wa.TRIANGLE_LIST,
                    vertexBundelIndices: [0]
                };
                G && (N.setNextAlignment(2), V.indexView = {
                    offset: N.getLength(),
                    length: G.byteLength,
                    count: H,
                    stride: 2
                }, N.addBuffer(G));
                var W = e.minPos;
                if (!W && n.calculateBounds) {
                    W = En.set(new En, 1 / 0, 1 / 0, 1 / 0);
                    for (var j = 0; j < s; ++j) En.set(yU, c[3 * j + 0], c[3 * j + 1], c[3 * j + 2]), En.min(W, W, yU)
                }
                var q = e.maxPos;
                if (!q && n.calculateBounds) {
                    q = En.set(new En, -1 / 0, -1 / 0, -1 / 0);
                    for (var X = 0; X < s; ++X) En.set(yU, c[3 * X + 0], c[3 * X + 1], c[3 * X + 2]), En.max(q, q, yU)
                }
                var Y = {
                    vertexBundles: [U],
                    primitives: [V]
                };
                return W && (Y.minPosition = new En(W.x, W.y, W.z)), q && (Y.maxPosition = new En(q.x, q.y, q.z)), t || (t = new _U), t.reset({
                    struct: Y,
                    data: new Uint8Array(N.getCombined())
                }), t
            }
            var EU = Object.freeze({
                __proto__: null,
                find: UP,
                toPPM: function(e, t, n) {
                    return "P3 " + t + " " + n + " 255\n" + e.filter((function(e, t) {
                        return t % 4 < 3
                    })).toString() + "\n"
                },
                readMesh: function(e, t) {
                    void 0 === t && (t = 0);
                    for (var n, i = {
                            positions: []
                        }, r = new DataView(e.data.buffer, e.data.byteOffset, e.data.byteLength), o = e.struct, a = o.primitives[t], s = te(a.vertexBundelIndices); !(n = s()).done;)
                        for (var c, l = n.value, u = o.vertexBundles[l], h = u.view.offset, _ = u.view, f = _.length, d = _.stride, p = te(u.attributes); !(c = p()).done;) {
                            var m = c.value,
                                g = Rz[m.name];
                            g && (i[g] = (i[g] || []).concat(qR(r, m.format, h, f, d))), h += tc[m.format].size
                        }
                    var v = a.indexView;
                    return i.indices = qR(r, Ea["R" + 8 * v.stride + "UI"], v.offset, v.length), i
                },
                createMesh: SU,
                readBuffer: qR,
                writeBuffer: jR,
                mapBuffer: XR
            });
            e("utils", EU);
            var TU, AU, xU, CU, bU, RU, wU, IU, PU, OU, DU, NU, MU, LU, BU, FU, zU, UU, GU, HU, kU, VU, WU, jU, qU, XU, YU, KU, ZU, QU, JU, $U, eG, tG, nG, iG, rG, oG, aG, sG, cG = function(e) {
                    function t() {
                        for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                        return (t = e.call.apply(e, [this].concat(i)) || this)._morphRenderingInstance = null, t._usedMaterials = new Set, t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.getMacroPatches = function(e) {
                        return this._morphRenderingInstance ? this._morphRenderingInstance.requiredPatches(e) : null
                    }, n.initSubModel = function(t, n, i) {
                        return e.prototype.initSubModel.call(this, t, n, this._launderMaterial(i))
                    }, n.setSubModelMaterial = function(t, n) {
                        return e.prototype.setSubModelMaterial.call(this, t, this._launderMaterial(n))
                    }, n._updateLocalDescriptors = function(t, n) {
                        e.prototype._updateLocalDescriptors.call(this, t, n), this._morphRenderingInstance && this._morphRenderingInstance.adaptPipelineState(t, n)
                    }, n._launderMaterial = function(e) {
                        return e
                    }, n.setMorphRendering = function(e) {
                        this._morphRenderingInstance = e
                    }, t
                }(ub),
                lG = $e({
                    OFF: 0,
                    ON: 1
                }),
                uG = $e({
                    OFF: 0,
                    ON: 1
                }),
                hG = (TU = A_("cc.ModelLightmapSettings"), AU = R_(P_({
                    formerlySerializedAs: "_recieveShadow"
                })), TU((DU = function() {
                    function e() {
                        ne(this, "texture", bU, this), ne(this, "uvParam", RU, this), ne(this, "_bakeable", wU, this), ne(this, "_castShadow", IU, this), ne(this, "_receiveShadow", PU, this), ne(this, "_lightmapSize", OU, this)
                    }
                    return K(e, [{
                        key: "bakeable",
                        get: function() {
                            return this._bakeable
                        },
                        set: function(e) {
                            this._bakeable = e
                        }
                    }, {
                        key: "castShadow",
                        get: function() {
                            return this._castShadow
                        },
                        set: function(e) {
                            this._castShadow = e
                        }
                    }, {
                        key: "receiveShadow",
                        get: function() {
                            return this._receiveShadow
                        },
                        set: function(e) {
                            this._receiveShadow = e
                        }
                    }, {
                        key: "lightmapSize",
                        get: function() {
                            return this._lightmapSize
                        },
                        set: function(e) {
                            this._lightmapSize = e
                        }
                    }]), e
                }(), bU = ie((CU = DU).prototype, "texture", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return null
                    }
                }), RU = ie(CU.prototype, "uvParam", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return new Wn
                    }
                }), wU = ie(CU.prototype, "_bakeable", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return !1
                    }
                }), IU = ie(CU.prototype, "_castShadow", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return !1
                    }
                }), PU = ie(CU.prototype, "_receiveShadow", [AU], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return !1
                    }
                }), OU = ie(CU.prototype, "_lightmapSize", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 64
                    }
                }), ie(CU.prototype, "bakeable", [F_], Object.getOwnPropertyDescriptor(CU.prototype, "bakeable"), CU.prototype), ie(CU.prototype, "castShadow", [F_], Object.getOwnPropertyDescriptor(CU.prototype, "castShadow"), CU.prototype), ie(CU.prototype, "receiveShadow", [F_], Object.getOwnPropertyDescriptor(CU.prototype, "receiveShadow"), CU.prototype), ie(CU.prototype, "lightmapSize", [F_], Object.getOwnPropertyDescriptor(CU.prototype, "lightmapSize"), CU.prototype), xU = CU)) || xU),
                _G = function(t) {
                    return e({
                        MeshRenderer: t,
                        ModelComponent: t
                    }), t
                }((NU = A_("cc.MeshRenderer"), MU = B_(), LU = C_(100), BU = D_(), FU = ef(lG), zU = G_(), UU = ef(uG), GU = G_(), HU = ef(_U), kU = G_(), VU = z_(), NU(WU = MU(WU = LU(WU = BU(WU = O_((JU = QU = function(e) {
                    function t() {
                        var t;
                        return ne(t = e.call(this) || this, "lightmapSettings", qU, $(t)), ne(t, "_mesh", XU, $(t)), ne(t, "_shadowCastingMode", YU, $(t)), ne(t, "_shadowReceivingMode", KU, $(t)), t._modelType = void 0, t._model = null, t._morphInstance = null, ne(t, "_enableMorph", ZU, $(t)), t._modelType = ub, t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.onLoad = function() {
                        this._mesh && this._mesh.initialize(), this._watchMorphInMesh(), this._updateModels(), this._updateCastShadow(), this._updateReceiveShadow()
                    }, n.onRestore = function() {
                        this._updateModels(), this._updateCastShadow(), this._updateReceiveShadow()
                    }, n.onEnable = function() {
                        this._model || this._updateModels(), this._attachToScene()
                    }, n.onDisable = function() {
                        this._model && this._detachFromScene()
                    }, n.onDestroy = function() {
                        this._model && (i.director.root.destroyModel(this._model), this._model = null, this._models.length = 0), this._morphInstance && this._morphInstance.destroy()
                    }, n.setWeights = function(e, t) {
                        this._morphInstance && this._morphInstance.setWeights(t, e)
                    }, n.setInstancedAttribute = function(e, t) {
                        if (this.model)
                            for (var n = this.model.instancedAttributes, i = n.attributes, r = n.views, o = 0; o < i.length; o++)
                                if (i[o].name === e) {
                                    r[o].set(t);
                                    break
                                }
                    }, n._updateLightmap = function(e, t, n, i, r) {
                        this.lightmapSettings.texture = e, this.lightmapSettings.uvParam.x = t, this.lightmapSettings.uvParam.y = n, this.lightmapSettings.uvParam.z = i, this.lightmapSettings.uvParam.w = r, this._onUpdateLightingmap()
                    }, n._updateModels = function() {
                        if (this.enabledInHierarchy && this._mesh) {
                            var e = this._model;
                            e ? (e.destroy(), e.initialize(), e.node = e.transform = this.node) : this._createModel(), this._model && (this._model.createBoundingShape(this._mesh.struct.minPosition, this._mesh.struct.maxPosition), this._updateModelParams(), this._onUpdateLightingmap())
                        }
                    }, n._createModel = function() {
                        var e = this._morphInstance && this._modelType === ub ? cG : this._modelType,
                            t = this._model = i.director.root.createModel(e);
                        t.visFlags = this.visibility, t.node = t.transform = this.node, this._models.length = 0, this._models.push(this._model), this._morphInstance && t instanceof cG && t.setMorphRendering(this._morphInstance)
                    }, n._attachToScene = function() {
                        if (this.node.scene && this._model) {
                            var e = this._getRenderScene();
                            null !== this._model.scene && this._detachFromScene(), e.addModel(this._model)
                        }
                    }, n._detachFromScene = function() {
                        this._model && this._model.scene && this._model.scene.removeModel(this._model)
                    }, n._updateModelParams = function() {
                        if (this._mesh && this._model) {
                            this.node.hasChangedFlags |= r_.POSITION, this._model.transform.hasChangedFlags |= r_.POSITION, this._model.isDynamicBatching = this._isBatchingEnabled();
                            var e = this._mesh ? this._mesh.renderingSubMeshes.length : 0,
                                t = this._mesh.renderingSubMeshes;
                            if (t)
                                for (var n = 0; n < e; ++n) {
                                    var i = this.getRenderMaterial(n);
                                    i && !i.isValid && (i = null);
                                    var r = t[n];
                                    r && this._model.initSubModel(n, r, i || this._getBuiltinMaterial())
                                }
                            this._model.enabled = !0
                        }
                    }, n._onUpdateLightingmap = function() {
                        null !== this.model && this.model.updateLightingmap(this.lightmapSettings.texture, this.lightmapSettings.uvParam), this.setInstancedAttribute("a_lightingMapUVParam", [this.lightmapSettings.uvParam.x, this.lightmapSettings.uvParam.y, this.lightmapSettings.uvParam.z, this.lightmapSettings.uvParam.w])
                    }, n._onMaterialModified = function(e, t) {
                        this._model && this._model.inited && this._onRebuildPSO(e, t || this._getBuiltinMaterial())
                    }, n._onRebuildPSO = function(e, t) {
                        this._model && this._model.inited && (this._model.isDynamicBatching = this._isBatchingEnabled(), this._model.setSubModelMaterial(e, t), this._onUpdateLightingmap())
                    }, n._onMeshChanged = function() {}, n._clearMaterials = function() {
                        if (this._model)
                            for (var e = this._model.subModels, t = 0; t < e.length; ++t) this._onMaterialModified(t, null)
                    }, n._getBuiltinMaterial = function() {
                        return em.get("missing-material")
                    }, n._onVisibilityChange = function(e) {
                        this._model && (this._model.visFlags = e)
                    }, n._updateCastShadow = function() {
                        this._model && (this._shadowCastingMode === lG.OFF ? this._model.castShadow = !1 : (this._shadowCastingMode, lG.ON, this._shadowCastingMode, this._model.castShadow = !0))
                    }, n._updateReceiveShadow = function() {
                        this._model && (this._shadowReceivingMode === uG.OFF ? this._model.receiveShadow = !1 : this._model.receiveShadow = !0)
                    }, n._isBatchingEnabled = function() {
                        for (var e = 0; e < this._materials.length; ++e) {
                            var t = this._materials[e];
                            if (t)
                                for (var n = 0; n < t.passes.length; ++n)
                                    if (t.passes[n].batchingScheme) return !0
                        }
                        return !1
                    }, n._watchMorphInMesh = function() {
                        if (this._morphInstance && (this._morphInstance.destroy(), this._morphInstance = null), this._enableMorph && this._mesh && this._mesh.struct.morph && this._mesh.morphRendering) {
                            var e = this._mesh.struct.morph;
                            this._morphInstance = this._mesh.morphRendering.createInstance();
                            for (var t = this._mesh.struct.primitives.length, n = 0; n < t; ++n) {
                                var i = e.subMeshMorphs[n];
                                if (i) {
                                    var r = i.weights || e.weights,
                                        o = r ? r.slice() : new Array(i.targets.length).fill(0);
                                    this._morphInstance.setWeights(n, o)
                                }
                            }
                            this._model && this._model instanceof cG && this._model.setMorphRendering(this._morphInstance)
                        }
                    }, n._syncMorphWeights = function(e) {
                        if (this._morphInstance) {
                            var t = this._morphInstance[e];
                            t && t.renderResources && t.renderResources.setWeights(t.weights)
                        }
                    }, K(t, [{
                        key: "shadowCastingMode",
                        get: function() {
                            return this._shadowCastingMode
                        },
                        set: function(e) {
                            this._shadowCastingMode = e, this._updateCastShadow()
                        }
                    }, {
                        key: "receiveShadow",
                        get: function() {
                            return this._shadowReceivingMode
                        },
                        set: function(e) {
                            this._shadowReceivingMode = e, this._updateReceiveShadow()
                        }
                    }, {
                        key: "mesh",
                        get: function() {
                            return this._mesh
                        },
                        set: function(e) {
                            var t = this._mesh;
                            this._mesh = e, this._mesh && this._mesh.initialize(), this._watchMorphInMesh(), this._onMeshChanged(t), this._updateModels(), this.enabledInHierarchy && this._attachToScene(), this._updateCastShadow(), this._updateReceiveShadow()
                        }
                    }, {
                        key: "model",
                        get: function() {
                            return this._model
                        }
                    }, {
                        key: "enableMorph",
                        get: function() {
                            return this._enableMorph
                        },
                        set: function(e) {
                            this._enableMorph = e
                        }
                    }]), t
                }(UM), QU.ShadowCastingMode = lG, QU.ShadowReceivingMode = uG, qU = ie((jU = JU).prototype, "lightmapSettings", [w_, F_, K_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return new hG
                    }
                }), XU = ie(jU.prototype, "_mesh", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return null
                    }
                }), YU = ie(jU.prototype, "_shadowCastingMode", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return lG.OFF
                    }
                }), KU = ie(jU.prototype, "_shadowReceivingMode", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return uG.ON
                    }
                }), ie(jU.prototype, "shadowCastingMode", [FU, zU, K_], Object.getOwnPropertyDescriptor(jU.prototype, "shadowCastingMode"), jU.prototype), ie(jU.prototype, "receiveShadow", [UU, GU, K_], Object.getOwnPropertyDescriptor(jU.prototype, "receiveShadow"), jU.prototype), ie(jU.prototype, "mesh", [HU, kU], Object.getOwnPropertyDescriptor(jU.prototype, "mesh"), jU.prototype), ie(jU.prototype, "enableMorph", [VU, K_], Object.getOwnPropertyDescriptor(jU.prototype, "enableMorph"), jU.prototype), ZU = ie(jU.prototype, "_enableMorph", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return !0
                    }
                }), WU = jU)) || WU) || WU) || WU) || WU) || WU));

            function fG(e, t) {
                var n = e.sharedMaterials.length;
                if (n !== t.sharedMaterials.length) return !1;
                for (var i = 0; i < n; i++)
                    if (e.getRenderMaterial(i) !== t.getRenderMaterial(i)) return !1;
                return !0
            }
            e("BatchingUtility", function() {
                function e() {}
                return e.batchStaticModel = function(e, t) {
                    var n = e.getComponentsInChildren(_G);
                    if (n.length < 2) return console.error("the number of static models to batch is less than 2,it needn't batch."), !1;
                    for (var i = 1; i < n.length; i++) {
                        if (!n[0].mesh.validateMergingMesh(n[i].mesh)) return console.error("the meshes of " + n[0].node.name + " and " + n[i].node.name + " can't be merged"), !1;
                        if (!fG(n[0], n[i])) return console.error("the materials of " + n[0].node.name + " and " + n[i].node.name + " can't be merged"), !1
                    }
                    var r = new _U,
                        o = new Bn,
                        a = new Bn;
                    e.getWorldMatrix(a), Bn.invert(a, a);
                    for (var s = 0; s < n.length; s++) {
                        var c = n[s];
                        c.node.getWorldMatrix(o), Bn.multiply(o, a, o), r.merge(n[s].mesh, o), c.enabled = !1
                    }
                    var l = t.addComponent(_G);
                    return l.mesh = r, l.sharedMaterials = n[0].sharedMaterials, !0
                }, e.unbatchStaticModel = function(e, t) {
                    for (var n = e.getComponentsInChildren(_G), i = 0; i < n.length; i++) n[i].enabled = !0;
                    var r = t.getComponent(_G);
                    return r && (r.mesh && r.mesh.destroyRenderingMesh(), r.destroy()), !0
                }, e
            }()), U(_U.prototype, "Mesh.prototype", [{
                name: "renderingMesh",
                newName: "renderingSubMeshes"
            }]), G(_U.prototype, "Mesh.prototype", [{
                name: "hasFlatBuffers"
            }, {
                name: "destroyFlatBuffers"
            }]);
            var dG, pG, mG, gG, vG, yG, SG, EG, TG, AG, xG, CG, bG, RG, wG, IG, PG, OG, DG, NG, MG, LG = e("Skeleton", ($U = A_("cc.Skeleton"), eG = ef([It]), tG = ef([Bn]), $U((sG = function(e) {
                function t() {
                    for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                    return ne(t = e.call.apply(e, [this].concat(i)) || this, "_joints", rG, $(t)), ne(t, "_bindposes", oG, $(t)), ne(t, "_hash", aG, $(t)), t._invBindposes = null, t
                }
                Q(t, e);
                var n = t.prototype;
                return n.destroy = function() {
                    return i.director.root.dataPoolManager.releaseSkeleton(this), e.prototype.destroy.call(this)
                }, n.validate = function() {
                    return this.joints.length > 0 && this.bindposes.length > 0
                }, K(t, [{
                    key: "joints",
                    get: function() {
                        return this._joints
                    },
                    set: function(e) {
                        this._joints = e
                    }
                }, {
                    key: "bindposes",
                    get: function() {
                        return this._bindposes
                    },
                    set: function(e) {
                        this._bindposes = e
                    }
                }, {
                    key: "inverseBindposes",
                    get: function() {
                        if (!this._invBindposes) {
                            this._invBindposes = [];
                            for (var e = 0; e < this._bindposes.length; e++) {
                                var t = new Bn;
                                Bn.invert(t, this._bindposes[e]), this._invBindposes.push(t)
                            }
                        }
                        return this._invBindposes
                    }
                }, {
                    key: "hash",
                    get: function() {
                        if (!this._hash) {
                            for (var e = "", t = 0; t < this._bindposes.length; t++) {
                                var n = this._bindposes[t];
                                e += n.m00.toPrecision(2) + " " + n.m01.toPrecision(2) + " " + n.m02.toPrecision(2) + " " + n.m03.toPrecision(2) + " " + n.m04.toPrecision(2) + " " + n.m05.toPrecision(2) + " " + n.m06.toPrecision(2) + " " + n.m07.toPrecision(2) + " " + n.m08.toPrecision(2) + " " + n.m09.toPrecision(2) + " " + n.m10.toPrecision(2) + " " + n.m11.toPrecision(2) + " " + n.m12.toPrecision(2) + " " + n.m13.toPrecision(2) + " " + n.m14.toPrecision(2) + " " + n.m15.toPrecision(2) + "\n"
                            }
                            this._hash = vc(e, 666)
                        }
                        return this._hash
                    }
                }]), t
            }(Nf), rG = ie((iG = sG).prototype, "_joints", [eG], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return []
                }
            }), oG = ie(iG.prototype, "_bindposes", [tG], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return []
                }
            }), aG = ie(iG.prototype, "_hash", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return 0
                }
            }), nG = iG)) || nG));
            i.Skeleton = LG, G(_G.prototype, "MeshRenderer.prototype", [{
                name: "enableDynamicBatching"
            }, {
                name: "recieveShadows"
            }]), i.ModelComponent = _G, Qe.setClassAlias(_G, "cc.ModelComponent");
            var BG, FG, zG, UG, GG, HG, kG, VG, WG, jG, qG, XG, YG, KG, ZG, QG, JG, $G, eH, tH, nH, iH, rH, oH, aH, sH, cH, lH, uH, hH, _H, fH, dH, pH, mH, gH, vH, yH, SH, EH, TH, AH, xH, CH, bH, RH, wH, IH, PH = $e({
                    LUMINOUS_POWER: 0,
                    LUMINANCE: 1
                }),
                OH = new En,
                DH = A_("cc.StaticLightSettings")((SG = function() {
                    function e() {
                        ne(this, "_baked", mG, this), ne(this, "_editorOnly", gG, this), ne(this, "_bakeable", vG, this), ne(this, "_castShadow", yG, this)
                    }
                    return K(e, [{
                        key: "editorOnly",
                        get: function() {
                            return this._editorOnly
                        },
                        set: function(e) {
                            this._editorOnly = e
                        }
                    }, {
                        key: "baked",
                        get: function() {
                            return this._baked
                        },
                        set: function(e) {
                            this._baked = e
                        }
                    }, {
                        key: "bakeable",
                        get: function() {
                            return this._bakeable
                        },
                        set: function(e) {
                            this._bakeable = e
                        }
                    }, {
                        key: "castShadow",
                        get: function() {
                            return this._castShadow
                        },
                        set: function(e) {
                            this._castShadow = e
                        }
                    }]), e
                }(), mG = ie((pG = SG).prototype, "_baked", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return !1
                    }
                }), gG = ie(pG.prototype, "_editorOnly", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return !1
                    }
                }), vG = ie(pG.prototype, "_bakeable", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return !1
                    }
                }), yG = ie(pG.prototype, "_castShadow", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return !1
                    }
                }), ie(pG.prototype, "editorOnly", [F_], Object.getOwnPropertyDescriptor(pG.prototype, "editorOnly"), pG.prototype), ie(pG.prototype, "bakeable", [F_], Object.getOwnPropertyDescriptor(pG.prototype, "bakeable"), pG.prototype), ie(pG.prototype, "castShadow", [F_], Object.getOwnPropertyDescriptor(pG.prototype, "castShadow"), pG.prototype), dG = pG)) || dG,
                NH = function(t) {
                    return e({
                        Light: t,
                        LightComponent: t
                    }), t
                }((EG = A_("cc.Light"), TG = G_(), AG = G_(), xG = H_(), CG = G_(), bG = ef(DH), EG((MG = NG = function(e) {
                    function t() {
                        var t;
                        return ne(t = e.call(this) || this, "_color", IG, $(t)), ne(t, "_useColorTemperature", PG, $(t)), ne(t, "_colorTemperature", OG, $(t)), ne(t, "_staticSettings", DG, $(t)), t._type = sm.UNKNOWN, t._lightType = void 0, t._light = null, t._lightType = hm, t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.onLoad = function() {
                        this._createLight()
                    }, n.onEnable = function() {
                        this._attachToScene()
                    }, n.onDisable = function() {
                        this._detachFromScene()
                    }, n.onDestroy = function() {
                        this._destroyLight()
                    }, n._createLight = function() {
                        this._light || (this._light = i.director.root.createLight(this._lightType)), this.color = this._color, this.useColorTemperature = this._useColorTemperature, this.colorTemperature = this._colorTemperature, this._light.node = this.node, this._light.baked = this.baked
                    }, n._destroyLight = function() {
                        this._light && (i.director.root.destroyLight(this), this._light = null)
                    }, n._attachToScene = function() {
                        if (this._detachFromScene(), this._light && !this._light.scene && this.node.scene) {
                            var e = this._getRenderScene();
                            switch (this._type) {
                                case sm.DIRECTIONAL:
                                    e.addDirectionalLight(this._light), e.setMainLight(this._light);
                                    break;
                                case sm.SPHERE:
                                    e.addSphereLight(this._light);
                                    break;
                                case sm.SPOT:
                                    e.addSpotLight(this._light)
                            }
                        }
                    }, n._detachFromScene = function() {
                        if (this._light && this._light.scene) {
                            var e = this._light.scene;
                            switch (this._type) {
                                case sm.DIRECTIONAL:
                                    e.removeDirectionalLight(this._light), e.unsetMainLight(this._light);
                                    break;
                                case sm.SPHERE:
                                    e.removeSphereLight(this._light);
                                    break;
                                case sm.SPOT:
                                    e.removeSpotLight(this._light)
                            }
                        }
                    }, K(t, [{
                        key: "color",
                        get: function() {
                            return this._color
                        },
                        set: function(e) {
                            this._color = e, this._light && (OH.x = e.r / 255, OH.y = e.g / 255, OH.z = e.b / 255, this._light.color = OH)
                        }
                    }, {
                        key: "useColorTemperature",
                        get: function() {
                            return this._useColorTemperature
                        },
                        set: function(e) {
                            this._useColorTemperature = e, this._light && (this._light.useColorTemperature = e)
                        }
                    }, {
                        key: "colorTemperature",
                        get: function() {
                            return this._colorTemperature
                        },
                        set: function(e) {
                            this._colorTemperature = e, this._light && (this._light.colorTemperature = e)
                        }
                    }, {
                        key: "staticSettings",
                        get: function() {
                            return this._staticSettings
                        },
                        set: function(e) {
                            this._staticSettings = e
                        }
                    }, {
                        key: "type",
                        get: function() {
                            return this._type
                        }
                    }, {
                        key: "baked",
                        get: function() {
                            return this.staticSettings.baked
                        },
                        set: function(e) {
                            this.staticSettings.baked = e, null !== this._light && (this._light.baked = e)
                        }
                    }]), t
                }(Jd), NG.Type = sm, NG.PhotometricTerm = PH, IG = ie((wG = MG).prototype, "_color", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return yn.WHITE.clone()
                    }
                }), PG = ie(wG.prototype, "_useColorTemperature", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return !1
                    }
                }), OG = ie(wG.prototype, "_colorTemperature", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 6550
                    }
                }), DG = ie(wG.prototype, "_staticSettings", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return new DH
                    }
                }), ie(wG.prototype, "color", [TG], Object.getOwnPropertyDescriptor(wG.prototype, "color"), wG.prototype), ie(wG.prototype, "useColorTemperature", [AG], Object.getOwnPropertyDescriptor(wG.prototype, "useColorTemperature"), wG.prototype), ie(wG.prototype, "colorTemperature", [j_, xG, CG], Object.getOwnPropertyDescriptor(wG.prototype, "colorTemperature"), wG.prototype), ie(wG.prototype, "staticSettings", [bG], Object.getOwnPropertyDescriptor(wG.prototype, "staticSettings"), wG.prototype), RG = wG)) || RG)),
                MH = function(t) {
                    return e({
                        DirectionalLight: t,
                        DirectionalLightComponent: t
                    }), t
                }((BG = A_("cc.DirectionalLight"), FG = B_(), zG = D_(), UG = X_(), GG = G_(), BG(HG = FG(HG = zG(HG = O_((WG = function(e) {
                    function t() {
                        var t;
                        return ne(t = e.call(this) || this, "_illuminance", VG, $(t)), t._type = sm.DIRECTIONAL, t._light = null, t._lightType = dm, t
                    }
                    return Q(t, e), t.prototype._createLight = function() {
                        e.prototype._createLight.call(this), this._light && (this.illuminance = this._illuminance)
                    }, K(t, [{
                        key: "illuminance",
                        get: function() {
                            return this._illuminance
                        },
                        set: function(e) {
                            this._illuminance = e, this._light && (this._light.illuminance = this._illuminance)
                        }
                    }]), t
                }(NH), VG = ie((kG = WG).prototype, "_illuminance", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 65e3
                    }
                }), ie(kG.prototype, "illuminance", [UG, GG], Object.getOwnPropertyDescriptor(kG.prototype, "illuminance"), kG.prototype), HG = kG)) || HG) || HG) || HG) || HG)),
                LH = function(t) {
                    return e({
                        SphereLight: t,
                        SphereLightComponent: t
                    }), t
                }((jG = A_("cc.SphereLight"), qG = B_(), XG = D_(), YG = X_(), KG = G_(), ZG = X_(), QG = G_(), JG = ef(PH), $G = G_(), eH = G_(), tH = G_(), jG(nH = qG(nH = XG(nH = O_((cH = function(e) {
                    function t() {
                        var t;
                        return ne(t = e.call(this) || this, "_size", rH, $(t)), ne(t, "_luminance", oH, $(t)), ne(t, "_term", aH, $(t)), ne(t, "_range", sH, $(t)), t._type = sm.SPHERE, t._light = null, t._lightType = hb, t
                    }
                    return Q(t, e), t.prototype._createLight = function() {
                        e.prototype._createLight.call(this), this._light && (this.luminance = this._luminance, this.size = this._size, this.range = this._range)
                    }, K(t, [{
                        key: "luminousPower",
                        get: function() {
                            return this._luminance * um(this._size)
                        },
                        set: function(e) {
                            this._luminance = e / um(this._size), this._light && (this._light.luminance = this._luminance)
                        }
                    }, {
                        key: "luminance",
                        get: function() {
                            return this._luminance
                        },
                        set: function(e) {
                            this._luminance = e, this._light && (this._light.luminance = e)
                        }
                    }, {
                        key: "term",
                        get: function() {
                            return this._term
                        },
                        set: function(e) {
                            this._term = e
                        }
                    }, {
                        key: "size",
                        get: function() {
                            return this._size
                        },
                        set: function(e) {
                            this._size = e, this._light && (this._light.size = e)
                        }
                    }, {
                        key: "range",
                        get: function() {
                            return this._range
                        },
                        set: function(e) {
                            this._range = e, this._light && (this._light.range = e)
                        }
                    }]), t
                }(NH), rH = ie((iH = cH).prototype, "_size", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return .15
                    }
                }), oH = ie(iH.prototype, "_luminance", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 1700 / um(.15)
                    }
                }), aH = ie(iH.prototype, "_term", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return PH.LUMINOUS_POWER
                    }
                }), sH = ie(iH.prototype, "_range", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 1
                    }
                }), ie(iH.prototype, "luminousPower", [YG, KG], Object.getOwnPropertyDescriptor(iH.prototype, "luminousPower"), iH.prototype), ie(iH.prototype, "luminance", [ZG, QG], Object.getOwnPropertyDescriptor(iH.prototype, "luminance"), iH.prototype), ie(iH.prototype, "term", [JG, $G], Object.getOwnPropertyDescriptor(iH.prototype, "term"), iH.prototype), ie(iH.prototype, "size", [eH], Object.getOwnPropertyDescriptor(iH.prototype, "size"), iH.prototype), ie(iH.prototype, "range", [tH], Object.getOwnPropertyDescriptor(iH.prototype, "range"), iH.prototype), nH = iH)) || nH) || nH) || nH) || nH)),
                BH = function(t) {
                    return e({
                        SpotLight: t,
                        SpotLightComponent: t
                    }), t
                }((lH = A_("cc.SpotLight"), uH = B_(), hH = D_(), _H = X_(), fH = G_(), dH = X_(), pH = G_(), mH = ef(PH), gH = G_(), vH = G_(), yH = G_(), SH = H_(), EH = G_(), lH(TH = uH(TH = hH(TH = O_((IH = function(e) {
                    function t() {
                        var t;
                        return ne(t = e.call(this) || this, "_size", xH, $(t)), ne(t, "_luminance", CH, $(t)), ne(t, "_term", bH, $(t)), ne(t, "_range", RH, $(t)), ne(t, "_spotAngle", wH, $(t)), t._type = sm.SPOT, t._light = null, t._lightType = vb, t
                    }
                    return Q(t, e), t.prototype._createLight = function() {
                        e.prototype._createLight.call(this), this._light && (this.luminance = this._luminance, this.size = this._size, this.range = this._range, this.spotAngle = this._spotAngle)
                    }, K(t, [{
                        key: "luminousPower",
                        get: function() {
                            return this._luminance * um(this._size)
                        },
                        set: function(e) {
                            this._luminance = e / um(this._size), this._light && (this._light.luminance = this._luminance)
                        }
                    }, {
                        key: "luminance",
                        get: function() {
                            return this._luminance
                        },
                        set: function(e) {
                            this._luminance = e, this._light && (this._light.luminance = e)
                        }
                    }, {
                        key: "term",
                        get: function() {
                            return this._term
                        },
                        set: function(e) {
                            this._term = e
                        }
                    }, {
                        key: "size",
                        get: function() {
                            return this._size
                        },
                        set: function(e) {
                            this._size = e, this._light && (this._light.size = e)
                        }
                    }, {
                        key: "range",
                        get: function() {
                            return this._range
                        },
                        set: function(e) {
                            this._range = e, this._light && (this._light.range = e)
                        }
                    }, {
                        key: "spotAngle",
                        get: function() {
                            return this._spotAngle
                        },
                        set: function(e) {
                            this._spotAngle = e, this._light && (this._light.spotAngle = rn(e))
                        }
                    }]), t
                }(NH), xH = ie((AH = IH).prototype, "_size", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return .15
                    }
                }), CH = ie(AH.prototype, "_luminance", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 1700 / um(.15)
                    }
                }), bH = ie(AH.prototype, "_term", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return PH.LUMINOUS_POWER
                    }
                }), RH = ie(AH.prototype, "_range", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 1
                    }
                }), wH = ie(AH.prototype, "_spotAngle", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 60
                    }
                }), ie(AH.prototype, "luminousPower", [_H, fH], Object.getOwnPropertyDescriptor(AH.prototype, "luminousPower"), AH.prototype), ie(AH.prototype, "luminance", [dH, pH], Object.getOwnPropertyDescriptor(AH.prototype, "luminance"), AH.prototype), ie(AH.prototype, "term", [mH, gH], Object.getOwnPropertyDescriptor(AH.prototype, "term"), AH.prototype), ie(AH.prototype, "size", [vH], Object.getOwnPropertyDescriptor(AH.prototype, "size"), AH.prototype), ie(AH.prototype, "range", [yH], Object.getOwnPropertyDescriptor(AH.prototype, "range"), AH.prototype), ie(AH.prototype, "spotAngle", [j_, SH, EH], Object.getOwnPropertyDescriptor(AH.prototype, "spotAngle"), AH.prototype), TH = AH)) || TH) || TH) || TH) || TH));
            i.LightComponent = NH, Qe.setClassAlias(NH, "cc.LightComponent"), i.DirectionalLightComponent = MH, Qe.setClassAlias(MH, "cc.DirectionalLightComponent"), i.SphereLightComponent = LH, Qe.setClassAlias(LH, "cc.SphereLightComponent"), i.SpotLightComponent = BH, Qe.setClassAlias(BH, "cc.SpotLightComponent");
            var FH = function(e, t, n) {
                e[t + 0] = n.m00, e[t + 1] = n.m01, e[t + 2] = n.m02, e[t + 3] = n.m12, e[t + 4] = n.m04, e[t + 5] = n.m05, e[t + 6] = n.m06, e[t + 7] = n.m13, e[t + 8] = n.m08, e[t + 9] = n.m09, e[t + 10] = n.m10, e[t + 11] = n.m14
            };

            function zH(e, t) {
                var n = 4 / Math.sqrt(t);
                return 12 * Math.ceil(Math.max(480 * n, e) / 12)
            }
            new wn, new wn, new En, new wn, new En;
            var UH = Kf([Da.POINT, Da.POINT, Da.NONE, Na.CLAMP, Na.CLAMP, Na.CLAMP]),
                GH = new En,
                HH = new En,
                kH = new En,
                VH = new En,
                WH = new Bn,
                jH = new Bn,
                qH = new tu,
                XH = Number.MAX_SAFE_INTEGER,
                YH = function() {
                    function e(e) {
                        this._device = void 0, this._pool = void 0, this._textureBuffers = new Map, this._formatSize = void 0, this._pixelsPerJoint = void 0, this._customPool = void 0, this._chunkIdxMap = new Map, this._device = e;
                        var t = function(e) {
                            return e.hasFeature(Sa.TEXTURE_FLOAT) ? Ea.RGBA32F : Ea.RGBA8
                        }(this._device);
                        this._formatSize = tc[t].size, this._pixelsPerJoint = 48 / this._formatSize, this._pool = new Tb(e), this._pool.initialize({
                            format: t,
                            roundUpFn: zH
                        }), this._customPool = new Tb(e), this._customPool.initialize({
                            format: t,
                            roundUpFn: zH
                        })
                    }
                    var t = e.prototype;
                    return t.clear = function() {
                        this._pool.destroy(), this._textureBuffers.clear()
                    }, t.registerCustomTextureLayouts = function(e) {
                        for (var t = 0; t < e.length; t++)
                            for (var n = e[t], i = this._customPool.createChunk(n.textureLength), r = 0; r < n.contents.length; r++) {
                                var o = n.contents[r],
                                    a = o.skeleton;
                                this._chunkIdxMap.set(a, i);
                                for (var s = 0; s < o.clips.length; s++) {
                                    var c = o.clips[s];
                                    this._chunkIdxMap.set(a ^ c, i)
                                }
                            }
                    }, t.getDefaultPoseTexture = function(e, t, n) {
                        var i = 0 ^ e.hash,
                            r = this._textureBuffers.get(i) || null;
                        if (r && r.bounds.has(t.hash)) return r.refCount++, r;
                        var o = e.joints,
                            a = e.bindposes,
                            s = null,
                            c = !1,
                            l = o.length;
                        if (r) r.refCount++;
                        else {
                            var u = 12 * l,
                                h = this._chunkIdxMap.get(i),
                                _ = void 0 !== h ? this._customPool.alloc(u * Float32Array.BYTES_PER_ELEMENT, h) : this._pool.alloc(u * Float32Array.BYTES_PER_ELEMENT);
                            if (!_) return r;
                            r = {
                                pixelOffset: _.start / this._formatSize,
                                refCount: 1,
                                bounds: new Map,
                                skeletonHash: e.hash,
                                clipHash: 0,
                                readyToBeDeleted: !1,
                                handle: _
                            }, s = new Float32Array(u), c = !0
                        }
                        En.set(kH, XH, XH, XH), En.set(VH, -XH, -XH, -XH);
                        for (var f = t.getBoneSpaceBounds(e), d = 0, p = 0; d < l; d++, p += 12) {
                            var m = n.getChildByPath(o[d]),
                                g = m ? WB(m, n, WH) : e.inverseBindposes[d],
                                v = f[d];
                            v && (tu.transform(qH, v, g), qH.getBoundary(GH, HH), En.min(kH, kH, GH), En.max(VH, VH, HH)), c && (m && Bn.multiply(g, g, a[d]), FH(s, p, m ? g : Bn.IDENTITY))
                        }
                        var y = [new tu];
                        return r.bounds.set(t.hash, y), tu.fromPoints(y[0], kH, VH), c && (this._pool.update(r.handle, s.buffer), this._textureBuffers.set(i, r)), r
                    }, t.getSequencePoseTexture = function(e, t, n, i) {
                        var r = e.hash ^ t.hash,
                            o = this._textureBuffers.get(r) || null;
                        if (o && o.bounds.has(n.hash)) return o.refCount++, o;
                        var a = e.joints,
                            s = e.bindposes,
                            c = XL.getOrExtract(t).info.frames,
                            l = null,
                            u = !1,
                            h = a.length;
                        if (o) o.refCount++;
                        else {
                            var _ = 12 * h * c,
                                f = this._chunkIdxMap.get(r),
                                d = void 0 !== f ? this._customPool.alloc(_ * Float32Array.BYTES_PER_ELEMENT, f) : this._pool.alloc(_ * Float32Array.BYTES_PER_ELEMENT);
                            if (!d) return null;
                            var p = this._createAnimInfos(e, t, i);
                            o = {
                                pixelOffset: d.start / this._formatSize,
                                refCount: 1,
                                bounds: new Map,
                                skeletonHash: e.hash,
                                clipHash: t.hash,
                                readyToBeDeleted: !1,
                                handle: d,
                                animInfos: p
                            }, l = new Float32Array(_), u = !0
                        }
                        var m = n.getBoneSpaceBounds(e),
                            g = [];
                        o.bounds.set(n.hash, g);
                        for (var v = 0; v < c; v++) g.push(new tu(XH, XH, XH, -XH, -XH, -XH));
                        for (var y = 0, S = 0; y < c; y++) {
                            for (var E = g[y], T = 0; T < h; T++, S += 12) {
                                var A = o.animInfos[T],
                                    x = A.curveData,
                                    C = A.downstream,
                                    b = A.bindposeIdx,
                                    R = A.bindposeCorrection,
                                    w = void 0,
                                    I = !0;
                                x && C ? w = Bn.multiply(WH, x[y], C) : x ? w = x[y] : C ? w = C : (w = e.inverseBindposes[b], I = !1);
                                var P = m[T];
                                if (P) {
                                    var O = R ? Bn.multiply(jH, w, R) : w;
                                    tu.transform(qH, P, O), qH.getBoundary(GH, HH), En.min(E.center, E.center, GH), En.max(E.halfExtents, E.halfExtents, HH)
                                }
                                u && (I && Bn.multiply(WH, w, s[b]), FH(l, S, I ? WH : Bn.IDENTITY))
                            }
                            tu.fromPoints(E, E.center, E.halfExtents)
                        }
                        return u && (this._pool.update(o.handle, l.buffer), this._textureBuffers.set(r, o)), o
                    }, t.releaseHandle = function(e) {
                        if (e.refCount > 0 && e.refCount--, !e.refCount && e.readyToBeDeleted) {
                            var t = e.skeletonHash ^ e.clipHash;
                            (void 0 !== this._chunkIdxMap.get(t) ? this._customPool : this._pool).free(e.handle), this._textureBuffers.get(t) === e && this._textureBuffers.delete(t)
                        }
                    }, t.releaseSkeleton = function(e) {
                        for (var t = this._textureBuffers.values(), n = t.next(); !n.done;) {
                            var i = n.value;
                            i.skeletonHash === e.hash && (i.readyToBeDeleted = !0, i.refCount ? this._textureBuffers.delete(i.skeletonHash ^ i.clipHash) : this.releaseHandle(i)), n = t.next()
                        }
                    }, t.releaseAnimationClip = function(e) {
                        for (var t = this._textureBuffers.values(), n = t.next(); !n.done;) {
                            var i = n.value;
                            i.clipHash === e.hash && (i.readyToBeDeleted = !0, i.refCount ? this._textureBuffers.delete(i.skeletonHash ^ i.clipHash) : this.releaseHandle(i)), n = t.next()
                        }
                    }, t._createAnimInfos = function(e, t, n) {
                        for (var i = [], r = e.joints, o = e.bindposes, a = r.length, s = XL.getOrExtract(t), c = 0; c < a; c++) {
                            for (var l = r[c], u = s.data[l], h = n.getChildByPath(l), _ = void 0, f = void 0; !u;) {
                                var d = l.lastIndexOf("/");
                                if (l = l.substring(0, d), u = s.data[l], h ? (_ || (_ = new Bn), Bn.fromRTS(WH, h.rotation, h.position, h.scale), Bn.multiply(_, WH, _), h = h.parent) : f = l, d < 0) break
                            }
                            var p = c,
                                m = void 0;
                            if (void 0 !== f && u) {
                                p = c - 1;
                                for (var g = 0; g < a; g++)
                                    if (r[g] === f) {
                                        p = g, m = new Bn, Bn.multiply(m, o[g], e.inverseBindposes[c]);
                                        break
                                    }
                            }
                            i.push({
                                curveData: u && u.worldMatrix.values,
                                downstream: _,
                                bindposeIdx: p,
                                bindposeCorrection: m
                            })
                        }
                        return i
                    }, K(e, [{
                        key: "pixelsPerJoint",
                        get: function() {
                            return this._pixelsPerJoint
                        }
                    }]), e
                }(),
                KH = function() {
                    function e(e) {
                        this._pool = new Map, this._device = void 0, this._device = e
                    }
                    var t = e.prototype;
                    return t.getData = function(e) {
                        void 0 === e && (e = "-1");
                        var t = this._pool.get(e);
                        if (t) return t;
                        var n = this._device.createBuffer(new gs(xa.UNIFORM | xa.TRANSFER_DST, Ra.HOST | Ra.DEVICE, bh.SIZE, bh.SIZE)),
                            i = new Float32Array([0, 0, 0, 0]);
                        n.update(i);
                        var r = {
                            buffer: n,
                            data: i,
                            dirty: !1
                        };
                        return this._pool.set(e, r), r
                    }, t.destroy = function(e) {
                        var t = this._pool.get(e);
                        t && (t.buffer.destroy(), this._pool.delete(e))
                    }, t.switchClip = function(e) {
                        return e.data[0] = 0, e.buffer.update(e.data), e.dirty = !1, e
                    }, t.clear = function() {
                        for (var e, t = te(this._pool.values()); !(e = t()).done;) e.value.buffer.destroy();
                        this._pool.clear()
                    }, e
                }(),
                ZH = function() {
                    function e(e) {
                        this.jointTexturePool = void 0, this.jointAnimationInfo = void 0, this.jointTexturePool = new YH(e), this.jointAnimationInfo = new KH(e)
                    }
                    var t = e.prototype;
                    return t.releaseSkeleton = function(e) {
                        this.jointTexturePool.releaseSkeleton(e)
                    }, t.releaseAnimationClip = function(e) {
                        this.jointTexturePool.releaseAnimationClip(e)
                    }, t.clear = function() {
                        this.jointTexturePool.clear(), this.jointAnimationInfo.clear()
                    }, e
                }();
            i.internal.DataPoolManager = ZH;
            var QH = [{
                name: "CC_USE_SKINNING",
                value: !0
            }];

            function JH(e, t, n, i) {
                for (var r = 0; r < n.length; r++) {
                    for (var o = n[r], a = -1, s = 0; s < o.length; s++)
                        if (o[s] === i) {
                            a = s;
                            break
                        }
                    a >= 0 && (t.push(r), e.push(a))
                }
            }
            var $H, ek, tk, nk, ik, rk, ok, ak, sk, ck, lk, uk, hk, _k, fk, dk, pk, mk, gk, vk, yk, Sk, Ek, Tk, Ak, xk, Ck, bk, Rk, wk, Ik, Pk, Ok, Dk, Nk, Mk, Lk, Bk, Fk, zk, Uk, Gk, Hk, kk, Vk, Wk = new En,
                jk = new En,
                qk = new En,
                Xk = new En,
                Yk = new Bn,
                Kk = new tu,
                Zk = function(e) {
                    function t() {
                        var t;
                        return (t = e.call(this) || this).uploadAnimation = null, t._buffers = [], t._dataArray = [], t._joints = [], t._bufferIndices = null, t.type = $C.SKINNING, t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.destroy = function() {
                        if (this.bindSkeleton(), this._buffers.length) {
                            for (var t = 0; t < this._buffers.length; t++) this._buffers[t].destroy();
                            this._buffers.length = 0
                        }
                        e.prototype.destroy.call(this)
                    }, n.bindSkeleton = function(e, t, n) {
                        void 0 === e && (e = null), void 0 === t && (t = null), void 0 === n && (n = null);
                        for (var i = 0; i < this._joints.length; i++) FB(this._joints[i].target);
                        if (this._bufferIndices = null, this._joints.length = 0, e && t && n) {
                            this.transform = t;
                            var r = n.getBoneSpaceBounds(e),
                                o = n.struct.jointMaps;
                            this._ensureEnoughBuffers(o && o.length || 1), this._bufferIndices = n.jointBufferIndices;
                            for (var a = 0; a < e.joints.length; a++) {
                                var s = r[a],
                                    c = t.getChildByPath(e.joints[a]);
                                if (s && c) {
                                    var l = BB(c, t),
                                        u = e.bindposes[a],
                                        h = [],
                                        _ = [];
                                    o ? JH(h, _, o, a) : (h.push(a), _.push(0)), this._joints.push({
                                        indices: h,
                                        buffers: _,
                                        bound: s,
                                        target: c,
                                        bindpose: u,
                                        transform: l
                                    })
                                }
                            }
                        }
                    }, n.updateTransform = function(e) {
                        var t = this.transform;
                        (t.hasChangedFlags || t._dirtyFlags) && (t.updateWorldTransform(), this._transformUpdated = !0), En.set(Wk, 1 / 0, 1 / 0, 1 / 0), En.set(jk, -1 / 0, -1 / 0, -1 / 0);
                        for (var n = 0; n < this._joints.length; n++) {
                            var i = this._joints[n],
                                r = i.bound,
                                o = LB(i.transform, e);
                            tu.transform(Kk, r, o), Kk.getBoundary(qk, Xk), En.min(Wk, Wk, qk), En.max(jk, jk, Xk)
                        }
                        var a = this._worldBounds;
                        this._modelBounds && a && (tu.fromPoints(this._modelBounds, Wk, jk), this._modelBounds.transform(t._mat, t._pos, t._rot, t._scale, this._worldBounds), qr.setVec3(this._hWorldBounds, Hr.CENTER, a.center), qr.setVec3(this._hWorldBounds, Hr.HALF_EXTENSION, a.halfExtents))
                    }, n.updateUBOs = function(t) {
                        e.prototype.updateUBOs.call(this, t);
                        for (var n = 0; n < this._joints.length; n++) {
                            var i = this._joints[n],
                                r = i.indices,
                                o = i.buffers,
                                a = i.transform,
                                s = i.bindpose;
                            Bn.multiply(Yk, a.world, s);
                            for (var c = 0; c < o.length; c++) FH(this._dataArray[o[c]], 12 * r[c], Yk)
                        }
                        for (var l = 0; l < this._buffers.length; l++) this._buffers[l].update(this._dataArray[l]);
                        return !0
                    }, n.initSubModel = function(t, n, i) {
                        var r = n.vertexBuffers,
                            o = n.iaInfo;
                        o.vertexBuffers = n.jointMappedBuffers, e.prototype.initSubModel.call(this, t, n, i), o.vertexBuffers = r
                    }, n.getMacroPatches = function(t) {
                        var n = e.prototype.getMacroPatches.call(this, t);
                        return n ? QH.concat(n) : QH
                    }, n._updateLocalDescriptors = function(t, n) {
                        e.prototype._updateLocalDescriptors.call(this, t, n);
                        var i = this._buffers[this._bufferIndices[t]];
                        i && n.bindBuffer(wh.BINDING, i)
                    }, n._ensureEnoughBuffers = function(e) {
                        for (var t = 0; t < e; t++) this._buffers[t] || (this._buffers[t] = this._device.createBuffer(new gs(xa.UNIFORM | xa.TRANSFER_DST, Ra.HOST | Ra.DEVICE, wh.SIZE, wh.SIZE))), this._dataArray[t] || (this._dataArray[t] = new Float32Array(wh.COUNT))
                    }, t
                }(cG),
                Qk = [{
                    name: "CC_USE_SKINNING",
                    value: !0
                }, {
                    name: "CC_USE_BAKED_ANIMATION",
                    value: !0
                }],
                Jk = function(e) {
                    function t() {
                        var t;
                        (t = e.call(this) || this).uploadedAnim = void 0, t._jointsMedium = void 0, t._skeleton = null, t._mesh = null, t._dataPoolManager = void 0, t._instAnimInfoIdx = -1, t.type = $C.BAKED_SKINNING, t._dataPoolManager = i.director.root.dataPoolManager;
                        var n = new Float32Array(4),
                            r = t._dataPoolManager.jointAnimationInfo.getData();
                        return t._jointsMedium = {
                            buffer: null,
                            jointTextureInfo: n,
                            animInfo: r,
                            texture: null,
                            boundsInfo: null
                        }, t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.destroy = function() {
                        this.uploadedAnim = void 0, this._jointsMedium.boundsInfo = null, this._jointsMedium.buffer && (this._jointsMedium.buffer.destroy(), this._jointsMedium.buffer = null), this._applyJointTexture(), e.prototype.destroy.call(this)
                    }, n.bindSkeleton = function(e, t, n) {
                        if (void 0 === e && (e = null), void 0 === t && (t = null), void 0 === n && (n = null), this._skeleton = e, this._mesh = n, e && t && n) {
                            this.transform = t;
                            var i = this._dataPoolManager;
                            this._jointsMedium.animInfo = i.jointAnimationInfo.getData(t.uuid), this._jointsMedium.buffer || (this._jointsMedium.buffer = this._device.createBuffer(new gs(xa.UNIFORM | xa.TRANSFER_DST, Ra.HOST | Ra.DEVICE, Ch.SIZE, Ch.SIZE)))
                        }
                    }, n.updateTransform = function(t) {
                        if (e.prototype.updateTransform.call(this, t), this.uploadedAnim) {
                            var n = this._jointsMedium,
                                i = n.animInfo,
                                r = n.boundsInfo[i.data[0]],
                                o = this._worldBounds;
                            if (o && r) {
                                var a = this.transform;
                                r.transform(a._mat, a._pos, a._rot, a._scale, o), qr.setVec3(this._hWorldBounds, Hr.CENTER, o.center), qr.setVec3(this._hWorldBounds, Hr.HALF_EXTENSION, o.halfExtents)
                            }
                        }
                    }, n.updateUBOs = function(t) {
                        e.prototype.updateUBOs.call(this, t);
                        var n = this._jointsMedium.animInfo,
                            i = this._instAnimInfoIdx;
                        return i >= 0 ? this.instancedAttributes.views[i][0] = n.data[0] : n.dirty && (n.buffer.update(n.data), n.dirty = !1), !0
                    }, n.uploadAnimation = function(e) {
                        if (this._skeleton && this._mesh && this.uploadedAnim !== e) {
                            this.uploadedAnim = e;
                            var t = this._dataPoolManager,
                                n = null;
                            e ? (n = t.jointTexturePool.getSequencePoseTexture(this._skeleton, e, this._mesh, this.transform), this._jointsMedium.boundsInfo = n && n.bounds.get(this._mesh.hash), this._modelBounds = null) : (n = t.jointTexturePool.getDefaultPoseTexture(this._skeleton, this._mesh, this.transform), this._jointsMedium.boundsInfo = null, this._modelBounds = n && n.bounds.get(this._mesh.hash)[0]), this._applyJointTexture(n)
                        }
                    }, n._applyJointTexture = function(e) {
                        void 0 === e && (e = null);
                        var t = this._jointsMedium.texture;
                        if (t && t !== e && this._dataPoolManager.jointTexturePool.releaseHandle(t), this._jointsMedium.texture = e, e) {
                            var n = this._jointsMedium,
                                i = n.buffer,
                                r = n.jointTextureInfo;
                            r[0] = e.handle.texture.width, r[1] = this._skeleton.joints.length, r[2] = e.pixelOffset + .1, r[3] = 1 / r[0], this.updateInstancedJointTextureInfo(), i && i.update(r);
                            for (var o = e.handle.texture, a = 0; a < this._subModels.length; ++a) this._subModels[a].descriptorSet.bindTexture(Ph, o)
                        }
                    }, n.getMacroPatches = function(t) {
                        var n = e.prototype.getMacroPatches.call(this, t);
                        return n ? n.concat(Qk) : Qk
                    }, n._updateLocalDescriptors = function(t, n) {
                        e.prototype._updateLocalDescriptors.call(this, t, n);
                        var i = this._jointsMedium,
                            r = i.buffer,
                            o = i.texture,
                            a = i.animInfo;
                        if (n.bindBuffer(Ch.BINDING, r), n.bindBuffer(bh.BINDING, a.buffer), o) {
                            var s = cd.getSampler(this._device, UH);
                            n.bindTexture(Ph, o.handle.texture), n.bindSampler(Ph, s)
                        }
                    }, n._updateInstancedAttributes = function(t, n) {
                        e.prototype._updateInstancedAttributes.call(this, t, n), this._instAnimInfoIdx = this._getInstancedAttributeIndex(Rh), this.updateInstancedJointTextureInfo()
                    }, n.updateInstancedJointTextureInfo = function() {
                        var e = this._jointsMedium,
                            t = e.jointTextureInfo,
                            n = e.animInfo,
                            i = this._instAnimInfoIdx;
                        if (i >= 0) {
                            var r = this.instancedAttributes.views[i];
                            r[0] = n.data[0], r[1] = t[1], r[2] = t[2]
                        }
                    }, t
                }(cG),
                $k = function(t) {
                    return e({
                        SkinnedMeshRenderer: t,
                        SkinningModelComponent: t
                    }), t
                }(($H = A_("cc.SkinnedMeshRenderer"), ek = B_(), tk = C_(100), nk = D_(), ik = ef(LG), rk = ef(Yv), ok = ef(LG), ak = ef(Yv), sk = G_(), $H(ck = ek(ck = tk(ck = O_(ck = nk((_k = function(e) {
                    function t() {
                        var t;
                        return ne(t = e.call(this) || this, "_skeleton", uk, $(t)), ne(t, "_skinningRoot", hk, $(t)), t._clip = null, t._modelType = Jk, t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.__preload = function() {
                        this._updateModelType()
                    }, n.uploadAnimation = function(e) {
                        this._clip = e, this.model && this.model.uploadAnimation && this.model.uploadAnimation(e)
                    }, n.setUseBakedAnimation = function(e) {
                        void 0 === e && (e = !0);
                        var t = e ? Jk : Zk;
                        this._modelType !== t && (this._modelType = t, this._model && (i.director.root.destroyModel(this._model), this._model = null, this._models.length = 0, this._updateModels(), this._updateCastShadow(), this.enabledInHierarchy && this._attachToScene()))
                    }, n.setMaterial = function(t, n) {
                        e.prototype.setMaterial.call(this, t, n), this._modelType === Zk && this.getMaterialInstance(n)
                    }, n._updateModelParams = function() {
                        this._update(), e.prototype._updateModelParams.call(this)
                    }, n._updateModelType = function() {
                        if (this._skinningRoot) {
                            var e = this._skinningRoot.getComponent("cc.SkeletalAnimation");
                            e ? this.setUseBakedAnimation(e.useBakedAnimation) : this.setUseBakedAnimation(!1)
                        }
                    }, n._update = function() {
                        this.model && (this.model.bindSkeleton(this._skeleton, this._skinningRoot, this._mesh), this.model.uploadAnimation && this.model.uploadAnimation(this._clip))
                    }, K(t, [{
                        key: "skeleton",
                        get: function() {
                            return this._skeleton
                        },
                        set: function(e) {
                            e !== this._skeleton && (this._skeleton = e, this._update())
                        }
                    }, {
                        key: "skinningRoot",
                        get: function() {
                            return this._skinningRoot
                        },
                        set: function(e) {
                            e !== this._skinningRoot && (this._skinningRoot = e, this._updateModelType(), this._update())
                        }
                    }, {
                        key: "model",
                        get: function() {
                            return this._model
                        }
                    }]), t
                }(_G), uk = ie((lk = _k).prototype, "_skeleton", [ik], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return null
                    }
                }), hk = ie(lk.prototype, "_skinningRoot", [rk], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return null
                    }
                }), ie(lk.prototype, "skeleton", [ok], Object.getOwnPropertyDescriptor(lk.prototype, "skeleton"), lk.prototype), ie(lk.prototype, "skinningRoot", [ak, sk], Object.getOwnPropertyDescriptor(lk.prototype, "skinningRoot"), lk.prototype), ck = lk)) || ck) || ck) || ck) || ck) || ck)),
                eV = new Ms(is.ATTR_BATCH_ID, Ea.R32F),
                tV = new Ms(is.ATTR_BATCH_UV, Ea.RG32F),
                nV = tc[eV.format].size + tc[tV.format].size,
                iV = function(t) {
                    return e({
                        SkinnedMeshUnit: t,
                        SkinningModelUnit: t
                    }), t
                }((fk = A_("cc.SkinnedMeshUnit"), dk = ef(_U), pk = ef(LG), mk = ef(nE), gk = ef($k), fk((bk = function() {
                    function e() {
                        ne(this, "mesh", Sk, this), ne(this, "skeleton", Ek, this), ne(this, "material", Tk, this), ne(this, "_localTransform", Ak, this), ne(this, "_offset", xk, this), ne(this, "_size", Ck, this)
                    }
                    return K(e, [{
                        key: "offset",
                        get: function() {
                            return this._offset
                        },
                        set: function(e) {
                            Gn.copy(this._offset, e)
                        }
                    }, {
                        key: "size",
                        get: function() {
                            return this._size
                        },
                        set: function(e) {
                            Gn.copy(this._size, e)
                        }
                    }, {
                        key: "copyFrom",
                        get: function() {
                            return null
                        },
                        set: function(e) {
                            e && (this.mesh = e.mesh, this.skeleton = e.skeleton, this.material = e.getMaterial(0), e.skinningRoot && WB(e.node, e.skinningRoot, this._localTransform))
                        }
                    }]), e
                }(), Sk = ie((yk = bk).prototype, "mesh", [dk], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return null
                    }
                }), Ek = ie(yk.prototype, "skeleton", [pk], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return null
                    }
                }), Tk = ie(yk.prototype, "material", [mk], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return null
                    }
                }), Ak = ie(yk.prototype, "_localTransform", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return new Bn
                    }
                }), xk = ie(yk.prototype, "_offset", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return new Gn(0, 0)
                    }
                }), Ck = ie(yk.prototype, "_size", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return new Gn(1, 1)
                    }
                }), ie(yk.prototype, "offset", [F_], Object.getOwnPropertyDescriptor(yk.prototype, "offset"), yk.prototype), ie(yk.prototype, "size", [F_], Object.getOwnPropertyDescriptor(yk.prototype, "size"), yk.prototype), ie(yk.prototype, "copyFrom", [gk], Object.getOwnPropertyDescriptor(yk.prototype, "copyFrom"), yk.prototype), vk = yk)) || vk)),
                rV = new Bn,
                oV = (new Bn, new En),
                aV = function(t) {
                    return e({
                        SkinnedMeshBatchRenderer: t,
                        BatchedSkinningModelComponent: t
                    }), t
                }((Rk = A_("cc.SkinnedMeshBatchRenderer"), wk = B_(), Ik = C_(100), Pk = D_(), Ok = G_(), Dk = ef([It]), Nk = G_(), Mk = ef([iV]), Lk = G_(), Bk = z_(), Fk = z_(), Rk(zk = wk(zk = Ik(zk = O_(zk = Pk((Vk = function(e) {
                    function t() {
                        for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                        return ne(t = e.call.apply(e, [this].concat(i)) || this, "atlasSize", Gk, $(t)), ne(t, "batchableTextureNames", Hk, $(t)), ne(t, "units", kk, $(t)), t._textures = {}, t._batchMaterial = null, t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.onLoad = function() {
                        e.prototype.onLoad.call(this), this.cook()
                    }, n.onDestroy = function() {
                        for (var t in this._textures) this._textures[t].destroy();
                        this._textures = {}, this._mesh && (this._mesh.destroy(), this._mesh = null), e.prototype.onDestroy.call(this)
                    }, n._onMaterialModified = function(t) {
                        this.cookMaterials(), e.prototype._onMaterialModified.call(this, t, this.getMaterialInstance(t))
                    }, n.cook = function() {
                        this.cookMaterials(), this.cookSkeletons(), this.cookMeshes()
                    }, n.cookMaterials = function() {
                        var e = this;
                        this._batchMaterial || (this._batchMaterial = this.getMaterial(0));
                        var t = this.getMaterialInstance(0);
                        if (t && this._batchMaterial && this._batchMaterial.effectAsset) {
                            t.copy(this._batchMaterial), this.resizeAtlases();
                            for (var n = t.effectAsset.techniques[t.technique], i = function(i) {
                                    var r = n.passes[i];
                                    if (!r.properties) return "continue";
                                    var o = function(n) {
                                        if (r.properties[n].type >= Aa.SAMPLER1D) {
                                            var o = null;
                                            e.batchableTextureNames.find((function(e) {
                                                return e === n
                                            })) ? ((o = e._textures[n]) || (o = e.createTexture(n)), e.cookTextures(o, n, i)) : e.units.some((function(e) {
                                                return o = e.material && e.material.getProperty(n, i)
                                            })), o && t.setProperty(n, o, i)
                                        } else {
                                            for (var a = [], s = 0; s < e.units.length; s++) {
                                                var c = e.units[s];
                                                c.material && a.push(c.material.getProperty(n.slice(0, -3), i))
                                            }
                                            t.setProperty(n, a, i)
                                        }
                                    };
                                    for (var a in r.properties) o(a)
                                }, r = 0; r < n.passes.length; r++) i(r)
                        } else console.warn("incomplete batch material!")
                    }, n.cookSkeletons = function() {
                        if (this._skinningRoot) {
                            for (var e = [], t = [], n = 0; n < this.units.length; n++) {
                                var i = this.units[n];
                                if (i && i.skeleton) {
                                    var r = i.skeleton;
                                    Bn.invert(rV, i._localTransform);
                                    for (var o = function(n) {
                                            var i = r.joints[n];
                                            if (e.findIndex((function(e) {
                                                    return e === i
                                                })) >= 0) return "continue";
                                            e.push(i), t.push(Bn.multiply(new Bn, r.bindposes[n] || Bn.IDENTITY, rV))
                                        }, a = 0; a < r.joints.length; a++) o(a)
                                }
                            }
                            var s = Array.from(Array(e.length).keys()).sort((function(t, n) {
                                    return e[t] > e[n] ? 1 : e[t] < e[n] ? -1 : 0
                                })),
                                c = new LG;
                            c.joints = e.map((function(e, t, n) {
                                return n[s[t]]
                            })), c.bindposes = t.map((function(e, t, n) {
                                return n[s[t]]
                            })), this._skeleton && this._skeleton.destroy(), this.skeleton = c
                        } else console.warn("no skinning root specified!")
                    }, n.cookMeshes = function() {
                        for (var e = this, t = !1, n = 0; n < this.units.length; n++)
                            if (this.units[n].mesh) {
                                t = !0;
                                break
                            }
                        if (t && this._skinningRoot) {
                            this._mesh ? this._mesh.destroyRenderingMesh() : this._mesh = new _U;
                            for (var i = 0, r = Ea.UNKNOWN, o = 0, a = Ea.UNKNOWN, s = 0, c = Ea.UNKNOWN, l = 0, u = Ea.UNKNOWN, h = 0, _ = Ea.UNKNOWN, f = new Array(this.units.length), d = this.units.length, p = 0; p < d; p++) {
                                var m = this.units[p];
                                m && m.skeleton && (f[p] = m.skeleton.joints.map((function(t) {
                                    return e._skeleton.joints.findIndex((function(e) {
                                        return t === e
                                    }))
                                })))
                            }
                            for (var g = function(t) {
                                    var n = e.units[t];
                                    if (!n || !n.mesh || !n.mesh.data) return "continue";
                                    var d = e._createUnitMesh(t, n.mesh),
                                        p = new DataView(d.data.buffer);
                                    Bn.inverseTranspose(rV, n._localTransform);
                                    for (var m = n.offset, g = n.size, v = function(e) {
                                            var v = d.struct.vertexBundles[e];
                                            i = v.view.offset, r = Ea.UNKNOWN;
                                            for (var y = 0; y < v.attributes.length; y++) {
                                                var S = v.attributes[y];
                                                if (S.name === is.ATTR_POSITION) {
                                                    r = S.format;
                                                    break
                                                }
                                                i += tc[S.format].size
                                            }
                                            if (r) {
                                                for (var E = qR(p, r, i, v.view.length, v.view.stride), T = 0; T < E.length; T += 3) En.fromArray(oV, E, T), En.transformMat4(oV, oV, n._localTransform), En.toArray(E, oV, T);
                                                jR(p, E, r, i, v.view.stride)
                                            }
                                            o = v.view.offset, a = Ea.UNKNOWN;
                                            for (var A = 0; A < v.attributes.length; A++) {
                                                var x = v.attributes[A];
                                                if (x.name === is.ATTR_NORMAL) {
                                                    a = x.format;
                                                    break
                                                }
                                                o += tc[x.format].size
                                            }
                                            if (a) {
                                                for (var C = qR(p, a, o, v.view.length, v.view.stride), b = 0; b < C.length; b += 3) En.fromArray(oV, C, b), En.transformMat4Normal(oV, oV, rV), En.toArray(C, oV, b);
                                                jR(p, C, a, o, v.view.stride)
                                            }
                                            s = v.view.offset, c = Ea.UNKNOWN;
                                            for (var R = 0; R < v.attributes.length; R++) {
                                                var w = v.attributes[R];
                                                if (w.name === is.ATTR_TANGENT) {
                                                    c = w.format;
                                                    break
                                                }
                                                s += tc[w.format].size
                                            }
                                            if (c) {
                                                for (var I = qR(p, c, s, v.view.length, v.view.stride), P = 0; P < I.length; P += 3) En.fromArray(oV, I, P), En.transformMat4Normal(oV, oV, rV), En.toArray(I, oV, P);
                                                jR(p, I, c, s, v.view.stride)
                                            }
                                            l = v.view.offset, u = Ea.UNKNOWN;
                                            for (var O = 0; O < v.attributes.length; O++) {
                                                var D = v.attributes[O];
                                                if (D.name === is.ATTR_BATCH_UV) {
                                                    u = D.format;
                                                    break
                                                }
                                                l += tc[D.format].size
                                            }
                                            u && XR(p, (function(e, t) {
                                                var n, i = 0 === t ? "x" : "y";
                                                return (e = (n = e) - Math.floor(n)) * g[i] + m[i]
                                            }), u, l, v.view.length, v.view.stride, p);
                                            var N = f[t];
                                            if (!N) return "continue";
                                            h = v.view.offset, _ = Ea.UNKNOWN;
                                            for (var M = 0; M < v.attributes.length; M++) {
                                                var L = v.attributes[M];
                                                if (L.name === is.ATTR_JOINTS) {
                                                    _ = L.format;
                                                    break
                                                }
                                                h += tc[L.format].size
                                            }
                                            _ && XR(p, (function(e) {
                                                return N[e]
                                            }), _, h, v.view.length, v.view.stride, p)
                                        }, y = 0; y < d.struct.vertexBundles.length; y++) v(y);
                                    e._mesh.merge(d)
                                }, v = 0; v < d; v++) g(v);
                            this._onMeshChanged(this._mesh), this._updateModels()
                        }
                    }, n.cookTextures = function(e, t, n) {
                        for (var r = [], o = [], a = [], s = [], c = 0; c < this.units.length; c++) {
                            var l = this.units[c];
                            if (l.material) {
                                var u = l.material.getProperty(t, n);
                                if (u && u.image && u.image.data) {
                                    var h = new fs;
                                    h.texOffset.x = l.offset.x * this.atlasSize, h.texOffset.y = l.offset.y * this.atlasSize, h.texExtent.width = l.size.x * this.atlasSize, h.texExtent.height = l.size.y * this.atlasSize;
                                    var _ = u.image.data;
                                    ArrayBuffer.isView(_) ? (a.push(_), s.push(h)) : (r.push(_), o.push(h))
                                }
                            }
                        }
                        var f = e.getGFXTexture(),
                            d = i.director.root.device;
                        a.length > 0 && d.copyBuffersToTexture(a, f, s), r.length > 0 && d.copyTexImagesToTexture(r, f, o)
                    }, n.createTexture = function(e) {
                        var t = new yp;
                        return t.setFilters(Bf.LINEAR, Bf.LINEAR), t.setMipFilter(Bf.NEAREST), t.reset({
                            width: this.atlasSize,
                            height: this.atlasSize,
                            format: Mf.RGBA8888
                        }), t.loaded = !0, this._textures[e] = t, t
                    }, n.resizeAtlases = function() {
                        for (var e in this._textures) this._textures[e].reset({
                            width: this.atlasSize,
                            height: this.atlasSize,
                            format: Mf.RGBA8888
                        })
                    }, n._createUnitMesh = function(e, t) {
                        for (var n = JSON.parse(JSON.stringify(t.struct)), r = {}, o = 0; o < t.struct.primitives.length; o++) {
                            for (var a = t.struct.primitives[o], s = 0, c = Ea.UNKNOWN, l = 0; l < a.vertexBundelIndices.length; l++) {
                                var u = t.struct.vertexBundles[a.vertexBundelIndices[l]];
                                s = u.view.offset, c = Ea.UNKNOWN;
                                for (var h = 0; h < u.attributes.length; h++) {
                                    var _ = u.attributes[h];
                                    if (_.name === is.ATTR_TEX_COORD) {
                                        c = _.format;
                                        break
                                    }
                                    s += tc[_.format].size
                                }
                                if (c) break
                            }
                            if (void 0 === r[l]) {
                                r[l] = [c, s];
                                var f = n.vertexBundles[l];
                                f.attributes.push(eV), f.attributes.push(tV), f.view.offset = 0, f.view.length += f.view.count * nV, f.view.stride += nV
                            }
                        }
                        for (var d = 0, p = 0; p < n.vertexBundles.length; p++) d += n.vertexBundles[p].view.length;
                        for (var m = 0; m < n.primitives.length; m++) {
                            var g = n.primitives[m];
                            g.indexView && (g.indexView.offset = d, d += g.indexView.length)
                        }
                        var v = new Uint8Array(d),
                            y = t.data,
                            S = new DataView(v.buffer),
                            E = new DataView(y.buffer),
                            T = i.sys.isLittleEndian;
                        for (var A in r)
                            for (var x = n.vertexBundles[A], C = t.struct.vertexBundles[A], b = r[A], R = qR(E, b[0], b[1], C.view.length, C.view.stride), w = C.view, I = x.view, P = w.stride, O = I.stride, D = w.offset, N = I.offset, M = 0; M < I.count; M++) {
                                var L = y.subarray(D, D + P);
                                v.set(L, N), S.setFloat32(N + P, e), S.setFloat32(N + P + 4, R[2 * M], T), S.setFloat32(N + P + 8, R[2 * M + 1], T), N += O, D += P
                            }
                        for (var B = 0; B < n.primitives.length; B++) {
                            var F = t.struct.primitives[B],
                                z = n.primitives[B];
                            if (F.indexView && z.indexView)
                                for (var U = F.indexView.stride, G = z.indexView.stride, H = F.indexView.offset, k = z.indexView.offset, V = 0; V < z.indexView.count; V++) {
                                    var W = y.subarray(H, H + U);
                                    v.set(W, k), k += G, H += U
                                }
                        }
                        var j = new _U;
                        return j.reset({
                            struct: n,
                            data: v
                        }), j
                    }, K(t, [{
                        key: "mesh",
                        get: function() {
                            return e.prototype.mesh
                        },
                        set: function(e) {
                            this.mesh = e
                        }
                    }, {
                        key: "skeleton",
                        get: function() {
                            return e.prototype.skeleton
                        },
                        set: function(e) {
                            this.skeleton = e
                        }
                    }]), t
                }($k), Gk = ie((Uk = Vk).prototype, "atlasSize", [w_, Ok], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 1024
                    }
                }), Hk = ie(Uk.prototype, "batchableTextureNames", [Dk, w_, Nk], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return []
                    }
                }), kk = ie(Uk.prototype, "units", [Mk, w_, Lk], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return []
                    }
                }), ie(Uk.prototype, "mesh", [tf, Bk], Object.getOwnPropertyDescriptor(Uk.prototype, "mesh"), Uk.prototype), ie(Uk.prototype, "skeleton", [tf, Fk], Object.getOwnPropertyDescriptor(Uk.prototype, "skeleton"), Uk.prototype), zk = Uk)) || zk) || zk) || zk) || zk) || zk));
            i.SkinningModelComponent = $k, Qe.setClassAlias($k, "cc.SkinningModelComponent"), i.SkinningModelUnit = iV, Qe.setClassAlias(iV, "cc.SkinningModelUnit"), i.BatchedSkinningModelComponent = aV, Qe.setClassAlias(aV, "cc.BatchedSkinningModelComponent");
            var sV, cV, lV, uV, hV, _V, fV, dV, pV, mV, gV, vV, yV, SV, EV, TV, AV, xV, CV, bV, RV = new Bn,
                wV = new Bn,
                IV = [],
                PV = e("SkeletalAnimationState", function(e) {
                    function t(t, n) {
                        var r;
                        return void 0 === n && (n = ""), (r = e.call(this, t, n) || this)._frames = 1, r._bakedDuration = 0, r._animInfo = null, r._sockets = [], r._animInfoMgr = void 0, r._comps = [], r._parent = null, r._curvesInited = !1, r._animInfoMgr = i.director.root.dataPoolManager.jointAnimationInfo, r
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.initialize = function(t) {
                        if (!this._curveLoaded) {
                            this._comps.length = 0;
                            for (var n = t.getComponentsInChildren($k), i = 0; i < n.length; ++i) {
                                var r = n[i];
                                r.skinningRoot === t && this._comps.push(r)
                            }
                            this._parent = t.getComponent("cc.SkeletalAnimation");
                            var o = this._parent.useBakedAnimation;
                            e.prototype.initialize.call(this, t, o ? IV : void 0), this._curvesInited = !o;
                            var a = XL.getOrExtract(this.clip).info;
                            this._frames = a.frames - 1, this._animInfo = this._animInfoMgr.getData(t.uuid), this._bakedDuration = this._frames / a.sample
                        }
                    }, n.onPlay = function() {
                        if (e.prototype.onPlay.call(this), this._parent.useBakedAnimation) {
                            this._sampleCurves = this._sampleCurvesBaked, this.duration = this._bakedDuration, this._animInfoMgr.switchClip(this._animInfo, this.clip);
                            for (var t = 0; t < this._comps.length; ++t) this._comps[t].uploadAnimation(this.clip)
                        } else this._sampleCurves = e.prototype._sampleCurves, this.duration = this.clip.duration, this._curvesInited || (this._curveLoaded = !1, e.prototype.initialize.call(this, this._targetNode), this._curvesInited = !0)
                    }, n.rebuildSocketCurves = function(e) {
                        if (this._sockets.length = 0, this._targetNode)
                            for (var t = this._targetNode, n = 0; n < e.length; ++n) {
                                var i = e[n],
                                    r = t.getChildByPath(i.path);
                                if (i.target) {
                                    for (var o = XL.getOrExtract(this.clip), a = i.path, s = o.data[a], c = r, l = void 0; !s;) {
                                        var u = a.lastIndexOf("/");
                                        if (a = a.substring(0, u), s = o.data[a], c && (l || (l = Bn.identity(wV)), Bn.fromRTS(RV, c.rotation, c.position, c.scale), Bn.multiply(l, RV, l), c = c.parent), u < 0) break
                                    }
                                    for (var h = s && s.worldMatrix.values, _ = o.info.frames, f = [], d = 0; d < _; d++) {
                                        var p;
                                        p = h && l ? Bn.multiply(RV, h[d], l) : h ? h[d] : l || Bn.IDENTITY;
                                        var m = {
                                            pos: new En,
                                            rot: new wn,
                                            scale: new En
                                        };
                                        Bn.toRTS(p, m.rot, m.pos, m.scale), f.push(m)
                                    }
                                    this._sockets.push({
                                        target: i.target,
                                        frames: f
                                    })
                                }
                            }
                    }, n._sampleCurvesBaked = function(e) {
                        var t = this._animInfo,
                            n = e * this._frames + .5 | 0;
                        if (n !== t.data[0]) {
                            t.data[0] = n, t.dirty = !0;
                            for (var i = 0; i < this._sockets.length; ++i) {
                                var r = this._sockets[i],
                                    o = r.target,
                                    a = r.frames[n],
                                    s = a.pos,
                                    c = a.rot,
                                    l = a.scale;
                                o.setRTS(c, s, l)
                            }
                        }
                    }, t
                }(cB)),
                OV = e("Socket", (sV = A_("cc.SkeletalAnimation.Socket"), cV = ef(Yv), sV((hV = ie((uV = function(e, t) {
                    void 0 === e && (e = ""), void 0 === t && (t = null), ne(this, "path", hV, this), ne(this, "target", _V, this), this.path = e, this.target = t
                }).prototype, "path", [w_, F_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return ""
                    }
                }), _V = ie(uV.prototype, "target", [cV], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return null
                    }
                }), lV = uV)) || lV));
            Qe.setClassAlias(OV, "cc.SkeletalAnimationComponent.Socket");
            var DV = new Bn,
                NV = new Bn;

            function MV(e, t, n) {
                void 0 === t && (t = ""), void 0 === n && (n = []);
                for (var i = 0; i < e.children.length; i++) {
                    var r = e.children[i];
                    if (r) {
                        var o = t ? t + "/" + r.name : r.name;
                        n.push(o), MV(r, o, n)
                    }
                }
                return n
            }
            var LV = function(t) {
                return e({
                    SkeletalAnimation: t,
                    SkeletalAnimationComponent: t
                }), t
            }((fV = A_("cc.SkeletalAnimation"), dV = B_(), pV = C_(99), mV = D_(), gV = ef([OV]), vV = G_(), yV = G_(), SV = ef([OV]), fV(EV = dV(EV = pV(EV = O_(EV = mV((bV = CV = function(e) {
                function t() {
                    for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                    return ne(t = e.call.apply(e, [this].concat(i)) || this, "_useBakedAnimation", AV, $(t)), ne(t, "_sockets", xV, $(t)), t
                }
                Q(t, e);
                var n = t.prototype;
                return n.onDestroy = function() {
                    e.prototype.onDestroy.call(this), i.director.root.dataPoolManager.jointAnimationInfo.destroy(this.node.uuid), i.director.getAnimationManager().removeSockets(this.node, this._sockets)
                }, n.start = function() {
                    this.sockets = this._sockets, this.useBakedAnimation = this._useBakedAnimation, e.prototype.start.call(this)
                }, n.querySockets = function() {
                    var e = this._defaultClip && Object.keys(XL.getOrExtract(this._defaultClip).data).sort().reduce((function(e, t) {
                        return t.startsWith(e[e.length - 1]) || e.push(t), e
                    }), []) || [];
                    if (!e.length) return ["please specify a valid default animation clip first"];
                    for (var t = [], n = 0; n < e.length; n++) {
                        var i = e[n],
                            r = this.node.getChildByPath(i);
                        r && (t.push(i), MV(r, i, t))
                    }
                    return t
                }, n.rebuildSocketAnimations = function() {
                    for (var e, t = te(this._sockets); !(e = t()).done;) {
                        var n = e.value,
                            i = this.node.getChildByPath(n.path),
                            r = n.target;
                        i && r && (r.name = n.path.substring(n.path.lastIndexOf("/") + 1) + " Socket", r.parent = this.node, WB(i, this.node, DV), Bn.fromRTS(NV, r.rotation, r.position, r.scale), Bn.equals(NV, DV) || (r.matrix = DV))
                    }
                    for (var o = 0, a = Object.keys(this._nameToState); o < a.length; o++) {
                        var s = a[o];
                        this._nameToState[s].rebuildSocketCurves(this._sockets)
                    }
                }, n.createSocket = function(e) {
                    var t = this._sockets.find((function(t) {
                        return t.path === e
                    }));
                    if (t) return t.target;
                    if (!this.node.getChildByPath(e)) return console.warn("illegal socket path"), null;
                    var n = new Yv;
                    return n.parent = this.node, this._sockets.push(new OV(e, n)), this.rebuildSocketAnimations(), n
                }, n._createState = function(e, t) {
                    return new PV(e, t)
                }, n._doCreateState = function(t, n) {
                    var i = e.prototype._doCreateState.call(this, t, n);
                    return i.rebuildSocketCurves(this._sockets), i
                }, K(t, [{
                    key: "sockets",
                    get: function() {
                        return this._sockets
                    },
                    set: function(e) {
                        if (!this._useBakedAnimation) {
                            var t = i.director.getAnimationManager();
                            t.removeSockets(this.node, this._sockets), t.addSockets(this.node, e)
                        }
                        this._sockets = e, this.rebuildSocketAnimations()
                    }
                }, {
                    key: "useBakedAnimation",
                    get: function() {
                        return this._useBakedAnimation
                    },
                    set: function(e) {
                        this._useBakedAnimation = e;
                        for (var t = this.node.getComponentsInChildren($k), n = 0; n < t.length; ++n) {
                            var r = t[n];
                            r.skinningRoot === this.node && r.setUseBakedAnimation(this._useBakedAnimation)
                        }
                        this._useBakedAnimation ? i.director.getAnimationManager().removeSockets(this.node, this._sockets) : i.director.getAnimationManager().addSockets(this.node, this._sockets)
                    }
                }]), t
            }(wB), CV.Socket = OV, ie((TV = bV).prototype, "sockets", [gV, vV], Object.getOwnPropertyDescriptor(TV.prototype, "sockets"), TV.prototype), ie(TV.prototype, "useBakedAnimation", [yV], Object.getOwnPropertyDescriptor(TV.prototype, "useBakedAnimation"), TV.prototype), AV = ie(TV.prototype, "_useBakedAnimation", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return !0
                }
            }), xV = ie(TV.prototype, "_sockets", [SV], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return []
                }
            }), EV = TV)) || EV) || EV) || EV) || EV) || EV));
            i.SkeletalAnimationComponent = LV, Qe.setClassAlias(LV, "cc.SkeletalAnimationComponent"), i.utils = EU;
            var BV = new En,
                FV = new Bn;

            function zV(e, t, n, i) {
                var r = n.data,
                    o = t.acquireBufferBatch(),
                    a = o.byteOffset >> 2,
                    s = n.vertexCount,
                    c = o.indicesOffset,
                    l = o.vertexOffset;
                o.request(s, n.indicesCount) || (o = t.currBufferBatch, s = 0, c = 0, l = 0);
                var u = o.vData,
                    h = o.iData;
                e.getWorldMatrix(FV);
                for (var _ = 0; _ < s; _++) {
                    var f = r[_];
                    En.set(BV, f.x, f.y, 0), En.transformMat4(BV, BV, FV), u[a++] = BV.x, u[a++] = BV.y, u[a++] = BV.z, u[a++] = f.u, u[a++] = f.v, yn.toArray(u, i, a), a += 4
                }
                for (var d = 0, p = s / 4; d < p; d++) {
                    var m = l + 4 * d;
                    h[c++] = m, h[c++] = m + 1, h[c++] = m + 2, h[c++] = m + 1, h[c++] = m + 3, h[c++] = m + 2
                }
            }
            var UV = function() {
                    function e(e, t) {
                        this._texture = void 0, this._width = void 0, this._height = void 0, this._x = void 0, this._y = void 0, this._nexty = void 0, this._innerTextureInfos = {}, this._innerSpriteFrames = void 0, this._count = void 0;
                        var n = new GV;
                        n.initWithSize(e, t), this._texture = n, this._width = e, this._height = t, this._x = 2, this._y = 2, this._nexty = 2, this._innerTextureInfos = {}, this._innerSpriteFrames = [], this._count = 0
                    }
                    var t = e.prototype;
                    return t.insertSpriteFrame = function(e) {
                        var t = e.rect,
                            n = e.texture,
                            r = this._innerTextureInfos[n.getId()],
                            o = t.x,
                            a = t.y;
                        if (r) o += r.x, a += r.y;
                        else {
                            var s = n.width,
                                c = n.height;
                            if (this._x + s + 2 > this._width && (this._x = 2, this._y = this._nexty), this._y + c + 2 > this._nexty && (this._nexty = this._y + c + 2), this._nexty > this._height) return null;
                            i.internal.dynamicAtlasManager.textureBleeding && ((s <= 8 || c <= 8) && (this._texture.drawTextureAt(n.image, this._x - 1, this._y - 1), this._texture.drawTextureAt(n.image, this._x - 1, this._y + 1), this._texture.drawTextureAt(n.image, this._x + 1, this._y - 1), this._texture.drawTextureAt(n.image, this._x + 1, this._y + 1)), this._texture.drawTextureAt(n.image, this._x - 1, this._y), this._texture.drawTextureAt(n.image, this._x + 1, this._y), this._texture.drawTextureAt(n.image, this._x, this._y - 1), this._texture.drawTextureAt(n.image, this._x, this._y + 1)), this._texture.drawTextureAt(n.image, this._x, this._y), this._innerTextureInfos[n.getId()] = {
                                x: this._x,
                                y: this._y,
                                texture: n
                            }, this._count++, o += this._x, a += this._y, this._x += s + 2
                        }
                        var l = {
                            x: o,
                            y: a,
                            texture: this._texture
                        };
                        return this._innerSpriteFrames.push(e), l
                    }, t.deleteInnerTexture = function(e) {
                        e && this._innerTextureInfos[e.getId()] && (delete this._innerTextureInfos[e.getId()], this._count--)
                    }, t.isEmpty = function() {
                        return this._count <= 0
                    }, t.reset = function() {
                        this._x = 2, this._y = 2, this._nexty = 2;
                        for (var e = this._innerSpriteFrames, t = 0, n = e.length; t < n; t++) {
                            var i = e[t];
                            i.isValid && i._resetDynamicAtlasFrame()
                        }
                        this._innerSpriteFrames.length = 0, this._innerTextureInfos = {}
                    }, t.destroy = function() {
                        this.reset(), this._texture.destroy()
                    }, e
                }(),
                GV = function(e) {
                    function t() {
                        return e.apply(this, arguments) || this
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.initWithSize = function(e, t, n) {
                        void 0 === n && (n = Mf.RGBA8888), this.reset({
                            width: e,
                            height: t,
                            format: n
                        }), this.loaded = !0, this.emit("load")
                    }, n.drawTextureAt = function(e, t, n) {
                        var i = this.getGFXTexture();
                        if (e && i) {
                            var r = this._getGFXDevice();
                            if (r) {
                                var o = new fs;
                                o.texOffset.x = t, o.texOffset.y = n, o.texExtent.width = e.width, o.texExtent.height = e.height, r.copyTexImagesToTexture([e.data], i, [o])
                            } else console.warn("Unable to get device")
                        }
                    }, t
                }(yp),
                HV = function() {
                    function e() {
                        this._atlases = [], this._atlasIndex = -1, this._maxAtlasCount = 5, this._textureSize = 2048, this._maxFrameSize = 512, this._textureBleeding = !0, this._enabled = !1
                    }
                    var t = e.prototype;
                    return t.newAtlas = function() {
                        var e = this._atlases[++this._atlasIndex];
                        return e || (e = new UV(this._textureSize, this._textureSize), this._atlases.push(e)), e
                    }, t.beforeSceneLoad = function() {
                        this.reset()
                    }, t.insertSpriteFrame = function(e) {
                        if (!this._enabled || this._atlasIndex === this._maxAtlasCount || !e || e._original) return null;
                        if (!e.packable) return null;
                        var t = this._atlases[this._atlasIndex];
                        t || (t = this.newAtlas());
                        var n = t.insertSpriteFrame(e);
                        return n || this._atlasIndex === this._maxAtlasCount ? n : (t = this.newAtlas()).insertSpriteFrame(e)
                    }, t.reset = function() {
                        for (var e = 0, t = this._atlases.length; e < t; e++) this._atlases[e].destroy();
                        this._atlases.length = 0, this._atlasIndex = -1
                    }, t.deleteAtlasSpriteFrame = function(e) {
                        if (e._original) {
                            var t = e._original._texture;
                            this.deleteAtlasTexture(t)
                        }
                    }, t.deleteAtlasTexture = function(e) {
                        if (e)
                            for (var t = this._atlases.length - 1; t >= 0; t--) this._atlases[t].deleteInnerTexture(e), this._atlases[t].isEmpty() && (this._atlases[t].destroy(), this._atlases.splice(t, 1), this._atlasIndex--)
                    }, t.packToDynamicAtlas = function(e, t) {
                        if (!t._original && t.packable) {
                            var n = this.insertSpriteFrame(t);
                            n && t._setDynamicAtlasFrame(n)
                        }
                    }, K(e, [{
                        key: "enabled",
                        get: function() {
                            return this._enabled
                        },
                        set: function(e) {
                            this._enabled !== e && (e ? (this.reset(), i.director.on(i.Director.EVENT_BEFORE_SCENE_LAUNCH, this.beforeSceneLoad, this)) : (this.reset(), i.director.off(i.Director.EVENT_BEFORE_SCENE_LAUNCH, this.beforeSceneLoad, this)), this._enabled = e)
                        }
                    }, {
                        key: "maxAtlasCount",
                        get: function() {
                            return this._maxAtlasCount
                        },
                        set: function(e) {
                            this._maxAtlasCount = e
                        }
                    }, {
                        key: "atlasCount",
                        get: function() {
                            return this._atlases.length
                        }
                    }, {
                        key: "textureBleeding",
                        get: function() {
                            return this._textureBleeding
                        },
                        set: function(e) {
                            this._textureBleeding = e
                        }
                    }, {
                        key: "textureSize",
                        get: function() {
                            return this._textureSize
                        },
                        set: function(e) {
                            this._textureSize = e
                        }
                    }, {
                        key: "maxFrameSize",
                        get: function() {
                            return this._maxFrameSize
                        },
                        set: function(e) {
                            this._maxFrameSize = e
                        }
                    }]), e
                }();
            HV.instance = void 0;
            var kV, VV = e("dynamicAtlasManager", HV.instance = new HV);
            i.internal.dynamicAtlasManager = VV;
            var WV, jV, qV, XV, YV = [{
                    u: 0,
                    v: 0
                }, {
                    u: 0,
                    v: 0
                }, {
                    u: 0,
                    v: 0
                }, {
                    u: 0,
                    v: 0
                }],
                KV = e("SpriteFrame", A_("cc.SpriteFrame")(kV = function(e) {
                    function t() {
                        var t;
                        return (t = e.call(this) || this).vertices = null, t.uv = [], t.uvHash = 0, t.unbiasUV = [], t.uvSliced = [], t._rect = new Kn, t._offset = new Gn, t._originalSize = new Xn, t._rotated = !1, t._capInsets = [0, 0, 0, 0], t._atlasUuid = "", t._texture = void 0, t._isFlipUVY = !1, t._isFlipUVX = !1, t._original = null, t._packable = !0, t
                    }
                    Q(t, e), t.createWithImage = function(e) {
                        var n = e instanceof Wf ? e : new Wf(e),
                            i = new yp;
                        i.image = n;
                        var r = new t;
                        return r.texture = i, r
                    };
                    var n = t.prototype;
                    return n.textureLoaded = function() {
                        return this.texture && this.texture.loaded
                    }, n.isRotated = function() {
                        return this._rotated
                    }, n.setRotated = function(e) {
                        this.rotated = e
                    }, n.getRect = function(e) {
                        return e ? (e.set(this._rect), e) : this._rect.clone()
                    }, n.setRect = function(e) {
                        this.rect = e
                    }, n.getOriginalSize = function(e) {
                        return e ? (e.set(this._originalSize), e) : this._originalSize.clone()
                    }, n.setOriginalSize = function(e) {
                        this.originalSize = e
                    }, n.getOffset = function(e) {
                        return e ? (e.set(this._offset), e) : this._offset.clone()
                    }, n.setOffset = function(e) {
                        this.offset = e
                    }, n.getGFXTexture = function() {
                        return this._texture.getGFXTexture()
                    }, n.getGFXSampler = function() {
                        return this._texture.getGFXSampler()
                    }, n.getHash = function() {
                        return this._texture.getHash()
                    }, n.getSamplerHash = function() {
                        return this._texture.getSamplerHash()
                    }, n.reset = function(e, t) {
                        void 0 === t && (t = !1);
                        var n = !1;
                        t && (this._originalSize.set(0, 0), this._rect.set(0, 0, 0, 0), this._offset.set(0, 0), this._capInsets = [0, 0, 0, 0], this._rotated = !1, n = !0), e && (e.texture && (this.loaded = !1, this._rect.x = this._rect.y = 0, this._rect.width = e.texture.width, this._rect.height = e.texture.height, this._refreshTexture(e.texture), this.checkRect(this._texture)), e.originalSize && this._originalSize.set(e.originalSize), e.rect && this._rect.set(e.rect), e.offset && this._offset.set(e.offset), void 0 !== e.borderTop && (this._capInsets[1] = e.borderTop), void 0 !== e.borderBottom && (this._capInsets[3] = e.borderBottom), void 0 !== e.borderLeft && (this._capInsets[0] = e.borderLeft), void 0 !== e.borderRight && (this._capInsets[2] = e.borderRight), void 0 !== e.isRotate && (this._rotated = !!e.isRotate), void 0 !== e.isFlipUv && (this._isFlipUVY = !!e.isFlipUv), n = !0), n && this.texture && this._calculateUV()
                    }, n.checkRect = function(e) {
                        var t = this._rect,
                            n = t.x,
                            i = t.y;
                        return this._rotated ? (n += t.height, i += t.width) : (n += t.width, i += t.height), n > e.width ? (b(3300, this.name + "/" + e.name, n, e.width), !1) : !(i > e.height && (b(3301, this.name + "/" + e.name, i, e.height), 1))
                    }, n.onLoaded = function() {
                        this.loaded = !0, this.emit("load")
                    }, n.destroy = function() {
                        return this._packable && VV && VV.deleteAtlasSpriteFrame(this), e.prototype.destroy.call(this)
                    }, n._calculateSlicedUV = function() {
                        var e = this._rect,
                            t = this.texture,
                            n = t.width,
                            i = t.height,
                            r = this._capInsets[0],
                            o = this._capInsets[2],
                            a = e.width - r - o,
                            s = this._capInsets[1],
                            c = this._capInsets[3],
                            l = e.height - s - c,
                            u = this.uvSliced;
                        if (u.length = 0, this._rotated) {
                            YV[0].u = e.x / n, YV[1].u = (e.x + c) / n, YV[2].u = (e.x + c + l) / n, YV[3].u = (e.x + e.height) / n, YV[3].v = e.y / i, YV[2].v = (e.y + r) / i, YV[1].v = (e.y + r + a) / i, YV[0].v = (e.y + e.width) / i;
                            for (var h = 0; h < 4; ++h)
                                for (var _ = YV[h], f = 0; f < 4; ++f) {
                                    var d = YV[3 - f];
                                    u.push({
                                        u: _.u,
                                        v: d.v
                                    })
                                }
                        } else {
                            YV[0].u = e.x / n, YV[1].u = (e.x + r) / n, YV[2].u = (e.x + r + a) / n, YV[3].u = (e.x + e.width) / n, YV[3].v = e.y / i, YV[2].v = (e.y + s) / i, YV[1].v = (e.y + s + l) / i, YV[0].v = (e.y + e.height) / i;
                            for (var p = 0; p < 4; ++p)
                                for (var m = YV[p], g = 0; g < 4; ++g) {
                                    var v = YV[g];
                                    u.push({
                                        u: v.u,
                                        v: m.v
                                    })
                                }
                        }
                    }, n._calculateUV = function() {
                        var e = this._rect,
                            t = this.uv,
                            n = this.unbiasUV,
                            i = this.texture,
                            r = i.width,
                            o = i.height;
                        if (this._rotated) {
                            var a = 0 === r ? 0 : e.x / r,
                                s = 0 === r ? 1 : (e.x + e.height) / r,
                                c = 0 === o ? 0 : e.y / o,
                                l = 0 === o ? 1 : (e.y + e.width) / o;
                            this._isFlipUVX && this._isFlipUVY ? (t[0] = s, t[1] = l, t[2] = s, t[3] = c, t[4] = a, t[5] = l, t[6] = a, t[7] = c) : this._isFlipUVX ? (t[0] = s, t[1] = c, t[2] = s, t[3] = l, t[4] = a, t[5] = c, t[6] = a, t[7] = l) : this._isFlipUVY ? (t[0] = a, t[1] = l, t[2] = a, t[3] = c, t[4] = s, t[5] = l, t[6] = s, t[7] = c) : (t[0] = a, t[1] = c, t[2] = a, t[3] = l, t[4] = s, t[5] = c, t[6] = s, t[7] = l);
                            var u = 0 === r ? 0 : e.x / r,
                                h = 0 === r ? 1 : (e.x + e.height) / r,
                                _ = 0 === o ? 0 : e.y / o,
                                f = 0 === o ? 1 : (e.y + e.width) / o;
                            this._isFlipUVX && this._isFlipUVY ? (n[0] = h, n[1] = f, n[2] = h, n[3] = _, n[4] = u, n[5] = f, n[6] = u, n[7] = _) : this._isFlipUVX ? (n[0] = h, n[1] = _, n[2] = h, n[3] = f, n[4] = u, n[5] = _, n[6] = u, n[7] = f) : this._isFlipUVY ? (n[0] = u, n[1] = f, n[2] = u, n[3] = _, n[4] = h, n[5] = f, n[6] = h, n[7] = _) : (n[0] = u, n[1] = _, n[2] = u, n[3] = f, n[4] = h, n[5] = _, n[6] = h, n[7] = f)
                        } else {
                            var d = 0 === r ? 0 : e.x / r,
                                p = 0 === r ? 1 : (e.x + e.width) / r,
                                m = 0 === o ? 1 : (e.y + e.height) / o,
                                g = 0 === o ? 0 : e.y / o;
                            this._isFlipUVX && this._isFlipUVY ? (t[0] = p, t[1] = g, t[2] = d, t[3] = g, t[4] = p, t[5] = m, t[6] = d, t[7] = m) : this._isFlipUVX ? (t[0] = p, t[1] = m, t[2] = d, t[3] = m, t[4] = p, t[5] = g, t[6] = d, t[7] = g) : this._isFlipUVY ? (t[0] = d, t[1] = g, t[2] = p, t[3] = g, t[4] = d, t[5] = m, t[6] = p, t[7] = m) : (t[0] = d, t[1] = m, t[2] = p, t[3] = m, t[4] = d, t[5] = g, t[6] = p, t[7] = g);
                            var v = 0 === r ? 0 : e.x / r,
                                y = 0 === r ? 1 : (e.x + e.width) / r,
                                S = 0 === o ? 1 : (e.y + e.height) / o,
                                E = 0 === o ? 0 : e.y / o;
                            this._isFlipUVX && this._isFlipUVY ? (n[0] = y, n[1] = E, n[2] = v, n[3] = E, n[4] = y, n[5] = S, n[6] = v, n[7] = S) : this._isFlipUVX ? (n[0] = y, n[1] = S, n[2] = v, n[3] = S, n[4] = y, n[5] = E, n[6] = v, n[7] = E) : this._isFlipUVY ? (n[0] = v, n[1] = E, n[2] = y, n[3] = E, n[4] = v, n[5] = S, n[6] = y, n[7] = S) : (n[0] = v, n[1] = S, n[2] = y, n[3] = S, n[4] = v, n[5] = E, n[6] = y, n[7] = E)
                        }
                        for (var T = "", A = 0; A < t.length; A++) T += t[A];
                        this.uvHash = vc(T, 666);
                        var x = this.vertices;
                        if (x) {
                            x.nu.length = 0, x.nv.length = 0;
                            for (var C = 0; C < x.u.length; C++) x.nu[C] = x.u[C] / r, x.nv[C] = x.v[C] / o
                        }
                        this._calculateSlicedUV()
                    }, n._setDynamicAtlasFrame = function(e) {
                        e && (this._original = {
                            _texture: this._texture,
                            _x: this._rect.x,
                            _y: this._rect.y
                        }, this._texture = e.texture, this._rect.x = e.x, this._rect.y = e.y, this._calculateUV())
                    }, n._resetDynamicAtlasFrame = function() {
                        this._original && (this._rect.x = this._original._x, this._rect.y = this._original._y, this._texture = this._original._texture, this._original = null, this._calculateUV())
                    }, n._checkPackable = function() {
                        var e = VV;
                        if (e) {
                            var t = this._texture;
                            if (t instanceof yp && !t.isCompressed) {
                                var n = this.width,
                                    i = this.height;
                                !t.image || n > e.maxFrameSize || i > e.maxFrameSize ? this._packable = !1 : t.image && t.image instanceof HTMLCanvasElement && (this._packable = !0)
                            } else this._packable = !1
                        }
                    }, n._serialize = function() {
                        return null
                    }, n._deserialize = function(e) {
                        var t = e,
                            n = t.rect;
                        n && (this._rect = new Kn(n.x, n.y, n.width, n.height));
                        var i = t.offset;
                        t.offset && (this._offset = new Gn(i.x, i.y));
                        var r = t.originalSize;
                        t.originalSize && (this._originalSize = new Xn(r.width, r.height)), this._rotated = !!t.rotated, this._name = t.name, this._packable = !!t.packable;
                        var o = t.capInsets;
                        o && (this._capInsets[0] = o[0], this._capInsets[1] = o[1], this._capInsets[2] = o[2], this._capInsets[3] = o[3]), this.vertices = t.vertices, this.vertices && (this.vertices.nu = [], this.vertices.nv = [])
                    }, n.clone = function() {
                        var e, n, i, r, o, a, s, c, l = new t,
                            u = this.vertices;
                        return l.vertices = u ? {
                            x: u.x,
                            y: u.y,
                            triangles: u.triangles,
                            nu: null === (e = u.nu) || void 0 === e ? void 0 : e.slice(0),
                            u: null === (n = u.u) || void 0 === n ? void 0 : n.slice(0),
                            nv: null === (i = u.nv) || void 0 === i ? void 0 : i.slice(0),
                            v: null === (r = u.v) || void 0 === r ? void 0 : r.slice(0)
                        } : null, (o = l.uv).splice.apply(o, [0, l.uv.length].concat(this.uv)), l.uvHash = this.uvHash, (a = l.unbiasUV).splice.apply(a, [0, l.unbiasUV.length].concat(this.unbiasUV)), (s = l.uvSliced).splice.apply(s, [0, l.uvSliced.length].concat(this.uvSliced)), l._rect.set(this._rect), l._offset.set(this._offset), l._originalSize.set(this._originalSize), l._rotated = this._rotated, (c = l._capInsets).splice.apply(c, [0, l._capInsets.length].concat(this._capInsets)), l._atlasUuid = this._atlasUuid, l._texture = this._texture, l._isFlipUVX = this._isFlipUVX, l._isFlipUVY = this._isFlipUVY, l
                    }, n._textureLoaded = function() {
                        var e = this._texture,
                            t = {},
                            n = !1;
                        0 !== this._rect.width && 0 !== this._rect.height && this.checkRect(e) || (t.rect = new Kn(0, 0, e.width, e.height), n = !0), (0 === this._originalSize.width || 0 === this._originalSize.height || n) && (t.originalSize = new Xn(e.width, e.height), n = !0), n && (this.reset(t), this.onLoaded()), this._checkPackable()
                    }, n._refreshTexture = function(e) {
                        this._texture = e, e.loaded ? this._textureLoaded() : e.once("load", this._textureLoaded, this)
                    }, n.initDefault = function(t) {
                        e.prototype.initDefault.call(this, t);
                        var n = new yp;
                        n.initDefault(), this._refreshTexture(n), this._calculateUV()
                    }, n.validate = function() {
                        return this._texture && this._rect && 0 !== this._rect.width && 0 !== this._rect.height
                    }, K(t, [{
                        key: "insetTop",
                        get: function() {
                            return this._capInsets[1]
                        },
                        set: function(e) {
                            this._capInsets[1] !== e && (this._capInsets[1] = e, this._texture && this._calculateSlicedUV())
                        }
                    }, {
                        key: "insetBottom",
                        get: function() {
                            return this._capInsets[3]
                        },
                        set: function(e) {
                            this._capInsets[3] !== e && (this._capInsets[3] = e, this._texture && this._calculateSlicedUV())
                        }
                    }, {
                        key: "insetLeft",
                        get: function() {
                            return this._capInsets[0]
                        },
                        set: function(e) {
                            this._capInsets[0] !== e && (this._capInsets[0] = e, this._texture && this._calculateSlicedUV())
                        }
                    }, {
                        key: "insetRight",
                        get: function() {
                            return this._capInsets[2]
                        },
                        set: function(e) {
                            this._capInsets[2] !== e && (this._capInsets[2] = e, this._texture && this._calculateSlicedUV())
                        }
                    }, {
                        key: "rect",
                        get: function() {
                            return this._rect
                        },
                        set: function(e) {
                            this._rect.equals(e) || (this._rect.set(e), this._texture && this._calculateUV())
                        }
                    }, {
                        key: "originalSize",
                        get: function() {
                            return this._originalSize
                        },
                        set: function(e) {
                            this._originalSize.equals(e) || (this._originalSize.set(e), this._texture && this._calculateUV())
                        }
                    }, {
                        key: "offset",
                        get: function() {
                            return this._offset
                        },
                        set: function(e) {
                            this._offset.set(e)
                        }
                    }, {
                        key: "rotated",
                        get: function() {
                            return this._rotated
                        },
                        set: function(e) {
                            this._rotated !== e && (this._rotated = e, this._texture && this._calculateUV())
                        }
                    }, {
                        key: "texture",
                        get: function() {
                            return this._texture
                        },
                        set: function(e) {
                            e ? this.reset({
                                texture: e
                            }, !0) : console.warn("Error Texture in " + this.name)
                        }
                    }, {
                        key: "atlasUuid",
                        get: function() {
                            return this._atlasUuid
                        },
                        set: function(e) {
                            this._atlasUuid = e
                        }
                    }, {
                        key: "width",
                        get: function() {
                            return this._texture.width
                        }
                    }, {
                        key: "height",
                        get: function() {
                            return this._texture.height
                        }
                    }, {
                        key: "_textureSource",
                        set: function(e) {
                            window.Build ? this._texture = e : e && (this._refreshTexture(e), this._calculateUV())
                        }
                    }, {
                        key: "flipUVX",
                        get: function() {
                            return this._isFlipUVX
                        },
                        set: function(e) {
                            this._isFlipUVX = e, this._calculateUV()
                        }
                    }, {
                        key: "flipUVY",
                        get: function() {
                            return this._isFlipUVY
                        },
                        set: function(e) {
                            this._isFlipUVY = e, this._calculateUV()
                        }
                    }, {
                        key: "packable",
                        get: function() {
                            return this._packable
                        },
                        set: function(e) {
                            this._packable = e
                        }
                    }, {
                        key: "original",
                        get: function() {
                            return this._original
                        }
                    }]), t
                }(Nf)) || kV);
            i.SpriteFrame = KV;
            var ZV, QV = e("SpriteAtlas", A_("cc.SpriteAtlas")((XV = function(e) {
                function t() {
                    for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                    return ne(t = e.call.apply(e, [this].concat(i)) || this, "spriteFrames", qV, $(t)), t
                }
                Q(t, e);
                var n = t.prototype;
                return n.getTexture = function() {
                    var e = Object.keys(this.spriteFrames);
                    if (e.length > 0) {
                        var t = this.spriteFrames[e[0]];
                        return t && t.texture
                    }
                    return null
                }, n.getSpriteFrame = function(e) {
                    var t = this.spriteFrames[e];
                    return t ? (t.name || (t.name = e), t) : null
                }, n.getSpriteFrames = function() {
                    for (var e = [], t = this.spriteFrames, n = 0, i = Object.keys(t); n < i.length; n++) {
                        var r = i[n];
                        e.push(t[r])
                    }
                    return e
                }, n._serialize = function() {}, n._deserialize = function(e, t) {
                    var n = e;
                    this._name = n.name;
                    var i = n.spriteFrames;
                    this.spriteFrames = Te();
                    for (var r = 0; r < i.length; r += 2) t.result.push(this.spriteFrames, i[r], i[r + 1], Ye(KV))
                }, t
            }(Nf), qV = ie((jV = XV).prototype, "spriteFrames", [w_, F_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return Te()
                }
            }), WV = jV)) || WV);
            i.SpriteAtlas = QV;
            var JV, $V, eW, tW, nW = e("Font", A_("cc.Font")(ZV = function(e) {
                function t() {
                    return e.apply(this, arguments) || this
                }
                return Q(t, e), t
            }(Nf)) || ZV);
            i.Font = nW;
            var iW, rW, oW, aW, sW, cW, lW, uW, hW, _W = e("TTFFont", A_("cc.TTFFont")((tW = function(e) {
                function t() {
                    for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                    return ne(t = e.call.apply(e, [this].concat(i)) || this, "_fontFamily", eW, $(t)), t
                }
                return Q(t, e), K(t, [{
                    key: "_nativeAsset",
                    get: function() {
                        return this._fontFamily
                    },
                    set: function(e) {
                        this._fontFamily = e || "Arial"
                    }
                }, {
                    key: "_nativeDep",
                    get: function() {
                        return {
                            uuid: this._uuid,
                            __nativeName__: this._native,
                            ext: bi(this._native),
                            __isNative__: !0
                        }
                    }
                }]), t
            }(nW), eW = ie(($V = tW).prototype, "_fontFamily", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return null
                }
            }), ie($V.prototype, "_nativeAsset", [tf, $_], Object.getOwnPropertyDescriptor($V.prototype, "_nativeAsset"), $V.prototype), ie($V.prototype, "_nativeDep", [tf], Object.getOwnPropertyDescriptor($V.prototype, "_nativeDep"), $V.prototype), JV = $V)) || JV);
            i.TTFFont = _W;
            var fW, dW = function() {
                    this.u = 0, this.v = 0, this.w = 0, this.h = 0, this.offsetX = 0, this.offsetY = 0, this.textureID = 0, this.valid = !1, this.xAdvance = 0
                },
                pW = function() {
                    function e(e) {
                        this.letterDefinitions = {}, this.texture = e
                    }
                    var t = e.prototype;
                    return t.addLetterDefinitions = function(e, t) {
                        this.letterDefinitions[e] = t
                    }, t.cloneLetterDefinition = function() {
                        for (var e = {}, t = 0, n = Object.keys(this.letterDefinitions); t < n.length; t++) {
                            var i = n[t],
                                r = new dW;
                            Ne(r, this.letterDefinitions[i]), e[i] = r
                        }
                        return e
                    }, t.getTexture = function() {
                        return this.texture
                    }, t.getLetter = function(e) {
                        return this.letterDefinitions[e]
                    }, t.getLetterDefinitionForChar = function(e) {
                        var t = e.charCodeAt(0);
                        return this.letterDefinitions.hasOwnProperty(t) ? this.letterDefinitions[t] : null
                    }, t.clear = function() {
                        this.letterDefinitions = {}
                    }, e
                }(),
                mW = e("BitmapFont", (iW = A_("cc.BitmapFont"), rW = ef(KV), iW((hW = function(e) {
                    function t() {
                        for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                        return ne(t = e.call.apply(e, [this].concat(i)) || this, "fntDataStr", sW, $(t)), ne(t, "spriteFrame", cW, $(t)), ne(t, "fontSize", lW, $(t)), ne(t, "fntConfig", uW, $(t)), t
                    }
                    return Q(t, e), t.prototype.onLoaded = function() {
                        var e = this.spriteFrame;
                        !this.fontDefDictionary && e && (this.fontDefDictionary = new pW(e.texture));
                        var t = this.fntConfig;
                        if (t) {
                            var n = t.fontDefDictionary;
                            for (var i in n) {
                                var r = new dW,
                                    o = n[i].rect;
                                r.offsetX = n[i].xOffset, r.offsetY = n[i].yOffset, r.w = o.width, r.h = o.height, r.u = o.x, r.v = o.y, r.textureID = 0, r.valid = !0, r.xAdvance = n[i].xAdvance, this.fontDefDictionary.addLetterDefinitions(i, r)
                            }
                        } else d("The fnt config is not exists!")
                    }, t
                }(nW), sW = ie((aW = hW).prototype, "fntDataStr", [w_, F_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return ""
                    }
                }), cW = ie(aW.prototype, "spriteFrame", [rW], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return null
                    }
                }), lW = ie(aW.prototype, "fontSize", [w_, F_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return -1
                    }
                }), uW = ie(aW.prototype, "fntConfig", [w_, F_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return null
                    }
                }), oW = aW)) || oW));
            i.BitmapFont = mW;
            var gW = e("LabelAtlas", A_("cc.LabelAtlas")(fW = function(e) {
                function t() {
                    return e.apply(this, arguments) || this
                }
                return Q(t, e), t
            }(mW)) || fW);
            i.LabelAtlas = gW;
            var vW = e("BASELINE_RATIO", .26),
                yW = e("MIDDLE_RATIO", (vW + 1) / 2 - vW);
            var SW = new Ke(2);
            SW.get = function() {
                return this._get() || {
                    key: "",
                    value: 0,
                    prev: null,
                    next: null
                }
            };
            var EW, TW = new(function() {
                    function e(e) {
                        this.count = 0, this.limit = 0, this.datas = {}, this.limit = e
                    }
                    var t = e.prototype;
                    return t.moveToHead = function(e) {
                        e.next = this.head, e.prev = null, this.head && (this.head.prev = e), this.head = e, this.tail || (this.tail = e), this.count++, this.datas[e.key] = e
                    }, t.put = function(e, t) {
                        var n = SW.get();
                        if (n.key = e, n.value = t, this.count >= this.limit) {
                            var i = this.tail;
                            delete this.datas[i.key], this.count--, this.tail = i.prev, this.tail.next = null, i.prev = null, i.next = null, SW.put(i)
                        }
                        this.moveToHead(n)
                    }, t.remove = function(e) {
                        e.prev ? e.prev.next = e.next : this.head = e.next, e.next ? e.next.prev = e.prev : this.tail = e.prev, delete this.datas[e.key], this.count--
                    }, t.get = function(e) {
                        var t = this.datas[e];
                        return t ? (this.remove(t), this.moveToHead(t), t.value) : null
                    }, t.clear = function() {
                        this.count = 0, this.datas = {}, this.head = null, this.tail = null
                    }, t.has = function(e) {
                        return !!this.datas[e]
                    }, t.delete = function(e) {
                        var t = this.datas[e];
                        this.remove(t)
                    }, e
                }())(100),
                AW = /([a-zA-Z0-9--]+|\S)/,
                xW = /^[!,.:;'}\]%\?>]/,
                CW = /([a-zA-Z0-9--]+|\S)$/,
                bW = /[a-zA-Z0-9--]+$/,
                RW = /^[a-zA-Z0-9--]/;

            function wW(e) {
                return /^[\u4E00-\u9FFF\u3400-\u4DFF]+$/.test(e) || /[\u3000-\u303F]|[\u3040-\u309F]|[\u30A0-\u30FF]|[\uFF00-\uFFEF]|[\u4E00-\u9FAF]|[\u2605-\u2606]|[\u2190-\u2195]|\u203B/g.test(e) || /^[\u1100-\u11FF]|[\u3130-\u318F]|[\uA960-\uA97F]|[\uAC00-\uD7AF]|[\uD7B0-\uD7FF]+$/.test(e)
            }

            function IW(e) {
                var t = e.charCodeAt(0);
                return t >= 9 && t <= 13 || 32 === t || 133 === t || 160 === t || 5760 === t || t >= 8192 && t <= 8202 || 8232 === t || 8233 === t || 8239 === t || 8287 === t || 12288 === t
            }

            function PW(e, t, n) {
                var i = (n || e.font) + "" + t,
                    r = TW.get(i);
                if (null !== r) return r;
                var o = e.measureText(t),
                    a = o && o.width || 0;
                return TW.put(i, a), a
            }

            function OW(e, t, n) {
                var i = t,
                    r = n,
                    o = e[t];
                if (o >= "\udc00" && o <= "\udfff" && i--, void 0 !== n)
                    if (n - 1 !== t) {
                        var a = e[n - 1];
                        a >= "\ud800" && a <= "\udbff" && r--
                    } else o >= "\ud800" && o <= "\udbff" && r++;
                return e.substring(i, r)
            }

            function DW(e, t, n, i) {
                var r = [];
                if (0 === e.length || n < 0) return r.push(""), r;
                for (var o = e; t > n && o.length > 1;) {
                    for (var a = o.length * (n / t) | 0, s = OW(o, a), c = t - i(s), l = s, u = 0, h = 0; c > n && h++ < 10;) a *= n / c, c = t - i(s = OW(o, a |= 0));
                    for (h = 0; c <= n && h++ < 10;) {
                        if (s) {
                            var _ = AW.exec(s);
                            u = _ ? _[0].length : 1, l = s
                        }
                        c = t - i(s = OW(o, a += u))
                    }
                    0 == (a -= u) ? (a = 1, l = OW(o, 1)) : 1 === a && o[0] >= "\ud800" && o[0] <= "\udbff" && (a = 2, l = OW(o, 2));
                    var f = OW(o, 0, a),
                        d = void 0;
                    xW.test(l || s) && (0 == (a -= (d = CW.exec(f)) ? d[0].length : 0) && (a = 1), l = OW(o, a), f = OW(o, 0, a)), RW.test(l) && (d = bW.exec(f)) && f !== d[0] && (l = OW(o, a -= d[0].length), f = OW(o, 0, a)), (0 === r.length || (f = f.trim()).length > 0) && r.push(f), t = i(o = l || s)
                }
                return (0 === r.length || (o = o.trim()).length > 0) && r.push(o), r
            }
            var NW, MW, LW, BW, FW, zW, UW, GW, HW, kW, VW, WW, jW, qW, XW, YW = e("CanvasPool", function() {
                    function e() {
                        this.pool = []
                    }
                    e.getInstance = function() {
                        return EW || (EW = new e), EW
                    };
                    var t = e.prototype;
                    return t.get = function() {
                        var e = this.pool.pop();
                        if (!e) {
                            var t = document.createElement("canvas"),
                                n = t.getContext("2d");
                            e = {
                                canvas: t,
                                context: n
                            }
                        }
                        return e
                    }, t.put = function(e) {
                        this.pool.length >= rt.MAX_LABEL_CANVAS_POOL_SIZE || this.pool.push(e)
                    }, e
                }()),
                KW = yn.WHITE.clone(),
                ZW = function() {
                    this.u = 0, this.v = 0, this.w = 0, this.h = 0, this.texture = null, this.offsetX = 0, this.offsetY = 0, this.valid = !1, this.xAdvance = 0
                },
                QW = "rgba(255, 255, 255, " + (1 / 255).toFixed(3) + ")",
                JW = function() {
                    function e(e, t) {
                        this.image = null, this.labelInfo = void 0, this.char = void 0, this.data = null, this.canvas = null, this.context = null, this.width = 0, this.height = 0, this.offsetY = 0, this.hash = void 0, this.char = e, this.labelInfo = t, this.hash = e.charCodeAt(0) + t.hash
                    }
                    var t = e.prototype;
                    return t.updateRenderData = function() {
                        this._updateProperties(), this._updateTexture()
                    }, t.destroy = function() {
                        this.image = null
                    }, t._updateProperties = function() {
                        if (this.data = YW.getInstance().get(), this.canvas = this.data.canvas, this.context = this.data.context, this.context) {
                            this.context.font = this.labelInfo.fontDesc;
                            var e = PW(this.context, this.char, this.labelInfo.fontDesc),
                                t = 2 * this.labelInfo.margin + 2;
                            this.width = parseFloat(e.toFixed(2)) + t, this.height = (1 + vW) * this.labelInfo.fontSize + t, this.offsetY = -this.labelInfo.fontSize * vW / 2
                        }
                        this.canvas.width !== this.width && (this.canvas.width = this.width), this.canvas.height !== this.height && (this.canvas.height = this.height), this.image || (this.image = new Wf), this.image.reset(this.canvas)
                    }, t._updateTexture = function() {
                        if (this.context && this.canvas) {
                            var e = this.context,
                                t = this.labelInfo,
                                n = this.canvas.width,
                                i = this.canvas.height;
                            e.textAlign = "center", e.textBaseline = "alphabetic", e.clearRect(0, 0, n, i), e.fillStyle = QW, e.fillRect(0, 0, n, i), e.font = t.fontDesc;
                            var r = t.fontSize,
                                o = n / 2,
                                a = i / 2 + r * yW + 0 * r,
                                s = t.color;
                            if (e.lineJoin = "round", e.fillStyle = "rgba(" + s.r + ", " + s.g + ", " + s.b + ", 1)", t.isOutlined) {
                                var c = t.out || KW;
                                e.strokeStyle = "rgba(" + c.r + ", " + c.g + ", " + c.b + ", " + c.a / 255 + ")", e.lineWidth = 2 * t.margin, e.strokeText(this.char, o, a)
                            }
                            e.fillText(this.char, o, a)
                        }
                    }, e
                }(),
                $W = function(e) {
                    function t() {
                        return e.apply(this, arguments) || this
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.initWithSize = function(e, t, n) {
                        void 0 === n && (n = Mf.RGBA8888), this.reset({
                            width: e,
                            height: t,
                            format: n
                        }), this.loaded = !0, this.emit("load")
                    }, n.drawTextureAt = function(e, t, n) {
                        var i = this.getGFXTexture();
                        if (e && i) {
                            var r = this._getGFXDevice();
                            if (r) {
                                var o = new fs;
                                o.texOffset.x = t, o.texOffset.y = n, o.texExtent.width = e.width, o.texExtent.height = e.height, r.copyTexImagesToTexture([e.data], i, [o])
                            } else console.warn("Unable to get device")
                        }
                    }, t
                }(yp),
                ej = function() {
                    function e(e, t) {
                        this._x = 0, this._y = 0, this._nextY = 0, this._width = 0, this._height = 0, this._halfBleed = 0, this._dirty = !1;
                        var n = new $W;
                        n.initWithSize(e, t), this.fontDefDictionary = new pW(n), this._halfBleed = 1, this._width = e, this._height = t, RO.on(bO.EVENT_BEFORE_SCENE_LAUNCH, this.beforeSceneLoad, this)
                    }
                    var t = e.prototype;
                    return t.insertLetterTexture = function(e) {
                        var t = e.image,
                            n = RO.root.device;
                        if (!t || !this.fontDefDictionary || !n) return null;
                        var i = t.width,
                            r = t.height;
                        if (this._x + i + 0 > this._width && (this._x = 0, this._y = this._nextY), this._y + r > this._nextY && (this._nextY = this._y + r + 0), this._nextY > this._height) return x(12100), null;
                        this.fontDefDictionary.texture.drawTextureAt(t, this._x, this._y), this._dirty = !0;
                        var o = new ZW;
                        return o.u = this._x + this._halfBleed, o.v = this._y + this._halfBleed, o.texture = this.fontDefDictionary.texture, o.valid = !0, o.w = e.width - 2, o.h = e.height - 2, o.xAdvance = o.w, o.offsetY = e.offsetY, this._x += i + 0, this.fontDefDictionary.addLetterDefinitions(e.hash, o), o
                    }, t.update = function() {
                        this._dirty && (this._dirty = !1)
                    }, t.reset = function() {
                        this._x = 0, this._y = 0, this._nextY = 0, this.fontDefDictionary.clear()
                    }, t.destroy = function() {
                        this.reset(), this.fontDefDictionary && (this.fontDefDictionary.texture.destroy(), this.fontDefDictionary.texture = null)
                    }, t.getTexture = function() {
                        return this.fontDefDictionary.getTexture()
                    }, t.beforeSceneLoad = function() {
                        this.clearAllCache()
                    }, t.clearAllCache = function() {
                        this.destroy();
                        var e = new $W;
                        e.initWithSize(this._width, this._height), this.fontDefDictionary.texture = e
                    }, t.getLetter = function(e) {
                        return this.fontDefDictionary.letterDefinitions[e]
                    }, t.getLetterDefinitionForChar = function(e, t) {
                        var n = e.charCodeAt(0) + t.hash,
                            i = this.fontDefDictionary.letterDefinitions[n];
                        if (!i) {
                            var r = new JW(e, t);
                            r.updateRenderData(), i = this.insertLetterTexture(r), r.destroy()
                        }
                        return i
                    }, K(e, [{
                        key: "width",
                        get: function() {
                            return this._width
                        }
                    }, {
                        key: "height",
                        get: function() {
                            return this._height
                        }
                    }]), e
                }(),
                tj = {
                    fontAtlas: null,
                    fontSize: 0,
                    lineHeight: 0,
                    hAlign: 0,
                    vAlign: 0,
                    hash: "",
                    fontFamily: "",
                    fontDesc: "Arial",
                    color: yn.WHITE.clone(),
                    isOutlined: !1,
                    out: yn.WHITE.clone(),
                    margin: 0
                },
                nj = function() {
                    this.material = null, this.vertexCount = 0, this.indicesCount = 0
                },
                ij = function(e) {
                    function t() {
                        for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                        return (t = e.call.apply(e, [this].concat(i)) || this).vData = null, t.uvDirty = !0, t.vertDirty = !0, t._data = [], t._indices = [], t._pivotX = 0, t._pivotY = 0, t._width = 0, t._height = 0, t
                    }
                    Q(t, e), t.add = function() {
                        return aj.add()
                    }, t.remove = function(e) {
                        var t = aj.data.indexOf(e); - 1 !== t && (aj.data[t].clear(), aj.removeAt(t))
                    };
                    var n = t.prototype;
                    return n.updateSizeNPivot = function(e, t, n, i) {
                        e === this._width && t === this._height && n === this._pivotX && i === this._pivotY || (this._width = e, this._height = t, this._pivotX = n, this._pivotY = i, this.vertDirty = !0)
                    }, n.clear = function() {
                        this._data.length = 0, this._indices.length = 0, this._pivotX = 0, this._pivotY = 0, this._width = 0, this._height = 0, this.uvDirty = !0, this.vertDirty = !0, this.material = null, this.vertexCount = 0, this.indicesCount = 0
                    }, K(t, [{
                        key: "dataLength",
                        get: function() {
                            return this._data.length
                        },
                        set: function(e) {
                            var t = this._data;
                            if (t.length !== e) {
                                var n = t.length,
                                    i = 0;
                                for (i = e; i < n; i++) oj.free(t[i]);
                                for (i = n; i < e; i++) t[i] = oj.alloc();
                                t.length = e
                            }
                        }
                    }, {
                        key: "data",
                        get: function() {
                            return this._data
                        }
                    }]), t
                }(nj),
                rj = function(e) {
                    function t(t) {
                        var n;
                        return void 0 === t && (t = 9), (n = e.call(this) || this).vData = void 0, n.iData = void 0, n.vertexStart = 0, n.indicesStart = 0, n.byteStart = 0, n.byteCount = 0, n.lastFilledIndices = 0, n.lastFilledVertex = 0, n._formatByte = void 0, n._formatByte = t * Float32Array.BYTES_PER_ELEMENT, n.vData = new Float32Array(256 * t * Float32Array.BYTES_PER_ELEMENT), n.iData = new Uint16Array(1536), n
                    }
                    Q(t, e), t.add = function() {
                        return sj.add()
                    }, t.remove = function(e) {
                        var t = sj.data.indexOf(e); - 1 !== t && (sj.data[t].reset(), sj.removeAt(t))
                    };
                    var n = t.prototype;
                    return n.request = function(e, t) {
                        var n = this.byteCount + e * this._formatByte;
                        return this.reserve(e, t), this.vertexCount += e, this.indicesCount += t, this.byteCount = n, !0
                    }, n.reserve = function(e, t) {
                        var n = this.byteCount + e * this._formatByte,
                            i = this.indicesCount + t;
                        if (e + this.vertexCount > 65535) return !1;
                        var r = this.vData.byteLength,
                            o = this.iData.length,
                            a = this.vData.length,
                            s = this.iData.length;
                        if (n > r || i > o) {
                            for (; r < n || o < i;) r = 4 * (a *= 2), o = s *= 2;
                            this._reallocBuffer(a, s)
                        }
                        return !0
                    }, n.advance = function(e, t) {
                        this.vertexCount += e, this.indicesCount += t, this.byteCount += e * this._formatByte
                    }, n.reset = function() {
                        this.vertexCount = 0, this.indicesCount = 0, this.byteCount = 0, this.vertexStart = 0, this.indicesStart = 0, this.byteStart = 0, this.lastFilledIndices = 0, this.lastFilledVertex = 0
                    }, n._reallocBuffer = function(e, t) {
                        var n = this.vData;
                        this.vData = new Float32Array(e), this.vData.set(n, 0);
                        var i = this.iData;
                        this.iData = new Uint16Array(t), this.iData.set(i, 0)
                    }, K(t, [{
                        key: "formatByte",
                        get: function() {
                            return this._formatByte
                        },
                        set: function(e) {
                            this._formatByte = e
                        }
                    }, {
                        key: "floatStride",
                        get: function() {
                            return this._formatByte >> 2
                        }
                    }, {
                        key: "vDataOffset",
                        get: function() {
                            return this.byteCount >>> 2
                        }
                    }]), t
                }(nj),
                oj = (function(e) {
                    function t() {
                        return e.apply(this, arguments) || this
                    }
                    Q(t, e);
                    var n = t.prototype;
                    n._fillQuadBuffer = function() {
                        for (var e = this.iData.length / 6, t = this.iData, n = 0, i = 0; n < e; n++) {
                            var r = 4 * n;
                            t[i++] = r, t[i++] = r + 1, t[i++] = r + 2, t[i++] = r + 1, t[i++] = r + 3, t[i++] = r + 2
                        }
                    }, n._reallocBuffer = function(t, n) {
                        e.prototype._reallocBuffer.call(this, t, n), this._fillQuadBuffer()
                    }
                }(rj), new Jn((function() {
                    return {
                        x: 0,
                        y: 0,
                        z: 0,
                        u: 0,
                        v: 0,
                        color: yn.WHITE.clone()
                    }
                }), 128)),
                aj = new $n((function() {
                    return new ij
                }), 32),
                sj = new $n((function() {
                    return new rj
                }), 32),
                cj = new Gn,
                lj = new Gn,
                uj = new Bn,
                hj = new Bn,
                _j = new Bn,
                fj = new Bn(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
                dj = new Kn,
                pj = function(t) {
                    return e({
                        UITransform: t,
                        UITransformComponent: t
                    }), t
                }((NW = A_("cc.UITransform"), MW = B_(), LW = C_(110), BW = D_(), FW = q_(), zW = G_(), UW = q_(), GW = G_(), NW(HW = MW(HW = LW(HW = BW(HW = b_(HW = O_((qW = jW = function(e) {
                    function t() {
                        for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                        return (t = e.call.apply(e, [this].concat(i)) || this)._priority = 0, ne(t, "_contentSize", VW, $(t)), ne(t, "_anchorPoint", WW, $(t)), t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.__preload = function() {
                        this.node._uiProps.uiTransformComp = this
                    }, n.onLoad = function() {
                        this.node.parent && t.insertChangeMap(this.node.parent)
                    }, n.onEnable = function() {
                        this.node.on(Om.PARENT_CHANGED, this._parentChanged, this)
                    }, n.onDisable = function() {
                        this.node.off(Om.PARENT_CHANGED, this._parentChanged, this)
                    }, n.onDestroy = function() {
                        this.node._uiProps.uiTransformComp = null
                    }, n.setContentSize = function(e, t) {
                        var n = this._contentSize;
                        if (void 0 === t) {
                            if ((e = e).width === n.width && e.height === n.height) return;
                            n.width = e.width, n.height = e.height
                        } else {
                            if (e === n.width && t === n.height) return;
                            n.width = e, n.height = t
                        }
                        this.node.emit(Om.SIZE_CHANGED)
                    }, n.setAnchorPoint = function(e, t) {
                        var n = this._anchorPoint;
                        if (void 0 === t) {
                            if ((e = e).x === n.x && e.y === n.y) return;
                            n.x = e.x, n.y = e.y
                        } else {
                            if (e === n.x && t === n.y) return;
                            n.x = e, n.y = t
                        }
                        this.node.emit(Om.ANCHOR_CHANGED, this._anchorPoint)
                    }, n.isHit = function(e, t) {
                        for (var n = this._contentSize.width, r = this._contentSize.height, o = cj, a = lj, s = this._getRenderScene().cameras, c = 0; c < s.length; c++) {
                            var l = s[c];
                            if (l.visibility & this.node.layer) {
                                l.node.getWorldRT(uj);
                                var u = uj.m12,
                                    h = uj.m13,
                                    _ = i.visibleRect.center;
                                if (uj.m12 = _.x - (uj.m00 * u + uj.m04 * h), uj.m13 = _.y - (uj.m01 * u + uj.m05 * h), Bn.invert(uj, uj), Gn.transformMat4(o, e, uj), this.node.getWorldMatrix(_j), Bn.invert(uj, _j), !Bn.strictEquals(uj, fj)) {
                                    Gn.transformMat4(a, o, uj), a.x += this._anchorPoint.x * n, a.y += this._anchorPoint.y * r;
                                    var f = !1;
                                    if (a.x >= 0 && a.y >= 0 && a.x <= n && a.y <= r && (f = !0, t && t.mask))
                                        for (var d = t.mask, p = this.node, m = d ? d.length : 0, g = 0, v = 0; p && v < m; ++g, p = p.parent) {
                                            var y = d[v];
                                            if (g === y.index) {
                                                if (p !== y.comp.node) {
                                                    d.length = v;
                                                    break
                                                }
                                                var S = y.comp;
                                                if (S && S._enabled && !S.isHit(o)) {
                                                    f = !1;
                                                    break
                                                }
                                                v++
                                            } else if (g > y.index) {
                                                d.length = v;
                                                break
                                            }
                                        }
                                    if (f) return !0
                                }
                            }
                        }
                        return !1
                    }, n.convertToNodeSpaceAR = function(e, t) {
                        return this.node.getWorldMatrix(_j), Bn.invert(uj, _j), t || (t = new En), En.transformMat4(t, e, uj)
                    }, n.convertToWorldSpaceAR = function(e, t) {
                        return this.node.getWorldMatrix(_j), t || (t = new En), En.transformMat4(t, e, _j)
                    }, n.getBoundingBox = function() {
                        Bn.fromRTS(hj, this.node.getRotation(), this.node.getPosition(), this.node.getScale());
                        var e = this._contentSize.width,
                            t = this._contentSize.height,
                            n = new Kn(-this._anchorPoint.x * e, -this._anchorPoint.y * t, e, t);
                        return n.transformMat4(hj), n
                    }, n.getBoundingBoxToWorld = function() {
                        return this.node.parent ? (this.node.parent.getWorldMatrix(_j), this.getBoundingBoxTo(_j)) : this.getBoundingBox()
                    }, n.getBoundingBoxTo = function(e) {
                        Bn.fromRTS(hj, this.node.getRotation(), this.node.getPosition(), this.node.getScale());
                        var n = this._contentSize.width,
                            i = this._contentSize.height,
                            r = new Kn(-this._anchorPoint.x * n, -this._anchorPoint.y * i, n, i);
                        if (Bn.multiply(_j, e, hj), r.transformMat4(_j), !this.node.children) return r;
                        for (var o, a = te(this.node.children); !(o = a()).done;) {
                            var s = o.value;
                            if (s && s.active) {
                                var c = s.getComponent(t);
                                if (c) {
                                    var l = c.getBoundingBoxTo(e);
                                    l && Kn.union(r, r, l)
                                }
                            }
                        }
                        return r
                    }, n.getComputeAABB = function(e) {
                        var t = this._contentSize.width,
                            n = this._contentSize.height;
                        dj.set(-this._anchorPoint.x * t, -this._anchorPoint.y * n, t, n), dj.transformMat4(this.node.worldMatrix);
                        var i = dj.x + .5 * dj.width,
                            r = dj.y + .5 * dj.height,
                            o = this.node.worldPosition.z,
                            a = dj.width / 2,
                            s = dj.height / 2;
                        return null != e ? (tu.set(e, i, r, o, a, s, .001), e) : new tu(i, r, o, a, s, .001)
                    }, n._parentChanged = function() {
                        this.node.getComponent("cc.RenderRoot2D") || this.node.parent && t.insertChangeMap(this.node.parent)
                    }, t.insertChangeMap = function(e) {
                        var n = e.uuid;
                        t.priorityChangeNodeMap.has(n) || t.priorityChangeNodeMap.set(n, e)
                    }, t._sortChildrenSibling = function(e) {
                        var t = e.children;
                        t && t.sort((function(e, t) {
                            var n = e._uiProps.uiTransformComp,
                                i = t._uiProps.uiTransformComp,
                                r = (n ? n._priority : 0) - (i ? i._priority : 0);
                            return 0 === r ? e.getSiblingIndex() - t.getSiblingIndex() : r
                        }))
                    }, t._sortSiblings = function() {
                        t.priorityChangeNodeMap.forEach((function(e) {
                            t._sortChildrenSibling(e), e._updateSiblingIndex(), e.emit("childrenSiblingOrderChanged")
                        })), t.priorityChangeNodeMap.clear()
                    }, t._cleanChangeMap = function() {
                        t.priorityChangeNodeMap.clear()
                    }, K(t, [{
                        key: "contentSize",
                        get: function() {
                            return this._contentSize
                        },
                        set: function(e) {
                            this._contentSize.equals(e) || (this._contentSize.set(e), this.node.emit(Om.SIZE_CHANGED))
                        }
                    }, {
                        key: "width",
                        get: function() {
                            return this._contentSize.width
                        },
                        set: function(e) {
                            this._contentSize.width !== e && (this._contentSize.width = e, this.node.emit(Om.SIZE_CHANGED))
                        }
                    }, {
                        key: "height",
                        get: function() {
                            return this._contentSize.height
                        },
                        set: function(e) {
                            this.contentSize.height !== e && (this._contentSize.height = e, this.node.emit(Om.SIZE_CHANGED))
                        }
                    }, {
                        key: "anchorPoint",
                        get: function() {
                            return this._anchorPoint
                        },
                        set: function(e) {
                            this._anchorPoint.equals(e) || (this._anchorPoint.set(e), this.node.emit(Om.ANCHOR_CHANGED, this._anchorPoint))
                        }
                    }, {
                        key: "anchorX",
                        get: function() {
                            return this._anchorPoint.x
                        },
                        set: function(e) {
                            this._anchorPoint.x !== e && (this._anchorPoint.x = e, this.node.emit(Om.ANCHOR_CHANGED, this._anchorPoint))
                        }
                    }, {
                        key: "anchorY",
                        get: function() {
                            return this._anchorPoint.y
                        },
                        set: function(e) {
                            this._anchorPoint.y !== e && (this._anchorPoint.y = e, this.node.emit(Om.ANCHOR_CHANGED, this._anchorPoint))
                        }
                    }, {
                        key: "priority",
                        get: function() {
                            return this._priority
                        },
                        set: function(e) {
                            this._priority !== e && (this.node.getComponent("cc.RenderRoot2D") ? x(6706) : (this._priority = e, this.node.parent && t.insertChangeMap(this.node.parent)))
                        }
                    }, {
                        key: "visibility",
                        get: function() {
                            var e = RO.root.batcher2D.getFirstRenderCamera(this.node);
                            return e ? e.visibility : 0
                        }
                    }, {
                        key: "cameraPriority",
                        get: function() {
                            var e = RO.root.batcher2D.getFirstRenderCamera(this.node);
                            return e ? e.priority : 0
                        }
                    }]), t
                }(Jd), jW.EventType = Om, jW.priorityChangeNodeMap = new Map, ie((kW = qW).prototype, "contentSize", [FW, zW], Object.getOwnPropertyDescriptor(kW.prototype, "contentSize"), kW.prototype), ie(kW.prototype, "anchorPoint", [UW, GW], Object.getOwnPropertyDescriptor(kW.prototype, "anchorPoint"), kW.prototype), VW = ie(kW.prototype, "_contentSize", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return new Xn(100, 100)
                    }
                }), WW = ie(kW.prototype, "_anchorPoint", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return new Gn(.5, .5)
                    }
                }), HW = kW)) || HW) || HW) || HW) || HW) || HW) || HW));
            RO.on(bO.EVENT_AFTER_UPDATE, pj._sortSiblings), RO.on(bO.EVENT_BEFORE_SCENE_LAUNCH, pj._cleanChangeMap),
                function(e) {
                    e[e.DISABLED = 0] = "DISABLED", e[e.CLEAR = 1] = "CLEAR", e[e.ENTER_LEVEL = 2] = "ENTER_LEVEL", e[e.ENABLED = 3] = "ENABLED", e[e.EXIT_LEVEL = 4] = "EXIT_LEVEL", e[e.CLEAR_INVERTED = 5] = "CLEAR_INVERTED", e[e.ENTER_LEVEL_INVERTED = 6] = "ENTER_LEVEL_INVERTED"
                }(XW || (XW = {}));
            var mj, gj, vj, yj, Sj, Ej, Tj, Aj, xj, Cj, bj, Rj, wj, Ij, Pj, Oj, Dj, Nj, Mj, Lj = e("StencilManager", function() {
                function e() {
                    this.stage = XW.DISABLED, this._maskStack = [], this._stencilPattern = {
                        stencilTest: !0,
                        func: Ma.ALWAYS,
                        stencilMask: 65535,
                        writeMask: 65535,
                        failOp: La.KEEP,
                        zFailOp: La.KEEP,
                        passOp: La.KEEP,
                        ref: 1
                    }, this.stencilStateMap = new Map, this.stencilStateMapWithDepth = new Map
                }
                var t = e.prototype;
                return t.pushMask = function(e) {
                    this._maskStack.push(e)
                }, t.clear = function(e) {
                    e.stencilStage = e.inverted ? XW.CLEAR_INVERTED : XW.CLEAR
                }, t.enterLevel = function(e) {
                    e.graphics.stencilStage = e.inverted ? XW.ENTER_LEVEL_INVERTED : XW.ENTER_LEVEL
                }, t.enableMask = function() {
                    this.stage = XW.ENABLED
                }, t.exitMask = function() {
                    0 !== this._maskStack.length && (this._maskStack.pop(), 0 === this._maskStack.length ? this.stage = XW.DISABLED : this.stage = XW.ENABLED)
                }, t.getWriteMask = function() {
                    return 1 << this._maskStack.length - 1
                }, t.getExitWriteMask = function() {
                    return 1 << this._maskStack.length
                }, t.getStencilRef = function() {
                    for (var e = 0, t = 0; t < this._maskStack.length; ++t) e += 1 << t;
                    return e
                }, t.reset = function() {
                    this._maskStack.length = 0, this.stage = XW.DISABLED
                }, t.destroy = function() {
                    this.stencilStateMap.forEach((function(e) {
                        e.destroy()
                    })), this.stencilStateMap.clear()
                }, t.getStencilStage = function(e, t) {
                    var n = 0,
                        i = !1,
                        r = !1,
                        o = Ma.LESS,
                        a = this.stencilStateMap;
                    if (t && t.passes[0]) {
                        var s = t.passes[0].depthStencilState,
                            c = 0,
                            l = 0;
                        s.depthTest && (c = 1), s.depthWrite && (l = 1), n = c | l << 1 | s.depthFunc << 2 | e << 6 | this._maskStack.length << 9, i = s.depthTest, r = s.depthWrite, o = s.depthFunc, a = this.stencilStateMapWithDepth
                    } else n = e << 16 | this._maskStack.length;
                    if (a && a.has(n)) return a.get(n);
                    this.setStateFromStage(e);
                    var u = new xc(i, r, o, this._stencilPattern.stencilTest, this._stencilPattern.func, this._stencilPattern.stencilMask, this._stencilPattern.writeMask, this._stencilPattern.failOp, this._stencilPattern.zFailOp, this._stencilPattern.passOp, this._stencilPattern.ref, this._stencilPattern.stencilTest, this._stencilPattern.func, this._stencilPattern.stencilMask, this._stencilPattern.writeMask, this._stencilPattern.failOp, this._stencilPattern.zFailOp, this._stencilPattern.passOp, this._stencilPattern.ref);
                    return a.set(n, u), u
                }, t.getStencilHash = function(e) {
                    return e << 8 | this._maskStack.length
                }, t.setStateFromStage = function(e) {
                    var t = this._stencilPattern;
                    e === XW.DISABLED ? (t.stencilTest = !1, t.func = Ma.ALWAYS, t.failOp = La.KEEP, t.stencilMask = t.writeMask = 65535, t.ref = 1) : (t.stencilTest = !0, e === XW.ENABLED ? (t.func = Ma.EQUAL, t.failOp = La.KEEP, t.stencilMask = t.ref = this.getStencilRef(), t.writeMask = this.getWriteMask()) : e === XW.CLEAR ? (t.func = Ma.NEVER, t.failOp = La.ZERO, t.writeMask = t.stencilMask = t.ref = this.getWriteMask()) : e === XW.CLEAR_INVERTED || e === XW.ENTER_LEVEL ? (t.func = Ma.NEVER, t.failOp = La.REPLACE, t.writeMask = t.stencilMask = t.ref = this.getWriteMask()) : e === XW.ENTER_LEVEL_INVERTED && (t.func = Ma.NEVER, t.failOp = La.ZERO, t.writeMask = t.stencilMask = t.ref = this.getWriteMask()))
                }, K(e, [{
                    key: "pattern",
                    get: function() {
                        return this._stencilPattern
                    }
                }]), e
            }());
            Lj.sharedManager = null, Lj.sharedManager = new Lj, nt(Ba),
                function(e) {
                    e[e.ADD_COLOR = 0] = "ADD_COLOR", e[e.ADD_COLOR_AND_TEXTURE = 1] = "ADD_COLOR_AND_TEXTURE", e[e.GRAYSCALE = 2] = "GRAYSCALE", e[e.USE_ALPHA_SEPARATED = 3] = "USE_ALPHA_SEPARATED", e[e.USE_ALPHA_SEPARATED_AND_GRAY = 4] = "USE_ALPHA_SEPARATED_AND_GRAY"
                }(Mj || (Mj = e("InstanceMaterialType", {})));
            var Bj, Fj, zj, Uj, Gj, Hj, kj, Vj, Wj, jj, qj, Xj, Yj, Kj, Zj, Qj, Jj, $j, eq, tq, nq, iq, rq, oq, aq, sq, cq, lq, uq, hq, _q, fq, dq, pq, mq, gq, vq, yq, Sq, Eq, Tq, Aq, xq, Cq, bq, Rq, wq, Iq, Pq, Oq, Dq, Nq, Mq, Lq, Bq, Fq, zq, Uq, Gq, Hq, kq, Vq, Wq, jq, qq = function(t) {
                return e({
                    Renderable2D: t,
                    RenderComponent: t,
                    UIRenderable: t
                }), t
            }((mj = A_("cc.Renderable2D"), gj = x_(pj), vj = z_(), yj = ef(nE), Sj = ef(nE), Ej = q_(), Tj = U_(), Aj = q_(), xj = G_(), mj(Cj = gj(Cj = b_(Cj = O_((Nj = Dj = function(e) {
                function t() {
                    for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                    return ne(t = e.call.apply(e, [this].concat(i)) || this, "_materials", Rj, $(t)), ne(t, "_customMaterial", wj, $(t)), t.stencilStage = XW.DISABLED, ne(t, "_srcBlendFactor", Ij, $(t)), ne(t, "_dstBlendFactor", Pj, $(t)), ne(t, "_color", Oj, $(t)), t._assembler = null, t._postAssembler = null, t._renderData = null, t._renderDataFlag = !0, t._renderFlag = !0, t._delegateSrc = null, t._instanceMaterialType = Mj.ADD_COLOR_AND_TEXTURE, t._blendState = new bc, t._blendHash = 0, t._colorDirty = !0, t._cacheAlpha = 1, t._lastParent = null, t
                }
                Q(t, e);
                var n = t.prototype;
                return n.updateMaterial = function() {
                    if (this._customMaterial) return this.setMaterial(this._customMaterial, 0), void(this._blendHash = -1);
                    var e = this._updateBuiltinMaterial();
                    this.setMaterial(e, 0), this._updateBlendFunc()
                }, n.updateBlendHash = function() {
                    var e = this._blendState.targets[0].blendDst << 4;
                    this._blendHash = e | this._blendState.targets[0].blendSrc
                }, n.__preload = function() {
                    this.node._uiProps.uiComp = this, this._flushAssembler && this._flushAssembler()
                }, n.onEnable = function() {
                    this.node.on(Om.ANCHOR_CHANGED, this._nodeStateChange, this), this.node.on(Om.SIZE_CHANGED, this._nodeStateChange, this), this.updateMaterial(), this._renderFlag = this._canRender()
                }, n.onRestore = function() {
                    this.updateMaterial(), this._renderFlag = this._canRender()
                }, n.onDisable = function() {
                    this.node.off(Om.ANCHOR_CHANGED, this._nodeStateChange, this), this.node.off(Om.SIZE_CHANGED, this._nodeStateChange, this), this._renderFlag = !1
                }, n.onDestroy = function() {
                    if (this.node._uiProps.uiComp === this && (this.node._uiProps.uiComp = null), this.destroyRenderData(), this._materialInstances)
                        for (var e = 0; e < this._materialInstances.length; e++) this._materialInstances[e] && this._materialInstances[e].destroy();
                    this._renderData = null, this._blendState && this._blendState.destroy()
                }, n.markForUpdateRenderData = function(e) {
                    if (void 0 === e && (e = !0), this._renderFlag = this._canRender(), e && this._renderFlag) {
                        var t = this._renderData;
                        t && (t.vertDirty = !0), this._renderDataFlag = e
                    } else e || (this._renderDataFlag = e)
                }, n.requestRenderData = function() {
                    var e = ij.add();
                    return this._renderData = e, e
                }, n.destroyRenderData = function() {
                    this._renderData && (ij.remove(this._renderData), this._renderData = null)
                }, n.updateAssembler = function(e) {
                    this._updateColor(), this._renderFlag && (this._checkAndUpdateRenderData(), this._render(e))
                }, n.postUpdateAssembler = function(e) {
                    this._renderFlag && this._postRender(e)
                }, n._render = function() {}, n._postRender = function() {}, n._checkAndUpdateRenderData = function() {
                    this._renderDataFlag && (this._assembler.updateRenderData(this), this._renderDataFlag = !1)
                }, n._canRender = function() {
                    return this.isValid && null !== this.getMaterial(0) && this.enabled && (this._delegateSrc ? this._delegateSrc.activeInHierarchy : this.enabledInHierarchy) && this.node._uiProps.opacity > 0
                }, n._postCanRender = function() {}, n._updateColor = function() {
                    this._updateWorldAlpha(), (this._colorDirty || this._cacheAlpha !== this.node._uiProps.opacity) && this._renderFlag && this._assembler && this._assembler.updateColor && (this._assembler.updateColor(this), this._cacheAlpha = this.node._uiProps.opacity, this._colorDirty = !1)
                }, n._updateWorldAlpha = function() {
                    var e = this.color.a / 255;
                    1 === e && (e = this.node._uiProps.localOpacity), this.node._uiProps.opacity = this.node.parent && this.node.parent._uiProps ? this.node.parent._uiProps.opacity * e : e, this._renderFlag = this._canRender()
                }, n._updateBlendFunc = function() {
                    var e = this._blendState.targets[0];
                    e || (e = new Cc, this._blendState.setTarget(0, e)), e.blendDst === this._dstBlendFactor && e.blendSrc === this._srcBlendFactor || (e.blend = !0, e.blendDstAlpha = Ba.ONE_MINUS_SRC_ALPHA, e.blendDst = this._dstBlendFactor, e.blendSrc = this._srcBlendFactor), this.updateBlendHash()
                }, n.getBlendState = function() {
                    return this._blendState
                }, n._nodeStateChange = function() {
                    this._renderData && this.markForUpdateRenderData();
                    for (var e = 0; e < this.node.children.length; ++e) {
                        var n = this.node.children[e].getComponent(t);
                        n && n.markForUpdateRenderData()
                    }
                }, n._updateBuiltinMaterial = function() {
                    var e;
                    switch (this._instanceMaterialType) {
                        case Mj.ADD_COLOR:
                            e = em.get("ui-base-material");
                            break;
                        case Mj.GRAYSCALE:
                            e = em.get("ui-sprite-gray-material");
                            break;
                        case Mj.USE_ALPHA_SEPARATED:
                            e = em.get("ui-sprite-alpha-sep-material");
                            break;
                        case Mj.USE_ALPHA_SEPARATED_AND_GRAY:
                            e = em.get("ui-sprite-gray-alpha-sep-material");
                            break;
                        default:
                            e = em.get("ui-sprite-material")
                    }
                    return e
                }, n._setCacheAlpha = function(e) {
                    this._cacheAlpha = e
                }, K(t, [{
                    key: "sharedMaterials",
                    get: function() {
                        return this._materials
                    },
                    set: function(e) {
                        for (var t = 0; t < e.length; t++) e[t] !== this._materials[t] && this.setMaterial(e[t], t);
                        if (e.length < this._materials.length) {
                            for (var n = e.length; n < this._materials.length; n++) this.setMaterial(null, n);
                            this._materials.splice(e.length)
                        }
                    }
                }, {
                    key: "customMaterial",
                    get: function() {
                        return this._customMaterial
                    },
                    set: function(e) {
                        this._customMaterial = e, this.updateMaterial()
                    }
                }, {
                    key: "srcBlendFactor",
                    get: function() {
                        return this._customMaterial && x(12001), this._srcBlendFactor
                    },
                    set: function(e) {
                        this._customMaterial ? x(12001) : this._srcBlendFactor !== e && (this._srcBlendFactor = e, this._updateBlendFunc())
                    }
                }, {
                    key: "dstBlendFactor",
                    get: function() {
                        return this._customMaterial && x(12001), this._dstBlendFactor
                    },
                    set: function(e) {
                        this._customMaterial ? x(12001) : this._dstBlendFactor !== e && (this._dstBlendFactor = e, this._updateBlendFunc())
                    }
                }, {
                    key: "color",
                    get: function() {
                        return this._color
                    },
                    set: function(e) {
                        this._color.equals(e) || (this._color.set(e), this._colorDirty = !0)
                    }
                }, {
                    key: "renderData",
                    get: function() {
                        return this._renderData
                    }
                }, {
                    key: "delegateSrc",
                    set: function(e) {
                        this._delegateSrc = e
                    }
                }, {
                    key: "blendHash",
                    get: function() {
                        return this._blendHash
                    }
                }]), t
            }(UM), Dj.BlendState = Ba, Dj.Assembler = null, Dj.PostAssembler = null, Rj = ie((bj = Nj).prototype, "_materials", [tf], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return []
                }
            }), ie(bj.prototype, "sharedMaterials", [tf, vj], Object.getOwnPropertyDescriptor(bj.prototype, "sharedMaterials"), bj.prototype), wj = ie(bj.prototype, "_customMaterial", [yj], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return null
                }
            }), ie(bj.prototype, "customMaterial", [Sj, Ej, Tj], Object.getOwnPropertyDescriptor(bj.prototype, "customMaterial"), bj.prototype), ie(bj.prototype, "color", [Aj, xj], Object.getOwnPropertyDescriptor(bj.prototype, "color"), bj.prototype), Ij = ie(bj.prototype, "_srcBlendFactor", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return Ba.SRC_ALPHA
                }
            }), Pj = ie(bj.prototype, "_dstBlendFactor", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return Ba.ONE_MINUS_SRC_ALPHA
                }
            }), Oj = ie(bj.prototype, "_color", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return yn.WHITE.clone()
                }
            }), Cj = bj)) || Cj) || Cj) || Cj) || Cj));
            i.internal.Renderable2D = qq,
                function(e) {
                    e[e.LEFT = 0] = "LEFT", e[e.CENTER = 1] = "CENTER", e[e.RIGHT = 2] = "RIGHT"
                }(kq || (kq = e("HorizontalTextAlignment", {}))), nt(kq),
                function(e) {
                    e[e.TOP = 0] = "TOP", e[e.CENTER = 1] = "CENTER", e[e.BOTTOM = 2] = "BOTTOM"
                }(Vq || (Vq = e("VerticalTextAlignment", {}))), nt(Vq),
                function(e) {
                    e[e.NONE = 0] = "NONE", e[e.CLAMP = 1] = "CLAMP", e[e.SHRINK = 2] = "SHRINK", e[e.RESIZE_HEIGHT = 3] = "RESIZE_HEIGHT"
                }(Wq || (Wq = e("Overflow", {}))), nt(Wq),
                function(e) {
                    e[e.NONE = 0] = "NONE", e[e.BITMAP = 1] = "BITMAP", e[e.CHAR = 2] = "CHAR"
                }(jq || (jq = e("CacheMode", {}))), nt(jq);
            var Xq, Yq, Kq, Zq = function(t) {
                return e({
                    Label: t,
                    LabelComponent: t
                }), t
            }((Bj = A_("cc.Label"), Fj = B_(), zj = C_(110), Uj = D_(), Gj = q_(), Hj = G_(), kj = ef(kq), Vj = q_(), Wj = G_(), jj = ef(Vq), qj = q_(), Xj = G_(), Yj = q_(), Kj = G_(), Zj = q_(), Qj = z_(), Jj = G_(), $j = q_(), eq = G_(), tq = ef(Wq), nq = q_(), iq = G_(), rq = q_(), oq = G_(), aq = ef(nW), sq = q_(), cq = z_(), lq = G_(), uq = q_(), hq = G_(), _q = ef(jq), fq = q_(), dq = G_(), pq = q_(), mq = G_(), gq = q_(), vq = G_(), yq = q_(), Sq = G_(), Eq = z_(), Bj(Tq = Fj(Tq = zj(Tq = Uj((Hq = Gq = function(e) {
                function t() {
                    var t;
                    return ne(t = e.call(this) || this, "_string", xq, $(t)), ne(t, "_horizontalAlign", Cq, $(t)), ne(t, "_verticalAlign", bq, $(t)), ne(t, "_actualFontSize", Rq, $(t)), ne(t, "_fontSize", wq, $(t)), ne(t, "_fontFamily", Iq, $(t)), ne(t, "_lineHeight", Pq, $(t)), ne(t, "_overflow", Oq, $(t)), ne(t, "_enableWrapText", Dq, $(t)), ne(t, "_font", Nq, $(t)), ne(t, "_isSystemFontUsed", Mq, $(t)), t._spacingX = 0, ne(t, "_isItalic", Lq, $(t)), ne(t, "_isBold", Bq, $(t)), ne(t, "_isUnderline", Fq, $(t)), ne(t, "_underlineHeight", zq, $(t)), ne(t, "_cacheMode", Uq, $(t)), t._N$file = null, t._texture = null, t._ttfSpriteFrame = null, t._userDefinedFont = null, t._assemblerData = null, t._fontAtlas = null, t._letterTexture = null, t._ttfSpriteFrame = null, t
                }
                Q(t, e);
                var n = t.prototype;
                return n.onEnable = function() {
                    e.prototype.onEnable.call(this), this._font || this._isSystemFontUsed || (this.useSystemFont = !0), this._isSystemFontUsed && !this._fontFamily && (this.fontFamily = "Arial"), this.updateRenderData(!0)
                }, n.onDisable = function() {
                    e.prototype.onDisable.call(this)
                }, n.onDestroy = function() {
                    if (this._assembler && this._assembler.resetAssemblerData && this._assembler.resetAssemblerData(this._assemblerData), this._assemblerData = null, this._ttfSpriteFrame) {
                        var t = this._ttfSpriteFrame.texture;
                        if (t && null === this._ttfSpriteFrame.original) {
                            var n = t;
                            n.image && n.image.destroy(), t.destroy()
                        }
                        this._ttfSpriteFrame = null
                    }
                    this._letterTexture = null, e.prototype.onDestroy.call(this)
                }, n.updateRenderData = function(e) {
                    void 0 === e && (e = !1), this.markForUpdateRenderData(), e && (this._flushAssembler(), this.renderData && (this.renderData.vertDirty = !0), this._applyFontTexture())
                }, n._render = function(e) {
                    e.commitComp(this, this._texture, this._assembler, null)
                }, n._updateColor = function() {
                    this._font instanceof mW ? (this._updateWorldAlpha(), this._colorDirty = !1) : (this._updateWorldAlpha(), this._colorDirty ? (this.updateRenderData(!1), this._colorDirty = !1) : this._cacheAlpha !== this.node._uiProps.opacity && this._renderFlag && this._assembler && this._assembler.updateOpacity && (this._assembler.updateOpacity(this), this._cacheAlpha = this.node._uiProps.opacity))
                }, n._canRender = function() {
                    if (!e.prototype._canRender.call(this) || !this._string) return !1;
                    var t = this._font;
                    if (t && t instanceof mW) {
                        var n = t.spriteFrame;
                        if (!n || !n.textureLoaded()) return !1
                    }
                    return !0
                }, n._flushAssembler = function() {
                    var e = t.Assembler.getAssembler(this);
                    this._assembler !== e && (this.destroyRenderData(), this._assembler = e), this._renderData || this._assembler && this._assembler.createData && (this._renderData = this._assembler.createData(this), this._renderData.material = this.material)
                }, n._applyFontTexture = function() {
                    var e = this,
                        t = this._font;
                    if (t instanceof mW) {
                        var n = t.spriteFrame,
                            i = function() {
                                e._texture = n, e.changeMaterialForDefine(), e._assembler && e._assembler.updateRenderData(e)
                            };
                        n && (n.loaded || n.textureLoaded ? i() : n.once("load", i, this))
                    } else {
                        if (this.cacheMode === jq.CHAR) this._letterTexture = this._assembler.getAssemblerData(), this._texture = this._letterTexture;
                        else if (!this._ttfSpriteFrame) {
                            this._ttfSpriteFrame = new KV, this._assemblerData = this._assembler.getAssemblerData();
                            var r = new Wf(this._assemblerData.canvas)._texture;
                            this._ttfSpriteFrame.texture = r
                        }
                        this.cacheMode !== jq.CHAR && (this._texture = this._ttfSpriteFrame), this.changeMaterialForDefine(), this._assembler && this._assembler.updateRenderData(this)
                    }
                }, n.changeMaterialForDefine = function() {
                    if (this._texture) {
                        var e = !1;
                        if (this.cacheMode !== jq.CHAR) {
                            var t = this._texture.texture;
                            if (t instanceof ud) {
                                var n = t.getPixelFormat();
                                e = n === Mf.RGBA_ETC1 || n === Mf.RGB_A_PVRTC_4BPPV1 || n === Mf.RGB_A_PVRTC_2BPPV1
                            }
                        }
                        this._instanceMaterialType = e ? Mj.USE_ALPHA_SEPARATED : Mj.ADD_COLOR_AND_TEXTURE, this.updateMaterial()
                    }
                }, K(t, [{
                    key: "string",
                    get: function() {
                        return this._string
                    },
                    set: function(e) {
                        e += "", this._string !== e && (this._string = e, this.updateRenderData())
                    }
                }, {
                    key: "horizontalAlign",
                    get: function() {
                        return this._horizontalAlign
                    },
                    set: function(e) {
                        this._horizontalAlign !== e && (this._horizontalAlign = e, this.updateRenderData())
                    }
                }, {
                    key: "verticalAlign",
                    get: function() {
                        return this._verticalAlign
                    },
                    set: function(e) {
                        this._verticalAlign !== e && (this._verticalAlign = e, this.updateRenderData())
                    }
                }, {
                    key: "actualFontSize",
                    get: function() {
                        return this._actualFontSize
                    },
                    set: function(e) {
                        this._actualFontSize = e
                    }
                }, {
                    key: "fontSize",
                    get: function() {
                        return this._fontSize
                    },
                    set: function(e) {
                        this._fontSize !== e && (this._fontSize = e, this.updateRenderData())
                    }
                }, {
                    key: "fontFamily",
                    get: function() {
                        return this._fontFamily
                    },
                    set: function(e) {
                        this._fontFamily !== e && (this._fontFamily = e, this.updateRenderData())
                    }
                }, {
                    key: "lineHeight",
                    get: function() {
                        return this._lineHeight
                    },
                    set: function(e) {
                        this._lineHeight !== e && (this._lineHeight = e, this.updateRenderData())
                    }
                }, {
                    key: "overflow",
                    get: function() {
                        return this._overflow
                    },
                    set: function(e) {
                        this._overflow !== e && (this._overflow = e, this.updateRenderData())
                    }
                }, {
                    key: "enableWrapText",
                    get: function() {
                        return this._enableWrapText
                    },
                    set: function(e) {
                        this._enableWrapText !== e && (this._enableWrapText = e, this.updateRenderData())
                    }
                }, {
                    key: "font",
                    get: function() {
                        return this._font
                    },
                    set: function(e) {
                        this._font !== e && (this._isSystemFontUsed = !e, this._font = e, this._renderData && (this.destroyRenderData(), this._renderData = null), this._fontAtlas = null, this.updateRenderData(!0))
                    }
                }, {
                    key: "useSystemFont",
                    get: function() {
                        return this._isSystemFontUsed
                    },
                    set: function(e) {
                        this._isSystemFontUsed !== e && (this.destroyRenderData(), this._renderData = null, this._isSystemFontUsed = !!e, e && (this.font = null), this._flushAssembler(), this.updateRenderData())
                    }
                }, {
                    key: "cacheMode",
                    get: function() {
                        return this._cacheMode
                    },
                    set: function(e) {
                        this._cacheMode !== e && (this._cacheMode !== jq.BITMAP || this._font instanceof mW || !this._ttfSpriteFrame || this._ttfSpriteFrame._resetDynamicAtlasFrame(), this._cacheMode === jq.CHAR && (this._ttfSpriteFrame = null), this._cacheMode = e, this.updateRenderData(!0))
                    }
                }, {
                    key: "spriteFrame",
                    get: function() {
                        return this._texture
                    }
                }, {
                    key: "ttfSpriteFrame",
                    get: function() {
                        return this._ttfSpriteFrame
                    }
                }, {
                    key: "isBold",
                    get: function() {
                        return this._isBold
                    },
                    set: function(e) {
                        this._isBold !== e && (this._isBold = e, this.updateRenderData())
                    }
                }, {
                    key: "isItalic",
                    get: function() {
                        return this._isItalic
                    },
                    set: function(e) {
                        this._isItalic !== e && (this._isItalic = e, this.updateRenderData())
                    }
                }, {
                    key: "isUnderline",
                    get: function() {
                        return this._isUnderline
                    },
                    set: function(e) {
                        this._isUnderline !== e && (this._isUnderline = e, this.updateRenderData())
                    }
                }, {
                    key: "underlineHeight",
                    get: function() {
                        return this._underlineHeight
                    },
                    set: function(e) {
                        this._underlineHeight !== e && (this._underlineHeight = e, this.updateRenderData())
                    }
                }, {
                    key: "assemblerData",
                    get: function() {
                        return this._assemblerData
                    }
                }, {
                    key: "fontAtlas",
                    get: function() {
                        return this._fontAtlas
                    },
                    set: function(e) {
                        this._fontAtlas = e
                    }
                }, {
                    key: "spacingX",
                    get: function() {
                        return this._spacingX
                    },
                    set: function(e) {
                        this._spacingX !== e && (this._spacingX = e, this.updateRenderData())
                    }
                }, {
                    key: "_bmFontOriginalSize",
                    get: function() {
                        return this._font instanceof mW ? this._font.fontSize : -1
                    }
                }]), t
            }(qq), Gq.HorizontalAlign = kq, Gq.VerticalAlign = Vq, Gq.Overflow = Wq, Gq.CacheMode = jq, Gq._canvasPool = YW.getInstance(), ie((Aq = Hq).prototype, "string", [Gj, Hj, Y_], Object.getOwnPropertyDescriptor(Aq.prototype, "string"), Aq.prototype), ie(Aq.prototype, "horizontalAlign", [kj, Vj, Wj], Object.getOwnPropertyDescriptor(Aq.prototype, "horizontalAlign"), Aq.prototype), ie(Aq.prototype, "verticalAlign", [jj, qj, Xj], Object.getOwnPropertyDescriptor(Aq.prototype, "verticalAlign"), Aq.prototype), ie(Aq.prototype, "fontSize", [Yj, Kj], Object.getOwnPropertyDescriptor(Aq.prototype, "fontSize"), Aq.prototype), ie(Aq.prototype, "fontFamily", [Zj, Qj, Jj], Object.getOwnPropertyDescriptor(Aq.prototype, "fontFamily"), Aq.prototype), ie(Aq.prototype, "lineHeight", [$j, eq], Object.getOwnPropertyDescriptor(Aq.prototype, "lineHeight"), Aq.prototype), ie(Aq.prototype, "overflow", [tq, nq, iq], Object.getOwnPropertyDescriptor(Aq.prototype, "overflow"), Aq.prototype), ie(Aq.prototype, "enableWrapText", [rq, oq], Object.getOwnPropertyDescriptor(Aq.prototype, "enableWrapText"), Aq.prototype), ie(Aq.prototype, "font", [aq, sq, cq, lq], Object.getOwnPropertyDescriptor(Aq.prototype, "font"), Aq.prototype), ie(Aq.prototype, "useSystemFont", [uq, hq], Object.getOwnPropertyDescriptor(Aq.prototype, "useSystemFont"), Aq.prototype), ie(Aq.prototype, "cacheMode", [_q, fq, dq], Object.getOwnPropertyDescriptor(Aq.prototype, "cacheMode"), Aq.prototype), ie(Aq.prototype, "isBold", [pq, mq], Object.getOwnPropertyDescriptor(Aq.prototype, "isBold"), Aq.prototype), ie(Aq.prototype, "isItalic", [gq, vq], Object.getOwnPropertyDescriptor(Aq.prototype, "isItalic"), Aq.prototype), ie(Aq.prototype, "isUnderline", [yq, Sq], Object.getOwnPropertyDescriptor(Aq.prototype, "isUnderline"), Aq.prototype), ie(Aq.prototype, "underlineHeight", [Eq, F_], Object.getOwnPropertyDescriptor(Aq.prototype, "underlineHeight"), Aq.prototype), xq = ie(Aq.prototype, "_string", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return "label"
                }
            }), Cq = ie(Aq.prototype, "_horizontalAlign", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return kq.CENTER
                }
            }), bq = ie(Aq.prototype, "_verticalAlign", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return Vq.CENTER
                }
            }), Rq = ie(Aq.prototype, "_actualFontSize", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return 0
                }
            }), wq = ie(Aq.prototype, "_fontSize", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return 40
                }
            }), Iq = ie(Aq.prototype, "_fontFamily", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return "Arial"
                }
            }), Pq = ie(Aq.prototype, "_lineHeight", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return 40
                }
            }), Oq = ie(Aq.prototype, "_overflow", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return Wq.NONE
                }
            }), Dq = ie(Aq.prototype, "_enableWrapText", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return !0
                }
            }), Nq = ie(Aq.prototype, "_font", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return null
                }
            }), Mq = ie(Aq.prototype, "_isSystemFontUsed", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return !0
                }
            }), Lq = ie(Aq.prototype, "_isItalic", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return !1
                }
            }), Bq = ie(Aq.prototype, "_isBold", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return !1
                }
            }), Fq = ie(Aq.prototype, "_isUnderline", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return !1
                }
            }), zq = ie(Aq.prototype, "_underlineHeight", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return 2
                }
            }), Uq = ie(Aq.prototype, "_cacheMode", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return jq.NONE
                }
            }), Tq = Aq)) || Tq) || Tq) || Tq) || Tq));
            ! function(e) {
                e[e.BUTT = 0] = "BUTT", e[e.ROUND = 1] = "ROUND", e[e.SQUARE = 2] = "SQUARE"
            }(Xq || (Xq = {})), nt(Xq),
                function(e) {
                    e[e.BEVEL = 0] = "BEVEL", e[e.ROUND = 1] = "ROUND", e[e.MITER = 2] = "MITER"
                }(Yq || (Yq = {})), nt(Yq),
                function(e) {
                    e[e.PT_CORNER = 1] = "PT_CORNER", e[e.PT_LEFT = 2] = "PT_LEFT", e[e.PT_BEVEL = 4] = "PT_BEVEL", e[e.PT_INNERBEVEL = 8] = "PT_INNERBEVEL"
                }(Kq || (Kq = {})), nt(Kq);
            var Qq = Math.PI,
                Jq = Math.min,
                $q = Math.max,
                eX = Math.cos,
                tX = Math.sin,
                nX = Math.abs,
                iX = Math.sign,
                rX = .5522847493;

            function oX(e, t, n, i, r) {
                e.moveTo(t - i, n), e.bezierCurveTo(t - i, n + r * rX, t - i * rX, n + r, t, n + r), e.bezierCurveTo(t + i * rX, n + r, t + i, n + r * rX, t + i, n), e.bezierCurveTo(t + i, n - r * rX, t + i * rX, n - r, t, n - r), e.bezierCurveTo(t - i * rX, n - r, t - i, n - r * rX, t - i, n), e.close()
            }

            function aX(e, t, n, i, r, o, a, s, c, l, u) {
                var h, _, f, d, p, m, g, v, y, S, E, T, A, x, C, b;
                l > 10 || (p = .5 * (o + s), m = .5 * (a + c), g = .5 * ((h = .5 * (t + i)) + (f = .5 * (i + o))), v = .5 * ((_ = .5 * (n + r)) + (d = .5 * (r + a))), ((C = nX((i - s) * (x = c - n) - (r - c) * (A = s - t))) + (b = nX((o - s) * x - (a - c) * A))) * (C + b) < e.tessTol * (A * A + x * x) ? e.addPoint(s, c, 0 === u ? u | Kq.PT_BEVEL : u) : (aX(e, t, n, h, _, g, v, E = .5 * (g + (y = .5 * (f + p))), T = .5 * (v + (S = .5 * (d + m))), l + 1, 0), aX(e, E, T, y, S, p, m, s, c, l + 1, u)))
            }
            var sX, cX, lX, uX, hX, _X, fX, dX, pX, mX, gX, vX, yX, SX, EX, TX, AX, xX, CX, bX, RX, wX, IX = function(e) {
                    function t(t, n) {
                        var i;
                        return (i = e.call(this, t, n) || this).dx = 0, i.dy = 0, i.dmx = 0, i.dmy = 0, i.flags = 0, i.len = 0, i.reset(), i
                    }
                    return Q(t, e), t.prototype.reset = function() {
                        this.dx = 0, this.dy = 0, this.dmx = 0, this.dmy = 0, this.flags = 0, this.len = 0
                    }, t
                }(Gn),
                PX = function() {
                    function e() {
                        this.closed = !1, this.bevel = 0, this.complex = !0, this.points = [], this.reset()
                    }
                    return e.prototype.reset = function() {
                        this.closed = !1, this.bevel = 0, this.complex = !0, this.points ? this.points.length = 0 : this.points = []
                    }, e
                }(),
                OX = function() {
                    function e() {
                        this.dataOffset = 0, this.updatePathOffset = !1, this.pathLength = 0, this.pathOffset = 0, this.paths = [], this.tessTol = .25, this.distTol = .01, this.fillColor = yn.WHITE.clone(), this.lineCap = Xq.BUTT, this.strokeColor = yn.BLACK.clone(), this.lineJoin = Yq.MITER, this.lineWidth = 0, this.pointsOffset = 0, this._commandX = 0, this._commandY = 0, this._points = [], this._renderDataList = [], this._curPath = null
                    }
                    var t = e.prototype;
                    return t.moveTo = function(e, t) {
                        this.updatePathOffset && (this.pathOffset = this.pathLength, this.updatePathOffset = !1), this._addPath(), this.addPoint(e, t, Kq.PT_CORNER), this._commandX = e, this._commandY = t
                    }, t.lineTo = function(e, t) {
                        this.addPoint(e, t, Kq.PT_CORNER), this._commandX = e, this._commandY = t
                    }, t.bezierCurveTo = function(e, t, n, i, r, o) {
                        var a = this._curPath,
                            s = a.points[a.points.length - 1];
                        s && (s.x !== e || s.y !== t || n !== r || i !== o ? (aX(this, s.x, s.y, e, t, n, i, r, o, 0, Kq.PT_CORNER), this._commandX = r, this._commandY = o) : this.lineTo(r, o))
                    }, t.quadraticCurveTo = function(e, t, n, i) {
                        var r = this._commandX,
                            o = this._commandY;
                        this.bezierCurveTo(r + 2 / 3 * (e - r), o + 2 / 3 * (t - o), n + 2 / 3 * (e - n), i + 2 / 3 * (t - i), n, i)
                    }, t.arc = function(e, t, n, i, r, o) {
                        ! function(e, t, n, i, r, o, a) {
                            var s, c, l = 0,
                                u = 0,
                                h = 0,
                                _ = 0,
                                f = 0,
                                d = 0,
                                p = 0,
                                m = 0,
                                g = 0,
                                v = 0,
                                y = 0,
                                S = 0,
                                E = 0,
                                T = 0;
                            if (u = o - r, a = a || !1)
                                if (nX(u) >= 2 * Qq) u = 2 * Qq;
                                else
                                    for (; u < 0;) u += 2 * Qq;
                            else if (nX(u) >= 2 * Qq) u = 2 * -Qq;
                            else
                                for (; u > 0;) u -= 2 * Qq;
                            for (c = 0 | $q(1, Jq(nX(u) / (.5 * Qq) + .5, 5)), h = nX(4 / 3 * (1 - eX(s = u / c / 2)) / tX(s)), a || (h = -h), T = 0; T <= c; T++) d = t + (_ = eX(l = r + u * (T / c))) * i, p = n + (f = tX(l)) * i, m = -f * i * h, g = _ * i * h, 0 === T ? e.moveTo(d, p) : e.bezierCurveTo(v + S, y + E, d - m, p - g, d, p), v = d, y = p, S = m, E = g
                        }(this, e, t, n, i, r, o)
                    }, t.ellipse = function(e, t, n, i) {
                        oX(this, e, t, n, i), this._curPath.complex = !1
                    }, t.circle = function(e, t, n) {
                        oX(this, e, t, n, n), this._curPath.complex = !1
                    }, t.rect = function(e, t, n, i) {
                        this.moveTo(e, t), this.lineTo(e + n, t), this.lineTo(e + n, t + i), this.lineTo(e, t + i), this.close(), this._curPath.complex = !1
                    }, t.roundRect = function(e, t, n, i, r) {
                        ! function(e, t, n, i, r, o) {
                            if (o < .1) e.rect(t, n, i, r);
                            else {
                                var a = Jq(o, .5 * nX(i)) * iX(i),
                                    s = Jq(o, .5 * nX(r)) * iX(r);
                                e.moveTo(t, n + s), e.lineTo(t, n + r - s), e.bezierCurveTo(t, n + r - s * (1 - rX), t + a * (1 - rX), n + r, t + a, n + r), e.lineTo(t + i - a, n + r), e.bezierCurveTo(t + i - a * (1 - rX), n + r, t + i, n + r - s * (1 - rX), t + i, n + r - s), e.lineTo(t + i, n + s), e.bezierCurveTo(t + i, n + s * (1 - rX), t + i - a * (1 - rX), n, t + i - a, n), e.lineTo(t + a, n), e.bezierCurveTo(t + a * (1 - rX), n, t, n + s * (1 - rX), t, n + s), e.close()
                            }
                        }(this, e, t, n, i, r), this._curPath.complex = !1
                    }, t.clear = function() {
                        this.pathLength = 0, this.pathOffset = 0, this.pointsOffset = 0, this.dataOffset = 0, this._curPath = null, this.paths.length = 0, this._points.length = 0;
                        for (var e = this._renderDataList, t = 0, n = e.length; t < n; t++) {
                            var i = e[t];
                            i && rj.remove(i)
                        }
                        this._renderDataList.length = 0
                    }, t.close = function() {
                        this._curPath.closed = !0
                    }, t.requestRenderData = function() {
                        var e = rj.add();
                        return this._renderDataList.push(e), e
                    }, t.getRenderDataList = function() {
                        return 0 === this._renderDataList.length && this.requestRenderData(), this._renderDataList
                    }, t.addPoint = function(e, t, n) {
                        var i = this._curPath;
                        if (i) {
                            var r = this._points,
                                o = i.points,
                                a = r[this.pointsOffset++];
                            a ? (a.x = e, a.y = t) : (a = new IX(e, t), r.push(a)), a.flags = n, o.push(a)
                        }
                    }, t._addPath = function() {
                        var e = this.pathLength,
                            t = this.paths[e];
                        return t ? t.reset() : (t = new PX, this.paths.push(t)), this.pathLength++, this._curPath = t, t
                    }, e
                }(),
                DX = [new Ms(is.ATTR_POSITION, Ea.RGB32F)],
                NX = [new Ms(is.ATTR_POSITION, Ea.RGB32F), new Ms(is.ATTR_COLOR, Ea.RGBA32F)],
                MX = [new Ms(is.ATTR_POSITION, Ea.RGB32F), new Ms(is.ATTR_TEX_COORD, Ea.RG32F), new Ms(is.ATTR_COLOR, Ea.RGBA32F)],
                LX = [new Ms(is.ATTR_POSITION, Ea.RGB32F), new Ms(is.ATTR_TEX_COORD, Ea.RG32F), new Ms(is.ATTR_COLOR, Ea.RGBA32F), new Ms(is.ATTR_COLOR2, Ea.RGBA32F)];

            function BX(e) {
                for (var t = 0, n = 0; n < e.length; n++) {
                    var i = e[n];
                    t += tc[i.format].count
                }
                return t
            }

            function FX(e) {
                for (var t = 0, n = 0; n < e.length; n++) {
                    var i = e[n];
                    t += tc[i.format].size
                }
                return t
            }
            i.internal.vfmtPosUvColor = MX, i.internal.vfmtPosUvTwoColor = LX, e("UIVertexFormat", Object.freeze({
                __proto__: null,
                vfmt: DX,
                vfmtPosColor: NX,
                vfmtPosUvColor: MX,
                vfmtPosUvTwoColor: LX,
                getComponentPerVertex: BX,
                getAttributeStride: FX
            }));
            var zX, UX, GX, HX, kX, VX, WX, jX, qX, XX, YX, KX, ZX, QX, JX, $X, eY, tY, nY, iY, rY, oY, aY, sY, cY, lY, uY = NX.concat([new Ms("a_dist", Ea.R32F)]),
                hY = BX(uY),
                _Y = FX(uY),
                fY = function(t) {
                    return e({
                        Graphics: t,
                        GraphicsComponent: t
                    }), t
                }((sX = A_("cc.Graphics"), cX = B_(), lX = C_(110), uX = D_(), hX = ef(Yq), _X = G_(), fX = ef(Xq), dX = G_(), pX = G_(), mX = G_(), gX = G_(), vX = z_(), sX(yX = cX(yX = lX(yX = uX((wX = RX = function(e) {
                    function t() {
                        var t;
                        return (t = e.call(this) || this).impl = null, t.model = null, ne(t, "_lineWidth", EX, $(t)), ne(t, "_strokeColor", TX, $(t)), ne(t, "_lineJoin", AX, $(t)), ne(t, "_lineCap", xX, $(t)), ne(t, "_fillColor", CX, $(t)), ne(t, "_miterLimit", bX, $(t)), t._isDrawing = !1, t._isNeedUploadData = !0, t._instanceMaterialType = Mj.ADD_COLOR, t.impl = new OX, t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.onRestore = function() {
                        this.impl || this._flushAssembler()
                    }, n.onLoad = function() {
                        this.model = RO.root.createModel(ub), this.model.node = this.model.transform = this.node, this._flushAssembler()
                    }, n.onEnable = function() {
                        e.prototype.onEnable.call(this), this._updateMtlForGraphics()
                    }, n.onDisable = function() {
                        e.prototype.onDisable.call(this)
                    }, n.onDestroy = function() {
                        e.prototype.onDestroy.call(this), this._sceneGetter = null, this.model && (RO.root.destroyModel(this.model), this.model = null), this.impl && (this._isDrawing = !1, this.impl.clear(), this.impl = null)
                    }, n.moveTo = function(e, t) {
                        this.impl && this.impl.moveTo(e, t)
                    }, n.lineTo = function(e, t) {
                        this.impl && this.impl.lineTo(e, t)
                    }, n.bezierCurveTo = function(e, t, n, i, r, o) {
                        this.impl && this.impl.bezierCurveTo(e, t, n, i, r, o)
                    }, n.quadraticCurveTo = function(e, t, n, i) {
                        this.impl && this.impl.quadraticCurveTo(e, t, n, i)
                    }, n.arc = function(e, t, n, i, r, o) {
                        this.impl && this.impl.arc(e, t, n, i, r, o)
                    }, n.ellipse = function(e, t, n, i) {
                        this.impl && this.impl.ellipse(e, t, n, i)
                    }, n.circle = function(e, t, n) {
                        this.impl && this.impl.circle(e, t, n)
                    }, n.rect = function(e, t, n, i) {
                        this.impl && this.impl.rect(e, t, n, i)
                    }, n.roundRect = function(e, t, n, i, r) {
                        this.impl && this.impl.roundRect(e, t, n, i, r)
                    }, n.fillRect = function(e, t, n, i) {
                        this.rect(e, t, n, i), this.fill()
                    }, n.clear = function() {
                        if (this.impl) {
                            if (this.impl.clear(), this._isDrawing = !1, this.model)
                                for (var e = 0; e < this.model.subModels.length; e++) this.model.subModels[e].inputAssembler.indexCount = 0;
                            this.markForUpdateRenderData()
                        }
                    }, n.close = function() {
                        this.impl && this.impl.close()
                    }, n.stroke = function() {
                        this._assembler || this._flushAssembler(), this._isDrawing = !0, this._isNeedUploadData = !0, this._assembler.stroke(this)
                    }, n.fill = function() {
                        this._assembler || this._flushAssembler(), this._isDrawing = !0, this._isNeedUploadData = !0, this._assembler.fill(this)
                    }, n._updateMtlForGraphics = function() {
                        var e;
                        this._customMaterial ? e = this.getMaterialInstance(0) : (e = em.get("ui-graphics-material"), this.setMaterial(e, 0), (e = this.getMaterialInstance(0)).recompileShaders({
                            USE_LOCAL: !0
                        }))
                    }, n.activeSubModel = function(e) {
                        if (this.model) {
                            if (this.model.subModels.length <= e) {
                                var t = i.director.root.device,
                                    n = t.createBuffer(new gs(xa.VERTEX | xa.TRANSFER_DST, Ra.DEVICE, 65535 * _Y, _Y)),
                                    r = t.createBuffer(new gs(xa.INDEX | xa.TRANSFER_DST, Ra.DEVICE, 131070 * Uint16Array.BYTES_PER_ELEMENT, Uint16Array.BYTES_PER_ELEMENT)),
                                    o = new YR([n], uY, Wa.TRIANGLE_LIST, r);
                                o.subMeshIdx = 0, this.model.initSubModel(e, o, this.getMaterialInstance(0))
                            }
                        } else x(4500, this.node.name)
                    }, n._uploadData = function(e) {
                        var t = this.impl;
                        if (t) {
                            var n = t && t.getRenderDataList();
                            if (!(n.length <= 0) && this.model) {
                                for (var i = this.model.subModels, r = 0; r < n.length; r++) {
                                    var o = n[r],
                                        a = i[r].inputAssembler;
                                    if (o.lastFilledVertex !== o.vertexStart) {
                                        var s = new Float32Array(o.vData.buffer, 0, o.vertexStart * hY);
                                        a.vertexBuffers[0].update(s), a.vertexCount = o.vertexStart;
                                        var c = new Uint16Array(o.iData.buffer, 0, o.indicesStart);
                                        a.indexBuffer.update(c), a.indexCount = o.indicesStart, o.lastFilledVertex = o.vertexStart, o.lastFilledIndices = o.indicesStart
                                    }
                                }
                                e.removeUploadBuffersFunc(this), this._isNeedUploadData = !1
                            }
                        }
                    }, n._render = function(e) {
                        if (this._isNeedUploadData) {
                            if (this.impl) {
                                var t = this.impl.getRenderDataList(),
                                    n = this.model.subModels.length;
                                if (t.length > n)
                                    for (var i = n; i < t.length; i++) this.activeSubModel(i)
                            }
                            e.addUploadBuffersFunc(this, this._uploadData)
                        }
                        e.commitModel(this, this.model, this.getMaterialInstance(0))
                    }, n._flushAssembler = function() {
                        var e = t.Assembler.getAssembler(this);
                        this._assembler !== e && (this._assembler = e)
                    }, n._canRender = function() {
                        return !!e.prototype._canRender.call(this) && !!this.model && this._isDrawing
                    }, K(t, [{
                        key: "lineWidth",
                        get: function() {
                            return this._lineWidth
                        },
                        set: function(e) {
                            this._lineWidth = e, this.impl && (this.impl.lineWidth = e)
                        }
                    }, {
                        key: "lineJoin",
                        get: function() {
                            return this._lineJoin
                        },
                        set: function(e) {
                            this._lineJoin = e, this.impl && (this.impl.lineJoin = e)
                        }
                    }, {
                        key: "lineCap",
                        get: function() {
                            return this._lineCap
                        },
                        set: function(e) {
                            this._lineCap = e, this.impl && (this.impl.lineCap = e)
                        }
                    }, {
                        key: "strokeColor",
                        get: function() {
                            return this._strokeColor
                        },
                        set: function(e) {
                            this.impl && (this._strokeColor.set(e), this.impl.strokeColor = this._strokeColor)
                        }
                    }, {
                        key: "fillColor",
                        get: function() {
                            return this._fillColor
                        },
                        set: function(e) {
                            this.impl && (this._fillColor.set(e), this.impl.fillColor = this._fillColor)
                        }
                    }, {
                        key: "miterLimit",
                        get: function() {
                            return this._miterLimit
                        },
                        set: function(e) {
                            this._miterLimit = e
                        }
                    }, {
                        key: "color",
                        get: function() {
                            return this._color
                        },
                        set: function(e) {
                            this._color !== e && this._color.set(e)
                        }
                    }, {
                        key: "srcBlendFactor",
                        get: function() {
                            return this._srcBlendFactor
                        },
                        set: function() {}
                    }, {
                        key: "dstBlendFactor",
                        get: function() {
                            return this._dstBlendFactor
                        },
                        set: function() {}
                    }]), t
                }(qq), RX.LineJoin = Yq, RX.LineCap = Xq, ie((SX = wX).prototype, "lineWidth", [F_], Object.getOwnPropertyDescriptor(SX.prototype, "lineWidth"), SX.prototype), ie(SX.prototype, "lineJoin", [hX, _X], Object.getOwnPropertyDescriptor(SX.prototype, "lineJoin"), SX.prototype), ie(SX.prototype, "lineCap", [fX, dX], Object.getOwnPropertyDescriptor(SX.prototype, "lineCap"), SX.prototype), ie(SX.prototype, "strokeColor", [pX], Object.getOwnPropertyDescriptor(SX.prototype, "strokeColor"), SX.prototype), ie(SX.prototype, "fillColor", [mX], Object.getOwnPropertyDescriptor(SX.prototype, "fillColor"), SX.prototype), ie(SX.prototype, "miterLimit", [gX], Object.getOwnPropertyDescriptor(SX.prototype, "miterLimit"), SX.prototype), ie(SX.prototype, "color", [tf, vX], Object.getOwnPropertyDescriptor(SX.prototype, "color"), SX.prototype), EX = ie(SX.prototype, "_lineWidth", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 1
                    }
                }), TX = ie(SX.prototype, "_strokeColor", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return yn.BLACK.clone()
                    }
                }), AX = ie(SX.prototype, "_lineJoin", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return Yq.MITER
                    }
                }), xX = ie(SX.prototype, "_lineCap", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return Xq.BUTT
                    }
                }), CX = ie(SX.prototype, "_fillColor", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return yn.WHITE.clone()
                    }
                }), bX = ie(SX.prototype, "_miterLimit", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 10
                    }
                }), yX = SX)) || yX) || yX) || yX) || yX)),
                dY = new Bn,
                pY = new Gn,
                mY = new Bn,
                gY = [];
            ! function(e) {
                e[e.RECT = 0] = "RECT", e[e.ELLIPSE = 1] = "ELLIPSE", e[e.GRAPHICS_STENCIL = 2] = "GRAPHICS_STENCIL", e[e.IMAGE_STENCIL = 3] = "IMAGE_STENCIL"
            }(lY || (lY = {})), nt(lY);
            var vY = function(t) {
                return e({
                    Mask: t,
                    MaskComponent: t
                }), t
            }((zX = A_("cc.Mask"), UX = B_(), GX = C_(110), HX = D_(), kX = ef(lY), VX = q_(), WX = G_(), jX = q_(), qX = G_(), XX = z_(), YX = ef(KV), KX = z_(), ZX = z_(), QX = H_(), JX = z_(), $X = z_(), zX(eY = UX(eY = GX(eY = HX((cY = sY = function(e) {
                function t() {
                    var t;
                    return (t = e.call(this) || this)._clearStencilMtl = null, t._clearModel = null, ne(t, "_type", nY, $(t)), ne(t, "_inverted", iY, $(t)), ne(t, "_segments", rY, $(t)), ne(t, "_spriteFrame", oY, $(t)), ne(t, "_alphaThreshold", aY, $(t)), t._graphics = null, t._instanceMaterialType = Mj.ADD_COLOR, t
                }
                Q(t, e);
                var n = t.prototype;
                return n.onLoad = function() {
                    this._createClearModel(), this._createGraphics(), this._graphics && this._graphics.onLoad()
                }, n.onEnable = function() {
                    e.prototype.onEnable.call(this), this._updateGraphics()
                }, n.onRestore = function() {
                    this._createGraphics(), e.prototype.updateMaterial.call(this), this._updateGraphics(), this._renderFlag = this._canRender()
                }, n.onDisable = function() {
                    e.prototype.onDisable.call(this), this._disableGraphics()
                }, n.onDestroy = function() {
                    e.prototype.onDestroy.call(this), this._clearModel && RO.root.destroyModel(this._clearModel), this._clearStencilMtl && this._clearStencilMtl.destroy(), this._removeGraphics()
                }, n.isHit = function(e) {
                    var t = this.node._uiProps.uiTransformComp,
                        n = t.contentSize,
                        i = n.width,
                        r = n.height,
                        o = pY;
                    this.node.getWorldMatrix(dY), Bn.invert(mY, dY), Gn.transformMat4(o, e, mY);
                    var a = t.anchorPoint;
                    o.x += a.x * i, o.y += a.y * r;
                    var s = !1;
                    if (this.type === lY.RECT || this.type === lY.GRAPHICS_STENCIL) s = o.x >= 0 && o.y >= 0 && o.x <= i && o.y <= r;
                    else if (this.type === lY.ELLIPSE) {
                        var c = i / 2,
                            l = r / 2,
                            u = o.x - .5 * i,
                            h = o.y - .5 * r;
                        s = u * u / (c * c) + h * h / (l * l) < 1
                    }
                    return this._inverted && (s = !s), s
                }, n._render = function(e) {
                    e.commitComp(this, null, this._assembler, null)
                }, n._postRender = function(e) {
                    this._postAssembler && e.commitComp(this, null, this._postAssembler, null)
                }, n._nodeStateChange = function(t) {
                    e.prototype._nodeStateChange.call(this, t), this._updateGraphics()
                }, n._canRender = function() {
                    return !!e.prototype._canRender.call(this) && null !== this._graphics && (this._type !== lY.IMAGE_STENCIL || null !== this._spriteFrame)
                }, n._flushAssembler = function() {
                    var e = t.Assembler.getAssembler(this),
                        n = t.PostAssembler.getAssembler(this);
                    this._assembler !== e && (this.destroyRenderData(), this._assembler = e), this._postAssembler !== n && (this._postAssembler = n), this._useRenderData()
                }, n._createGraphics = function() {
                    if (!this._graphics) {
                        var e = this._graphics = new fY;
                        e._objFlags |= ni.Flags.IsOnLoadCalled, e.node = this.node, e.node.getWorldMatrix(), e.lineWidth = 0;
                        var t = yn.WHITE.clone();
                        t.a = 0, e.fillColor = t
                    }
                    this._updateMaterial()
                }, n._updateGraphics = function() {
                    if (this._graphics && (this._type === lY.RECT || this._type === lY.ELLIPSE)) {
                        var e = this.node._uiProps.uiTransformComp,
                            t = this._graphics;
                        t.clear();
                        var n = e.contentSize,
                            i = n.width,
                            r = n.height,
                            o = e.anchorPoint,
                            a = -i * o.x,
                            s = -r * o.y;
                        if (this._type === lY.RECT) t.rect(a, s, i, r);
                        else if (this._type === lY.ELLIPSE) {
                            for (var c = function(e, t, n) {
                                    gY.length = 0;
                                    for (var i = 2 * Math.PI / n, r = 0; r < n; ++r) gY.push(new En(t.x * Math.cos(i * r) + e.x, t.y * Math.sin(i * r) + e.y, 0));
                                    return gY
                                }(new En(a + i / 2, s + r / 2, 0), new En(i / 2, r / 2, 0), this._segments), l = 0; l < c.length; ++l) {
                                var u = c[l];
                                0 === l ? t.moveTo(u.x, u.y) : t.lineTo(u.x, u.y)
                            }
                            t.close()
                        }
                        t.fill()
                    }
                }, n._createClearModel = function() {
                    if (!this._clearModel) {
                        var e = em.get("default-clear-stencil");
                        this._clearStencilMtl = new OE({
                            parent: e,
                            owner: this,
                            subModelIdx: 0
                        }), this._clearModel = RO.root.createModel(ub), this._clearModel.node = this._clearModel.transform = this.node;
                        var t = FX(DX),
                            n = i.director.root.device,
                            r = n.createBuffer(new gs(xa.VERTEX | xa.TRANSFER_DST, Ra.DEVICE, 4 * t, t)),
                            o = new Float32Array([-1, -1, 0, 1, -1, 0, -1, 1, 0, 1, 1, 0]);
                        r.update(o);
                        var a = n.createBuffer(new gs(xa.INDEX | xa.TRANSFER_DST, Ra.DEVICE, 6 * Uint16Array.BYTES_PER_ELEMENT, Uint16Array.BYTES_PER_ELEMENT)),
                            s = new Uint16Array([0, 1, 2, 2, 1, 3]);
                        a.update(s);
                        var c = new YR([r], DX, Wa.TRIANGLE_LIST, a);
                        c.subMeshIdx = 0, this._clearModel.initSubModel(0, c, this._clearStencilMtl)
                    }
                }, n._updateMaterial = function() {
                    if (this._graphics) {
                        var e, t = this._graphics;
                        t.stencilStage = XW.DISABLED, this._type === lY.IMAGE_STENCIL ? (e = em.get("ui-alpha-test-material"), t.setMaterial(e, 0), (e = t.getMaterialInstance(0)).setProperty("alphaThreshold", this._alphaThreshold)) : (e = em.get("ui-graphics-material"), t.setMaterial(e, 0), t.getMaterialInstance(0))
                    }
                }, n._disableGraphics = function() {
                    this._graphics && this._graphics.onDisable()
                }, n._removeGraphics = function() {
                    this._graphics && (this._graphics.destroy(), this._graphics._destroyImmediate(), this._graphics = null)
                }, n._useRenderData = function() {
                    this._type !== lY.IMAGE_STENCIL || this._renderData || this._assembler && this._assembler.createData && (this._renderData = this._assembler.createData(this), this.markForUpdateRenderData())
                }, K(t, [{
                    key: "type",
                    get: function() {
                        return this._type
                    },
                    set: function(e) {
                        this._type !== e && (this._type = e, this.markForUpdateRenderData(!1), this._updateMaterial(), this._type !== lY.IMAGE_STENCIL ? (this._spriteFrame = null, this._updateGraphics(), this._renderData && (this.destroyRenderData(), this._renderData = null)) : (this._useRenderData(), this._graphics && this._graphics.clear()))
                    }
                }, {
                    key: "inverted",
                    get: function() {
                        return this._inverted
                    },
                    set: function(e) {
                        i.game.renderType !== VC.RENDER_TYPE_CANVAS ? (this._inverted = e, this.stencilStage = XW.DISABLED, this._graphics && (this._graphics.stencilStage = XW.DISABLED)) : x(4202)
                    }
                }, {
                    key: "segments",
                    get: function() {
                        return this._segments
                    },
                    set: function(e) {
                        this._segments !== e && (this._segments = en(e, 3, 1e4), this._updateGraphics())
                    }
                }, {
                    key: "spriteFrame",
                    get: function() {
                        return this._spriteFrame
                    },
                    set: function(e) {
                        if (this._spriteFrame !== e) {
                            var t = this._spriteFrame;
                            this._spriteFrame = e, this._type === lY.IMAGE_STENCIL && !t && e && this.markForUpdateRenderData()
                        }
                    }
                }, {
                    key: "alphaThreshold",
                    get: function() {
                        return this._alphaThreshold
                    },
                    set: function(e) {
                        this._alphaThreshold !== e && (this._alphaThreshold = e, this.type === lY.IMAGE_STENCIL && this._graphics && this._graphics.getMaterialInstance(0).setProperty("alphaThreshold", this._alphaThreshold))
                    }
                }, {
                    key: "graphics",
                    get: function() {
                        return this._graphics
                    }
                }, {
                    key: "dstBlendFactor",
                    get: function() {
                        return this._dstBlendFactor
                    },
                    set: function(e) {
                        this._dstBlendFactor !== e && (this._dstBlendFactor = e, this._updateBlendFunc())
                    }
                }, {
                    key: "srcBlendFactor",
                    get: function() {
                        return this._srcBlendFactor
                    },
                    set: function(e) {
                        this._srcBlendFactor !== e && (this._srcBlendFactor = e, this._updateBlendFunc())
                    }
                }, {
                    key: "color",
                    get: function() {
                        return this._color
                    },
                    set: function(e) {
                        this._color !== e && (this._color.set(e), this.markForUpdateRenderData())
                    }
                }, {
                    key: "customMaterial",
                    get: function() {
                        return this._customMaterial
                    },
                    set: function() {}
                }]), t
            }(qq), sY.Type = lY, ie((tY = cY).prototype, "type", [kX, VX, WX], Object.getOwnPropertyDescriptor(tY.prototype, "type"), tY.prototype), ie(tY.prototype, "inverted", [jX, qX], Object.getOwnPropertyDescriptor(tY.prototype, "inverted"), tY.prototype), ie(tY.prototype, "segments", [XX], Object.getOwnPropertyDescriptor(tY.prototype, "segments"), tY.prototype), ie(tY.prototype, "spriteFrame", [YX, KX], Object.getOwnPropertyDescriptor(tY.prototype, "spriteFrame"), tY.prototype), ie(tY.prototype, "alphaThreshold", [ZX, QX, j_], Object.getOwnPropertyDescriptor(tY.prototype, "alphaThreshold"), tY.prototype), ie(tY.prototype, "color", [tf, JX], Object.getOwnPropertyDescriptor(tY.prototype, "color"), tY.prototype), ie(tY.prototype, "customMaterial", [tf, $X], Object.getOwnPropertyDescriptor(tY.prototype, "customMaterial"), tY.prototype), nY = ie(tY.prototype, "_type", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return lY.RECT
                }
            }), iY = ie(tY.prototype, "_inverted", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return !1
                }
            }), rY = ie(tY.prototype, "_segments", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return 64
                }
            }), oY = ie(tY.prototype, "_spriteFrame", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return null
                }
            }), aY = ie(tY.prototype, "_alphaThreshold", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return .1
                }
            }), eY = tY)) || eY) || eY) || eY) || eY));
            hw._comp = vY, i.Mask = vY;
            var yY, SY, EY, TY, AY, xY, CY, bY, RY, wY, IY, PY, OY, DY, NY, MY, LY, BY, FY, zY, UY, GY, HY, kY, VY, WY, jY, qY, XY, YY, KY, ZY, QY, JY, $Y, eK, tK, nK, iK, rK, oK, aK, sK, cK, lK, uK, hK, _K, fK, dK, pK, mK, gK, vK, yK, SK = /^(click)(\s)*=|(param)(\s)*=/,
                EK = /(\s)*src(\s)*=|(\s)*height(\s)*=|(\s)*width(\s)*=|(\s)*align(\s)*=|(\s)*offset(\s)*=|(\s)*click(\s)*=|(\s)*param(\s)*=/,
                TK = e("HtmlTextParser", function() {
                    function e() {
                        this._specialSymbolArray = [], this._stack = [], this._resultObjectArray = [], this._specialSymbolArray.push([/&lt;/g, "<"]), this._specialSymbolArray.push([/&gt;/g, ">"]), this._specialSymbolArray.push([/&amp;/g, "&"]), this._specialSymbolArray.push([/&quot;/g, '"']), this._specialSymbolArray.push([/&apos;/g, "'"])
                    }
                    var t = e.prototype;
                    return t.parse = function(e) {
                        this._resultObjectArray.length = 0, this._stack.length = 0;
                        for (var t = 0, n = e.length; t < n;) {
                            var i = e.indexOf(">", t),
                                r = -1;
                            if (i >= 0 && (r = e.lastIndexOf("<", i)) < t - 1 && (r = e.indexOf("<", i + 1), i = e.indexOf(">", r + 1)), r < 0) this._stack.pop(), this._processResult(e.substring(t)), t = n;
                            else {
                                var o = e.substring(t, r),
                                    a = e.substring(r + 1, i);
                                "" === a && (o = e.substring(t, i + 1)), this._processResult(o), -1 === i ? i = r : "/" === e.charAt(r + 1) ? this._stack.pop() : this._addToStack(a), t = i + 1
                            }
                        }
                        return this._resultObjectArray
                    }, t._attributeToObject = function(e) {
                        e = e.trim();
                        var t = {},
                            n = /^(color|size)(\s)*=/.exec(e),
                            i = "",
                            r = 0,
                            o = "";
                        if (n) {
                            if (i = n[0], "" === (e = e.substring(i.length).trim())) return t;
                            switch (r = e.indexOf(" "), i[0]) {
                                case "c":
                                    t.color = r > -1 ? e.substring(0, r).trim() : e;
                                    break;
                                case "s":
                                    t.size = parseInt(e)
                            }
                            return r > -1 && (o = e.substring(r + 1).trim(), t.event = this._processEventHandler(o)), t
                        }
                        if ((n = /^(br(\s)*\/)/.exec(e)) && n[0].length > 0 && (i = n[0].trim()).startsWith("br") && "/" === i[i.length - 1]) return t.isNewLine = !0, this._resultObjectArray.push({
                            text: "",
                            style: {
                                isNewLine: !0
                            }
                        }), t;
                        var a = "";
                        if ((n = /^(img(\s)*src(\s)*=[^>]+\/)/.exec(e)) && n[0].length > 0 && (i = n[0].trim()).startsWith("img") && "/" === i[i.length - 1]) {
                            var s;
                            n = EK.exec(e);
                            for (var c = !1; n;) {
                                if (i = (e = e.substring(e.indexOf(n[0]))).substr(0, n[0].length), s = (r = (a = e.substring(i.length).trim()).indexOf(" ")) > -1 ? a.substr(0, r) : a, i = (i = i.replace(/[^a-zA-Z]/g, "").trim()).toLowerCase(), e = a.substring(r).trim(), s.endsWith("/") && (s = s.slice(0, -1)), "src" === i) {
                                    switch (s.charCodeAt(0)) {
                                        case 34:
                                        case 39:
                                            c = !0, s = s.slice(1, -1)
                                    }
                                    t.isImage = !0, t.src = s
                                } else if ("height" === i) t.imageHeight = parseInt(s);
                                else if ("width" === i) t.imageWidth = parseInt(s);
                                else if ("align" === i) {
                                    switch (s.charCodeAt(0)) {
                                        case 34:
                                        case 39:
                                            s = s.slice(1, -1)
                                    }
                                    t.imageAlign = s.toLowerCase()
                                } else "offset" === i ? t.imageOffset = s : "click" === i && (t.event = this._processEventHandler(i + "=" + s));
                                t.event && "param" === i && (t.event[i] = s.replace(/^"|"$/g, "")), n = EK.exec(e)
                            }
                            return c && t.isImage && this._resultObjectArray.push({
                                text: "",
                                style: t
                            }), {}
                        }
                        if (n = /^(outline(\s)*[^>]*)/.exec(e)) {
                            var l = {
                                color: "#ffffff",
                                width: 1
                            };
                            if (e = n[0].substring("outline".length).trim()) {
                                var u, h = /(\s)*color(\s)*=|(\s)*width(\s)*=|(\s)*click(\s)*=|(\s)*param(\s)*=/;
                                for (n = h.exec(e); n;) i = (e = e.substring(e.indexOf(n[0]))).substr(0, n[0].length), u = (r = (a = e.substring(i.length).trim()).indexOf(" ")) > -1 ? a.substr(0, r) : a, i = (i = i.replace(/[^a-zA-Z]/g, "").trim()).toLowerCase(), e = a.substring(r).trim(), "click" === i ? t.event = this._processEventHandler(i + "=" + u) : "color" === i ? l.color = u : "width" === i && (l.width = parseInt(u)), t.event && "param" === i && (t.event[i] = u.replace(/^"|"$/g, "")), n = h.exec(e)
                            }
                            t.outline = l
                        }
                        if ((n = /^(on|u|b|i)(\s)*/.exec(e)) && n[0].length > 0) {
                            switch (i = n[0], e = e.substring(i.length).trim(), i[0]) {
                                case "u":
                                    t.underline = !0;
                                    break;
                                case "i":
                                    t.italic = !0;
                                    break;
                                case "b":
                                    t.bold = !0
                            }
                            if ("" === e) return t;
                            t.event = this._processEventHandler(e)
                        }
                        return t
                    }, t._processEventHandler = function(e) {
                        for (var t = {}, n = 0, i = !1, r = SK.exec(e); r;) {
                            var o = r[0],
                                a = "";
                            if (i = !1, '"' === (e = e.substring(o.length).trim()).charAt(0))(n = e.indexOf('"', 1)) > -1 && (a = e.substring(1, n).trim(), i = !0), n++;
                            else if ("'" === e.charAt(0))(n = e.indexOf("'", 1)) > -1 && (a = e.substring(1, n).trim(), i = !0), n++;
                            else {
                                var s = /(\S)+/.exec(e);
                                n = (a = s ? s[0] : "").length
                            }
                            i && (t[o = o.substring(0, o.length - 1).trim()] = a), e = e.substring(n).trim(), r = SK.exec(e)
                        }
                        return t
                    }, t._addToStack = function(e) {
                        var t = this._attributeToObject(e);
                        if (0 === this._stack.length) this._stack.push(t);
                        else {
                            if (t.isNewLine || t.isImage) return;
                            var n = this._stack[this._stack.length - 1];
                            for (var i in n) t[i] || (t[i] = n[i]);
                            this._stack.push(t)
                        }
                    }, t._processResult = function(e) {
                        0 !== e.length && (e = this._escapeSpecialSymbol(e), this._stack.length > 0 ? this._resultObjectArray.push({
                            text: e,
                            style: this._stack[this._stack.length - 1]
                        }) : this._resultObjectArray.push({
                            text: e
                        }))
                    }, t._escapeSpecialSymbol = function(e) {
                        for (var t, n = te(this._specialSymbolArray); !(t = n()).done;) {
                            var i = t.value,
                                r = i[0],
                                o = i[1];
                            e = e.replace(r, o)
                        }
                        return e
                    }, e
                }()),
                AK = function(t) {
                    return e({
                        LabelOutline: t,
                        LabelOutlineComponent: t
                    }), t
                }((yY = A_("cc.LabelOutline"), SY = B_(), EY = C_(110), TY = D_(), AY = x_(Zq), xY = G_(), CY = G_(), yY(bY = SY(bY = EY(bY = TY(bY = AY(bY = O_((PY = function(e) {
                    function t() {
                        for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                        return ne(t = e.call.apply(e, [this].concat(i)) || this, "_color", wY, $(t)), ne(t, "_width", IY, $(t)), t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.onEnable = function() {
                        this._updateRenderData()
                    }, n.onDisable = function() {
                        this._updateRenderData()
                    }, n._updateRenderData = function() {
                        var e = this.node.getComponent(Zq);
                        e && e.updateRenderData(!0)
                    }, K(t, [{
                        key: "color",
                        get: function() {
                            return this._color
                        },
                        set: function(e) {
                            this._color !== e && (this._color.set(e), this._updateRenderData())
                        }
                    }, {
                        key: "width",
                        get: function() {
                            return this._width
                        },
                        set: function(e) {
                            this._width !== e && (this._width = e, this._updateRenderData())
                        }
                    }]), t
                }(Jd), wY = ie((RY = PY).prototype, "_color", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return new yn(0, 0, 0, 255)
                    }
                }), IY = ie(RY.prototype, "_width", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 2
                    }
                }), ie(RY.prototype, "color", [xY], Object.getOwnPropertyDescriptor(RY.prototype, "color"), RY.prototype), ie(RY.prototype, "width", [CY], Object.getOwnPropertyDescriptor(RY.prototype, "width"), RY.prototype), bY = RY)) || bY) || bY) || bY) || bY) || bY) || bY));
            ! function(e) {
                e[e.SIMPLE = 0] = "SIMPLE", e[e.SLICED = 1] = "SLICED", e[e.TILED = 2] = "TILED", e[e.FILLED = 3] = "FILLED"
            }(mK || (mK = {})), nt(mK),
                function(e) {
                    e[e.HORIZONTAL = 0] = "HORIZONTAL", e[e.VERTICAL = 1] = "VERTICAL", e[e.RADIAL = 2] = "RADIAL"
                }(gK || (gK = {})), nt(gK),
                function(e) {
                    e[e.CUSTOM = 0] = "CUSTOM", e[e.TRIMMED = 1] = "TRIMMED", e[e.RAW = 2] = "RAW"
                }(vK || (vK = {})), nt(vK),
                function(e) {
                    e.SPRITE_FRAME_CHANGED = "spriteframe-changed"
                }(yK || (yK = {}));
            var xK, CK, bK, RK, wK, IK, PK, OK, DK, NK, MK, LK, BK, FK, zK = function(t) {
                    return e({
                        Sprite: t,
                        SpriteComponent: t
                    }), t
                }((OY = A_("cc.Sprite"), DY = B_(), NY = C_(110), MY = D_(), LY = ef(QV), BY = q_(), FY = G_(), zY = ef(KV), UY = q_(), GY = G_(), HY = ef(mK), kY = q_(), VY = G_(), WY = ef(gK), jY = G_(), qY = G_(), XY = H_(), YY = G_(), KY = H_(), ZY = G_(), QY = q_(), JY = G_(), $Y = ef(vK), eK = q_(), tK = G_(), OY(nK = DY(nK = NY(nK = MY((pK = dK = function(e) {
                    function t() {
                        for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                        return ne(t = e.call.apply(e, [this].concat(i)) || this, "_spriteFrame", rK, $(t)), ne(t, "_type", oK, $(t)), ne(t, "_fillType", aK, $(t)), ne(t, "_sizeMode", sK, $(t)), ne(t, "_fillCenter", cK, $(t)), ne(t, "_fillStart", lK, $(t)), ne(t, "_fillRange", uK, $(t)), ne(t, "_isTrimmedMode", hK, $(t)), ne(t, "_useGrayscale", _K, $(t)), ne(t, "_atlas", fK, $(t)), t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.__preload = function() {
                        this.changeMaterialForDefine(), e.prototype.__preload.call(this), this._spriteFrame && this._spriteFrame.once("load", this._onTextureLoaded, this)
                    }, n.onEnable = function() {
                        e.prototype.onEnable.call(this), this._activateMaterial(), this._markForUpdateUvDirty()
                    }, n.onDestroy = function() {
                        this.destroyRenderData(), this._spriteFrame && !this._spriteFrame.loaded && this._spriteFrame.off("load", this._onTextureLoaded, this), e.prototype.onDestroy.call(this)
                    }, n.changeSpriteFrameFromAtlas = function(e) {
                        if (this._atlas) {
                            var t = this._atlas.getSpriteFrame(e);
                            this.spriteFrame = t
                        } else console.warn("SpriteAtlas is null.")
                    }, n.changeMaterialForDefine = function() {
                        var e, t = this._instanceMaterialType;
                        this._spriteFrame && (e = this._spriteFrame.texture);
                        var n = !1;
                        if (e instanceof ud) {
                            var i = e.getPixelFormat();
                            n = i === Mf.RGBA_ETC1 || i === Mf.RGB_A_PVRTC_4BPPV1 || i === Mf.RGB_A_PVRTC_2BPPV1
                        }
                        n && this.grayscale ? this._instanceMaterialType = Mj.USE_ALPHA_SEPARATED_AND_GRAY : n ? this._instanceMaterialType = Mj.USE_ALPHA_SEPARATED : this.grayscale ? this._instanceMaterialType = Mj.GRAYSCALE : this._instanceMaterialType = Mj.ADD_COLOR_AND_TEXTURE, t !== this._instanceMaterialType && this.updateMaterial()
                    }, n._updateBuiltinMaterial = function() {
                        var t = e.prototype._updateBuiltinMaterial.call(this);
                        if (this.spriteFrame && this.spriteFrame.texture instanceof tE) {
                            var n = Z({
                                    SAMPLE_FROM_RT: !0
                                }, t.passes[0].defines),
                                i = new nE;
                            i.initialize({
                                effectAsset: t.effectAsset,
                                defines: n
                            }), t = i
                        }
                        return t
                    }, n._render = function(e) {
                        e.commitComp(this, this._spriteFrame, this._assembler, null)
                    }, n._canRender = function() {
                        if (!e.prototype._canRender.call(this)) return !1;
                        var t = this._spriteFrame;
                        return !(!t || !t.textureLoaded())
                    }, n._flushAssembler = function() {
                        var e = t.Assembler.getAssembler(this);
                        this._assembler !== e && (this.destroyRenderData(), this._assembler = e), this._renderData || this._assembler && this._assembler.createData && (this._renderData = this._assembler.createData(this), this._renderData.material = this.getRenderMaterial(0), this.markForUpdateRenderData(), this._colorDirty = !0, this._updateColor())
                    }, n._applySpriteSize = function() {
                        if (this._spriteFrame) {
                            if (!this._spriteFrame.isDefault)
                                if (vK.RAW === this._sizeMode) {
                                    var e = this._spriteFrame.originalSize;
                                    this.node._uiProps.uiTransformComp.setContentSize(e)
                                } else if (vK.TRIMMED === this._sizeMode) {
                                var t = this._spriteFrame.getRect();
                                this.node._uiProps.uiTransformComp.setContentSize(t.width, t.height)
                            }
                            this._activateMaterial()
                        }
                    }, n._resized = function() {}, n._activateMaterial = function() {
                        var e = this._spriteFrame,
                            t = this.getRenderMaterial(0);
                        i.game.renderType !== i.game.RENDER_TYPE_CANVAS ? (e && t && this.markForUpdateRenderData(), this._renderData && (this._renderData.material = t)) : this.markForUpdateRenderData()
                    }, n._onTextureLoaded = function() {
                        this.isValid && (this.changeMaterialForDefine(), this._applySpriteSize())
                    }, n._applySpriteFrame = function(e) {
                        var t = this._spriteFrame;
                        this._renderData && (e && !e.loaded && e.off("load", this._onTextureLoaded, this), this._renderData.uvDirty || (this._renderData.uvDirty = !e || !t || e.uvHash !== t.uvHash), this._renderDataFlag = this._renderData.uvDirty), t && (e && t === e || (t.loaded ? this._onTextureLoaded() : t.once("load", this._onTextureLoaded, this)))
                    }, n._markForUpdateUvDirty = function() {
                        this._renderData && (this._renderData.uvDirty = !0, this._renderDataFlag = !0)
                    }, K(t, [{
                        key: "spriteAtlas",
                        get: function() {
                            return this._atlas
                        },
                        set: function(e) {
                            this._atlas !== e && (this._atlas = e)
                        }
                    }, {
                        key: "spriteFrame",
                        get: function() {
                            return this._spriteFrame
                        },
                        set: function(e) {
                            if (this._spriteFrame !== e) {
                                var t = this._spriteFrame;
                                this._spriteFrame = e, this.markForUpdateRenderData(!1), this._applySpriteFrame(t)
                            }
                        }
                    }, {
                        key: "type",
                        get: function() {
                            return this._type
                        },
                        set: function(e) {
                            this._type !== e && (this._type = e, this._flushAssembler())
                        }
                    }, {
                        key: "fillType",
                        get: function() {
                            return this._fillType
                        },
                        set: function(e) {
                            this._fillType !== e && (e === gK.RADIAL || this._fillType === gK.RADIAL ? (this.destroyRenderData(), this._renderData = null) : this._renderData && this.markForUpdateRenderData(!0)), this._fillType = e, this._flushAssembler()
                        }
                    }, {
                        key: "fillCenter",
                        get: function() {
                            return this._fillCenter
                        },
                        set: function(e) {
                            this._fillCenter.x = e.x, this._fillCenter.y = e.y, this._type === mK.FILLED && this._renderData && this.markForUpdateRenderData()
                        }
                    }, {
                        key: "fillStart",
                        get: function() {
                            return this._fillStart
                        },
                        set: function(e) {
                            this._fillStart = en(e, -1, 1), this._type === mK.FILLED && this._renderData && (this.markForUpdateRenderData(), this._renderData.uvDirty = !0)
                        }
                    }, {
                        key: "fillRange",
                        get: function() {
                            return this._fillRange
                        },
                        set: function(e) {
                            this._fillRange = en(e, -1, 1), this._type === mK.FILLED && this._renderData && (this.markForUpdateRenderData(), this._renderData.uvDirty = !0)
                        }
                    }, {
                        key: "trim",
                        get: function() {
                            return this._isTrimmedMode
                        },
                        set: function(e) {
                            this._isTrimmedMode !== e && (this._isTrimmedMode = e, this._type === mK.SIMPLE && this._renderData && this.markForUpdateRenderData(!0))
                        }
                    }, {
                        key: "grayscale",
                        get: function() {
                            return this._useGrayscale
                        },
                        set: function(e) {
                            this._useGrayscale !== e && (this._useGrayscale = e, this._instanceMaterialType = !0 === e ? Mj.GRAYSCALE : Mj.ADD_COLOR_AND_TEXTURE, this.updateMaterial())
                        }
                    }, {
                        key: "sizeMode",
                        get: function() {
                            return this._sizeMode
                        },
                        set: function(e) {
                            this._sizeMode !== e && (this._sizeMode = e, e !== vK.CUSTOM && this._applySpriteSize())
                        }
                    }]), t
                }(qq), dK.FillType = gK, dK.Type = mK, dK.SizeMode = vK, dK.EventType = yK, ie((iK = pK).prototype, "spriteAtlas", [LY, BY, FY], Object.getOwnPropertyDescriptor(iK.prototype, "spriteAtlas"), iK.prototype), ie(iK.prototype, "spriteFrame", [zY, UY, GY], Object.getOwnPropertyDescriptor(iK.prototype, "spriteFrame"), iK.prototype), ie(iK.prototype, "type", [HY, kY, VY], Object.getOwnPropertyDescriptor(iK.prototype, "type"), iK.prototype), ie(iK.prototype, "fillType", [WY, jY], Object.getOwnPropertyDescriptor(iK.prototype, "fillType"), iK.prototype), ie(iK.prototype, "fillCenter", [qY], Object.getOwnPropertyDescriptor(iK.prototype, "fillCenter"), iK.prototype), ie(iK.prototype, "fillStart", [XY, YY], Object.getOwnPropertyDescriptor(iK.prototype, "fillStart"), iK.prototype), ie(iK.prototype, "fillRange", [KY, ZY], Object.getOwnPropertyDescriptor(iK.prototype, "fillRange"), iK.prototype), ie(iK.prototype, "trim", [QY, JY], Object.getOwnPropertyDescriptor(iK.prototype, "trim"), iK.prototype), ie(iK.prototype, "grayscale", [F_], Object.getOwnPropertyDescriptor(iK.prototype, "grayscale"), iK.prototype), ie(iK.prototype, "sizeMode", [$Y, eK, tK], Object.getOwnPropertyDescriptor(iK.prototype, "sizeMode"), iK.prototype), rK = ie(iK.prototype, "_spriteFrame", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return null
                    }
                }), oK = ie(iK.prototype, "_type", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return mK.SIMPLE
                    }
                }), aK = ie(iK.prototype, "_fillType", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return gK.HORIZONTAL
                    }
                }), sK = ie(iK.prototype, "_sizeMode", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return vK.TRIMMED
                    }
                }), cK = ie(iK.prototype, "_fillCenter", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return new Gn(0, 0)
                    }
                }), lK = ie(iK.prototype, "_fillStart", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 0
                    }
                }), uK = ie(iK.prototype, "_fillRange", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 0
                    }
                }), hK = ie(iK.prototype, "_isTrimmedMode", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return !0
                    }
                }), _K = ie(iK.prototype, "_useGrayscale", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return !1
                    }
                }), fK = ie(iK.prototype, "_atlas", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return null
                    }
                }), nK = iK)) || nK) || nK) || nK) || nK)),
                UK = e("RenderRoot2D", A_("cc.RenderRoot2D")(xK = C_(100)(xK = D_()(xK = x_(pj)(xK = b_(xK = O_(xK = function(e) {
                    function t() {
                        return e.apply(this, arguments) || this
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.onEnable = function() {
                        i.director.root.batcher2D.addScreen(this)
                    }, n.onDisable = function() {
                        i.director.root.batcher2D.removeScreen(this)
                    }, n.onDestroy = function() {
                        i.director.root.batcher2D.removeScreen(this)
                    }, t
                }(Jd)) || xK) || xK) || xK) || xK) || xK) || xK),
                GK = new En,
                HK = $e({
                    OVERLAY: 0,
                    INTERSPERSE: 1
                }),
                kK = function(t) {
                    return e({
                        Canvas: t,
                        CanvasComponent: t
                    }), t
                }((CK = A_("cc.Canvas"), bK = B_(), RK = C_(100), wK = D_(), IK = ef(IM), PK = G_(), OK = G_(), DK = ef(IM), CK(NK = bK(NK = RK(NK = wK(NK = O_(NK = b_((ie((MK = function(e) {
                    function t() {
                        var t;
                        return ne(t = e.call(this) || this, "_cameraComponent", LK, $(t)), ne(t, "_alignCanvasWithScreen", BK, $(t)), t._thisOnCameraResized = void 0, t._fitDesignResolution = void 0, t._pos = new En, t._renderMode = HK.OVERLAY, t._thisOnCameraResized = t._onResizeCamera.bind($(t)), t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.__preload = function() {
                        var e = this.getComponent("cc.Widget");
                        e && e.updateAlignment(), this._cameraComponent && this._cameraComponent._createCamera(), this._onResizeCamera(), this.node.on(Om.TRANSFORM_CHANGED, this._thisOnCameraResized)
                    }, n.onDestroy = function() {
                        e.prototype.onDestroy.call(this), this.node.off(Om.TRANSFORM_CHANGED, this._thisOnCameraResized)
                    }, n._onResizeCamera = function() {
                        if (this._cameraComponent && this._alignCanvasWithScreen) {
                            if (this._cameraComponent.targetTexture) {
                                var e = this._cameraComponent.targetTexture.window;
                                this._cameraComponent.camera && this._cameraComponent.camera.setFixedSize(e.width, e.height), this._cameraComponent.orthoHeight = jC.height / 2
                            } else if (WC.canvas) {
                                var t = WC.canvas;
                                this._cameraComponent.camera && this._cameraComponent.camera.resize(t.width, t.height), this._cameraComponent.orthoHeight = WC.canvas.height / QC.getScaleY() / 2
                            }
                            this.node.getWorldPosition(GK), this._cameraComponent.node.setWorldPosition(GK.x, GK.y, 1e3)
                        }
                    }, n._getViewPriority = function() {
                        if (this._cameraComponent) {
                            var e, t = null === (e = this.cameraComponent) || void 0 === e ? void 0 : e.priority;
                            return this._renderMode === HK.OVERLAY ? t | 1 << 30 : t & ~(1 << 30)
                        }
                        return 0
                    }, K(t, [{
                        key: "renderMode",
                        get: function() {
                            return this._renderMode
                        },
                        set: function(e) {
                            this._renderMode = e, this._cameraComponent && (this._cameraComponent.priority = this._getViewPriority())
                        }
                    }, {
                        key: "cameraComponent",
                        get: function() {
                            return this._cameraComponent
                        },
                        set: function(e) {
                            this._cameraComponent !== e && (this._cameraComponent = e, this._onResizeCamera())
                        }
                    }, {
                        key: "alignCanvasWithScreen",
                        get: function() {
                            return this._alignCanvasWithScreen
                        },
                        set: function(e) {
                            this._alignCanvasWithScreen = e, this._onResizeCamera()
                        }
                    }]), t
                }(UK)).prototype, "cameraComponent", [IK, PK], Object.getOwnPropertyDescriptor(MK.prototype, "cameraComponent"), MK.prototype), ie(MK.prototype, "alignCanvasWithScreen", [OK], Object.getOwnPropertyDescriptor(MK.prototype, "alignCanvasWithScreen"), MK.prototype), LK = ie(MK.prototype, "_cameraComponent", [DK], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return null
                    }
                }), BK = ie(MK.prototype, "_alignCanvasWithScreen", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return !0
                    }
                }), NK = MK)) || NK) || NK) || NK) || NK) || NK) || NK));
            i.Canvas = kK;
            var VK, WK, jK, qK, XK, YK, KK, ZK, QK, JK, $K, eZ, tZ, nZ, iZ, rZ, oZ, aZ, sZ, cZ, lZ, uZ, hZ, _Z, fZ, dZ, pZ, mZ, gZ, vZ, yZ, SZ, EZ, TZ, AZ, xZ = e("UIComponent", A_("cc.UIComponent")(FK = x_(pj)(FK = C_(110)(FK = b_(FK = O_(FK = function(e) {
                function t() {
                    for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                    return (t = e.call.apply(e, [this].concat(i)) || this)._lastParent = null, t.stencilStage = XW.DISABLED, t
                }
                Q(t, e);
                var n = t.prototype;
                return n.__preload = function() {
                    this.node._uiProps.uiComp = this
                }, n.onEnable = function() {}, n.onDisable = function() {}, n.onDestroy = function() {
                    this.node._uiProps.uiComp === this && (this.node._uiProps.uiComp = null)
                }, n.updateAssembler = function() {}, n.postUpdateAssembler = function() {}, t
            }(Jd)) || FK) || FK) || FK) || FK) || FK);
            G(xZ.prototype, "UIComponent", [{
                name: "_visibility"
            }, {
                name: "setVisibility"
            }]), U(kK.prototype, "Canvas.prototype", [{
                name: "camera",
                newName: "cameraComponent.camera",
                customGetter: function() {
                    return this._cameraComponent.camera
                }
            }, {
                name: "clearFlag",
                newName: "cameraComponent.clearFlags",
                customGetter: function() {
                    return this._cameraComponent ? this._cameraComponent.clearFlags : 0
                },
                customSetter: function(e) {
                    this._cameraComponent && (this._cameraComponent.clearFlags = e)
                }
            }, {
                name: "color",
                newName: "cameraComponent.clearColor",
                customGetter: function() {
                    return this._cameraComponent ? this._cameraComponent.clearColor : yn.BLACK
                },
                customSetter: function(e) {
                    this._cameraComponent && (this._cameraComponent.clearColor = e)
                }
            }, {
                name: "priority",
                newName: "cameraComponent.priority",
                customGetter: function() {
                    return this._cameraComponent ? this._cameraComponent.priority : 0
                },
                customSetter: function(e) {
                    this._cameraComponent && (this._cameraComponent.priority = e)
                }
            }, {
                name: "targetTexture",
                newName: "cameraComponent.targetTexture",
                customGetter: function() {
                    return this._cameraComponent ? this._cameraComponent.targetTexture : null
                },
                customSetter: function(e) {
                    this._cameraComponent && (this._cameraComponent.targetTexture = e)
                }
            }, {
                name: "visibility",
                newName: "cameraComponent.visibility",
                customGetter: function() {
                    return this._cameraComponent ? this._cameraComponent.visibility : 0
                }
            }]), H(qq.prototype, "Renderable2D.prototype", [{
                name: "srcBlendFactor",
                suggest: "Please use a custom material to specify blending options instead."
            }, {
                name: "dstBlendFactor",
                suggest: "Please use a custom material to specify blending options instead."
            }]), H(pj.prototype, "UITransform.prototype", [{
                name: "priority",
                suggest: "Please use setSiblingIndex to change index of the current node in its parent's children array."
            }]), i.UITransformComponent = pj, Qe.setClassAlias(pj, "cc.UITransformComponent"), Qe.setClassAlias(qq, "cc.RenderComponent"), i.CanvasComponent = kK, Qe.setClassAlias(kK, "cc.CanvasComponent");
            var CZ = new TK,
                bZ = "RICHTEXT_CHILD",
                RZ = "RICHTEXT_Image_CHILD",
                wZ = new Ke((function(e) {
                    if (!i.isValid(e.node)) return !1;
                    var t = e.node.getComponent(AK);
                    return t && (t.width = 0), !0
                }), 20),
                IZ = new Ke((function(e) {
                    return i.isValid(e.node)
                }), 10);

            function PZ(e) {
                return {
                    node: new Yv(e),
                    comp: null,
                    lineCount: 0,
                    styleIndex: 0,
                    imageOffset: "",
                    clickParam: "",
                    clickHandler: "",
                    type: e
                }
            }

            function OZ(e, t) {
                var n;
                e === bZ ? n = wZ._get() : e === RZ && (n = IZ._get());
                var i = (n = n || PZ(e)).node;
                return i || (i = new Yv(e)), i.hideFlags |= ni.Flags.DontSave | ni.Flags.HideInHierarchy, e === RZ ? (n.comp = i.getComponent(zK) || i.addComponent(zK), n.comp.spriteFrame = t, n.comp.type = zK.Type.SLICED, n.comp.sizeMode = zK.SizeMode.CUSTOM) : (n.comp = i.getComponent(Zq) || i.addComponent(Zq), n.comp.string = t, n.comp.horizontalAlign = kq.LEFT, n.comp.verticalAlign = Vq.TOP), i.setPosition(0, 0, 0), i._uiProps.uiTransformComp.setAnchorPoint(.5, .5), n.node = i, n.lineCount = 0, n.styleIndex = 0, n.imageOffset = "", n.clickParam = "", n.clickHandler = "", n
            }
            var DZ, NZ = function(t) {
                    return e({
                        RichText: t,
                        RichTextComponent: t
                    }), t
                }((VK = A_("cc.RichText"), WK = B_(), jK = C_(110), qK = D_(), XK = G_(), YK = ef(kq), KK = G_(), ZK = G_(), QK = G_(), JK = ef(nW), $K = G_(), eZ = G_(), tZ = ef(jq), nZ = G_(), iZ = G_(), rZ = G_(), oZ = ef(QV), aZ = G_(), sZ = G_(), VK(cZ = WK(cZ = jK(cZ = qK(cZ = O_((AZ = TZ = function(e) {
                    function t() {
                        var t;
                        return ne(t = e.call(this) || this, "_lineHeight", uZ, $(t)), ne(t, "_string", hZ, $(t)), ne(t, "_horizontalAlign", _Z, $(t)), ne(t, "_fontSize", fZ, $(t)), ne(t, "_maxWidth", dZ, $(t)), ne(t, "_fontFamily", pZ, $(t)), ne(t, "_font", mZ, $(t)), ne(t, "_isSystemFontUsed", gZ, $(t)), ne(t, "_userDefinedFont", vZ, $(t)), ne(t, "_cacheMode", yZ, $(t)), ne(t, "_imageAtlas", SZ, $(t)), ne(t, "_handleTouchEvent", EZ, $(t)), t._textArray = [], t._segments = [], t._labelSegmentsCache = [], t._linesWidth = [], t._lineCount = 1, t._labelWidth = 0, t._labelHeight = 0, t._layoutDirty = !0, t._lineOffsetX = 0, t._updateRichTextStatus = void 0, t._updateRichTextStatus = t._updateRichText, t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.onLoad = function() {
                        this.node.on(Om.LAYER_CHANGED, this._applyLayer, this)
                    }, n.onEnable = function() {
                        this.handleTouchEvent && this._addEventListeners(), this._updateRichText(), this._activateChildren(!0)
                    }, n.onDisable = function() {
                        this.handleTouchEvent && this._removeEventListeners(), this._activateChildren(!1)
                    }, n.start = function() {
                        this._onTTFLoaded(), this.node.on(Yv.EventType.ANCHOR_CHANGED, this._updateRichTextPosition, this)
                    }, n.onRestore = function() {}, n.onDestroy = function() {
                        for (var e, t = te(this._segments); !(e = t()).done;) {
                            var n = e.value;
                            n.node.removeFromParent(), n.type === bZ ? wZ.put(n) : n.type === RZ && IZ.put(n)
                        }
                        this.node.off(Yv.EventType.ANCHOR_CHANGED, this._updateRichTextPosition, this), this.node.off(Om.LAYER_CHANGED, this._applyLayer, this)
                    }, n._addEventListeners = function() {
                        this.node.on(Yv.EventType.TOUCH_END, this._onTouchEnded, this)
                    }, n._removeEventListeners = function() {
                        this.node.off(Yv.EventType.TOUCH_END, this._onTouchEnded, this)
                    }, n._updateLabelSegmentTextAttributes = function() {
                        var e = this;
                        this._segments.forEach((function(t) {
                            e._applyTextAttribute(t)
                        }))
                    }, n._createFontLabel = function(e) {
                        return OZ(bZ, e)
                    }, n._createImage = function(e) {
                        return OZ(RZ, e)
                    }, n._onTTFLoaded = function() {
                        var e = this;
                        this._font instanceof _W ? this._font._nativeAsset ? (this._layoutDirty = !0, this._updateRichText()) : RD.postLoadNative(this._font, (function() {
                            e.isValid && (e._layoutDirty = !0, e._updateRichText())
                        })) : (this._layoutDirty = !0, this._updateRichText())
                    }, n._measureText = function(e, t) {
                        var n = this,
                            i = function(t) {
                                var i;
                                return 0 === n._labelSegmentsCache.length ? (i = n._createFontLabel(t), n._labelSegmentsCache.push(i)) : (i = n._labelSegmentsCache[0]).node.getComponent(Zq).string = t, i.styleIndex = e, n._applyTextAttribute(i), i.node._uiProps.uiTransformComp.contentSize.width
                            };
                        return t ? i(t) : i
                    }, n._onTouchEnded = function(e) {
                        for (var t, n = this, i = this.node.getComponents(Jd), r = function() {
                                var r = t.value,
                                    o = r.clickHandler,
                                    a = r.clickParam;
                                o && n._containsTouchLocation(r, e.touch.getUILocation()) && (i.forEach((function(t) {
                                    var n = t[o];
                                    t.enabledInHierarchy && n && n.call(t, e, a)
                                })), e.propagationStopped = !0)
                            }, o = te(this._segments); !(t = o()).done;) r()
                    }, n._containsTouchLocation = function(e, t) {
                        var n = e.node.getComponent(pj);
                        return !!n && n.getBoundingBoxToWorld().contains(t)
                    }, n._resetState = function() {
                        for (var e = this.node.children, t = e.length - 1; t >= 0; t--) {
                            var n = e[t];
                            if (n.name === bZ || n.name === RZ) {
                                n.parent === this.node ? n.parent = null : e.splice(t, 1);
                                var i = PZ(n.name);
                                i.node = n, n.name === bZ ? (i.comp = n.getComponent(Zq), wZ.put(i)) : (i.comp = n.getComponent(zK), IZ.put(i))
                            }
                        }
                        e.length = 0, this._segments.length = 0, this._labelSegmentsCache.length = 0, this._linesWidth.length = 0, this._lineOffsetX = 0, this._lineCount = 1, this._labelWidth = 0, this._labelHeight = 0, this._layoutDirty = !0
                    }, n._activateChildren = function(e) {
                        for (var t = this.node.children.length - 1; t >= 0; t--) {
                            var n = this.node.children[t];
                            n.name !== bZ && n.name !== RZ || (n.active = e)
                        }
                    }, n._addLabelSegment = function(e, t) {
                        var n;
                        if (0 === this._labelSegmentsCache.length) n = this._createFontLabel(e);
                        else {
                            var i = (n = this._labelSegmentsCache.pop()).node.getComponent(Zq);
                            i && (i.string = e)
                        }
                        return n.styleIndex = t, n.lineCount = this._lineCount, n.node._uiProps.uiTransformComp.setAnchorPoint(0, 0), n.node.layer = this.node.layer, this._applyTextAttribute(n), this.node.addChild(n.node), this._segments.push(n), n
                    }, n._updateRichTextWithMaxWidth = function(e, t, n) {
                        var i = t;
                        if (this._lineOffsetX > 0 && i + this._lineOffsetX > this._maxWidth)
                            for (var r = 0; this._lineOffsetX <= this._maxWidth;) {
                                var o = this._getFirstWordLen(e, r, e.length),
                                    a = e.substr(r, o),
                                    s = this._measureText(n, a);
                                if (!(this._lineOffsetX + s <= this._maxWidth)) {
                                    if (r > 0) {
                                        var c = e.substr(0, r);
                                        this._addLabelSegment(c, n), e = e.substr(r, e.length), i = this._measureText(n, e)
                                    }
                                    this._updateLineInfo();
                                    break
                                }
                                this._lineOffsetX += s, r += o
                            }
                        if (i > this._maxWidth)
                            for (var l = DW(e, i, this._maxWidth, this._measureText(n)), u = 0; u < l.length; ++u) {
                                var h = l[u],
                                    _ = this._addLabelSegment(h, n).node._uiProps.uiTransformComp.contentSize;
                                this._lineOffsetX += _.width, l.length > 1 && u < l.length - 1 && this._updateLineInfo()
                            } else this._lineOffsetX += i, this._addLabelSegment(e, n)
                    }, n._isLastComponentCR = function(e) {
                        return e.length - 1 === e.lastIndexOf("\n")
                    }, n._updateLineInfo = function() {
                        this._linesWidth.push(this._lineOffsetX), this._lineOffsetX = 0, this._lineCount++
                    }, n._needsUpdateTextLayout = function(e) {
                        if (this._layoutDirty || !this._textArray || !e) return !0;
                        if (this._textArray.length !== e.length) return !0;
                        for (var t = 0; t < this._textArray.length; t++) {
                            var n = this._textArray[t],
                                i = e[t];
                            if (n.text !== i.text) return !0;
                            var r = n.style,
                                o = i.style;
                            if (r) {
                                if (o) {
                                    if (!!o.outline != !!r.outline) return !0;
                                    if (r.size !== o.size || r.italic !== o.italic || r.isImage !== o.isImage) return !0;
                                    if (r.src !== o.src || r.imageAlign !== o.imageAlign || r.imageHeight !== o.imageHeight || r.imageWidth !== o.imageWidth || r.imageOffset !== o.imageOffset) return !0
                                } else if (r.size || r.italic || r.isImage || r.outline) return !0
                            } else if (o && (o.size || o.italic || o.isImage || o.outline)) return !0
                        }
                        return !1
                    }, n._addRichTextImageElement = function(e) {
                        if (e.style) {
                            var t = e.style,
                                n = t.src,
                                i = this._imageAtlas && n && this._imageAtlas.getSpriteFrame(n);
                            if (i) {
                                var r = this._createImage(i);
                                switch (r.comp, t.imageAlign) {
                                    case "top":
                                        r.node._uiProps.uiTransformComp.setAnchorPoint(0, 1);
                                        break;
                                    case "center":
                                        r.node._uiProps.uiTransformComp.setAnchorPoint(0, .5);
                                        break;
                                    default:
                                        r.node._uiProps.uiTransformComp.setAnchorPoint(0, 0)
                                }
                                r.node.layer = this.node.layer, this.node.addChild(r.node), this._segments.push(r);
                                var o = i.rect.clone(),
                                    a = 1,
                                    s = o.width,
                                    c = o.height,
                                    l = t.imageWidth || 0,
                                    u = t.imageHeight || 0;
                                u > 0 ? (s *= a = u / c, c *= a) : (s *= a = this._lineHeight / c, c *= a), l > 0 && (s = l), this._maxWidth > 0 ? (this._lineOffsetX + s > this._maxWidth && this._updateLineInfo(), this._lineOffsetX += s) : (this._lineOffsetX += s, this._lineOffsetX > this._labelWidth && (this._labelWidth = this._lineOffsetX)), r.node._uiProps.uiTransformComp.setContentSize(s, c), r.lineCount = this._lineCount, r.clickHandler = "", r.clickParam = "";
                                var h = t.event;
                                h && (r.clickHandler = h.click, r.clickParam = h.param)
                            } else x(4400)
                        }
                    }, n._updateRichText = function() {
                        if (this.enabledInHierarchy) {
                            var e = CZ.parse(this._string);
                            if (!this._needsUpdateTextLayout(e)) return this._textArray = e.slice(), void this._updateLabelSegmentTextAttributes();
                            this._textArray = e.slice(), this._resetState();
                            for (var t, n = !1, i = 0; i < this._textArray.length; ++i) {
                                var r = this._textArray[i],
                                    o = r.text;
                                if (void 0 !== o) {
                                    if ("" === o) {
                                        if (r.style && r.style.isNewLine) {
                                            this._updateLineInfo();
                                            continue
                                        }
                                        if (r.style && r.style.isImage && this._imageAtlas) {
                                            this._addRichTextImageElement(r);
                                            continue
                                        }
                                    }
                                    for (var a = o.split("\n"), s = 0; s < a.length; ++s) {
                                        var c = a[s];
                                        if ("" !== c)
                                            if (n = !1, this._maxWidth > 0) {
                                                var l = this._measureText(i, c);
                                                this._updateRichTextWithMaxWidth(c, l, i), a.length > 1 && s < a.length - 1 && this._updateLineInfo()
                                            } else t = this._addLabelSegment(c, i), this._lineOffsetX += t.node._uiProps.uiTransformComp.width, this._lineOffsetX > this._labelWidth && (this._labelWidth = this._lineOffsetX), a.length > 1 && s < a.length - 1 && this._updateLineInfo();
                                        else {
                                            if (this._isLastComponentCR(o) && s === a.length - 1) continue;
                                            this._updateLineInfo(), n = !0
                                        }
                                    }
                                }
                            }
                            n || this._linesWidth.push(this._lineOffsetX), this._maxWidth > 0 && (this._labelWidth = this._maxWidth), this._labelHeight = (this._lineCount + vW) * this._lineHeight, this.node._uiProps.uiTransformComp.setContentSize(this._labelWidth, this._labelHeight), this._updateRichTextPosition(), this._layoutDirty = !1
                        }
                    }, n._getFirstWordLen = function(e, t, n) {
                        var i = e.charAt(t);
                        if (wW(i) || IW(i)) return 1;
                        for (var r = 1, o = t + 1; o < n && !IW(i = e.charAt(o)) && !wW(i); ++o) r++;
                        return r
                    }, n._updateRichTextPosition = function() {
                        for (var e = 0, t = 1, n = this._lineCount, i = this.node._uiProps.uiTransformComp, r = i.anchorX, o = i.anchorY, a = 0; a < this._segments.length; ++a) {
                            var s = this._segments[a],
                                c = s.lineCount;
                            c > t && (e = 0, t = c);
                            var l = this._labelWidth * (.5 * this._horizontalAlign - r);
                            switch (this._horizontalAlign) {
                                case kq.LEFT:
                                    break;
                                case kq.CENTER:
                                    l -= this._linesWidth[c - 1] / 2;
                                    break;
                                case kq.RIGHT:
                                    l -= this._linesWidth[c - 1]
                            }
                            var u = s.node.position;
                            if (s.node.setPosition(e + l, this._lineHeight * (n - c) - this._labelHeight * o, u.z), c === t && (e += s.node._uiProps.uiTransformComp.width), s.node.getComponent(zK)) {
                                var h = s.node.position.clone(),
                                    _ = this._lineHeight,
                                    f = this._lineHeight * (1 + vW);
                                switch (s.node._uiProps.uiTransformComp.anchorY) {
                                    case 1:
                                        h.y += _ + (f - _) / 2;
                                        break;
                                    case .5:
                                        h.y += f / 2;
                                        break;
                                    default:
                                        h.y += (f - _) / 2
                                }
                                if (s.imageOffset) {
                                    var d = s.imageOffset.split(",");
                                    if (1 === d.length && d[0]) {
                                        var p = parseFloat(d[0]);
                                        Number.isInteger(p) && (h.y += p)
                                    } else if (2 === d.length) {
                                        var m = parseFloat(d[0]),
                                            g = parseFloat(d[1]);
                                        Number.isInteger(m) && (h.x += m), Number.isInteger(g) && (h.y += g)
                                    }
                                }
                                s.node.position = h
                            }
                            var v = s.node.getComponent(AK);
                            if (v) {
                                var y = s.node.position.clone();
                                y.y -= v.width, s.node.position = y
                            }
                        }
                    }, n._convertLiteralColorValue = function(e) {
                        var t = e.toUpperCase();
                        return yn[t] ? yn[t] : (new yn).fromHEX(e)
                    }, n._applyTextAttribute = function(e) {
                        var t = e.node.getComponent(Zq);
                        if (t) {
                            var n, i = e.styleIndex;
                            if (this._textArray[i] && (n = this._textArray[i].style), n) {
                                if (t.color = this._convertLiteralColorValue(n.color || "white"), t.isBold = !!n.bold, t.isItalic = !!n.italic, t.isUnderline = !!n.underline, n.outline) {
                                    var r = e.node.getComponent(AK);
                                    r || (r = e.node.addComponent(AK)), r.color = this._convertLiteralColorValue(n.outline.color), r.width = n.outline.width
                                }
                                t.fontSize = n.size || this._fontSize, e.clickHandler = "", e.clickParam = "";
                                var o = n.event;
                                o && (e.clickHandler = o.click || "", e.clickParam = o.param || "")
                            } else t.fontSize = this._fontSize;
                            t.cacheMode = this._cacheMode, this._font instanceof nW && !this._isSystemFontUsed ? t.font = this._font : t.fontFamily = this._fontFamily, t.useSystemFont = this._isSystemFontUsed, t.lineHeight = this._lineHeight, t.updateRenderData(!0);
                            var a = t._assembler;
                            a && a.updateRenderData(t)
                        }
                    }, n._applyLayer = function() {
                        for (var e, t = te(this._segments); !(e = t()).done;) e.value.node.layer = this.node.layer
                    }, K(t, [{
                        key: "string",
                        get: function() {
                            return this._string
                        },
                        set: function(e) {
                            this._string !== e && (this._string = e, this._updateRichTextStatus())
                        }
                    }, {
                        key: "horizontalAlign",
                        get: function() {
                            return this._horizontalAlign
                        },
                        set: function(e) {
                            this.horizontalAlign !== e && (this._horizontalAlign = e, this._layoutDirty = !0, this._updateRichTextStatus())
                        }
                    }, {
                        key: "fontSize",
                        get: function() {
                            return this._fontSize
                        },
                        set: function(e) {
                            this._fontSize !== e && (this._fontSize = e, this._layoutDirty = !0, this._updateRichTextStatus())
                        }
                    }, {
                        key: "fontFamily",
                        get: function() {
                            return this._fontFamily
                        },
                        set: function(e) {
                            this._fontFamily !== e && (this._fontFamily = e, this._layoutDirty = !0, this._updateRichTextStatus())
                        }
                    }, {
                        key: "font",
                        get: function() {
                            return this._font
                        },
                        set: function(e) {
                            this._font !== e && (this._font = e, this._layoutDirty = !0, this._font ? (this.useSystemFont = !1, this._onTTFLoaded()) : this.useSystemFont = !0, this._updateRichTextStatus())
                        }
                    }, {
                        key: "useSystemFont",
                        get: function() {
                            return this._isSystemFontUsed
                        },
                        set: function(e) {
                            this._isSystemFontUsed !== e && (this._isSystemFontUsed = e, this._layoutDirty = !0, this._updateRichTextStatus())
                        }
                    }, {
                        key: "cacheMode",
                        get: function() {
                            return this._cacheMode
                        },
                        set: function(e) {
                            this._cacheMode !== e && (this._cacheMode = e, this._updateRichTextStatus())
                        }
                    }, {
                        key: "maxWidth",
                        get: function() {
                            return this._maxWidth
                        },
                        set: function(e) {
                            this._maxWidth !== e && (this._maxWidth = e, this._layoutDirty = !0, this._updateRichTextStatus())
                        }
                    }, {
                        key: "lineHeight",
                        get: function() {
                            return this._lineHeight
                        },
                        set: function(e) {
                            this._lineHeight !== e && (this._lineHeight = e, this._layoutDirty = !0, this._updateRichTextStatus())
                        }
                    }, {
                        key: "imageAtlas",
                        get: function() {
                            return this._imageAtlas
                        },
                        set: function(e) {
                            this._imageAtlas !== e && (this._imageAtlas = e, this._layoutDirty = !0, this._updateRichTextStatus())
                        }
                    }, {
                        key: "handleTouchEvent",
                        get: function() {
                            return this._handleTouchEvent
                        },
                        set: function(e) {
                            this._handleTouchEvent !== e && (this._handleTouchEvent = e, this.enabledInHierarchy && (this.handleTouchEvent ? this._addEventListeners() : this._removeEventListeners()))
                        }
                    }]), t
                }(xZ), TZ.HorizontalAlign = kq, TZ.VerticalAlign = Vq, ie((lZ = AZ).prototype, "string", [Y_, XK], Object.getOwnPropertyDescriptor(lZ.prototype, "string"), lZ.prototype), ie(lZ.prototype, "horizontalAlign", [YK, KK], Object.getOwnPropertyDescriptor(lZ.prototype, "horizontalAlign"), lZ.prototype), ie(lZ.prototype, "fontSize", [ZK], Object.getOwnPropertyDescriptor(lZ.prototype, "fontSize"), lZ.prototype), ie(lZ.prototype, "fontFamily", [QK], Object.getOwnPropertyDescriptor(lZ.prototype, "fontFamily"), lZ.prototype), ie(lZ.prototype, "font", [JK, $K], Object.getOwnPropertyDescriptor(lZ.prototype, "font"), lZ.prototype), ie(lZ.prototype, "useSystemFont", [eZ], Object.getOwnPropertyDescriptor(lZ.prototype, "useSystemFont"), lZ.prototype), ie(lZ.prototype, "cacheMode", [tZ, nZ], Object.getOwnPropertyDescriptor(lZ.prototype, "cacheMode"), lZ.prototype), ie(lZ.prototype, "maxWidth", [iZ], Object.getOwnPropertyDescriptor(lZ.prototype, "maxWidth"), lZ.prototype), ie(lZ.prototype, "lineHeight", [rZ], Object.getOwnPropertyDescriptor(lZ.prototype, "lineHeight"), lZ.prototype), ie(lZ.prototype, "imageAtlas", [oZ, aZ], Object.getOwnPropertyDescriptor(lZ.prototype, "imageAtlas"), lZ.prototype), ie(lZ.prototype, "handleTouchEvent", [sZ], Object.getOwnPropertyDescriptor(lZ.prototype, "handleTouchEvent"), lZ.prototype), uZ = ie(lZ.prototype, "_lineHeight", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 40
                    }
                }), hZ = ie(lZ.prototype, "_string", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return "<color=#00ff00>Rich</color><color=#0fffff>Text</color>"
                    }
                }), _Z = ie(lZ.prototype, "_horizontalAlign", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return kq.LEFT
                    }
                }), fZ = ie(lZ.prototype, "_fontSize", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 40
                    }
                }), dZ = ie(lZ.prototype, "_maxWidth", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 0
                    }
                }), pZ = ie(lZ.prototype, "_fontFamily", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return "Arial"
                    }
                }), mZ = ie(lZ.prototype, "_font", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return null
                    }
                }), gZ = ie(lZ.prototype, "_isSystemFontUsed", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return !0
                    }
                }), vZ = ie(lZ.prototype, "_userDefinedFont", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return null
                    }
                }), yZ = ie(lZ.prototype, "_cacheMode", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return jq.NONE
                    }
                }), SZ = ie(lZ.prototype, "_imageAtlas", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return null
                    }
                }), EZ = ie(lZ.prototype, "_handleTouchEvent", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return !0
                    }
                }), cZ = lZ)) || cZ) || cZ) || cZ) || cZ) || cZ)),
                MZ = function(t) {
                    return e({
                        UIMeshRenderer: t,
                        UIModelComponent: t
                    }), t
                }(A_("cc.UIMeshRenderer")(DZ = B_()(DZ = C_(110)(DZ = D_()(DZ = function(e) {
                    function t() {
                        for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                        return (t = e.call.apply(e, [this].concat(i)) || this)._models = null, t._modelComponent = null, t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.onLoad = function() {
                        this.node._uiProps.uiTransformComp || this.node.addComponent("cc.UITransform"), this._modelComponent = this.getComponent("cc.RenderableComponent"), this._modelComponent ? this._models = this._modelComponent._collectModels() : console.warn("node '" + (this.node && this.node.name) + "' doesn't have any renderable component")
                    }, n.onEnable = function() {
                        e.prototype.onEnable.call(this)
                    }, n.onDisable = function() {
                        e.prototype.onDisable.call(this)
                    }, n.onDestroy = function() {
                        e.prototype.onDestroy.call(this), this._modelComponent = this.getComponent("cc.RenderableComponent"), this._modelComponent && (this._modelComponent._sceneGetter = null, this._models = null)
                    }, n.updateAssembler = function(e) {
                        if (this._models) {
                            this._modelComponent._detachFromScene();
                            for (var t, n = te(this._models); !(t = n()).done;) {
                                var i = t.value;
                                e.commitModel.call(e, this, i, this._modelComponent.material)
                            }
                            return !0
                        }
                        return !1
                    }, n.update = function() {
                        this._fitUIRenderQueue()
                    }, n._fitUIRenderQueue = function() {
                        if (this._modelComponent)
                            for (var e = this._modelComponent.sharedMaterials.length, t = 0; t < e; t++) {
                                var n = this._modelComponent.getMaterialInstance(t);
                                if (null != n)
                                    for (var i = n.passes, r = i.length, o = 0; o < r; o++) {
                                        var a = i[o];
                                        a._priority = Du.MAX - 11, a.blendState.targets[0].blend || n.overridePipelineStates({
                                            blendState: {
                                                targets: [{
                                                    blend: !0
                                                }]
                                            }
                                        }, o)
                                    }
                            }
                    }, K(t, [{
                        key: "modelComponent",
                        get: function() {
                            return this._modelComponent
                        }
                    }]), t
                }(xZ)) || DZ) || DZ) || DZ) || DZ),
                LZ = e("MeshBuffer", function() {
                    function e(e) {
                        this.vData = null, this.iData = null, this.byteStart = 0, this.byteOffset = 0, this.indicesStart = 0, this.indicesOffset = 0, this.vertexStart = 0, this.vertexOffset = 0, this.lastByteOffset = 1, this._attributes = null, this._vertexBuffers = [], this._indexBuffer = null, this._iaInfo = null, this._batcher = void 0, this._dirty = !1, this._vertexFormatBytes = 0, this._initVDataCount = 0, this._initIDataCount = 1536, this._outOfCallback = null, this._hInputAssemblers = [], this._nextFreeIAHandle = 0, this._batcher = e
                    }
                    var t = e.prototype;
                    return t.initialize = function(e, t) {
                        this._outOfCallback = t;
                        var n = BX(e);
                        this._vertexFormatBytes = n * Float32Array.BYTES_PER_ELEMENT, this._initVDataCount = 256 * this._vertexFormatBytes;
                        var i = Float32Array.BYTES_PER_ELEMENT * n;
                        this.vertexBuffers.length || this.vertexBuffers.push(this._batcher.device.createBuffer(new gs(xa.VERTEX | xa.TRANSFER_DST, Ra.HOST | Ra.DEVICE, i, i)));
                        var r = Uint16Array.BYTES_PER_ELEMENT;
                        this.indexBuffer || (this._indexBuffer = this._batcher.device.createBuffer(new gs(xa.INDEX | xa.TRANSFER_DST, Ra.HOST | Ra.DEVICE, r, r))), this._attributes = e, this._iaInfo = new Bs(this.attributes, this.vertexBuffers, this.indexBuffer), this._reallocBuffer()
                    }, t.request = function(e, t) {
                        void 0 === e && (e = 4), void 0 === t && (t = 6), this.lastByteOffset = this.byteOffset;
                        var n = this.byteOffset + e * this._vertexFormatBytes,
                            i = this.indicesOffset + t;
                        if (e + this.vertexOffset > 65535) return this._outOfCallback && this._outOfCallback.call(this._batcher, e, t), !1;
                        var r = this.vData.byteLength,
                            o = this.iData.length;
                        if (n > r || i > o) {
                            for (; r < n || o < i;) this._initVDataCount *= 2, this._initIDataCount *= 2, r = 4 * this._initVDataCount, o = this._initIDataCount;
                            this._reallocBuffer()
                        }
                        return this.vertexOffset += e, this.indicesOffset += t, this.byteOffset = n, this._dirty = !0, !0
                    }, t.reset = function() {
                        this.byteStart = 0, this.byteOffset = 0, this.indicesStart = 0, this.indicesOffset = 0, this.vertexStart = 0, this.vertexOffset = 0, this.lastByteOffset = 0, this._nextFreeIAHandle = 0, this._dirty = !1
                    }, t.destroy = function() {
                        this._attributes = null, this.vertexBuffers[0].destroy(), this.vertexBuffers.length = 0, this.indexBuffer.destroy(), this._indexBuffer = null;
                        for (var e = 0; e < this._hInputAssemblers.length; e++) Sr.free(this._hInputAssemblers[e]);
                        this._hInputAssemblers.length = 0
                    }, t.recordBatch = function() {
                        var e = this.indicesOffset - this.indicesStart;
                        if (!e) return 0;
                        this._hInputAssemblers.length <= this._nextFreeIAHandle && this._hInputAssemblers.push(Sr.alloc(this._batcher.device, this._iaInfo));
                        var t = this._hInputAssemblers[this._nextFreeIAHandle++],
                            n = Sr.get(t);
                        return n.firstIndex = this.indicesStart, n.indexCount = e, t
                    }, t.uploadBuffers = function() {
                        if (0 !== this.byteOffset && this._dirty) {
                            var e = new Float32Array(this.vData.buffer, 0, this.byteOffset >> 2),
                                t = new Uint16Array(this.iData.buffer, 0, this.indicesOffset);
                            this.byteOffset > this.vertexBuffers[0].size && this.vertexBuffers[0].resize(this.byteOffset), this.vertexBuffers[0].update(e), 2 * this.indicesOffset > this.indexBuffer.size && this.indexBuffer.resize(2 * this.indicesOffset), this.indexBuffer.update(t), this._dirty = !1
                        }
                    }, t._reallocBuffer = function() {
                        this._reallocVData(!0), this._reallocIData(!0)
                    }, t._reallocVData = function(e) {
                        var t;
                        if (this.vData && (t = new Uint8Array(this.vData.buffer)), this.vData = new Float32Array(this._initVDataCount), t && e)
                            for (var n = new Uint8Array(this.vData.buffer), i = 0, r = t.length; i < r; i++) n[i] = t[i]
                    }, t._reallocIData = function(e) {
                        var t = this.iData;
                        if (this.iData = new Uint16Array(this._initIDataCount), t && e)
                            for (var n = this.iData, i = 0, r = t.length; i < r; i++) n[i] = t[i]
                    }, K(e, [{
                        key: "attributes",
                        get: function() {
                            return this._attributes
                        }
                    }, {
                        key: "vertexBuffers",
                        get: function() {
                            return this._vertexBuffers
                        }
                    }, {
                        key: "indexBuffer",
                        get: function() {
                            return this._indexBuffer
                        }
                    }, {
                        key: "vertexFormatBytes",
                        get: function() {
                            return this._vertexFormatBytes
                        }
                    }]), e
                }());
            LZ.OPACITY_OFFSET = 8;
            var BZ, FZ, zZ, UZ, GZ, HZ, kZ, VZ, WZ, jZ, qZ, XZ, YZ, KZ, ZZ, QZ, JZ, $Z, eQ, tQ, nQ, iQ, rQ, oQ, aQ = Pu.Enum.NONE | Pu.Enum.UI_3D,
                sQ = e("UIDrawBatch", function() {
                    function e() {
                        this.bufferBatch = null, this.camera = null, this.renderScene = null, this.model = null, this.texture = null, this.sampler = null, this.useLocalData = null, this.isStatic = !1, this.textureHash = 0, this.samplerHash = 0, this._handle = 0, this._passes = [], this._handle = Vr.alloc(), Vr.set(this._handle, zr.VIS_FLAGS, aQ), Vr.set(this._handle, zr.INPUT_ASSEMBLER, 0), Vr.set(this._handle, zr.DESCRIPTOR_SET, 0)
                    }
                    var t = e.prototype;
                    return t.destroy = function() {
                        if (this._handle) {
                            for (var e = this.passes.length, t = 0; t < e; t++) this.passes[t]._destroyHandle();
                            this._passes = [], Vr.free(this._handle), this._handle = 0
                        }
                    }, t.clear = function() {
                        this.bufferBatch = null, this.hInputAssembler = 0, this.hDescriptorSet = 0, this.camera = null, this.texture = null, this.sampler = null, this.model = null, this.isStatic = !1, this.useLocalData = null, this.visFlags = aQ
                    }, t.fillPasses = function(e, t, n, r, o, a) {
                        if (e) {
                            var s = e.passes;
                            if (!s) return;
                            Vr.set(this._handle, zr.PASS_COUNT, s.length);
                            for (var c = zr.PASS_0, l = zr.SHADER_0, u = 0, h = 0; h < s.length; h++, c++, l++) {
                                this._passes[h] || (this._passes[h] = new om(i.director.root), this._passes[h]._handle = Mr.alloc());
                                var _ = s[h],
                                    f = this._passes[h];
                                t || (t = _.depthStencilState, n = 0), r || (r = _.blendState, o = 0), -1 === o && (o = 0), u = n << 16 | o, _.update(), f._initPassFromTarget(_, t, r, u), Vr.set(this._handle, c, f.handle), Vr.set(this._handle, l, f.getShaderVariant(a))
                            }
                        }
                    }, K(e, [{
                        key: "handle",
                        get: function() {
                            return this._handle
                        }
                    }, {
                        key: "hInputAssembler",
                        get: function() {
                            return Vr.get(this._handle, zr.INPUT_ASSEMBLER)
                        },
                        set: function(e) {
                            Vr.set(this._handle, zr.INPUT_ASSEMBLER, e)
                        }
                    }, {
                        key: "hDescriptorSet",
                        get: function() {
                            return Vr.get(this._handle, zr.DESCRIPTOR_SET)
                        },
                        set: function(e) {
                            Vr.set(this._handle, zr.DESCRIPTOR_SET, e)
                        }
                    }, {
                        key: "visFlags",
                        get: function() {
                            return Vr.get(this._handle, zr.VIS_FLAGS)
                        },
                        set: function(e) {
                            Vr.set(this._handle, zr.VIS_FLAGS, e)
                        }
                    }, {
                        key: "passes",
                        get: function() {
                            return this._passes
                        }
                    }]), e
                }()),
                cQ = function(t) {
                    return e({
                        UIStaticBatch: t,
                        UIStaticBatchComponent: t
                    }), t
                }((BZ = A_("cc.UIStaticBatch"), FZ = B_(), zZ = D_(), UZ = C_(110), GZ = z_(), BZ(HZ = FZ(HZ = zZ(HZ = UZ((ie((kZ = function(e) {
                    function t() {
                        for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                        return (t = e.call.apply(e, [this].concat(i)) || this)._init = !1, t._meshBuffer = null, t._dirty = !0, t._lastMeshBuffer = null, t._uiDrawBatchList = [], t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.onLoad = function() {
                        var e = this._getBatcher();
                        if (e) {
                            var t = MX,
                                n = new LZ(e);
                            n.initialize(t, this._arrivalMaxBuffer.bind(this)), this._meshBuffer = n
                        }
                    }, n.onDestroy = function() {
                        e.prototype.onDestroy.call(this), this._clearData(), this._meshBuffer && (this._meshBuffer.destroy(), this._meshBuffer = null)
                    }, n.updateAssembler = function(e) {
                        e.currIsStatic = !0, this._dirty && (e.finishMergeBatches(), this._lastMeshBuffer = e.currBufferBatch, e.currBufferBatch = this._meshBuffer, e.currStaticRoot = this), this._init && (e.finishMergeBatches(), e.commitStaticBatch(this))
                    }, n.postUpdateAssembler = function(e) {
                        this._dirty && (e.finishMergeBatches(), e.currBufferBatch = this._lastMeshBuffer, e.currStaticRoot = null, this._dirty = !1, this._init = !0, this.node._static = !0, this._meshBuffer.uploadBuffers()), e.currIsStatic = !1
                    }, n.markAsDirty = function() {
                        this._getBatcher() && (this.node._static = !1, this._dirty = !0, this._init = !1, this._clearData())
                    }, n._requireDrawBatch = function() {
                        var e = new sQ;
                        return e.isStatic = !0, this._uiDrawBatchList.push(e), e
                    }, n._clearData = function() {
                        if (this._meshBuffer) {
                            this._meshBuffer.reset();
                            for (var e = this._getBatcher(), t = 0; t < this._uiDrawBatchList.length; t++) this._uiDrawBatchList[t].destroy(e)
                        }
                        this._uiDrawBatchList.length = 0, this._init = !1
                    }, n._getBatcher = function() {
                        return RO.root && RO.root.batcher2D ? RO.root.batcher2D : (x(9301), null)
                    }, n._arrivalMaxBuffer = function() {
                        var e = this._getBatcher();
                        e && e.autoMergeBatches(), x(9300)
                    }, K(t, [{
                        key: "color",
                        get: function() {
                            return this._color
                        },
                        set: function(e) {
                            this._color !== e && this._color.set(e)
                        }
                    }, {
                        key: "drawBatchList",
                        get: function() {
                            return this._uiDrawBatchList
                        }
                    }]), t
                }(qq)).prototype, "color", [tf, GZ], Object.getOwnPropertyDescriptor(kZ.prototype, "color"), kZ.prototype), HZ = kZ)) || HZ) || HZ) || HZ) || HZ)),
                lQ = e("LabelShadow", (VZ = A_("cc.LabelShadow"), WZ = B_(), jZ = C_(110), qZ = D_(), XZ = x_(Zq), YZ = G_(), KZ = G_(), ZZ = G_(), VZ(QZ = WZ(QZ = jZ(QZ = qZ(QZ = XZ(QZ = O_((nQ = function(e) {
                    function t() {
                        for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                        return ne(t = e.call.apply(e, [this].concat(i)) || this, "_color", $Z, $(t)), ne(t, "_offset", eQ, $(t)), ne(t, "_blur", tQ, $(t)), t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.onEnable = function() {
                        this._updateRenderData()
                    }, n.onDisable = function() {
                        this._updateRenderData()
                    }, n._updateRenderData = function() {
                        var e = this.node.getComponent(Zq);
                        e && e.updateRenderData(!0)
                    }, K(t, [{
                        key: "color",
                        get: function() {
                            return this._color
                        },
                        set: function(e) {
                            this._color !== e && (this._color.set(e), this._updateRenderData())
                        }
                    }, {
                        key: "offset",
                        get: function() {
                            return this._offset
                        },
                        set: function(e) {
                            this._offset = e, this._updateRenderData()
                        }
                    }, {
                        key: "blur",
                        get: function() {
                            return this._blur
                        },
                        set: function(e) {
                            this._blur = e, this._updateRenderData()
                        }
                    }]), t
                }(Jd), $Z = ie((JZ = nQ).prototype, "_color", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return new yn(0, 0, 0, 255)
                    }
                }), eQ = ie(JZ.prototype, "_offset", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return new Gn(2, 2)
                    }
                }), tQ = ie(JZ.prototype, "_blur", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 2
                    }
                }), ie(JZ.prototype, "color", [YZ], Object.getOwnPropertyDescriptor(JZ.prototype, "color"), JZ.prototype), ie(JZ.prototype, "offset", [KZ], Object.getOwnPropertyDescriptor(JZ.prototype, "offset"), JZ.prototype), ie(JZ.prototype, "blur", [ZZ], Object.getOwnPropertyDescriptor(JZ.prototype, "blur"), JZ.prototype), QZ = JZ)) || QZ) || QZ) || QZ) || QZ) || QZ) || QZ)),
                uQ = function(t) {
                    return e({
                        UIOpacity: t,
                        UIOpacityComponent: t
                    }), t
                }(A_("cc.UIOpacity")(iQ = B_()(iQ = C_(110)(iQ = D_()(iQ = O_((ie((rQ = function(e) {
                    function t() {
                        for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                        return ne(t = e.call.apply(e, [this].concat(i)) || this, "_opacity", oQ, $(t)), t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.onEnable = function() {
                        this.node._uiProps.localOpacity = this._opacity / 255
                    }, n.onDisable = function() {
                        this.node._uiProps.localOpacity = 1
                    }, K(t, [{
                        key: "opacity",
                        get: function() {
                            return this._opacity
                        },
                        set: function(e) {
                            this._opacity !== e && (e = mt(e, 0, 255), this._opacity = e, this.node._uiProps.localOpacity = e / 255)
                        }
                    }]), t
                }(Jd)).prototype, "opacity", [F_], Object.getOwnPropertyDescriptor(rQ.prototype, "opacity"), rQ.prototype), oQ = ie(rQ.prototype, "_opacity", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 255
                    }
                }), iQ = rQ)) || iQ) || iQ) || iQ) || iQ) || iQ);
            i.MaskComponent = vY, Qe.setClassAlias(vY, "cc.MaskComponent"), i.LabelComponent = Zq, Qe.setClassAlias(Zq, "cc.LabelComponent"), i.LabelOutlineComponent = AK, Qe.setClassAlias(AK, "cc.LabelOutlineComponent"), i.RichTextComponent = NZ, Qe.setClassAlias(NZ, "cc.RichTextComponent"), i.SpriteComponent = zK, Qe.setClassAlias(zK, "cc.SpriteComponent"), i.UIModelComponent = MZ, Qe.setClassAlias(MZ, "cc.UIModelComponent"), i.GraphicsComponent = fY, Qe.setClassAlias(fY, "cc.GraphicsComponent"), Qe.setClassAlias(cQ, "cc.UIStaticBatchComponent"), Qe.setClassAlias(uQ, "cc.UIOpacityComponent");
            var hQ = function(e, t, n) {
                this.i = void 0, this.x = void 0, this.y = void 0, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1, this.i = e, this.x = t, this.y = n
            };

            function _Q(e, t, n, i, r) {
                var o = 0,
                    a = null;
                if (r === function(e, t, n, i) {
                        for (var r = 0, o = t, a = n - i; o < n; o += i) r += (e[a] - e[o]) * (e[o + 1] + e[a + 1]), a = o;
                        return r
                    }(e, t, n, i) > 0)
                    for (o = t; o < n; o += i) a = PQ(o, e[o], e[o + 1], a);
                else
                    for (o = n - i; o >= t; o -= i) a = PQ(o, e[o], e[o + 1], a);
                return a && bQ(a, a.next) && (OQ(a), a = a.next), a
            }

            function fQ(e, t) {
                if (void 0 === t && (t = null), !e) return e;
                t || (t = e);
                var n = e,
                    i = !1;
                do {
                    if (i = !1, n.steiner || !bQ(n, n.next) && 0 !== CQ(n.prev, n, n.next)) n = n.next;
                    else {
                        if (OQ(n), (n = t = n.prev) === n.next) return null;
                        i = !0
                    }
                } while (i || n !== t);
                return t
            }

            function dQ(e, t, n, i, r, o, a) {
                if (void 0 === a && (a = 0), e) {
                    !a && o && function(e, t, n, i) {
                        var r = e;
                        do {
                            null === r.z && (r.z = EQ(r.x, r.y, t, n, i)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next
                        } while (r !== e);
                        r.prevZ.nextZ = null, r.prevZ = null,
                            function(e) {
                                var t = 0,
                                    n = null,
                                    i = null,
                                    r = null,
                                    o = null,
                                    a = 0,
                                    s = 0,
                                    c = 0,
                                    l = 1;
                                do {
                                    for (n = e, e = null, o = null, a = 0; n;) {
                                        for (a++, i = n, s = 0, t = 0; t < l && (s++, i = i.nextZ); t++);
                                        for (c = l; s > 0 || c > 0 && i;) 0 === s ? (r = i, i = i.nextZ, c--) : 0 !== c && i ? n.z <= i.z ? (r = n, n = n.nextZ, s--) : (r = i, i = i.nextZ, c--) : (r = n, n = n.nextZ, s--), o ? o.nextZ = r : e = r, r.prevZ = o, o = r;
                                        n = i
                                    }
                                    o.nextZ = null, l *= 2
                                } while (a > 1)
                            }(r)
                    }(e, i, r, o);
                    for (var s = e, c = null, l = null; e.prev !== e.next;)
                        if (c = e.prev, l = e.next, o ? mQ(e, i, r, o) : pQ(e)) t.push(c.i / n), t.push(e.i / n), t.push(l.i / n), OQ(e), e = l.next, s = l.next;
                        else if ((e = l) === s) {
                        a ? 1 === a ? dQ(e = gQ(e, t, n), t, n, i, r, o, 2) : 2 === a && vQ(e, t, n, i, r, o) : dQ(fQ(e), t, n, i, r, o, 1);
                        break
                    }
                }
            }

            function pQ(e) {
                var t = e.prev,
                    n = e,
                    i = e.next;
                if (CQ(t, n, i) >= 0) return !1;
                for (var r = e.next.next; r !== e.prev;) {
                    if (AQ(t.x, t.y, n.x, n.y, i.x, i.y, r.x, r.y) && CQ(r.prev, r, r.next) >= 0) return !1;
                    r = r.next
                }
                return !0
            }

            function mQ(e, t, n, i) {
                var r = e.prev,
                    o = e,
                    a = e.next;
                if (CQ(r, o, a) >= 0) return !1;
                for (var s = r.x < o.x ? r.x < a.x ? r.x : a.x : o.x < a.x ? o.x : a.x, c = r.y < o.y ? r.y < a.y ? r.y : a.y : o.y < a.y ? o.y : a.y, l = r.x > o.x ? r.x > a.x ? r.x : a.x : o.x > a.x ? o.x : a.x, u = r.y > o.y ? r.y > a.y ? r.y : a.y : o.y > a.y ? o.y : a.y, h = EQ(s, c, t, n, i), _ = EQ(l, u, t, n, i), f = e.nextZ; f && f.z <= _;) {
                    if (f !== e.prev && f !== e.next && AQ(r.x, r.y, o.x, o.y, a.x, a.y, f.x, f.y) && CQ(f.prev, f, f.next) >= 0) return !1;
                    f = f.nextZ
                }
                for (f = e.prevZ; f && f.z >= h;) {
                    if (f !== e.prev && f !== e.next && AQ(r.x, r.y, o.x, o.y, a.x, a.y, f.x, f.y) && CQ(f.prev, f, f.next) >= 0) return !1;
                    f = f.prevZ
                }
                return !0
            }

            function gQ(e, t, n) {
                var i = e;
                do {
                    var r = i.prev,
                        o = i.next.next;
                    !bQ(r, o) && RQ(r, i, i.next, o) && wQ(r, o) && wQ(o, r) && (t.push(r.i / n), t.push(i.i / n), t.push(o.i / n), OQ(i), OQ(i.next), i = e = o), i = i.next
                } while (i !== e);
                return i
            }

            function vQ(e, t, n, i, r, o) {
                var a = e;
                do {
                    for (var s = a.next.next; s !== a.prev;) {
                        if (a.i !== s.i && xQ(a, s)) {
                            var c = IQ(a, s);
                            return a = fQ(a, a.next), c = fQ(c, c.next), dQ(a, t, n, i, r, o), void dQ(c, t, n, i, r, o)
                        }
                        s = s.next
                    }
                    a = a.next
                } while (a !== e)
            }

            function yQ(e, t) {
                return e.x - t.x
            }

            function SQ(e, t) {
                if (t = function(e, t) {
                        var n = t,
                            i = e.x,
                            r = e.y,
                            o = -1 / 0,
                            a = null;
                        do {
                            if (r <= n.y && r >= n.next.y) {
                                var s = n.x + (r - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
                                if (s <= i && s > o) {
                                    if (o = s, s === i) {
                                        if (r === n.y) return n;
                                        if (r === n.next.y) return n.next
                                    }
                                    a = n.x < n.next.x ? n : n.next
                                }
                            }
                            n = n.next
                        } while (n !== t);
                        if (!a) return null;
                        if (i === o) return a.prev;
                        var c, l = a,
                            u = a.x,
                            h = a.y,
                            _ = 1 / 0;
                        for (n = a.next; n !== l;) i >= n.x && n.x >= u && AQ(r < h ? i : o, r, u, h, r < h ? o : i, r, n.x, n.y) && ((c = Math.abs(r - n.y) / (i - n.x)) < _ || c === _ && n.x > a.x) && wQ(n, e) && (a = n, _ = c), n = n.next;
                        return a
                    }(e, t)) {
                    var n = IQ(t, e);
                    fQ(n, n.next)
                }
            }

            function EQ(e, t, n, i, r) {
                return (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - n) / r) | e << 8)) | e << 4)) | e << 2)) | e << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - i) / r) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1
            }

            function TQ(e) {
                var t = e,
                    n = e;
                do {
                    t.x < n.x && (n = t), t = t.next
                } while (t !== e);
                return n
            }

            function AQ(e, t, n, i, r, o, a, s) {
                return (r - a) * (t - s) - (e - a) * (o - s) >= 0 && (e - a) * (i - s) - (n - a) * (t - s) >= 0 && (n - a) * (o - s) - (r - a) * (i - s) >= 0
            }

            function xQ(e, t) {
                return e.next.i !== t.i && e.prev.i !== t.i && ! function(e, t) {
                    var n = e;
                    do {
                        if (n.i !== e.i && n.next.i !== e.i && n.i !== t.i && n.next.i !== t.i && RQ(n, n.next, e, t)) return !0;
                        n = n.next
                    } while (n !== e);
                    return !1
                }(e, t) && wQ(e, t) && wQ(t, e) && function(e, t) {
                    var n = e,
                        i = !1,
                        r = (e.x + t.x) / 2,
                        o = (e.y + t.y) / 2;
                    do {
                        n.y > o != n.next.y > o && r < (n.next.x - n.x) * (o - n.y) / (n.next.y - n.y) + n.x && (i = !i), n = n.next
                    } while (n !== e);
                    return i
                }(e, t)
            }

            function CQ(e, t, n) {
                return (t.y - e.y) * (n.x - t.x) - (t.x - e.x) * (n.y - t.y)
            }

            function bQ(e, t) {
                return e.x === t.x && e.y === t.y
            }

            function RQ(e, t, n, i) {
                return !!(bQ(e, t) && bQ(n, i) || bQ(e, i) && bQ(n, t)) || CQ(e, t, n) > 0 != CQ(e, t, i) > 0 && CQ(n, i, e) > 0 != CQ(n, i, t) > 0
            }

            function wQ(e, t) {
                return CQ(e.prev, e, e.next) < 0 ? CQ(e, t, e.next) >= 0 && CQ(e, e.prev, t) >= 0 : CQ(e, t, e.prev) < 0 || CQ(e, e.next, t) < 0
            }

            function IQ(e, t) {
                var n = new hQ(e.i, e.x, e.y),
                    i = new hQ(t.i, t.x, t.y),
                    r = e.next,
                    o = t.prev;
                return e.next = t, t.prev = e, n.next = r, r.prev = n, i.next = n, n.prev = i, o.next = i, i.prev = o, i
            }

            function PQ(e, t, n, i) {
                var r = new hQ(e, t, n);
                return i ? (r.next = i.next, r.prev = i, i.next.prev = r, i.next = r) : (r.prev = r, r.next = r), r
            }

            function OQ(e) {
                e.next.prev = e.prev, e.prev.next = e.next, e.prevZ && (e.prevZ.nextZ = e.nextZ), e.nextZ && (e.nextZ.prevZ = e.prevZ)
            }

            function DQ(e, t, n) {
                n = n || 3;
                var i = t ? t.length : 0,
                    r = i ? t[0] * n : e.length,
                    o = _Q(e, 0, r, n, !0),
                    a = [];
                if (!o) return a;
                var s = 0,
                    c = 0,
                    l = 0,
                    u = 0,
                    h = 0,
                    _ = 0,
                    f = 0;
                if (i && (o = function(e, t, n, i) {
                        var r, o = [],
                            a = 0,
                            s = null;
                        for (a = 0, r = t.length; a < r; a++)(s = _Q(e, t[a] * i, a < r - 1 ? t[a + 1] * i : e.length, i, !1)) && (s === s.next && (s.steiner = !0), o.push(TQ(s)));
                        if (o.sort(yQ), !n) return n;
                        for (a = 0; a < o.length; a++) SQ(o[a], n), n = fQ(n, n.next);
                        return n
                    }(e, t, o, n)), e.length > 80 * n) {
                    s = l = e[0], c = u = e[1];
                    for (var d = n; d < r; d += n)(h = e[d]) < s && (s = h), (_ = e[d + 1]) < c && (c = _), h > l && (l = h), _ > u && (u = _);
                    f = Math.max(l - s, u - c)
                }
                return dQ(o, a, n, s, c, f), a
            }
            for (var NQ = Math.PI, MQ = Math.min, LQ = Math.max, BQ = Math.ceil, FQ = Math.acos, zQ = Math.cos, UQ = Math.sin, GQ = Math.atan2, HQ = null, kQ = null, VQ = new yn, WQ = [], jQ = 0; jQ < 4; jQ++) WQ.push(new En);

            function qQ(e, t, n) {
                return e < t ? t : e > n ? n : e
            }
            var XQ = {
                    useModel: !0,
                    updateRenderData: function() {},
                    fillBuffers: function() {},
                    renderIA: function() {},
                    getRenderData: function(e, t) {
                        if (!kQ) return null;
                        var n = kQ.getRenderDataList(),
                            i = n[kQ.dataOffset];
                        if (!i) return null;
                        var r = i,
                            o = r ? r.vertexStart + t : 0;
                        return (o > 65535 || 3 * o > 131070) && (++kQ.dataOffset, kQ.dataOffset < n.length ? i = n[kQ.dataOffset] : (i = kQ.requestRenderData(), n[kQ.dataOffset] = i), r = i), r && r.vertexCount < o && r.request(t, 3 * t), i
                    },
                    stroke: function(e) {
                        yn.copy(VQ, e.strokeColor), e.impl && (this._flattenPaths(e.impl), this._expandStroke(e), e.impl.updatePathOffset = !0, this.end(e))
                    },
                    fill: function(e) {
                        yn.copy(VQ, e.fillColor), this._expandFill(e), e.impl && (e.impl.updatePathOffset = !0), this.end(e)
                    },
                    end: function(e) {
                        e.markForUpdateRenderData()
                    },
                    _expandStroke: function(e) {
                        var t = .5 * e.lineWidth,
                            n = e.lineCap,
                            i = e.lineJoin,
                            r = e.miterLimit;
                        if (kQ = e.impl) {
                            var o = function(e, t, n) {
                                var i = 2 * FQ(e / (e + n));
                                return LQ(2, BQ(t / i))
                            }(t, NQ, kQ.tessTol);
                            this._calculateJoins(kQ, t, i, r);
                            for (var a = kQ.paths, s = 0, c = kQ.pathOffset, l = kQ.pathLength; c < l; c++) {
                                var u = a[c],
                                    h = u.points.length;
                                i === Yq.ROUND ? s += 2 * (h + u.bevel * (o + 2) + 1) : s += 2 * (h + 5 * u.bevel + 1), u.closed || (n === Xq.ROUND ? s += 2 * (2 * o + 2) : s += 12)
                            }
                            var _ = HQ = this.getRenderData(e, s);
                            if (_) {
                                for (var f = _.vData, d = _.iData, p = kQ.pathOffset, m = kQ.pathLength; p < m; p++) {
                                    var g = a[p],
                                        v = g.points,
                                        y = v.length,
                                        S = _.vertexStart,
                                        E = void 0,
                                        T = void 0,
                                        A = 0,
                                        x = 0,
                                        C = g.closed;
                                    if (C ? (E = v[y - 1], T = v[0], A = 0, x = y) : (E = v[0], T = v[1], A = 1, x = y - 1), T = T || E, !C) {
                                        var b = new IX(T.x, T.y);
                                        b.subtract(E), b.normalize();
                                        var R = b.x,
                                            w = b.y;
                                        n === Xq.BUTT ? this._buttCapStart(E, R, w, t, 0) : n === Xq.SQUARE ? this._buttCapStart(E, R, w, t, t) : n === Xq.ROUND && this._roundCapStart(E, R, w, t, o)
                                    }
                                    for (var I = A; I < x; ++I) i === Yq.ROUND ? this._roundJoin(E, T, t, t, o) : 0 != (T.flags & (Kq.PT_BEVEL | Kq.PT_INNERBEVEL)) ? this._bevelJoin(E, T, t, t) : (this._vSet(T.x + T.dmx * t, T.y + T.dmy * t, 1), this._vSet(T.x - T.dmx * t, T.y - T.dmy * t, -1)), E = T, T = v[I + 1];
                                    if (C) {
                                        var P = 8 * S;
                                        this._vSet(f[P], f[P + 1], 1), this._vSet(f[P + 8], f[P + 8 + 1], -1)
                                    } else {
                                        var O = new IX(T.x, T.y);
                                        O.subtract(E), O.normalize();
                                        var D = O.x,
                                            N = O.y;
                                        n === Xq.BUTT ? this._buttCapEnd(T, D, N, t, 0) : n === Xq.SQUARE ? this._buttCapEnd(T, D, N, t, t) : n === Xq.ROUND && this._roundCapEnd(T, D, N, t, o)
                                    }
                                    for (var M = _.indicesStart, L = S + 2, B = _.vertexStart; L < B; L++) d[M++] = L - 2, d[M++] = L - 1, d[M++] = L;
                                    _.indicesStart = M
                                }
                                HQ = null, kQ = null
                            }
                        }
                    },
                    _expandFill: function(e) {
                        if (kQ = e.impl) {
                            for (var t = kQ.paths, n = 0, i = kQ.pathOffset, r = kQ.pathLength; i < r; i++) n += t[i].points.length;
                            var o = HQ = this.getRenderData(e, n);
                            if (o) {
                                for (var a = o, s = a.vData, c = a.iData, l = kQ.pathOffset, u = kQ.pathLength; l < u; l++) {
                                    var h = t[l],
                                        _ = h.points,
                                        f = _.length;
                                    if (0 !== f) {
                                        for (var d = o.vertexStart, p = 0; p < f; ++p) this._vSet(_[p].x, _[p].y);
                                        var m = o.indicesStart;
                                        if (h.complex) {
                                            for (var g = [], v = d, y = o.vertexStart; v < y; v++) {
                                                var S = 8 * v;
                                                g.push(s[S++]), g.push(s[S++]), g.push(s[S++])
                                            }
                                            var E = DQ(g, null, 3);
                                            if (!E || 0 === E.length) continue;
                                            for (var T = 0, A = E.length; T < A; T++) c[m++] = E[T] + d
                                        } else
                                            for (var x = d, C = d + 2, b = a.vertexStart; C < b; C++) c[m++] = x, c[m++] = C - 1, c[m++] = C;
                                        a.indicesStart = m
                                    }
                                }
                                HQ = null, kQ = null
                            }
                        }
                    },
                    _calculateJoins: function(e, t, n, i) {
                        var r = 0;
                        t > 0 && (r = 1 / t);
                        for (var o = e.paths, a = e.pathOffset, s = e.pathLength; a < s; a++) {
                            var c = o[a],
                                l = c.points,
                                u = l.length,
                                h = l[u - 1],
                                _ = l[0];
                            c.bevel = 0;
                            for (var f = 0; f < u; f++) {
                                var d, p, m = h.dy,
                                    g = -h.dx,
                                    v = _.dy,
                                    y = -_.dx;
                                if (_.dmx = .5 * (m + v), _.dmy = .5 * (g + y), (d = _.dmx * _.dmx + _.dmy * _.dmy) > 1e-6) {
                                    var S = 1 / d;
                                    S > 600 && (S = 600), _.dmx *= S, _.dmy *= S
                                }
                                _.dx * h.dy - h.dx * _.dy > 0 && (_.flags |= Kq.PT_LEFT), d * (p = LQ(11, MQ(h.len, _.len) * r)) * p < 1 && (_.flags |= Kq.PT_INNERBEVEL), _.flags & Kq.PT_CORNER && (d * i * i < 1 || n === Yq.BEVEL || n === Yq.ROUND) && (_.flags |= Kq.PT_BEVEL), 0 != (_.flags & (Kq.PT_BEVEL | Kq.PT_INNERBEVEL)) && c.bevel++, h = _, _ = l[f + 1]
                            }
                        }
                    },
                    _flattenPaths: function(e) {
                        for (var t = e.paths, n = e.pathOffset, i = e.pathLength; n < i; n++) {
                            var r = t[n],
                                o = r.points,
                                a = o[o.length - 1],
                                s = o[0];
                            o.length > 2 && a.equals(s) && (r.closed = !0, o.pop(), a = o[o.length - 1]);
                            for (var c = 0, l = o.length; c < l; c++) {
                                var u = new IX(s.x, s.y);
                                u.subtract(a), a.len = u.length(), (u.x || u.y) && u.normalize(), a.dx = u.x, a.dy = u.y, a = s, s = o[c + 1]
                            }
                        }
                    },
                    _chooseBevel: function(e, t, n, i) {
                        var r = n.x,
                            o = n.y,
                            a = 0,
                            s = 0,
                            c = 0,
                            l = 0;
                        return 0 !== e ? (a = r + t.dy * i, s = o - t.dx * i, c = r + n.dy * i, l = o - n.dx * i) : (a = c = r + n.dmx * i, s = l = o + n.dmy * i), [a, s, c, l]
                    },
                    _buttCapStart: function(e, t, n, i, r) {
                        var o = e.x - t * r,
                            a = e.y - n * r,
                            s = n,
                            c = -t;
                        this._vSet(o + s * i, a + c * i, 1), this._vSet(o - s * i, a - c * i, -1)
                    },
                    _buttCapEnd: function(e, t, n, i, r) {
                        var o = e.x + t * r,
                            a = e.y + n * r,
                            s = n,
                            c = -t;
                        this._vSet(o + s * i, a + c * i, 1), this._vSet(o - s * i, a - c * i, -1)
                    },
                    _roundCapStart: function(e, t, n, i, r) {
                        for (var o = e.x, a = e.y, s = n, c = -t, l = 0; l < r; l++) {
                            var u = l / (r - 1) * NQ,
                                h = zQ(u) * i,
                                _ = UQ(u) * i;
                            this._vSet(o - s * h - t * _, a - c * h - n * _, 1), this._vSet(o, a, 0)
                        }
                        this._vSet(o + s * i, a + c * i, 1), this._vSet(o - s * i, a - c * i, -1)
                    },
                    _roundCapEnd: function(e, t, n, i, r) {
                        var o = e.x,
                            a = e.y,
                            s = n,
                            c = -t;
                        this._vSet(o + s * i, a + c * i, 1), this._vSet(o - s * i, a - c * i, -1);
                        for (var l = 0; l < r; l++) {
                            var u = l / (r - 1) * NQ,
                                h = zQ(u) * i,
                                _ = UQ(u) * i;
                            this._vSet(o, a, 0), this._vSet(o - s * h + t * _, a - c * h + n * _, 1)
                        }
                    },
                    _roundJoin: function(e, t, n, i, r) {
                        var o = e.dy,
                            a = -e.dx,
                            s = t.dy,
                            c = -t.dx,
                            l = t.x,
                            u = t.y;
                        if (0 != (t.flags & Kq.PT_LEFT)) {
                            var h = this._chooseBevel(t.flags & Kq.PT_INNERBEVEL, e, t, n),
                                _ = h[0],
                                f = h[1],
                                d = h[2],
                                p = h[3],
                                m = GQ(-a, -o),
                                g = GQ(-c, -s);
                            g > m && (g -= 2 * NQ), this._vSet(_, f, 1), this._vSet(l - o * i, t.y - a * i, -1);
                            for (var v = qQ(BQ((m - g) / NQ) * r, 2, r), y = 0; y < v; y++) {
                                var S = m + y / (v - 1) * (g - m),
                                    E = l + zQ(S) * i,
                                    T = u + UQ(S) * i;
                                this._vSet(l, u, 0), this._vSet(E, T, -1)
                            }
                            this._vSet(d, p, 1), this._vSet(l - s * i, u - c * i, -1)
                        } else {
                            var A = this._chooseBevel(t.flags & Kq.PT_INNERBEVEL, e, t, -i),
                                x = A[0],
                                C = A[1],
                                b = A[2],
                                R = A[3],
                                w = GQ(a, o),
                                I = GQ(c, s);
                            I < w && (I += 2 * NQ), this._vSet(l + o * i, u + a * i, 1), this._vSet(x, C, -1);
                            for (var P = qQ(BQ((I - w) / NQ) * r, 2, r), O = 0; O < P; O++) {
                                var D = w + O / (P - 1) * (I - w),
                                    N = l + zQ(D) * n,
                                    M = u + UQ(D) * n;
                                this._vSet(N, M, 1), this._vSet(l, u, 0)
                            }
                            this._vSet(l + s * i, u + c * i, 1), this._vSet(b, R, -1)
                        }
                    },
                    _bevelJoin: function(e, t, n, i) {
                        var r = 0,
                            o = 0,
                            a = 0,
                            s = 0,
                            c = 0,
                            l = 0,
                            u = 0,
                            h = 0,
                            _ = e.dy,
                            f = -e.dx,
                            d = t.dy,
                            p = -t.dx;
                        if (t.flags & Kq.PT_LEFT) {
                            var m = this._chooseBevel(t.flags & Kq.PT_INNERBEVEL, e, t, n);
                            c = m[0], l = m[1], u = m[2], h = m[3], this._vSet(c, l, 1), this._vSet(t.x - _ * i, t.y - f * i, -1), this._vSet(u, h, 1), this._vSet(t.x - d * i, t.y - p * i, -1)
                        } else {
                            var g = this._chooseBevel(t.flags & Kq.PT_INNERBEVEL, e, t, -i);
                            r = g[0], o = g[1], a = g[2], s = g[3], this._vSet(t.x + _ * n, t.y + f * n, 1), this._vSet(r, o, -1), this._vSet(t.x + d * n, t.y + p * n, 1), this._vSet(a, s, -1)
                        }
                    },
                    _vSet: function(e, t, n) {
                        if (void 0 === n && (n = 0), HQ) {
                            var i = HQ,
                                r = 8 * i.vertexStart,
                                o = i.vData;
                            o[r++] = e, o[r++] = t, o[r++] = 0, yn.toArray(o, VQ, r), r += 4, o[r++] = n, i.vertexStart++
                        }
                    }
                },
                YQ = e("graphicsAssembler", {
                    getAssembler: function() {
                        return XQ
                    }
                });
            fY.Assembler = YQ;
            var KQ = function() {
                    this.char = "", this.valid = !0, this.x = 0, this.y = 0, this.line = 0, this.hash = ""
                },
                ZQ = new Kn,
                QQ = null,
                JQ = null,
                $Q = [],
                eJ = [],
                tJ = [],
                nJ = [],
                iJ = new Xn,
                rJ = new Xn,
                oJ = new Gn,
                aJ = null,
                sJ = 0,
                cJ = 0,
                lJ = 0,
                uJ = 0,
                hJ = 0,
                _J = 1,
                fJ = null,
                dJ = "",
                pJ = 0,
                mJ = 0,
                gJ = 0,
                vJ = 0,
                yJ = 0,
                SJ = 0,
                EJ = 0,
                TJ = !1,
                AJ = 0,
                xJ = 0,
                CJ = 0,
                bJ = {
                    updateRenderData: function(e) {
                        e.renderData && e.renderData.vertDirty && QQ !== e && (JQ = (QQ = e).node._uiProps.uiTransformComp, this._updateFontFamily(e), this._updateProperties(e), this._updateLabelInfo(e), this._updateContent(), QQ.actualFontSize = pJ, JQ.setContentSize(rJ), QQ.renderData.vertDirty = QQ.renderData.uvDirty = !1, QQ.markForUpdateRenderData(!1), QQ = null, this._resetProperties())
                    },
                    _updateFontScale: function() {
                        _J = pJ / mJ
                    },
                    _updateFontFamily: function(e) {
                        var t = e.font;
                        fJ = t.spriteFrame, aJ = t.fntConfig, tj.fontAtlas = t.fontDefDictionary, VV.packToDynamicAtlas(e, fJ)
                    },
                    _updateLabelInfo: function() {
                        tj.hash = "", tj.margin = 0
                    },
                    _updateProperties: function(e) {
                        dJ = e.string.toString(), pJ = e.fontSize, mJ = aJ ? aJ.fontSize : e.fontSize, gJ = e.horizontalAlign, vJ = e.verticalAlign, yJ = e.spacingX, EJ = e.overflow, SJ = e._lineHeight;
                        var t = JQ.contentSize;
                        rJ.width = t.width, rJ.height = t.height, EJ === Wq.NONE ? (TJ = !1, rJ.width += 2 * tj.margin, rJ.height += 2 * tj.margin) : EJ === Wq.RESIZE_HEIGHT ? (TJ = !0, rJ.height += 2 * tj.margin) : TJ = e.enableWrapText, tj.lineHeight = SJ, tj.fontSize = pJ, this._setupBMFontOverflowMetrics()
                    },
                    _resetProperties: function() {
                        aJ = null, fJ = null, tj.hash = "", tj.margin = 0
                    },
                    _updateContent: function() {
                        this._updateFontScale(), this._computeHorizontalKerningForText(), this._alignText()
                    },
                    _computeHorizontalKerningForText: function() {
                        for (var e = dJ, t = e.length, n = aJ.kerningDict, i = $Q, r = -1, o = 0; o < t; ++o) {
                            var a = e.charCodeAt(o),
                                s = n[r << 16 | 65535 & a] || 0;
                            i[o] = o < t - 1 ? s : 0, r = a
                        }
                    },
                    _multilineTextWrap: function(e) {
                        for (var t = dJ.length, n = 0, i = 0, r = 0, o = 0, a = 0, s = 0, c = 0, l = null, u = 0; u < t;) {
                            var h = dJ.charAt(u);
                            if ("\n" !== h) {
                                for (var _ = e(dJ, u, t), f = s, d = c, p = a, m = i, g = !1, v = 0; v < _; ++v) {
                                    var y = u + v;
                                    if ("\r" !== (h = dJ.charAt(y)))
                                        if (l = tj.fontAtlas.getLetterDefinitionForChar(h, tj)) {
                                            var S = m + l.offsetX * _J - tj.margin;
                                            if (TJ && CJ > 0 && i > 0 && S + l.w * _J > CJ && !IW(h)) {
                                                tJ.push(a), a = 0, n++, i = 0, r -= SJ * this._getFontScale() + 0, g = !0;
                                                break
                                            }
                                            oJ.x = S, oJ.y = r - l.offsetY * _J, this._recordLetterInfo(oJ, h, y, n), y + 1 < $Q.length && y < t - 1 && (m += $Q[y + 1]), m += l.xAdvance * _J + yJ, p = oJ.x + l.w * _J, f < oJ.y && (f = oJ.y), d > oJ.y - l.h * _J && (d = oJ.y - l.h * _J)
                                        } else this._recordPlaceholderInfo(y, h), console.log("Can't find letter definition in texture atlas " + aJ.atlasName + " for letter:" + h);
                                    else this._recordPlaceholderInfo(y, h)
                                }
                                g || (i = m, s < f && (s = f), c > d && (c = d), o < (a = p) && (o = a), u += _)
                            } else tJ.push(a), a = 0, n++, i = 0, r -= SJ * this._getFontScale() + 0, this._recordPlaceholderInfo(u, h), u++
                        }
                        return tJ.push(a), cJ = (sJ = n + 1) * SJ * this._getFontScale(), sJ > 1 && (cJ += 0 * (sJ - 1)), rJ.width = AJ, rJ.height = xJ, AJ <= 0 && (rJ.width = parseFloat(o.toFixed(2)) + 2 * tj.margin), xJ <= 0 && (rJ.height = parseFloat(cJ.toFixed(2)) + 2 * tj.margin), uJ = rJ.height, hJ = 0, s > 0 && (uJ = rJ.height + s), c < -cJ && (hJ = cJ + c), !0
                    },
                    _getFirstCharLen: function() {
                        return 1
                    },
                    _getFontScale: function() {
                        return EJ === Wq.SHRINK ? _J : 1
                    },
                    _getFirstWordLen: function(e, t, n) {
                        var i = e.charAt(t);
                        if (wW(i) || "\n" === i || IW(i)) return 1;
                        var r = 1,
                            o = tj.fontAtlas.getLetterDefinitionForChar(i, tj);
                        if (!o) return r;
                        for (var a = o.xAdvance * _J + yJ, s = t + 1; s < n && (i = e.charAt(s), o = tj.fontAtlas.getLetterDefinitionForChar(i, tj)); ++s) {
                            if (a + o.offsetX * _J + o.w * _J > CJ && !IW(i) && CJ > 0) return r;
                            if (a += o.xAdvance * _J + yJ, "\n" === i || IW(i) || wW(i)) break;
                            r++
                        }
                        return r
                    },
                    _multilineTextWrapByWord: function() {
                        return this._multilineTextWrap(this._getFirstWordLen)
                    },
                    _multilineTextWrapByChar: function() {
                        return this._multilineTextWrap(this._getFirstCharLen)
                    },
                    _recordPlaceholderInfo: function(e, t) {
                        if (e >= eJ.length) {
                            var n = new KQ;
                            eJ.push(n)
                        }
                        eJ[e].char = t, eJ[e].hash = t.charCodeAt(0) + tj.hash, eJ[e].valid = !1
                    },
                    _recordLetterInfo: function(e, t, n, i) {
                        if (n >= eJ.length) {
                            var r = new KQ;
                            eJ.push(r)
                        }
                        var o = t.charCodeAt(0) + tj.hash;
                        eJ[n].line = i, eJ[n].char = t, eJ[n].hash = o, eJ[n].valid = tj.fontAtlas.getLetter(o).valid, eJ[n].x = e.x, eJ[n].y = e.y
                    },
                    _alignText: function() {
                        cJ = 0, tJ.length = 0, this._multilineTextWrapByWord(), this._computeAlignmentOffset(), EJ === Wq.SHRINK && pJ > 0 && this._isVerticalClamp() && this._shrinkLabelToContentSize(this._isVerticalClamp), this._updateQuads() || EJ === Wq.SHRINK && this._shrinkLabelToContentSize(this._isHorizontalClamp)
                    },
                    _scaleFontSizeDown: function(e) {
                        var t = !0;
                        e || (e = .1, t = !1), pJ = e, t && this._updateContent()
                    },
                    _shrinkLabelToContentSize: function(e) {
                        for (var t = 0, n = 0 | pJ, i = 0; t < n;) {
                            var r = i = t + n + 1 >> 1;
                            if (r <= 0) break;
                            _J = r / mJ, this._multilineTextWrapByWord(), this._computeAlignmentOffset(), e() ? n = i - 1 : t = i
                        }
                        t >= 0 && this._scaleFontSizeDown(t)
                    },
                    _isVerticalClamp: function() {
                        return cJ > rJ.height
                    },
                    _isHorizontalClamp: function() {
                        for (var e = !1, t = 0, n = dJ.length; t < n; ++t) {
                            var i = eJ[t];
                            if (i.valid) {
                                var r = tj.fontAtlas.getLetterDefinitionForChar(i.char, tj);
                                if (!r) continue;
                                var o = i.x + r.w / 2 * _J,
                                    a = i.line;
                                if (AJ > 0)
                                    if (TJ) {
                                        if (tJ[a] > rJ.width && (o > rJ.width || o < 0)) {
                                            e = !0;
                                            break
                                        }
                                    } else if (o > rJ.width) {
                                    e = !0;
                                    break
                                }
                            }
                        }
                        return e
                    },
                    _isHorizontalClamped: function(e, t) {
                        var n = tJ[t],
                            i = e > rJ.width || e < 0;
                        return TJ ? n > rJ.width && i : i
                    },
                    _updateQuads: function() {
                        if (!QQ) return !1;
                        var e = fJ ? fJ.texture : tj.fontAtlas.getTexture(),
                            t = QQ.renderData;
                        t.dataLength = t.vertexCount = t.indicesCount = 0;
                        for (var n = JQ.anchorPoint, i = rJ, r = n.x * i.width, o = n.y * i.height, a = !0, s = 0, c = dJ.length; s < c; ++s) {
                            var l = eJ[s];
                            if (l.valid) {
                                var u = tj.fontAtlas.getLetter(l.hash);
                                if (u) {
                                    ZQ.height = u.h, ZQ.width = u.w, ZQ.x = u.u, ZQ.y = u.v;
                                    var h = l.y + lJ;
                                    if (xJ > 0) {
                                        if (h > uJ) {
                                            var _ = h - uJ;
                                            ZQ.y += _, ZQ.height -= _, h -= _
                                        }
                                        h - u.h * _J < hJ && EJ === Wq.CLAMP && (ZQ.height = h < hJ ? 0 : (h - hJ) / _J)
                                    }
                                    var f = l.line,
                                        d = l.x + u.w / 2 * _J + nJ[f];
                                    if (AJ > 0 && this._isHorizontalClamped(d, f))
                                        if (EJ === Wq.CLAMP) ZQ.width = 0;
                                        else if (EJ === Wq.SHRINK) {
                                        if (rJ.width > u.w) {
                                            a = !1;
                                            break
                                        }
                                        ZQ.width = 0
                                    }
                                    if (ZQ.height > 0 && ZQ.width > 0) {
                                        var p = this._determineRect(),
                                            m = l.x + nJ[l.line];
                                        this.appendQuad(QQ, e, ZQ, p, m - r, h - o, _J)
                                    }
                                } else console.warn("Can't find letter in this bitmap-font")
                            }
                        }
                        return a
                    },
                    appendQuad: function() {},
                    _determineRect: function() {
                        var e = fJ.isRotated(),
                            t = fJ.getOriginalSize(),
                            n = fJ.getRect(),
                            i = fJ.getOffset(),
                            r = i.x + (t.width - n.width) / 2,
                            o = i.y - (t.height - n.height) / 2;
                        if (e) {
                            var a = ZQ.x;
                            ZQ.x = n.x + n.height - ZQ.y - ZQ.height - o, ZQ.y = a + n.y - r, ZQ.y < 0 && (ZQ.height += o)
                        } else ZQ.x += n.x - r, ZQ.y += n.y + o;
                        return e
                    },
                    _computeAlignmentOffset: function() {
                        switch (nJ.length = 0, gJ) {
                            case kq.LEFT:
                                for (var e = 0; e < sJ; ++e) nJ.push(0);
                                break;
                            case kq.CENTER:
                                for (var t = 0, n = tJ.length; t < n; t++) nJ.push((rJ.width - tJ[t]) / 2);
                                break;
                            case kq.RIGHT:
                                for (var i = 0, r = tJ.length; i < r; i++) nJ.push(rJ.width - tJ[i])
                        }
                        if (lJ = rJ.height, vJ !== Vq.TOP) {
                            var o = rJ.height - cJ + SJ * this._getFontScale() - mJ * _J;
                            vJ === Vq.BOTTOM ? lJ -= o : lJ -= o / 2
                        }
                    },
                    _setupBMFontOverflowMetrics: function() {
                        var e = rJ.width,
                            t = rJ.height;
                        EJ === Wq.RESIZE_HEIGHT && (t = 0), EJ === Wq.NONE && (e = 0, t = 0), AJ = e, xJ = t, iJ.width = e, iJ.height = t, CJ = e
                    }
                },
                RJ = new yn(255, 255, 255, 255),
                wJ = {
                    createData: function(e) {
                        return e.requestRenderData()
                    },
                    fillBuffers: function(e, t) {
                        var n = e.node;
                        e._setCacheAlpha(n._uiProps.opacity), RJ.set(e.color), RJ.a = 255 * n._uiProps.opacity, zV(n, t, e.renderData, RJ)
                    },
                    appendQuad: function(e, t, n, i, r, o, a) {
                        var s = e.renderData;
                        if (s) {
                            var c = s.dataLength;
                            s.dataLength += 4, s.vertexCount = s.dataLength, s.indicesCount = s.dataLength / 2 * 3;
                            var l = s.data,
                                u = t.width,
                                h = t.height,
                                _ = n.width,
                                f = n.height,
                                d = 0,
                                p = 0,
                                m = 0,
                                g = 0;
                            i ? (d = n.x / u, g = (n.x + f) / u, p = (n.y + _) / h, m = n.y / h, l[c].u = d, l[c].v = m, l[c + 1].u = d, l[c + 1].v = p, l[c + 2].u = g, l[c + 2].v = m, l[c + 3].u = g, l[c + 3].v = p) : (d = n.x / u, g = (n.x + _) / u, p = (n.y + f) / h, m = n.y / h, l[c].u = d, l[c].v = p, l[c + 1].u = g, l[c + 1].v = p, l[c + 2].u = d, l[c + 2].v = m, l[c + 3].u = g, l[c + 3].v = m), l[c].x = r, l[c].y = o - f * a, l[c + 1].x = r + _ * a, l[c + 1].y = o - f * a, l[c + 2].x = r, l[c + 2].y = o, l[c + 3].x = r + _ * a, l[c + 3].y = o
                        }
                    }
                };
            De(wJ, bJ);
            var IJ = null,
                PJ = Ne(bJ, {
                    getAssemblerData: function() {
                        return IJ || (IJ = new ej(1024, 1024)), IJ.getTexture()
                    },
                    _updateFontFamily: function(e) {
                        tj.fontAtlas = IJ, tj.fontFamily = this._getFontFamily(e);
                        var t = e.getComponent(AK);
                        t && t.enabled ? (tj.isOutlined = !0, tj.margin = t.width, tj.out = t.color.clone(), tj.out.a = t.color.a * e.color.a / 255) : (tj.isOutlined = !1, tj.margin = 0)
                    },
                    _getFontFamily: function(e) {
                        var t = "Arial";
                        return e.useSystemFont ? t = e.fontFamily || "Arial" : e.font && (e.font._nativeAsset ? t = e.font._nativeAsset : RD.postLoadNative(e.font, (function() {
                            e.isValid && (t = e.font._nativeAsset || "Arial", e.updateRenderData(!0))
                        }))), t
                    },
                    _updateLabelInfo: function(e) {
                        tj.fontDesc = this._getFontDesc(), tj.color = e.color, tj.hash = function(e) {
                            var t = e.color.toHEX(),
                                n = "";
                            return e.isOutlined && e.margin > 0 && (n = n + e.margin + e.out.toHEX()), "" + e.fontSize + e.fontFamily + t + n
                        }(tj)
                    },
                    _getFontDesc: function() {
                        return tj.fontSize.toString() + "px " + tj.fontFamily
                    },
                    _computeHorizontalKerningForText: function() {},
                    _determineRect: function() {
                        return !1
                    }
                }),
                OJ = new yn(255, 255, 255, 255),
                DJ = {
                    createData: function(e) {
                        return e.requestRenderData()
                    },
                    fillBuffers: function(e, t) {
                        if (e.renderData) {
                            var n = e.node;
                            e._setCacheAlpha(n._uiProps.opacity), OJ.a = 255 * n._uiProps.opacity, zV(n, t, e.renderData, OJ)
                        }
                    },
                    appendQuad: wJ.appendQuad
                };
            De(DJ, PJ);
            var NJ = Zq.Overflow,
                MJ = (1 / 255).toFixed(3),
                LJ = null,
                BJ = null,
                FJ = null,
                zJ = "",
                UJ = "",
                GJ = 0,
                HJ = 0,
                kJ = [],
                VJ = new Xn,
                WJ = 0,
                jJ = 0,
                qJ = 0,
                XJ = new yn,
                YJ = 1,
                KJ = "",
                ZJ = NJ.NONE,
                QJ = !1,
                JJ = null,
                $J = yn.BLACK.clone(),
                e$ = null,
                t$ = yn.BLACK.clone(),
                n$ = new Kn,
                i$ = Xn.ZERO.clone(),
                r$ = Xn.ZERO.clone(),
                o$ = Gn.ZERO.clone(),
                a$ = Gn.ZERO.clone(),
                s$ = 0,
                c$ = 0,
                l$ = !1,
                u$ = !1,
                h$ = !1,
                _$ = ["left", "center", "right"],
                f$ = {
                    getAssemblerData: function() {
                        return Zq._canvasPool.get()
                    },
                    resetAssemblerData: function(e) {
                        e && Zq._canvasPool.put(e)
                    },
                    updateRenderData: function(e) {
                        if (e.renderData && e.renderData.vertDirty) {
                            var t = e.node._uiProps.uiTransformComp;
                            this._updateFontFamily(e), this._updateProperties(e, t), this._calculateLabelFont(), this._updateLabelDimensions(), this._resetDynamicAtlas(e), this._updateTexture(e), this.updateOpacity(e), e._setCacheAlpha(YJ), this._calDynamicAtlas(e), e.actualFontSize = GJ, t.setContentSize(VJ), this.updateVertexData(e), this.updateUvs(e), e.markForUpdateRenderData(!1), LJ = null, BJ = null, FJ = null
                        }
                    },
                    updateVertexData: function() {},
                    updateUvs: function() {},
                    updateOpacity: function(e) {
                        for (var t = e.renderData.vData, n = 5, i = e.node._uiProps.opacity, r = 0; r < 4; r++) t[n + 3] = i, n += 9
                    },
                    _updateFontFamily: function(e) {
                        e.useSystemFont ? KJ = e.fontFamily || "Arial" : e.font ? e.font._nativeAsset ? KJ = e.font._nativeAsset : (RD.postLoadNative(e.font, (function() {
                            e.isValid && (KJ = e.font._nativeAsset || "Arial", e.updateRenderData(!0))
                        })), KJ = "Arial") : KJ = "Arial"
                    },
                    _updateProperties: function(e, t) {
                        var n = e.assemblerData;
                        n && (LJ = n.context, BJ = n.canvas, FJ = e.spriteFrame, UJ = e.string.toString(), GJ = e.fontSize, HJ = GJ, ZJ = e.overflow, r$.width = VJ.width = t.width, r$.height = VJ.height = t.height, c$ = e.underlineHeight, WJ = e.lineHeight, jJ = e.horizontalAlign, qJ = e.verticalAlign, XJ = e.color, YJ = e.node._uiProps.opacity, l$ = e.isBold, u$ = e.isItalic, h$ = e.isUnderline, QJ = ZJ !== NJ.NONE && (ZJ === NJ.RESIZE_HEIGHT || e.enableWrapText), (JJ = (JJ = AK && e.getComponent(AK)) && JJ.enabled && JJ.width > 0 ? JJ : null) && $J.set(JJ.color), (e$ = (e$ = lQ && e.getComponent(lQ)) && e$.enabled ? e$ : null) && t$.set(e$.color), this._updatePaddingRect())
                    },
                    _updatePaddingRect: function() {
                        var e = 0,
                            t = 0,
                            n = 0,
                            i = 0,
                            r = 0;
                        if (i$.width = i$.height = 0, JJ && (e = t = n = i = r = JJ.width, i$.width = i$.height = 2 * r), e$) {
                            var o = e$.blur + r,
                                a = e$.offset.x,
                                s = e$.offset.y;
                            n = Math.max(n, -a + o), i = Math.max(i, a + o), e = Math.max(e, s + o), t = Math.max(t, -s + o)
                        }
                        if (u$) {
                            var c = HJ * Math.tan(.20943951);
                            i += c, i$.width += c
                        }
                        n$.x = n, n$.y = e, n$.width = n + i, n$.height = e + t
                    },
                    _calculateFillTextStartPosition: function() {
                        var e = 0;
                        jJ === kq.RIGHT ? e = VJ.width - n$.width : jJ === kq.CENTER && (e = (VJ.width - n$.width) / 2);
                        var t = this._getLineHeight() * (kJ.length - 1),
                            n = GJ * (1 - vW / 2);
                        if (qJ !== Vq.TOP) {
                            var i = t + n$.height + GJ - VJ.height;
                            qJ === Vq.BOTTOM ? n -= i += vW / 2 * GJ : n -= i / 2
                        }
                        n += 0 * GJ, o$.set(e + n$.x, n + n$.y)
                    },
                    _updateTexture: function(e) {
                        if (LJ && BJ) {
                            LJ.clearRect(0, 0, BJ.width, BJ.height), LJ.font = zJ, this._calculateFillTextStartPosition();
                            var t = this._getLineHeight();
                            LJ.lineJoin = "round", e._srcBlendFactor === Ba.SRC_ALPHA && (LJ.fillStyle = "rgba(" + XJ.r + ", " + XJ.g + ", " + XJ.b + ", " + MJ + ")", LJ.fillRect(0, 0, BJ.width, BJ.height)), LJ.fillStyle = "rgb(" + XJ.r + ", " + XJ.g + ", " + XJ.b + ")";
                            var n, r = o$.x,
                                o = 0;
                            this._drawTextEffect(o$, t);
                            for (var a = 0; a < kJ.length; ++a) o = o$.y + a * t, JJ && LJ.strokeText(kJ[a], r, o), LJ.fillText(kJ[a], r, o);
                            e$ && (LJ.shadowColor = "transparent"), FJ && (n = FJ instanceof KV ? FJ.texture : FJ, 0 !== BJ.width && 0 !== BJ.height && (n.reset({
                                width: BJ.width,
                                height: BJ.height,
                                mipmapLevel: 1
                            }), n.uploadData(BJ), FJ instanceof KV && (FJ.rect = new Kn(0, 0, BJ.width, BJ.height), FJ._calculateUV()), i.director.root && i.director.root.batcher2D && i.director.root.batcher2D._releaseDescriptorSetCache(n.getHash())))
                        }
                    },
                    _resetDynamicAtlas: function(e) {
                        if (e.cacheMode === Zq.CacheMode.BITMAP) {
                            var t = e.ttfSpriteFrame;
                            VV.deleteAtlasSpriteFrame(t), t._resetDynamicAtlasFrame()
                        }
                    },
                    _calDynamicAtlas: function(e) {
                        if (e.cacheMode === Zq.CacheMode.BITMAP) {
                            var t = e.ttfSpriteFrame;
                            VV.packToDynamicAtlas(e, t), e.renderData.uvDirty = !0
                        }
                    },
                    _setupOutline: function() {
                        LJ.strokeStyle = "rgba(" + $J.r + ", " + $J.g + ", " + $J.b + ", " + $J.a / 255 + ")", LJ.lineWidth = 2 * JJ.width
                    },
                    _setupShadow: function() {
                        LJ.shadowColor = "rgba(" + t$.r + ", " + t$.g + ", " + t$.b + ", " + t$.a / 255 + ")", LJ.shadowBlur = e$.blur, LJ.shadowOffsetX = e$.offset.x, LJ.shadowOffsetY = -e$.offset.y
                    },
                    _drawTextEffect: function(e, t) {
                        if (e$ || JJ || h$) {
                            var n = kJ.length > 1 && e$,
                                i = this._measureText(LJ, zJ),
                                r = 0,
                                o = 0;
                            e$ && this._setupShadow(), JJ && this._setupOutline();
                            for (var a = 0; a < kJ.length; ++a) r = e.x, o = e.y + a * t, n && (JJ && LJ.strokeText(kJ[a], r, o), LJ.fillText(kJ[a], r, o)), h$ && (s$ = i(kJ[a]), jJ === kq.RIGHT ? a$.x = e.x - s$ : jJ === kq.CENTER ? a$.x = e.x - s$ / 2 : a$.x = e.x, a$.y = o + HJ / 8, LJ.fillRect(a$.x, a$.y, s$, c$));
                            n && (LJ.shadowColor = "transparent")
                        }
                    },
                    _updateLabelDimensions: function() {
                        VJ.width = Math.min(VJ.width, 2048), VJ.height = Math.min(VJ.height, 2048);
                        var e = !1;
                        BJ.width !== VJ.width && (BJ.width = VJ.width, e = !0), BJ.height !== VJ.height && (BJ.height = VJ.height, e = !0), e && (LJ.font = zJ), LJ.textAlign = _$[jJ], LJ.textBaseline = "alphabetic"
                    },
                    _getFontDesc: function() {
                        var e = GJ.toString() + "px ";
                        return e += KJ, l$ && (e = "bold " + e), u$ && (e = "italic " + e), e
                    },
                    _getLineHeight: function() {
                        return 0 | (0 === WJ ? GJ : WJ * GJ / HJ)
                    },
                    _calculateParagraphLength: function(e, t) {
                        for (var n, i = [], r = te(e); !(n = r()).done;) {
                            var o = PW(t, n.value, zJ);
                            i.push(o)
                        }
                        return i
                    },
                    _measureText: function(e, t) {
                        return function(n) {
                            return PW(e, n, t)
                        }
                    },
                    _calculateShrinkFont: function(e) {
                        if (LJ) {
                            var t = this._calculateParagraphLength(e, LJ),
                                n = 0,
                                i = 0,
                                r = 0;
                            if (QJ) {
                                var o = r$.width,
                                    a = r$.height;
                                if (o < 0 || a < 0) return;
                                i = a + 1;
                                for (var s = 0, c = 0 | GJ + 1, l = 0; s < c;) {
                                    if ((l = s + c + 1 >> 1) <= 0) {
                                        T(4003);
                                        break
                                    }
                                    GJ = l, zJ = this._getFontDesc(), LJ.font = zJ;
                                    var u = this._getLineHeight();
                                    for (i = 0, n = 0; n < e.length; ++n) {
                                        var h = PW(LJ, e[n], zJ);
                                        i += DW(e[n], h, o, this._measureText(LJ, zJ)).length * u
                                    }
                                    i > a ? c = l - 1 : s = l
                                }
                                0 === s ? T(4003) : (GJ = s, zJ = this._getFontDesc(), LJ.font = zJ)
                            } else {
                                for (i = e.length * this._getLineHeight(), n = 0; n < e.length; ++n) r < t[n] && (r = t[n]);
                                var _ = (VJ.width - n$.width) / r,
                                    f = VJ.height / i;
                                GJ = HJ * Math.min(1, _, f) | 0, zJ = this._getFontDesc(), LJ.font = zJ
                            }
                        }
                    },
                    _calculateWrapText: function(e) {
                        if (QJ && LJ) {
                            kJ = [];
                            for (var t = r$.width, n = 0; n < e.length; ++n) {
                                var i = PW(LJ, e[n], zJ),
                                    r = DW(e[n], i, t, this._measureText(LJ, zJ));
                                kJ = kJ.concat(r)
                            }
                        }
                    },
                    _calculateLabelFont: function() {
                        if (LJ) {
                            var e = UJ.split("\n");
                            switch (kJ = e, zJ = this._getFontDesc(), LJ.font = zJ, ZJ) {
                                case NJ.NONE:
                                    for (var t = 0, n = 0, i = 0; i < e.length; ++i) {
                                        var r = PW(LJ, e[i], zJ);
                                        t = t > r ? t : r
                                    }
                                    n = (kJ.length + vW) * this._getLineHeight();
                                    var o = parseFloat(t.toFixed(2)),
                                        a = parseFloat(n.toFixed(2));
                                    VJ.width = o + n$.width, VJ.height = a + n$.height, r$.width = o + i$.width, r$.height = a + i$.height;
                                    break;
                                case NJ.SHRINK:
                                    this._calculateShrinkFont(e), this._calculateWrapText(e);
                                    break;
                                case NJ.CLAMP:
                                    this._calculateWrapText(e);
                                    break;
                                case NJ.RESIZE_HEIGHT:
                                    this._calculateWrapText(e);
                                    var s = (kJ.length + vW) * this._getLineHeight();
                                    VJ.height = s + n$.height, r$.height = s + i$.height
                            }
                        }
                    }
                },
                d$ = yn.WHITE.clone(),
                p$ = {
                    createData: function(e) {
                        var t = e.requestRenderData();
                        t.dataLength = 4, t.vertexCount = 4, t.indicesCount = 6;
                        var n = t.vData = new Float32Array(36);
                        n[3] = n[21] = n[22] = n[31] = 0, n[4] = n[12] = n[13] = n[30] = 1;
                        for (var i = 5, r = 0; r < 4; r++) yn.toArray(n, d$, i), i += 9;
                        return t
                    },
                    fillBuffers: function(e, t) {
                        var n = e.renderData,
                            i = n.data,
                            r = e.node,
                            o = t.acquireBufferBatch(),
                            a = o.byteOffset >> 2,
                            s = o.indicesOffset,
                            c = o.vertexOffset;
                        o.request() || (o = t.currBufferBatch, s = 0, c = 0, a = 0);
                        var l = o.vData,
                            u = o.iData,
                            h = n.vData,
                            _ = i[0],
                            f = i[3];
                        r.updateWorldTransform();
                        var d = r._pos,
                            p = r._rot,
                            m = r._scale,
                            g = _.x * m.x,
                            v = f.x * m.x,
                            y = _.y * m.y,
                            S = f.y * m.y,
                            E = p.x,
                            T = p.y,
                            A = p.z,
                            x = p.w,
                            C = E * T,
                            b = A * x,
                            R = E * E - T * T,
                            w = x * x - A * A,
                            I = w + R,
                            P = 2 * (C - b),
                            O = w - R,
                            D = 2 * (C + b),
                            N = d.x,
                            M = d.y;
                        h[0] = I * g + P * y + N, h[1] = O * y + D * g + M, h[9] = I * v + P * y + N, h[10] = O * y + D * v + M, h[18] = I * g + P * S + N, h[19] = O * S + D * g + M, h[27] = I * v + P * S + N, h[28] = O * S + D * v + M, l.set(h, a), u[s++] = c, u[s++] = c + 1, u[s++] = c + 2, u[s++] = c + 2, u[s++] = c + 1, u[s++] = c + 3
                    },
                    updateVertexData: function(e) {
                        var t = e.renderData;
                        if (t) {
                            var n = e.node._uiProps.uiTransformComp,
                                i = n.width,
                                r = n.height,
                                o = n.anchorX * i,
                                a = n.anchorY * r,
                                s = t.data;
                            s[0].x = -o, s[0].y = -a, s[3].x = i - o, s[3].y = r - a
                        }
                    },
                    updateUvs: function(e) {
                        var t = e.renderData;
                        if (t) {
                            var n = t.vData;
                            if (n && t.uvDirty) {
                                var i = e.ttfSpriteFrame.uv;
                                n[3] = i[0], n[4] = i[1], n[12] = i[2], n[13] = i[3], n[21] = i[4], n[22] = i[5], n[30] = i[6], n[31] = i[7], t.uvDirty = !1
                            }
                        }
                    }
                };
            De(p$, f$);
            var m$ = e("labelAssembler", {
                getAssembler: function(e) {
                    var t = p$;
                    return e.font instanceof mW ? t = wJ : e.cacheMode === Zq.CacheMode.CHAR && (t = DJ), t
                }
            });
            Zq.Assembler = m$;
            var g$ = zK.FillType,
                v$ = new Bn,
                y$ = new yn(255, 255, 255, 255),
                S$ = {
                    useModel: !1,
                    updateRenderData: function(e) {
                        var t = e.spriteFrame;
                        VV.packToDynamicAtlas(e, t);
                        var n = e.renderData;
                        if (n && t) {
                            var i = n.uvDirty,
                                r = n.vertDirty;
                            if (!i && !r) return;
                            var o = e.fillStart,
                                a = e.fillRange;
                            a < 0 && (o += a, a = -a), a = (a = (a = o + a) > 1 ? 1 : a) < 0 ? 0 : a;
                            var s = (o = (o = o > 1 ? 1 : o) < 0 ? 0 : o) + (a = (a -= o) < 0 ? 0 : a);
                            s = s > 1 ? 1 : s, i && this.updateUVs(e, o, s), r && (this.updateVertexData && this.updateVertexData(e, o, s), this.updateWorldVertexData(e))
                        }
                    },
                    updateUVs: function(e, t, n) {
                        var i = e.spriteFrame,
                            r = e.renderData,
                            o = r.data,
                            a = i.width,
                            s = i.height,
                            c = i.getRect(),
                            l = 0,
                            u = 0,
                            h = 0,
                            _ = 0,
                            f = 0,
                            d = 0,
                            p = 0,
                            m = 0,
                            g = 0,
                            v = 0;
                        switch (i.isRotated() ? (l = c.x / a, u = (c.y + c.width) / s, h = f = l, p = g = (c.x + c.height) / a, d = v = u, _ = m = c.y / s) : (l = c.x / a, u = (c.y + c.height) / s, h = p = l, f = g = (c.x + c.width) / a, _ = d = u, m = v = c.y / s), e.fillType) {
                            case g$.HORIZONTAL:
                                o[0].u = h + (f - h) * t, o[0].v = _ + (d - _) * t, o[1].u = h + (f - h) * n, o[1].v = _ + (d - _) * n, o[2].u = p + (g - p) * t, o[2].v = m + (v - m) * t, o[3].u = p + (g - p) * n, o[3].v = m + (v - m) * n;
                                break;
                            case g$.VERTICAL:
                                o[0].u = h + (p - h) * t, o[0].v = _ + (m - _) * t, o[1].u = f + (g - f) * t, o[1].v = d + (v - d) * t, o[2].u = h + (p - h) * n, o[2].v = _ + (m - _) * n, o[3].u = f + (g - f) * n, o[3].v = d + (v - d) * n;
                                break;
                            default:
                                b(2626)
                        }
                        r.uvDirty = !1
                    },
                    updateVertexData: function(e, t, n) {
                        var i = e.renderData,
                            r = i.data,
                            o = e.node._uiProps.uiTransformComp,
                            a = o.width,
                            s = o.height,
                            c = o.anchorX * a,
                            l = o.anchorY * s,
                            u = -c,
                            h = -l,
                            _ = a - c,
                            f = s - l,
                            d = 0;
                        switch (e.fillType) {
                            case g$.HORIZONTAL:
                                d = u + (_ - u) * n, u += (_ - u) * t, _ = d;
                                break;
                            case g$.VERTICAL:
                                d = h + (f - h) * n, h += (f - h) * t, f = d;
                                break;
                            default:
                                b(2626)
                        }
                        r[4].x = u, r[4].y = h, r[5].x = _, r[5].y = h, r[6].x = u, r[6].y = f, r[7].x = _, r[7].y = f, i.vertDirty = !1
                    },
                    createData: function(e) {
                        var t = e.requestRenderData();
                        t.dataLength = 8, t.vertexCount = 4, t.indicesCount = 6;
                        for (var n, i = te(t.data); !(n = i()).done;) n.value.z = 0;
                        return t
                    },
                    updateWorldVertexData: function(e) {
                        var t = e.node,
                            n = e.renderData.data;
                        t.getWorldMatrix(v$);
                        for (var i = 0; i < 4; i++) {
                            var r = n[i + 4],
                                o = n[i];
                            En.transformMat4(o, r, v$)
                        }
                    },
                    fillBuffers: function(e, t) {
                        e.node.hasChangedFlags && this.updateWorldVertexData(e);
                        var n = e.node;
                        y$.set(e.color), y$.a = 255 * n._uiProps.opacity,
                            function(e, t, n, i) {
                                var r = n.data,
                                    o = t.acquireBufferBatch(),
                                    a = o.byteOffset >> 2,
                                    s = n.vertexCount,
                                    c = o.indicesOffset,
                                    l = o.vertexOffset;
                                o.request(s, n.indicesCount) || (o = t.currBufferBatch, s = 0, c = 0, l = 0);
                                for (var u = o.vData, h = 0; h < s; h++) {
                                    var _ = r[h];
                                    u[a++] = _.x, u[a++] = _.y, u[a++] = _.z, u[a++] = _.u, u[a++] = _.v, yn.toArray(u, i, a), a += 4
                                }
                                var f = o.iData;
                                f[c++] = l, f[c++] = l + 1, f[c++] = l + 2, f[c++] = l + 1, f[c++] = l + 3, f[c++] = l + 2
                            }(0, t, e.renderData, y$)
                    },
                    updateColor: function() {}
                },
                E$ = 2 * Math.PI,
                T$ = 1e-6,
                A$ = new yn(255, 255, 255, 255),
                x$ = [new Gn, new Gn, new Gn, new Gn],
                C$ = new Array(4),
                b$ = new Array(8),
                R$ = [new Gn, new Gn, new Gn, new Gn],
                w$ = [new Gn, new Gn, new Gn, new Gn],
                I$ = new Gn,
                P$ = [new Gn, new Gn, new Gn, new Gn];

            function O$(e, t, n, i, r, o, a) {
                var s = Math.sin(o);
                s = Math.abs(s) > T$ ? s : 0;
                var c = Math.cos(o),
                    l = 0,
                    u = 0;
                if (0 !== (c = Math.abs(c) > T$ ? c : 0)) {
                    if (l = s / c, (e - r.x) * c > 0) {
                        var h = r.y + l * (e - r.x);
                        a[0].x = e, a[0].y = h
                    }
                    if ((t - r.x) * c > 0) {
                        var _ = r.y + l * (t - r.x);
                        a[2].x = t, a[2].y = _
                    }
                }
                if (0 !== s) {
                    if (u = c / s, (i - r.y) * s > 0) {
                        var f = r.x + u * (i - r.y);
                        a[3].x = f, a[3].y = i
                    }
                    if ((n - r.y) * s > 0) {
                        var d = r.x + u * (n - r.y);
                        a[1].x = d, a[1].y = n
                    }
                }
            }

            function D$(e, t) {
                var n = t.x - e.x,
                    i = t.y - e.y;
                if (0 === n && 0 === i) return 0;
                if (0 === n) return i > 0 ? .5 * Math.PI : 1.5 * Math.PI;
                var r = Math.atan(i / n);
                return n < 0 && (r += Math.PI), r
            }

            function N$(e, t, n, i, r) {
                var o = C$,
                    a = o[0],
                    s = o[1],
                    c = o[2],
                    l = o[3];
                e[t].x = n.x, e[t].y = n.y, e[t + 1].x = i.x, e[t + 1].y = i.y, e[t + 2].x = r.x, e[t + 2].y = r.y, M$((n.x - a) / (c - a), (n.y - s) / (l - s), e, t), M$((i.x - a) / (c - a), (i.y - s) / (l - s), e, t + 1), M$((r.x - a) / (c - a), (r.y - s) / (l - s), e, t + 2)
            }

            function M$(e, t, n, i) {
                var r = b$,
                    o = r[0] + (r[2] - r[0]) * e,
                    a = r[4] + (r[6] - r[4]) * e,
                    s = r[1] + (r[3] - r[1]) * e,
                    c = r[5] + (r[7] - r[5]) * e,
                    l = n[i];
                l.u = o + (a - o) * t, l.v = s + (c - s) * t
            }
            for (var L$ = {
                    useModel: !1,
                    createData: function(e) {
                        return e.requestRenderData()
                    },
                    updateRenderData: function(e) {
                        var t = e.spriteFrame;
                        VV.packToDynamicAtlas(e, t);
                        var n = e.renderData;
                        if (n && t && (n.vertDirty || n.uvDirty)) {
                            var i = n.data,
                                r = e.fillStart,
                                o = e.fillRange;
                            for (o < 0 && (r += o, o = -o); r >= 1;) r -= 1;
                            for (; r < 0;) r += 1;
                            var a = (r *= E$) + (o *= E$);
                            ! function(e) {
                                var t = e.node._uiProps.uiTransformComp,
                                    n = t.width,
                                    i = t.height,
                                    r = t.anchorX * n,
                                    o = t.anchorY * i,
                                    a = -r,
                                    s = -o,
                                    c = n - r,
                                    l = i - o,
                                    u = C$;
                                u[0] = a, u[1] = s, u[2] = c, u[3] = l;
                                var h = e.fillCenter,
                                    _ = I$.x = Math.min(Math.max(0, h.x), 1) * (c - a) + a,
                                    f = I$.y = Math.min(Math.max(0, h.y), 1) * (l - s) + s;
                                x$[0].x = x$[3].x = a, x$[1].x = x$[2].x = c, x$[0].y = x$[1].y = s, x$[2].y = x$[3].y = l;
                                for (var d, p = te(P$); !(d = p()).done;) {
                                    var m = d.value;
                                    Gn.set(m, 0, 0)
                                }
                                _ !== u[0] && Gn.set(P$[0], 3, 0), _ !== u[2] && Gn.set(P$[2], 1, 2), f !== u[1] && Gn.set(P$[1], 0, 1), f !== u[3] && Gn.set(P$[3], 2, 3)
                            }(e),
                            function(e) {
                                var t = e.width,
                                    n = e.height,
                                    i = e.getRect(),
                                    r = 0,
                                    o = 0,
                                    a = 0,
                                    s = 0,
                                    c = b$;
                                e.isRotated() ? (r = i.x / t, o = (i.x + i.height) / t, a = i.y / n, s = (i.y + i.width) / n, c[0] = c[2] = r, c[4] = c[6] = o, c[3] = c[7] = s, c[1] = c[5] = a) : (r = i.x / t, o = (i.x + i.width) / t, a = i.y / n, s = (i.y + i.height) / n, c[0] = c[4] = r, c[2] = c[6] = o, c[1] = c[3] = s, c[5] = c[7] = a)
                            }(t), O$(C$[0], C$[2], C$[1], C$[3], I$, r, R$), O$(C$[0], C$[2], C$[1], C$[3], I$, r + o, w$);
                            for (var s = 0, c = 0; c < 4; ++c) {
                                var l = P$[c];
                                if (l)
                                    if (o >= E$) n.dataLength = s + 3, N$(i, s, I$, x$[l.x], x$[l.y]), s += 3;
                                    else {
                                        var u = D$(I$, x$[l.x]),
                                            h = D$(I$, x$[l.y]);
                                        h < u && (h += E$), u -= E$, h -= E$;
                                        for (var _ = 0; _ < 3; ++_) u >= a || (u >= r ? (n.dataLength = s + 3, N$(i, s, I$, x$[l.x], h >= a ? w$[c] : x$[l.y]), s += 3) : h > r && (h <= a ? (n.dataLength = s + 3, N$(i, s, I$, R$[c], x$[l.y]), s += 3) : (n.dataLength = s + 3, N$(i, s, I$, R$[c], w$[c]), s += 3))), u += E$, h += E$
                                    }
                            }
                            n.indicesCount = n.vertexCount = s, n.vertDirty = n.uvDirty = !1
                        }
                    },
                    fillBuffers: function(e, t) {
                        var n = e.node,
                            i = e.renderData;
                        A$.set(e.color), A$.a = 255 * n._uiProps.opacity,
                            function(e, t, n, i) {
                                var r = n.data,
                                    o = t.acquireBufferBatch(),
                                    a = o.byteOffset >> 2,
                                    s = n.vertexCount,
                                    c = o.indicesOffset,
                                    l = o.vertexOffset;
                                o.request(s, n.indicesCount) || (o = t.currBufferBatch, s = 0, c = 0, l = 0);
                                var u = o.vData;
                                e.getWorldMatrix(FV);
                                for (var h = 0; h < s; h++) {
                                    var _ = r[h];
                                    En.set(BV, _.x, _.y, 0), En.transformMat4(BV, BV, FV), u[a++] = BV.x, u[a++] = BV.y, u[a++] = BV.z, u[a++] = _.u, u[a++] = _.v, yn.toArray(u, i, a), a += 4
                                }
                                for (var f = o.iData, d = 0; d < n.dataLength; d++) f[c + d] = l + d
                            }(n, t, i, A$)
                    },
                    updateColor: function() {}
                }, B$ = [], F$ = 0; F$ < 4; F$++) B$.push(new En);
            for (var z$ = {
                    createData: function(e) {
                        var t = e.requestRenderData();
                        return t.dataLength = 4, t.vertexCount = 4, t.indicesCount = 6, t.vData = new Float32Array(36), t
                    },
                    updateRenderData: function(e) {
                        var t = e.spriteFrame;
                        VV.packToDynamicAtlas(e, t);
                        var n = e.renderData;
                        n && t && (n.vertDirty && this.updateVertexData(e), n.uvDirty && this.updateUvs(e))
                    },
                    fillBuffers: function(e, t) {
                        if (null !== e) {
                            var n = e.renderData.data,
                                i = e.node,
                                r = t.acquireBufferBatch(),
                                o = r.byteOffset >> 2,
                                a = r.indicesOffset,
                                s = r.vertexOffset;
                            r.request() || (r = t.currBufferBatch, o = 0, a = 0, s = 0);
                            var c = r.vData,
                                l = r.iData,
                                u = e.renderData.vData,
                                h = n[0],
                                _ = n[3],
                                f = i.worldMatrix,
                                d = f.m00,
                                p = f.m01,
                                m = f.m04,
                                g = f.m05,
                                v = f.m12,
                                y = f.m13,
                                S = h.x,
                                E = _.x,
                                T = h.y,
                                A = _.y,
                                x = d * S,
                                C = d * E,
                                b = p * S,
                                R = p * E,
                                w = m * T,
                                I = m * A,
                                P = g * T,
                                O = g * A;
                            u[0] = x + w + v, u[1] = b + P + y, u[9] = C + w + v, u[10] = R + P + y, u[18] = x + I + v, u[19] = b + O + y, u[27] = C + I + v, u[28] = R + O + y, c.set(u, o), l[a++] = s, l[a++] = s + 1, l[a++] = s + 2, l[a++] = s + 2, l[a++] = s + 1, l[a++] = s + 3
                        }
                    },
                    updateVertexData: function(e) {
                        var t = e.renderData;
                        if (t) {
                            var n = e.node._uiProps.uiTransformComp,
                                i = t.data,
                                r = n.width,
                                o = n.height,
                                a = n.anchorX * r,
                                s = n.anchorY * o,
                                c = 0,
                                l = 0,
                                u = 0,
                                h = 0;
                            if (e.trim) c = -a, l = -s, u = r - a, h = o - s;
                            else {
                                var _ = e.spriteFrame,
                                    f = _.getOriginalSize(),
                                    d = _.getRect(),
                                    p = f.width,
                                    m = f.height,
                                    g = d.width,
                                    v = d.height,
                                    y = _.getOffset(),
                                    S = r / p,
                                    E = o / m,
                                    T = y.x + (p - g) / 2,
                                    A = y.x - (p - g) / 2;
                                c = T * S - a, l = (y.y + (m - v) / 2) * E - s, u = r + A * S - a, h = o + (y.y - (m - v) / 2) * E - s
                            }
                            i[0].x = c, i[0].y = l, i[0].z = 0, i[3].x = u, i[3].y = h, i[3].z = 0, t.vertDirty = !1
                        }
                    },
                    updateUvs: function(e) {
                        var t = e.renderData,
                            n = t.vData,
                            i = e.spriteFrame.uv;
                        n[3] = i[0], n[4] = i[1], n[12] = i[2], n[13] = i[3], n[21] = i[4], n[22] = i[5], n[30] = i[6], n[31] = i[7], t.uvDirty = !1
                    },
                    updateColor: function(e) {
                        for (var t = e.renderData.vData, n = 5, i = e.color, r = i.r / 255, o = i.g / 255, a = i.b / 255, s = e.node._uiProps.opacity, c = 0; c < 4; c++) t[n] = r, t[n + 1] = o, t[n + 2] = a, t[n + 3] = s, n += 9
                    }
                }, U$ = new En, G$ = new Bn, H$ = {
                    useModel: !1,
                    createData: function(e) {
                        var t = e.requestRenderData();
                        return t.dataLength = 20, t.vertexCount = 16, t.indicesCount = 54, t
                    },
                    updateRenderData: function(e) {
                        var t = e.spriteFrame;
                        VV.packToDynamicAtlas(e, t);
                        var n = e.renderData;
                        n && t && n.vertDirty && (this.updateVertexData(e), this.updateWorldVertexData(e))
                    },
                    updateVertexData: function(e) {
                        var t = e.renderData,
                            n = t.data,
                            i = e.node._uiProps.uiTransformComp,
                            r = i.width,
                            o = i.height,
                            a = i.anchorX * r,
                            s = i.anchorY * o,
                            c = e.spriteFrame,
                            l = c.insetLeft,
                            u = c.insetRight,
                            h = c.insetTop,
                            _ = c.insetBottom,
                            f = r - l - u,
                            d = o - h - _,
                            p = r / (l + u),
                            m = o / (h + _);
                        p = Number.isNaN(p) || p > 1 ? 1 : p, m = Number.isNaN(m) || m > 1 ? 1 : m, f = f < 0 ? 0 : f, d = d < 0 ? 0 : d, n[0].x = -a, n[0].y = -s, n[1].x = l * p - a, n[1].y = _ * m - s, n[2].x = n[1].x + f, n[2].y = n[1].y + d, n[3].x = r - a, n[3].y = o - s, t.vertDirty = !1
                    },
                    fillBuffers: function(e, t) {
                        e.node.hasChangedFlags && this.updateWorldVertexData(e);
                        var n = t.acquireBufferBatch(),
                            i = e.renderData,
                            r = i.data,
                            o = n.byteOffset >> 2,
                            a = i.vertexCount,
                            s = n.indicesOffset,
                            c = n.vertexOffset,
                            l = e.spriteFrame.uvSliced;
                        n.request(a, i.indicesCount) || (n = t.currBufferBatch, o = 0, s = 0, c = 0);
                        for (var u = n.vData, h = n.iData, _ = 4; _ < 20; ++_) {
                            var f = r[_],
                                d = l[_ - 4];
                            u[o++] = f.x, u[o++] = f.y, u[o++] = f.z, u[o++] = d.u, u[o++] = d.v, yn.toArray(u, r[_].color, o), o += 4
                        }
                        for (var p = 0; p < 3; ++p)
                            for (var m = 0; m < 3; ++m) {
                                var g = c + 4 * p + m;
                                h[s++] = g, h[s++] = g + 1, h[s++] = g + 4, h[s++] = g + 1, h[s++] = g + 5, h[s++] = g + 4
                            }
                    },
                    updateWorldVertexData: function(e) {
                        var t = e.node,
                            n = e.renderData.data;
                        t.getWorldMatrix(G$);
                        for (var i = 0; i < 4; ++i)
                            for (var r = n[i], o = 0; o < 4; ++o) {
                                var a = n[o],
                                    s = n[4 + 4 * i + o];
                                En.set(U$, a.x, r.y, 0), En.transformMat4(s, U$, G$)
                            }
                    },
                    updateColor: function(e) {
                        for (var t = e.renderData.data, n = e.color, i = n.r, r = n.g, o = n.b, a = 255 * e.node._uiProps.opacity, s = 4; s < 20; s++) t[s].color.r = i, t[s].color.g = r, t[s].color.b = o, t[s].color.a = a
                    }
                }, k$ = [], V$ = 0; V$ < 4; V$++) k$.push(new En);
            var W$ = {
                    createData: function(e) {
                        return e.requestRenderData()
                    },
                    updateRenderData: function(e) {
                        var t = e.renderData,
                            n = e.spriteFrame;
                        if (n && t && (t.uvDirty || t.vertDirty)) {
                            var i = e.node._uiProps.uiTransformComp,
                                r = Math.abs(i.width),
                                o = Math.abs(i.height),
                                a = n.getRect(),
                                s = n.insetLeft,
                                c = n.insetRight,
                                l = a.width - s - c,
                                u = n.insetTop,
                                h = n.insetBottom,
                                _ = a.height - u - h,
                                f = r - s - c,
                                d = o - u - h;
                            f = f > 0 ? f : 0, d = d > 0 ? d : 0;
                            var p = 0 === l ? f : f / l,
                                m = 0 === _ ? d : d / _,
                                g = Math.ceil(m + 2),
                                v = Math.ceil(p + 2);
                            t.dataLength = Math.max(8, g + 1, v + 1), this.updateVerts(e, f, d, g, v), t.vertexCount = g * v * 4, t.indicesCount = g * v * 6, t.uvDirty = !1, t.vertDirty = !1, this.updateColor(e)
                        }
                    },
                    fillBuffers: function(e, t) {
                        var n = e.node,
                            i = e.node._uiProps.uiTransformComp,
                            r = Math.abs(i.width),
                            o = Math.abs(i.height),
                            a = e.renderData,
                            s = t.acquireBufferBatch(),
                            c = s.indicesOffset,
                            l = s.byteOffset >> 2,
                            u = s.vertexOffset,
                            h = a.vertexCount,
                            _ = a.indicesCount,
                            f = s.vData,
                            d = s.iData;
                        s.request(h, _) || (s = t.currBufferBatch, l = 0, c = 0, u = 0);
                        var p = e.spriteFrame,
                            m = p.isRotated(),
                            g = p.uv,
                            v = e.spriteFrame.uvSliced,
                            y = p.getRect(),
                            S = p.insetLeft,
                            E = p.insetRight,
                            T = y.width - S - E,
                            A = p.insetTop,
                            x = p.insetBottom,
                            C = y.height - A - x,
                            b = r - S - E,
                            R = o - A - x;
                        b = b > 0 ? b : 0, R = R > 0 ? R : 0;
                        var w = 0 === T ? b : b / T,
                            I = 0 === C ? R : R / C,
                            P = Math.ceil(I + 2),
                            O = Math.ceil(w + 2),
                            D = n.worldMatrix,
                            N = a.data;
                        this.fillVertices(f, l, D, P, O, N);
                        for (var M = 0, L = 0, B = [], F = [], z = 0, U = P; z < U; ++z) {
                            L = R > C ? R >= z * C ? 1 : I % 1 : I;
                            for (var G = 0, H = O; G < H; ++G) {
                                M = b > T ? b >= G * T ? 1 : w % 1 : w;
                                var k = l + 3,
                                    V = k + 1;
                                m ? (0 === z ? (B[0] = v[0].u, B[1] = v[0].u, B[2] = v[4].u + (v[8].u - v[4].u) * L) : z < P - 1 ? (B[0] = v[4].u, B[1] = v[4].u, B[2] = v[4].u + (v[8].u - v[4].u) * L) : z === P - 1 && (B[0] = v[8].u, B[1] = v[8].u, B[2] = v[12].u), 0 === G ? (F[0] = v[0].v, F[1] = v[1].v + (v[2].v - v[1].v) * M, F[2] = v[0].v) : G < O - 1 ? (F[0] = v[1].v, F[1] = v[1].v + (v[2].v - v[1].v) * M, F[2] = v[1].v) : G === O - 1 && (F[0] = v[2].v, F[1] = v[3].v, F[2] = v[2].v), B[3] = B[2], F[3] = F[1]) : (0 === G ? (B[0] = v[0].u, B[1] = v[1].u + (v[2].u - v[1].u) * M, B[2] = g[0]) : G < O - 1 ? (B[0] = v[1].u, B[1] = v[1].u + (v[2].u - v[1].u) * M, B[2] = v[1].u) : G === O - 1 && (B[0] = v[2].u, B[1] = v[3].u, B[2] = v[2].u), 0 === z ? (F[0] = v[0].v, F[1] = v[0].v, F[2] = v[4].v + (v[8].v - v[4].v) * L) : z < P - 1 ? (F[0] = v[4].v, F[1] = v[4].v, F[2] = v[4].v + (v[8].v - v[4].v) * L) : z === P - 1 && (F[0] = v[8].v, F[1] = v[8].v, F[2] = v[12].v), B[3] = B[1], F[3] = F[2]), f[k] = B[0], f[V] = F[0], f[k + 9] = B[1], f[V + 9] = F[1], f[k + 18] = B[2], f[V + 18] = F[2], f[k + 27] = B[3], f[V + 27] = F[3], yn.toArray(f, N[0].color, V + 1), yn.toArray(f, N[0].color, V + 9 + 1), yn.toArray(f, N[0].color, V + 18 + 1), yn.toArray(f, N[0].color, V + 27 + 1), l += 36
                            }
                        }
                        for (var W = 0; W < _; W += 6) d[c++] = u, d[c++] = u + 1, d[c++] = u + 2, d[c++] = u + 1, d[c++] = u + 3, d[c++] = u + 2, u += 4
                    },
                    fillVertices: function(e, t, n, i, r, o) {
                        for (var a = 0, s = 0, c = 0, l = 0, u = 0, h = i; u < h; ++u) {
                            c = o[u].y, l = o[u + 1].y;
                            for (var _ = 0, f = r; _ < f; ++_) {
                                a = o[_].x, s = o[_ + 1].x, En.set(k$[0], a, c, 0), En.set(k$[1], s, c, 0), En.set(k$[2], a, l, 0), En.set(k$[3], s, l, 0);
                                for (var d = 0; d < 4; d++) {
                                    var p = k$[d];
                                    En.transformMat4(p, p, n);
                                    var m = 9 * d;
                                    e[t + m] = p.x, e[t + m + 1] = p.y, e[t + m + 2] = p.z
                                }
                                t += 36
                            }
                        }
                    },
                    updateVerts: function(e, t, n, i, r) {
                        var o, a, s = e.node._uiProps.uiTransformComp,
                            c = e.renderData.data,
                            l = e.spriteFrame,
                            u = l.getRect(),
                            h = Math.abs(s.width),
                            _ = Math.abs(s.height),
                            f = s.anchorX * h,
                            d = s.anchorY * _,
                            p = l.insetLeft,
                            m = l.insetRight,
                            g = u.width - p - m,
                            v = l.insetTop,
                            y = l.insetBottom,
                            S = u.height - v - y,
                            E = s.width / (p + m) > 1 ? 1 : s.width / (p + m),
                            T = s.height / (v + y) > 1 ? 1 : s.height / (v + y);
                        o = g > 0 ? Math.floor(1e3 * t) / 1e3 % g == 0 ? g : t % g : t, a = S > 0 ? Math.floor(1e3 * n) / 1e3 % S == 0 ? S : n % S : n;
                        for (var A = 0; A <= r; A++) 0 === A ? c[A].x = -f : A > 0 && A < r ? c[A].x = 1 === A ? p * E + Math.min(g, t) - f : g > 0 ? A === r - 1 ? p + o + g * (A - 2) - f : p + Math.min(g, t) + g * (A - 2) - f : p + t - f : A === r && (c[A].x = Math.min(p + t + m, h) - f);
                        for (var x = 0; x <= i; x++) 0 === x ? c[x].y = -d : x > 0 && x < i ? c[x].y = 1 === x ? y * T + Math.min(S, n) - d : S > 0 ? x === i - 1 ? y + a + (x - 2) * S - d : y + Math.min(S, n) + (x - 2) * S - d : y + n - d : x === i && (c[x].y = Math.min(y + n + v, _) - d)
                    },
                    updateColor: function(e) {
                        var t = e.renderData.data,
                            n = t.length;
                        if (0 !== n)
                            for (var i = e.color, r = i.r, o = i.g, a = i.b, s = 255 * e.node._uiProps.opacity, c = 0; c < n; c++) t[c].color.r = r, t[c].color.g = o, t[c].color.b = a, t[c].color.a = s
                    }
                },
                j$ = zK.Type,
                q$ = zK.FillType,
                X$ = e("spriteAssembler", {
                    getAssembler: function(e) {
                        var t = z$,
                            n = e;
                        switch (n.type) {
                            case j$.SLICED:
                                t = H$;
                                break;
                            case j$.TILED:
                                t = W$;
                                break;
                            case j$.FILLED:
                                t = n.fillType === q$.RADIAL ? L$ : S$
                        }
                        return t
                    }
                });
            zK.Assembler = X$;
            var Y$ = Lj.sharedManager,
                K$ = {
                    createData: function(e) {
                        var t = e.requestRenderData();
                        return t.dataLength = 4, t.vertexCount = 4, t.indicesCount = 6, t.vData = new Float32Array(36), t
                    },
                    updateRenderData: function(e) {
                        e.type === lY.IMAGE_STENCIL && (z$.updateRenderData(e), z$.updateColor(e))
                    },
                    fillBuffers: function(e, t) {
                        (e.type !== lY.IMAGE_STENCIL || e.spriteFrame) && (Y$.pushMask(e), t.finishMergeBatches(), function(e, t) {
                            Y$.clear(e), t.commitModel(e, e._clearModel, e._clearStencilMtl)
                        }(e, t), function(e, t) {
                            if (Y$.enterLevel(e), e.type === lY.IMAGE_STENCIL) {
                                z$.fillBuffers(e, t);
                                var n = e.graphics.getMaterialInstance(0);
                                t.forceMergeBatches(n, e.spriteFrame, e.graphics)
                            } else e.graphics.updateAssembler(t)
                        }(e, t), Y$.enableMask())
                    }
                },
                Z$ = {
                    fillBuffers: function() {
                        Y$.exitMask()
                    }
                },
                Q$ = {
                    getAssembler: function() {
                        return K$
                    }
                },
                J$ = {
                    getAssembler: function() {
                        return Z$
                    }
                };
            vY.Assembler = Q$, vY.PostAssembler = J$;
            var $$ = new qs(null),
                e0 = new Bn,
                t0 = e("UI", function() {
                    var e = t.prototype;

                    function t(e) {
                        var t = this;
                        this.device = void 0, this._screens = [], this._bufferBatchPool = new $n((function() {
                            return new LZ(t)
                        }), 128), this._drawBatchPool = void 0, this._meshBuffers = new Map, this._customMeshBuffers = new Map, this._meshBufferUseCount = new Map, this._batches = void 0, this._doUploadBuffersCall = new Map, this._emptyMaterial = new nE, this._currScene = null, this._currMaterial = this._emptyMaterial, this._currTexture = null, this._currSampler = null, this._currMeshBuffer = null, this._currStaticRoot = null, this._currComponent = null, this._currTransform = null, this._currTextureHash = 0, this._currSamplerHash = 0, this._currBlendTargetHash = 0, this._currLayer = 0, this._currDepthStencilStateStage = null, this._currIsStatic = !1, this._descriptorSetCache = new i0, this._root = e, this.device = e.device, this._batches = new ei(64), this._drawBatchPool = new Jn((function() {
                            return new sQ
                        }), 128)
                    }
                    return e.acquireBufferBatch = function(e) {
                        void 0 === e && (e = MX);
                        var t = e === MX ? 36 : FX(e);
                        return this._currMeshBuffer && this._currMeshBuffer.vertexFormatBytes === t || this._requireBufferBatch(e), this._currMeshBuffer
                    }, e.registerCustomBuffer = function(e, t) {
                        var n;
                        e instanceof LZ ? n = e : (n = this._bufferBatchPool.add()).initialize(e, t || this._recreateMeshBuffer.bind(this, e));
                        var i = n.vertexFormatBytes,
                            r = this._customMeshBuffers.get(i);
                        return r || (r = [], this._customMeshBuffers.set(i, r)), r.push(n), n
                    }, e.unRegisterCustomBuffer = function(e) {
                        var t = this._customMeshBuffers.get(e.vertexFormatBytes);
                        if (t)
                            for (var n = 0; n < t.length; n++)
                                if (t[n] === e) {
                                    t.splice(n, 1);
                                    break
                                }
                    }, e.initialize = function() {
                        return !0
                    }, e.destroy = function() {
                        for (var e = this, t = 0; t < this._batches.length; t++) this._batches.array[t] && this._batches.array[t].destroy(this);
                        this._batches.destroy();
                        for (var n, i = te(this._meshBuffers.keys()); !(n = i()).done;) {
                            var r = n.value,
                                o = this._meshBuffers.get(r);
                            o && o.forEach((function(e) {
                                return e.destroy()
                            }))
                        }
                        this._drawBatchPool && this._drawBatchPool.destroy((function(t) {
                            t.destroy(e)
                        })), this._descriptorSetCache.destroy(), this._meshBuffers.clear(), Lj.sharedManager.destroy()
                    }, e.addScreen = function(e) {
                        this._screens.push(e), this._screens.sort(this._screenSort)
                    }, e.getFirstRenderCamera = function(e) {
                        if (e.scene && e.scene.renderScene)
                            for (var t = e.scene.renderScene.cameras, n = 0; n < t.length; n++) {
                                var i = t[n];
                                if (i.visibility & e.layer) return i
                            }
                        return null
                    }, e.removeScreen = function(e) {
                        var t = this._screens.indexOf(e); - 1 !== t && this._screens.splice(t, 1)
                    }, e.sortScreens = function() {
                        this._screens.sort(this._screenSort)
                    }, e.addUploadBuffersFunc = function(e, t) {
                        this._doUploadBuffersCall.set(e, t)
                    }, e.removeUploadBuffersFunc = function(e) {
                        this._doUploadBuffersCall.delete(e)
                    }, e.update = function() {
                        for (var e = this._screens, t = 0; t < e.length; ++t) {
                            var n = e[t];
                            n.enabledInHierarchy && this._recursiveScreenNode(n.node)
                        }
                        var i = 0;
                        if (this._batches.length)
                            for (var r = 0; r < this._batches.length; ++r) {
                                var o = this._batches.array[r];
                                if (o.renderScene) {
                                    if (o.model)
                                        for (var a = o.model.subModels, s = 0; s < a.length; s++) a[s].priority = i++;
                                    else o.hDescriptorSet = this._descriptorSetCache.getDescriptorSet(o);
                                    o.renderScene.addBatch(o)
                                }
                            }
                    }, e.uploadBuffers = function() {
                        var e = this;
                        this._batches.length > 0 && (this._doUploadBuffersCall.forEach((function(t, n) {
                            t.call(n, e)
                        })), this._meshBuffers.forEach((function(e) {
                            e.forEach((function(e) {
                                e.uploadBuffers(), e.reset()
                            }))
                        })), this._customMeshBuffers.forEach((function(e) {
                            e.forEach((function(e) {
                                e.uploadBuffers(), e.reset()
                            }))
                        })), this._descriptorSetCache.update())
                    }, e.reset = function() {
                        for (var e = 0; e < this._batches.length; ++e) {
                            var t = this._batches.array[e];
                            t.isStatic || (t.clear(), this._drawBatchPool.free(t))
                        }
                        this._currLayer = 0, this._currMaterial = this._emptyMaterial, this._currTexture = null, this._currSampler = null, this._currComponent = null, this._currTransform = null, this._currScene = null, this._currMeshBuffer = null, this._meshBufferUseCount.clear(), this._batches.clear(), Lj.sharedManager.reset(), this._descriptorSetCache.reset()
                    }, e.commitComp = function(e, t, n, i) {
                        var r, o, a = e,
                            s = 0,
                            c = 0;
                        t ? (r = t.getGFXTexture(), o = t.getGFXSampler(), s = t.getHash(), c = t.getSamplerHash()) : (r = null, o = null);
                        var l = a._getRenderScene(),
                            u = a.getRenderMaterial(0);
                        a.stencilStage = Lj.sharedManager.stage;
                        var h = a.blendHash,
                            _ = a.stencilStage;
                        this._currScene === l && this._currLayer === e.node.layer && this._currMaterial === u && this._currBlendTargetHash === h && this._currDepthStencilStateStage === _ && this._currTextureHash === s && this._currSamplerHash === c && this._currTransform === i || (this.autoMergeBatches(this._currComponent), this._currScene = l, this._currComponent = a, this._currTransform = i, this._currMaterial = u, this._currTexture = r, this._currSampler = o, this._currTextureHash = s, this._currSamplerHash = c, this._currBlendTargetHash = h, this._currDepthStencilStateStage = _, this._currLayer = e.node.layer), n && n.fillBuffers(a, this)
                    }, e.commitModel = function(e, t, n) {
                        var r;
                        this._currMaterial !== this._emptyMaterial && this.autoMergeBatches(this._currComponent);
                        var o = 0;
                        n && (e.stencilStage !== XW.ENABLED && e.stencilStage !== XW.DISABLED || (e.stencilStage = Lj.sharedManager.stage), r = Lj.sharedManager.getStencilStage(e.stencilStage, n), o = Lj.sharedManager.getStencilHash(e.stencilStage));
                        var a = i.director.getTotalFrames();
                        t && (t.updateTransform(a), t.updateUBOs(a));
                        for (var s = 0; s < t.subModels.length; s++) {
                            var c = this._drawBatchPool.alloc(),
                                l = t.subModels[s];
                            c.renderScene = e._getRenderScene(), c.visFlags = e.node.layer, c.model = t, c.bufferBatch = null, c.texture = null, c.sampler = null, c.useLocalData = null, r || (r = null), c.fillPasses(n, r, o, null, 0, l.patches), c.hDescriptorSet = Fr.get(l.handle, Dr.DESCRIPTOR_SET), c.hInputAssembler = Fr.get(l.handle, Dr.INPUT_ASSEMBLER), c.model.visFlags = c.visFlags, this._batches.push(c)
                        }
                        this._currMaterial = this._emptyMaterial, this._currScene = null, this._currComponent = null, this._currTransform = null, this._currTexture = null, this._currSampler = null, this._currTextureHash = 0, this._currSamplerHash = 0, this._currLayer = 0
                    }, e.commitStaticBatch = function(e) {
                        this._batches.concat(e.drawBatchList), this.finishMergeBatches()
                    }, e.autoMergeBatches = function(e) {
                        var t = this.currBufferBatch,
                            n = null == t ? void 0 : t.recordBatch(),
                            i = this._currMaterial;
                        if (n && i && t) {
                            var r, o, a = 0,
                                s = 0;
                            e && (r = -1 === e.blendHash ? null : e.getBlendState(), s = e.blendHash, o = null !== e.customMaterial ? Lj.sharedManager.getStencilStage(e.stencilStage, i) : Lj.sharedManager.getStencilStage(e.stencilStage), a = Lj.sharedManager.getStencilHash(e.stencilStage));
                            var c = this._currStaticRoot ? this._currStaticRoot._requireDrawBatch() : this._drawBatchPool.alloc();
                            c.renderScene = this._currScene, c.visFlags = this._currLayer, c.bufferBatch = t, c.texture = this._currTexture, c.sampler = this._currSampler, c.hInputAssembler = n, c.useLocalData = this._currTransform, c.textureHash = this._currTextureHash, c.samplerHash = this._currSamplerHash, c.fillPasses(i, o, a, r, s, null), this._batches.push(c), t.vertexStart = t.vertexOffset, t.indicesStart = t.indicesOffset, t.byteStart = t.byteOffset, oS.__isWebIOS14OrIPadOS14Env && !this._currIsStatic && (this._currMeshBuffer = null)
                        }
                    }, e.forceMergeBatches = function(e, t, n) {
                        this._currMaterial = e, t ? (this._currTexture = t.getGFXTexture(), this._currSampler = t.getGFXSampler(), this._currTextureHash = t.getHash(), this._currSamplerHash = t.getSamplerHash()) : (this._currTexture = this._currSampler = null, this._currTextureHash = this._currSamplerHash = 0), this._currLayer = n.node.layer, this._currScene = n._getRenderScene(), this.autoMergeBatches(n)
                    }, e.finishMergeBatches = function() {
                        this.autoMergeBatches(), this._currMaterial = this._emptyMaterial, this._currTexture = null, this._currComponent = null, this._currTransform = null, this._currTextureHash = 0, this._currSamplerHash = 0, this._currLayer = 0
                    }, e.flushMaterial = function(e) {
                        this._currMaterial = e
                    }, e.walk = function(e, t) {
                        void 0 === t && (t = 0);
                        var n = e.children.length;
                        if (this._preProcess(e), n > 0 && !e._static)
                            for (var i = e.children, r = 0; r < i.length; ++r) {
                                var o = i[r];
                                this.walk(o, t)
                            }
                        this._postProcess(e), t += 1
                    }, e._preProcess = function(e) {
                        var t = e._uiProps.uiComp;
                        if (!t) {
                            var n = e._uiProps.localOpacity;
                            e._uiProps.opacity = e.parent && e.parent._uiProps ? e.parent._uiProps.opacity * n : n
                        }
                        e._uiProps.uiTransformComp && t && t.enabledInHierarchy && t.updateAssembler(this)
                    }, e._postProcess = function(e) {
                        var t = e._uiProps.uiComp;
                        t && t.enabledInHierarchy && t.postUpdateAssembler(this)
                    }, e._recursiveScreenNode = function(e) {
                        this.walk(e), this.autoMergeBatches(this._currComponent)
                    }, e._createMeshBuffer = function(e) {
                        var t = this._bufferBatchPool.add();
                        t.initialize(e, this._recreateMeshBuffer.bind(this, e));
                        var n = FX(e),
                            i = this._meshBuffers.get(n);
                        return i || (i = [], this._meshBuffers.set(n, i)), i.push(t), t
                    }, e._recreateMeshBuffer = function(e, t, n) {
                        this.autoMergeBatches(), this._requireBufferBatch(e, t, n)
                    }, e._requireBufferBatch = function(e, t, n) {
                        var i = FX(e),
                            r = this._meshBuffers.get(i);
                        r || (r = [], this._meshBuffers.set(i, r));
                        var o = this._meshBufferUseCount.get(i) || 0;
                        o >= r.length ? this._currMeshBuffer = this._createMeshBuffer(e) : this._currMeshBuffer = r[o], this._meshBufferUseCount.set(i, o + 1), t && n && this._currMeshBuffer.request(t, n)
                    }, e._screenSort = function(e, t) {
                        return e.node.getSiblingIndex() - t.node.getSiblingIndex()
                    }, e._releaseDescriptorSetCache = function(e) {
                        this._descriptorSetCache.releaseDescriptorSetCache(e)
                    }, K(t, [{
                        key: "currBufferBatch",
                        get: function() {
                            return this._currMeshBuffer || (this._currMeshBuffer = this.acquireBufferBatch()), this._currMeshBuffer
                        },
                        set: function(e) {
                            e && (this._currMeshBuffer = e)
                        }
                    }, {
                        key: "batches",
                        get: function() {
                            return this._batches
                        }
                    }, {
                        key: "currStaticRoot",
                        set: function(e) {
                            this._currStaticRoot = e
                        }
                    }, {
                        key: "currIsStatic",
                        set: function(e) {
                            this._currIsStatic = e
                        }
                    }]), t
                }()),
                n0 = function() {
                    function e() {
                        this._handle = null, this._transform = null, this._textureHash = 0, this._samplerHash = 0, this._localBuffer = null, this._transformUpdate = !0;
                        var e = i.director.root.device;
                        this._localData = new Float32Array(Sh.COUNT), this._localBuffer = e.createBuffer(new gs(xa.UNIFORM | xa.TRANSFER_DST, Ra.HOST | Ra.DEVICE, Sh.SIZE, Sh.SIZE))
                    }
                    var t = e.prototype;
                    return t.initialize = function(e) {
                        var t = i.director.root.device;
                        this._transform = e.useLocalData, this._textureHash = e.textureHash, this._samplerHash = e.samplerHash, $$.layout = e.passes[0].localSetLayout, this._handle && (yr.free(this._handle), this._handle = null), this._handle = yr.alloc(t, $$), this._descriptorSet = yr.get(this._handle), this._descriptorSet.bindBuffer(Sh.BINDING, this._localBuffer);
                        var n = Gu.SAMPLER_SPRITE;
                        this._descriptorSet.bindTexture(n, e.texture), this._descriptorSet.bindSampler(n, e.sampler), this._descriptorSet.update(), this._transformUpdate = !0
                    }, t.updateTransform = function(e) {
                        e !== this._transform && (this._transform = e, this._transformUpdate = !0, this.uploadLocalData())
                    }, t.updateLocal = function() {
                        this._transform && this.uploadLocalData()
                    }, t.equals = function(e, t, n) {
                        return this._transform === e && this._textureHash === t && this._samplerHash === n
                    }, t.reset = function() {
                        this._transform = null, this._textureHash = 0, this._samplerHash = 0
                    }, t.destroy = function() {
                        this._localBuffer && (this._localBuffer.destroy(), this._localBuffer = null), this._handle && (yr.free(this._handle), this._handle = null), this._localData = null
                    }, t.uploadLocalData = function() {
                        var e = this._transform;
                        if ((e.hasChangedFlags || e._dirtyFlags) && e.updateWorldTransform(), this._transformUpdate) {
                            var t = e._mat;
                            Bn.toArray(this._localData, t, Sh.MAT_WORLD_OFFSET), Bn.inverseTranspose(e0, t), Bn.toArray(this._localData, e0, Sh.MAT_WORLD_IT_OFFSET), this._localBuffer.update(this._localData), this._transformUpdate = !1
                        }
                    }, K(e, [{
                        key: "handle",
                        get: function() {
                            return this._handle
                        }
                    }]), e
                }(),
                i0 = function() {
                    function e() {
                        this._descriptorSetCache = new Map, this._localDescriptorSetCache = [], this._localCachePool = void 0, this._localCachePool = new Jn((function() {
                            return new n0
                        }), 16)
                    }
                    var t = e.prototype;
                    return t.getDescriptorSet = function(e) {
                        var t = i.director.root;
                        if (e.useLocalData) {
                            for (var n = this._localDescriptorSetCache, r = 0, o = n.length; r < o; r++) {
                                var a = n[r];
                                if (a.equals(e.useLocalData, e.textureHash, e.samplerHash)) return a.handle
                            }
                            var s = this._localCachePool.alloc();
                            return s.initialize(e), this._localDescriptorSetCache.push(s), s.handle
                        }
                        var c = this._descriptorSetCache.get(e.textureHash);
                        if (c && c.has(e.samplerHash)) return c.get(e.samplerHash);
                        $$.layout = e.passes[0].localSetLayout;
                        var l = yr.alloc(t.device, $$),
                            u = yr.get(l),
                            h = Gu.SAMPLER_SPRITE;
                        return u.bindTexture(h, e.texture), u.bindSampler(h, e.sampler), u.update(), c ? this._descriptorSetCache.get(e.textureHash).set(e.samplerHash, l) : this._descriptorSetCache.set(e.textureHash, new Map([
                            [e.samplerHash, l]
                        ])), l
                    }, t.update = function() {
                        this._localDescriptorSetCache.forEach((function(e) {
                            e.updateLocal()
                        }))
                    }, t.reset = function() {
                        var e = this;
                        this._localDescriptorSetCache.forEach((function(t) {
                            e._localCachePool.free(t)
                        })), this._localDescriptorSetCache.length = 0
                    }, t.releaseDescriptorSetCache = function(e) {
                        this._descriptorSetCache.has(e) && (this._descriptorSetCache.get(e).forEach((function(e) {
                            yr.free(e)
                        })), this._descriptorSetCache.delete(e))
                    }, t.destroy = function() {
                        this._descriptorSetCache.forEach((function(e) {
                            e.forEach((function(e) {
                                yr.free(e)
                            }))
                        })), this._descriptorSetCache.clear(), this._localDescriptorSetCache.length = 0, this._localCachePool.destroy((function(e) {
                            e.destroy()
                        }))
                    }, e
                }();
            i.internal.Batcher2D = t0;
            var r0, o0, a0, s0, c0, l0, u0, h0, _0, f0, d0, p0, m0, g0, v0, y0, S0, E0, T0, A0, x0, C0, b0, R0, w0, I0, P0, O0, D0, N0, M0, L0, B0, F0, z0, U0, G0, H0, k0, V0, W0, j0, q0, X0, Y0, K0, Z0, Q0, J0, $0, e1, t1 = null,
                n1 = -1,
                i1 = "BES bswy:->@123",
                r1 = Object.create(null),
                o1 = [],
                a1 = 3e3;

            function s1() {
                for (var e = !0, t = Date.now(), n = o1.length - 1; n >= 0; n--) {
                    var i = o1[n],
                        r = i.fontFamilyName;
                    if (t - i.startTime > a1) x(4933, r), i.onComplete(null, r), o1.splice(n, 1);
                    else {
                        var o = i.refWidth,
                            a = "40px " + r;
                        t1.font = a, o !== PW(t1, i1, a) ? (o1.splice(n, 1), i.onComplete(null, r)) : e = !1
                    }
                }
                e && (clearInterval(n1), n1 = -1)
            }

            function c1(e, t, n) {
                var i = function(e) {
                    var t = e.lastIndexOf(".ttf");
                    if (-1 === t) return e;
                    var n, i = e.lastIndexOf("/");
                    return -1 !== (n = -1 === i ? e.substring(0, t) + "_LABEL" : e.substring(i + 1, t) + "_LABEL").indexOf(" ") && (n = '"' + n + '"'), n
                }(e);
                if (r1[i]) n(null, i);
                else {
                    if (!t1) {
                        var r = document.createElement("canvas");
                        r.width = 100, r.height = 100, t1 = r.getContext("2d")
                    }
                    var o = PW(t1, i1, "40px " + i),
                        a = document.createElement("style");
                    a.type = "text/css";
                    var s = "";
                    Number.isNaN(i) ? s += "@font-face { font-family:" + i + "; src:" : s += '@font-face { font-family:"' + i + '"; src:', s += 'url("' + e + '");', a.textContent = s + "}", document.body.appendChild(a);
                    var c = document.createElement("div"),
                        l = c.style;
                    if (l.fontFamily = i, c.innerHTML = ".", l.position = "absolute", l.left = "-100px", l.top = "-100px", document.body.appendChild(c), function() {
                            if (void 0 === r0)
                                if ("FontFace" in window) {
                                    var e = /Gecko.*Firefox\/(\d+)/.exec(window.navigator.userAgent),
                                        t = /OS X.*Version\/10\..*Safari/.exec(window.navigator.userAgent) && /Apple/.exec(window.navigator.vendor);
                                    r0 = e ? parseInt(e[1], 10) > 42 : !t
                                } else r0 = !1;
                            return r0
                        }()) ! function(e, t, n) {
                        var i = new Promise((function(n, i) {
                                ! function r() {
                                    Date.now() - e >= a1 ? i() : document.fonts.load("40px " + t).then((function(e) {
                                        e.length >= 1 ? n() : setTimeout(r, 100)
                                    }), (function() {
                                        i()
                                    }))
                                }()
                            })),
                            r = null,
                            o = new Promise((function(e, t) {
                                r = setTimeout(t, a1)
                            }));
                        Promise.race([o, i]).then((function() {
                            r && (clearTimeout(r), r = null), n(null, t)
                        }), (function() {
                            x(4933, t), n(null, t)
                        }))
                    }(Date.now(), i, n);
                    else {
                        var u = {
                            fontFamilyName: i,
                            refWidth: o,
                            onComplete: n,
                            startTime: Date.now()
                        };
                        o1.push(u), -1 === n1 && (n1 = setInterval(s1, 100))
                    }
                    r1[i] = a
                }
            }

            function l1(e, t, n, i) {
                var r = new _W;
                r._nativeUrl = e, r._nativeAsset = t, i(null, r)
            }
            oD.register({
                ".font": c1,
                ".eot": c1,
                ".ttf": c1,
                ".woff": c1,
                ".svg": c1,
                ".ttc": c1
            }), _D.register({
                ".font": l1,
                ".eot": l1,
                ".ttf": l1,
                ".woff": l1,
                ".svg": l1,
                ".ttc": l1
            }), i.UI = {
                MeshBuffer: LZ,
                spriteAssembler: X$,
                graphicsAssembler: YQ,
                labelAssembler: m$
            };
            var u1, h1, _1, f1 = new yn;
            ! function(e) {
                e[e.NONE = 0] = "NONE", e[e.COLOR = 1] = "COLOR", e[e.SPRITE = 2] = "SPRITE", e[e.SCALE = 3] = "SCALE"
            }(u1 || (u1 = {})), nt(u1),
                function(e) {
                    e.NORMAL = "normal", e.HOVER = "hover", e.PRESSED = "pressed", e.DISABLED = "disabled"
                }(h1 || (h1 = {})),
                function(e) {
                    e.CLICK = "click"
                }(_1 || (_1 = {}));
            var d1, p1, m1, g1 = function(t) {
                    return e({
                        Button: t,
                        ButtonComponent: t
                    }), t
                }((o0 = A_("cc.Button"), a0 = B_(), s0 = C_(110), c0 = D_(), l0 = x_(pj), u0 = ef(Yv), h0 = q_(), _0 = G_(), f0 = q_(), d0 = G_(), p0 = ef(u1), m0 = q_(), g0 = G_(), v0 = G_(), y0 = G_(), S0 = G_(), E0 = G_(), T0 = k_(), A0 = V_(), x0 = G_(), C0 = G_(), b0 = ef(KV), R0 = G_(), w0 = ef(KV), I0 = G_(), P0 = ef(KV), O0 = G_(), D0 = ef(KV), N0 = G_(), M0 = ef([uM]), L0 = q_(), B0 = G_(), o0(F0 = a0(F0 = s0(F0 = c0(F0 = l0(F0 = O_((e1 = $0 = function(e) {
                    function t() {
                        for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                        return ne(t = e.call.apply(e, [this].concat(i)) || this, "clickEvents", U0, $(t)), ne(t, "_interactable", G0, $(t)), ne(t, "_transition", H0, $(t)), ne(t, "_normalColor", k0, $(t)), ne(t, "_hoverColor", V0, $(t)), ne(t, "_pressedColor", W0, $(t)), ne(t, "_disabledColor", j0, $(t)), ne(t, "_normalSprite", q0, $(t)), ne(t, "_hoverSprite", X0, $(t)), ne(t, "_pressedSprite", Y0, $(t)), ne(t, "_disabledSprite", K0, $(t)), ne(t, "_duration", Z0, $(t)), ne(t, "_zoomScale", Q0, $(t)), ne(t, "_target", J0, $(t)), t._pressed = !1, t._hovered = !1, t._fromColor = new yn, t._toColor = new yn, t._time = 0, t._transitionFinished = !0, t._fromScale = new En, t._toScale = new En, t._originalScale = null, t._sprite = null, t._targetScale = new En, t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.__preload = function() {
                        this.target || (this.target = this.node);
                        var e = this.node.getComponent(zK);
                        e && (this._normalSprite = e.spriteFrame), this._applyTarget(), this._resetState()
                    }, n.onEnable = function() {
                        this._registerNodeEvent()
                    }, n.onDisable = function() {
                        this._resetState(), this._unregisterNodeEvent()
                    }, n.update = function(e) {
                        var t = this.target;
                        if (!this._transitionFinished && t && (this._transition === u1.COLOR || this._transition === u1.SCALE)) {
                            this._time += e;
                            var n = 1;
                            if (this._duration > 0 && (n = this._time / this._duration), n >= 1 && (n = 1), this._transition === u1.COLOR) {
                                var i = t._uiProps.uiComp;
                                yn.lerp(f1, this._fromColor, this._toColor, n), i && (i.color = f1)
                            } else this.transition === u1.SCALE && (t.getScale(this._targetScale), this._targetScale.x = nn(this._fromScale.x, this._toScale.x, n), this._targetScale.y = nn(this._fromScale.y, this._toScale.y, n), t.setScale(this._targetScale));
                            1 === n && (this._transitionFinished = !0)
                        }
                    }, n._resizeNodeToTargetNode = function() {
                        this.target && this.target._uiProps.uiTransformComp
                    }, n._resetState = function() {
                        this._pressed = !1, this._hovered = !1;
                        var e = this.target;
                        if (e) {
                            var t = e.getComponent(qq);
                            if (t) {
                                var n = this._transition;
                                n === u1.COLOR && this._interactable ? t.color = this._normalColor : n === u1.SCALE && this._originalScale && e.setScale(this._originalScale), this._transitionFinished = !0
                            }
                        }
                    }, n._registerNodeEvent = function() {
                        this.node.on(Om.TOUCH_START, this._onTouchBegan, this), this.node.on(Om.TOUCH_MOVE, this._onTouchMove, this), this.node.on(Om.TOUCH_END, this._onTouchEnded, this), this.node.on(Om.TOUCH_CANCEL, this._onTouchCancel, this), this.node.on(Om.MOUSE_ENTER, this._onMouseMoveIn, this), this.node.on(Om.MOUSE_LEAVE, this._onMouseMoveOut, this)
                    }, n._registerTargetEvent = function(e) {
                        e.on(Om.TRANSFORM_CHANGED, this._onTargetTransformChanged, this)
                    }, n._unregisterNodeEvent = function() {
                        this.node.off(Om.TOUCH_START, this._onTouchBegan, this), this.node.off(Om.TOUCH_MOVE, this._onTouchMove, this), this.node.off(Om.TOUCH_END, this._onTouchEnded, this), this.node.off(Om.TOUCH_CANCEL, this._onTouchCancel, this), this.node.off(Om.MOUSE_ENTER, this._onMouseMoveIn, this), this.node.off(Om.MOUSE_LEAVE, this._onMouseMoveOut, this)
                    }, n._unregisterTargetEvent = function(e) {
                        e.off(Om.TRANSFORM_CHANGED)
                    }, n._getTargetSprite = function(e) {
                        var t = null;
                        return e && (t = e.getComponent(zK)), t
                    }, n._applyTarget = function() {
                        this.target && (this._sprite = this._getTargetSprite(this.target), this._originalScale || (this._originalScale = new En), En.copy(this._originalScale, this.target.getScale()))
                    }, n._onTargetSpriteFrameChanged = function(e) {
                        this._transition === u1.SPRITE && this._setCurrentStateSpriteFrame(e.spriteFrame)
                    }, n._setCurrentStateSpriteFrame = function(e) {
                        if (e) switch (this._getButtonState()) {
                            case h1.NORMAL:
                                this._normalSprite = e;
                                break;
                            case h1.HOVER:
                                this._hoverSprite = e;
                                break;
                            case h1.PRESSED:
                                this._pressedSprite = e;
                                break;
                            case h1.DISABLED:
                                this._disabledSprite = e
                        }
                    }, n._onTargetColorChanged = function(e) {
                        this._transition === u1.COLOR && this._setCurrentStateColor(e)
                    }, n._setCurrentStateColor = function(e) {
                        switch (this._getButtonState()) {
                            case h1.NORMAL:
                                this._normalColor = e;
                                break;
                            case h1.HOVER:
                                this._hoverColor = e;
                                break;
                            case h1.PRESSED:
                                this._pressedColor = e;
                                break;
                            case h1.DISABLED:
                                this._disabledColor = e
                        }
                    }, n._onTargetTransformChanged = function(e) {
                        e | r_.SCALE && this._originalScale && this._transition === u1.SCALE && this._transitionFinished && En.copy(this._originalScale, this.target.getScale())
                    }, n._onTouchBegan = function(e) {
                        this._interactable && this.enabledInHierarchy && (this._pressed = !0, this._updateState(), e && (e.propagationStopped = !0))
                    }, n._onTouchMove = function(e) {
                        if (this._interactable && this.enabledInHierarchy && this._pressed && e) {
                            var t = e.touch;
                            if (t) {
                                var n, i = this.node._uiProps.uiTransformComp.isHit(t.getUILocation());
                                this._transition === u1.SCALE && this.target && this._originalScale ? i ? (En.copy(this._fromScale, this._originalScale), En.multiplyScalar(this._toScale, this._originalScale, this._zoomScale), this._transitionFinished = !1) : (this._time = 0, this._transitionFinished = !0, this.target.setScale(this._originalScale)) : (n = i ? h1.PRESSED : h1.NORMAL, this._applyTransition(n)), e && (e.propagationStopped = !0)
                            }
                        }
                    }, n._onTouchEnded = function(e) {
                        this._interactable && this.enabledInHierarchy && (this._pressed && (uM.emitEvents(this.clickEvents, e), this.node.emit(_1.CLICK, this)), this._pressed = !1, this._updateState(), e && (e.propagationStopped = !0))
                    }, n._onTouchCancel = function() {
                        this._interactable && this.enabledInHierarchy && (this._pressed = !1, this._updateState())
                    }, n._onMouseMoveIn = function() {
                        !this._pressed && this.interactable && this.enabledInHierarchy && (this._transition !== u1.SPRITE || this._hoverSprite) && (this._hovered || (this._hovered = !0, this._updateState()))
                    }, n._onMouseMoveOut = function() {
                        this._hovered && (this._hovered = !1, this._updateState())
                    }, n._updateState = function() {
                        var e = this._getButtonState();
                        this._applyTransition(e)
                    }, n._getButtonState = function() {
                        var e = h1.NORMAL;
                        return this._interactable ? this._pressed ? e = h1.PRESSED : this._hovered && (e = h1.HOVER) : e = h1.DISABLED, e.toString()
                    }, n._updateColorTransition = function(e) {
                        var t, n = this[e + "Color"],
                            i = null === (t = this.target) || void 0 === t ? void 0 : t.getComponent(qq);
                        i && (e === h1.DISABLED ? i.color = n : (this._fromColor = i.color.clone(), this._toColor = n, this._time = 0, this._transitionFinished = !1))
                    }, n._updateSpriteTransition = function(e) {
                        var t = this[e + "Sprite"];
                        this._sprite && t && (this._sprite.spriteFrame = t)
                    }, n._updateScaleTransition = function(e) {
                        this._interactable && (e === h1.PRESSED ? this._zoomUp() : this._zoomBack())
                    }, n._zoomUp = function() {
                        this._originalScale && (En.copy(this._fromScale, this._originalScale), En.multiplyScalar(this._toScale, this._originalScale, this._zoomScale), this._time = 0, this._transitionFinished = !1)
                    }, n._zoomBack = function() {
                        this.target && this._originalScale && (En.copy(this._fromScale, this.target.getScale()), En.copy(this._toScale, this._originalScale), this._time = 0, this._transitionFinished = !1)
                    }, n._applyTransition = function(e) {
                        var t = this._transition;
                        t === u1.COLOR ? this._updateColorTransition(e) : t === u1.SPRITE ? this._updateSpriteTransition(e) : t === u1.SCALE && this._updateScaleTransition(e)
                    }, K(t, [{
                        key: "target",
                        get: function() {
                            return this._target || this.node
                        },
                        set: function(e) {
                            this._target !== e && (this._target && this._unregisterTargetEvent(this._target), this._target = e, this._applyTarget())
                        }
                    }, {
                        key: "interactable",
                        get: function() {
                            return this._interactable
                        },
                        set: function(e) {
                            this._interactable = e, this._updateState(), this._interactable || this._resetState()
                        }
                    }, {
                        key: "_resizeToTarget",
                        set: function(e) {
                            e && this._resizeNodeToTargetNode()
                        }
                    }, {
                        key: "transition",
                        get: function() {
                            return this._transition
                        },
                        set: function(e) {
                            this._transition !== e && (this._transition === u1.COLOR ? this._updateColorTransition(h1.NORMAL) : this._transition === u1.SPRITE && this._updateSpriteTransition(h1.NORMAL), this._transition = e, this._updateState())
                        }
                    }, {
                        key: "normalColor",
                        get: function() {
                            return this._normalColor
                        },
                        set: function(e) {
                            this._normalColor !== e && (this._normalColor.set(e), this._updateState())
                        }
                    }, {
                        key: "pressedColor",
                        get: function() {
                            return this._pressedColor
                        },
                        set: function(e) {
                            this._pressedColor !== e && this._pressedColor.set(e)
                        }
                    }, {
                        key: "hoverColor",
                        get: function() {
                            return this._hoverColor
                        },
                        set: function(e) {
                            this._hoverColor !== e && this._hoverColor.set(e)
                        }
                    }, {
                        key: "disabledColor",
                        get: function() {
                            return this._disabledColor
                        },
                        set: function(e) {
                            this._disabledColor !== e && (this._disabledColor.set(e), this._updateState())
                        }
                    }, {
                        key: "duration",
                        get: function() {
                            return this._duration
                        },
                        set: function(e) {
                            this._duration !== e && (this._duration = e)
                        }
                    }, {
                        key: "zoomScale",
                        get: function() {
                            return this._zoomScale
                        },
                        set: function(e) {
                            this._zoomScale !== e && (this._zoomScale = e)
                        }
                    }, {
                        key: "normalSprite",
                        get: function() {
                            return this._normalSprite
                        },
                        set: function(e) {
                            if (this._normalSprite !== e) {
                                this._normalSprite = e;
                                var t = this.node.getComponent(zK);
                                t && (t.spriteFrame = e), this._updateState()
                            }
                        }
                    }, {
                        key: "pressedSprite",
                        get: function() {
                            return this._pressedSprite
                        },
                        set: function(e) {
                            this._pressedSprite !== e && (this._pressedSprite = e, this._updateState())
                        }
                    }, {
                        key: "hoverSprite",
                        get: function() {
                            return this._hoverSprite
                        },
                        set: function(e) {
                            this._hoverSprite !== e && (this._hoverSprite = e, this._updateState())
                        }
                    }, {
                        key: "disabledSprite",
                        get: function() {
                            return this._disabledSprite
                        },
                        set: function(e) {
                            this._disabledSprite !== e && (this._disabledSprite = e, this._updateState())
                        }
                    }]), t
                }(Jd), $0.Transition = u1, $0.EventType = _1, ie((z0 = e1).prototype, "target", [u0, h0, _0], Object.getOwnPropertyDescriptor(z0.prototype, "target"), z0.prototype), ie(z0.prototype, "interactable", [f0, d0], Object.getOwnPropertyDescriptor(z0.prototype, "interactable"), z0.prototype), ie(z0.prototype, "transition", [p0, m0, g0], Object.getOwnPropertyDescriptor(z0.prototype, "transition"), z0.prototype), ie(z0.prototype, "normalColor", [v0], Object.getOwnPropertyDescriptor(z0.prototype, "normalColor"), z0.prototype), ie(z0.prototype, "pressedColor", [y0], Object.getOwnPropertyDescriptor(z0.prototype, "pressedColor"), z0.prototype), ie(z0.prototype, "hoverColor", [S0], Object.getOwnPropertyDescriptor(z0.prototype, "hoverColor"), z0.prototype), ie(z0.prototype, "disabledColor", [E0], Object.getOwnPropertyDescriptor(z0.prototype, "disabledColor"), z0.prototype), ie(z0.prototype, "duration", [T0, A0, x0], Object.getOwnPropertyDescriptor(z0.prototype, "duration"), z0.prototype), ie(z0.prototype, "zoomScale", [C0], Object.getOwnPropertyDescriptor(z0.prototype, "zoomScale"), z0.prototype), ie(z0.prototype, "normalSprite", [b0, R0], Object.getOwnPropertyDescriptor(z0.prototype, "normalSprite"), z0.prototype), ie(z0.prototype, "pressedSprite", [w0, I0], Object.getOwnPropertyDescriptor(z0.prototype, "pressedSprite"), z0.prototype), ie(z0.prototype, "hoverSprite", [P0, O0], Object.getOwnPropertyDescriptor(z0.prototype, "hoverSprite"), z0.prototype), ie(z0.prototype, "disabledSprite", [D0, N0], Object.getOwnPropertyDescriptor(z0.prototype, "disabledSprite"), z0.prototype), U0 = ie(z0.prototype, "clickEvents", [M0, w_, L0, B0], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return []
                    }
                }), G0 = ie(z0.prototype, "_interactable", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return !0
                    }
                }), H0 = ie(z0.prototype, "_transition", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return u1.NONE
                    }
                }), k0 = ie(z0.prototype, "_normalColor", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return yn.WHITE.clone()
                    }
                }), V0 = ie(z0.prototype, "_hoverColor", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return new yn(211, 211, 211, 255)
                    }
                }), W0 = ie(z0.prototype, "_pressedColor", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return yn.WHITE.clone()
                    }
                }), j0 = ie(z0.prototype, "_disabledColor", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return new yn(124, 124, 124, 255)
                    }
                }), q0 = ie(z0.prototype, "_normalSprite", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return null
                    }
                }), X0 = ie(z0.prototype, "_hoverSprite", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return null
                    }
                }), Y0 = ie(z0.prototype, "_pressedSprite", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return null
                    }
                }), K0 = ie(z0.prototype, "_disabledSprite", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return null
                    }
                }), Z0 = ie(z0.prototype, "_duration", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return .1
                    }
                }), Q0 = ie(z0.prototype, "_zoomScale", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 1.2
                    }
                }), J0 = ie(z0.prototype, "_target", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return null
                    }
                }), F0 = z0)) || F0) || F0) || F0) || F0) || F0) || F0)),
                v1 = function() {
                    function e() {}
                    return e.add = function(e) {
                        var t = this._tabIndexList; - 1 === t.indexOf(e) && t.push(e)
                    }, e.remove = function(e) {
                        var t = this._tabIndexList,
                            n = t.indexOf(e); - 1 !== n && t.splice(n, 1)
                    }, e.resort = function() {
                        this._tabIndexList.sort((function(e, t) {
                            return e._delegate.tabIndex - t._delegate.tabIndex
                        }))
                    }, e.next = function(e) {
                        var t = this._tabIndexList,
                            n = t.indexOf(e);
                        if (e.setFocus(!1), -1 !== n) {
                            var i = t[n + 1];
                            i && i._delegate.tabIndex >= 0 && i.setFocus(!0)
                        }
                    }, e
                }();
            v1._tabIndexList = [],
                function(e) {
                    e[e.DEFAULT = 0] = "DEFAULT", e[e.DONE = 1] = "DONE", e[e.SEND = 2] = "SEND", e[e.SEARCH = 3] = "SEARCH", e[e.GO = 4] = "GO", e[e.NEXT = 5] = "NEXT"
                }(d1 || (d1 = {})), $e(d1),
                function(e) {
                    e[e.ANY = 0] = "ANY", e[e.EMAIL_ADDR = 1] = "EMAIL_ADDR", e[e.NUMERIC = 2] = "NUMERIC", e[e.PHONE_NUMBER = 3] = "PHONE_NUMBER", e[e.URL = 4] = "URL", e[e.DECIMAL = 5] = "DECIMAL", e[e.SINGLE_LINE = 6] = "SINGLE_LINE"
                }(p1 || (p1 = {})), $e(p1),
                function(e) {
                    e[e.PASSWORD = 0] = "PASSWORD", e[e.SENSITIVE = 1] = "SENSITIVE", e[e.INITIAL_CAPS_WORD = 2] = "INITIAL_CAPS_WORD", e[e.INITIAL_CAPS_SENTENCE = 3] = "INITIAL_CAPS_SENTENCE", e[e.INITIAL_CAPS_ALL_CHARACTERS = 4] = "INITIAL_CAPS_ALL_CHARACTERS", e[e.DEFAULT = 5] = "DEFAULT"
                }(m1 || (m1 = {})), $e(m1);
            var y1, S1, E1, T1, A1, x1, C1, b1, R1, w1, I1, P1, O1, D1, N1, M1, L1, B1, F1, z1, U1, G1, H1, k1, V1, W1, j1, q1, X1, Y1, K1, Z1, Q1, J1, $1, e2, t2, n2, i2, r2, o2, a2, s2, c2, l2, u2, h2, _2, f2, d2, p2, m2, g2, v2, y2, S2, E2, T2, A2, x2, C2, b2 = function() {
                    function e() {
                        this._editing = !1, this._delegate = null
                    }
                    var t = e.prototype;
                    return t.init = function() {}, t.onEnable = function() {}, t.update = function() {}, t.onDisable = function() {
                        this._editing && this.endEditing()
                    }, t.clear = function() {
                        this._delegate = null
                    }, t.setTabIndex = function() {}, t.setSize = function() {}, t.setFocus = function(e) {
                        e ? this.beginEditing() : this.endEditing()
                    }, t.isFocused = function() {
                        return this._editing
                    }, t.beginEditing = function() {}, t.endEditing = function() {}, e
                }(),
                R2 = new Bn,
                w2 = new Bn,
                I2 = new En,
                P2 = null,
                O2 = 0,
                D2 = function(e) {
                    function t() {
                        for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                        return (t = e.call.apply(e, [this].concat(i)) || this)._delegate = null, t._inputMode = -1, t._inputFlag = -1, t._returnType = -1, t.__eventListeners = {}, t.__fullscreen = !1, t.__autoResize = !1, t.__orientationChanged = void 0, t._edTxt = null, t._isTextArea = !1, t._textLabelFont = null, t._textLabelFontSize = null, t._textLabelFontColor = null, t._textLabelAlign = null, t._placeholderLabelFont = null, t._placeholderLabelFontSize = null, t._placeholderLabelFontColor = null, t._placeholderLabelAlign = null, t._placeholderLineHeight = null, t._placeholderStyleSheet = null, t._domId = "EditBoxId_" + ++O2, t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.init = function(e) {
                        e && (this._delegate = e, e.inputMode === p1.ANY ? this._createTextArea() : this._createInput(), v1.add(this), this.setTabIndex(e.tabIndex), this._initStyleSheet(), this._registerEventListeners(), this._addDomToGameContainer(), this.__fullscreen = QC.isAutoFullScreenEnabled(), this.__autoResize = QC._resizeWithBrowserSize)
                    }, n.clear = function() {
                        this._removeEventListeners(), this._removeDomFromGameContainer(), v1.remove(this), P2 === this && (P2 = null), this._delegate = null
                    }, n.update = function() {
                        this._updateMatrix()
                    }, n.setTabIndex = function(e) {
                        this._edTxt.tabIndex = e, v1.resort()
                    }, n.setSize = function(e, t) {
                        var n = this._edTxt;
                        n && (n.style.width = e + "px", n.style.height = t + "px")
                    }, n.beginEditing = function() {
                        P2 && P2 !== this && P2.setFocus(!1), this._editing = !0, P2 = this, this._delegate._editBoxEditingDidBegan(), this._showDom(), this._edTxt.focus()
                    }, n.endEditing = function() {
                        this._edTxt.blur()
                    }, n._createInput = function() {
                        this._isTextArea = !1, this._edTxt = document.createElement("input")
                    }, n._createTextArea = function() {
                        this._isTextArea = !0, this._edTxt = document.createElement("textarea")
                    }, n._addDomToGameContainer = function() {
                        i.GAME_VIEW && this._edTxt ? (i.gameView.container.appendChild(this._edTxt), i.gameView.head.appendChild(this._placeholderStyleSheet)) : WC.container && this._edTxt && (WC.container.appendChild(this._edTxt), document.head.appendChild(this._placeholderStyleSheet))
                    }, n._removeDomFromGameContainer = function() {
                        (i.GAME_VIEW ? _t(i.gameView.container, this._edTxt) : _t(WC.container, this._edTxt)) && this._edTxt && (i.GAME_VIEW ? i.gameView.container.removeChild(this._edTxt) : WC.container.removeChild(this._edTxt)), (i.GAME_VIEW ? _t(i.gameView.head, this._placeholderStyleSheet) : _t(document.head, this._placeholderStyleSheet)) && (i.GAME_VIEW ? i.gameView.head.removeChild(this._placeholderStyleSheet) : document.head.removeChild(this._placeholderStyleSheet)), this._edTxt = null, this._placeholderStyleSheet = null
                    }, n._showDom = function() {
                        this._updateMaxLength(), this._updateInputType(), this._updateStyleSheet(), this._edTxt && this._delegate && (this._edTxt.style.display = "", this._delegate._hideLabels()), oS.isMobile && this._showDomOnMobile()
                    }, n._hideDom = function() {
                        var e = this._edTxt;
                        e && this._delegate && (e.style.display = "none", this._delegate._showLabels()), oS.isMobile && this._hideDomOnMobile()
                    }, n._showDomOnMobile = function() {
                        Ei.os === gi.ANDROID && (this.__fullscreen && (QC.enableAutoFullScreen(!1), JC.exitFullScreen()), this.__autoResize && QC.resizeWithBrowserSize(!1), this._adjustWindowScroll())
                    }, n._hideDomOnMobile = function() {
                        var e = this;
                        Ei.os === gi.ANDROID && (this.__autoResize && QC.resizeWithBrowserSize(!0), setTimeout((function() {
                            P2 || e.__fullscreen && QC.enableAutoFullScreen(!0)
                        }), 400)), this._scrollBackWindow()
                    }, n._adjustWindowScroll = function() {
                        var e = this;
                        setTimeout((function() {
                            window.scrollY < 40 && e._edTxt.scrollIntoView({
                                block: "start",
                                inline: "nearest",
                                behavior: "smooth"
                            })
                        }), 400)
                    }, n._scrollBackWindow = function() {
                        setTimeout((function() {
                            Ei.browserType !== fi.WECHAT || Ei.os !== gi.IOS ? window.scrollTo(0, 0) : window.top && window.top.scrollTo(0, 0)
                        }), 400)
                    }, n._updateMatrix = function() {
                        if (this._edTxt) {
                            var e = this._delegate.node,
                                t = QC.getScaleX(),
                                n = QC.getScaleY(),
                                r = 1,
                                o = 1;
                            i.GAME_VIEW && (r = i.gameView.canvas.width / i.game.canvas.width, o = i.gameView.canvas.height / i.game.canvas.height), t *= r, n *= o;
                            var a = QC.getViewportRect(),
                                s = QC.getDevicePixelRatio();
                            e.getWorldMatrix(R2);
                            var c = e._uiProps.uiTransformComp;
                            if (c && En.set(I2, -c.anchorX * c.width, -c.anchorY * c.height, I2.z), Bn.transform(R2, R2, I2), e._uiProps.uiTransformComp) {
                                var l = RO.root.batcher2D.getFirstRenderCamera(e);
                                if (l) {
                                    l.node.getWorldRT(w2);
                                    var u = w2.m12,
                                        h = w2.m13,
                                        _ = jC.center;
                                    w2.m12 = _.x - (w2.m00 * u + w2.m04 * h), w2.m13 = _.y - (w2.m01 * u + w2.m05 * h), Bn.multiply(w2, w2, R2), t /= s, n /= s;
                                    var f = i.GAME_VIEW ? i.gameView.container : WC.container,
                                        d = w2.m00 * t,
                                        p = R2.m01,
                                        m = R2.m04,
                                        g = w2.m05 * n,
                                        v = parseInt(f && f.style.paddingLeft || "0");
                                    v += a.x * r / s;
                                    var y = parseInt(f && f.style.paddingBottom || "0");
                                    y += a.y / s;
                                    var S = "matrix(" + d + "," + -p + "," + -m + "," + g + "," + (w2.m12 * t + v) + "," + -(w2.m13 * n + y) + ")";
                                    this._edTxt.style.transform = S, this._edTxt.style["-webkit-transform"] = S, this._edTxt.style["transform-origin"] = "0px 100% 0px", this._edTxt.style["-webkit-transform-origin"] = "0px 100% 0px"
                                }
                            }
                        }
                    }, n._updateInputType = function() {
                        var e = this._delegate,
                            t = e.inputMode,
                            n = e.inputFlag,
                            i = e.returnType,
                            r = this._edTxt;
                        if (this._inputMode !== t || this._inputFlag !== n || this._returnType !== i) {
                            if (this._inputMode = t, this._inputFlag = n, this._returnType = i, this._isTextArea) {
                                var o = "none";
                                return n === m1.INITIAL_CAPS_ALL_CHARACTERS ? o = "uppercase" : n === m1.INITIAL_CAPS_WORD && (o = "capitalize"), void(r.style.textTransform = o)
                            }
                            if (r = r, n === m1.PASSWORD) return r.type = "password", void(r.style.textTransform = "none");
                            var a = r.type;
                            t === p1.EMAIL_ADDR ? a = "email" : t === p1.NUMERIC || t === p1.DECIMAL ? a = "number" : t === p1.PHONE_NUMBER ? (a = "number", r.pattern = "[0-9]*") : t === p1.URL ? a = "url" : (a = "text", i === d1.SEARCH && (a = "search")), r.type = a;
                            var s = "none";
                            n === m1.INITIAL_CAPS_ALL_CHARACTERS ? s = "uppercase" : n === m1.INITIAL_CAPS_WORD && (s = "capitalize"), r.style.textTransform = s
                        }
                    }, n._updateMaxLength = function() {
                        var e = this._delegate.maxLength;
                        e < 0 && (e = 65535), this._edTxt.maxLength = e
                    }, n._initStyleSheet = function() {
                        if (this._edTxt) {
                            var e = this._edTxt;
                            e.style.color = "#000000", e.style.border = "0px", e.style.background = "transparent", e.style.width = "100%", e.style.height = "100%", e.style.outline = "medium", e.style.padding = "0", e.style.textTransform = "none", e.style.display = "none", e.style.position = "absolute", e.style.bottom = "0px", e.style.left = "2px", e.className = "cocosEditBox", e.style.fontFamily = "Arial", e.id = this._domId, this._isTextArea ? (e.style.resize = "none", e.style.overflowY = "scroll") : ((e = e).type = "text", e.style["-moz-appearance"] = "textfield"), this._placeholderStyleSheet = document.createElement("style")
                        }
                    }, n._updateStyleSheet = function() {
                        var e = this._delegate,
                            t = this._edTxt;
                        t && e && (t.value = e.string, t.placeholder = e.placeholder, this._updateTextLabel(e.textLabel), this._updatePlaceholderLabel(e.placeholderLabel))
                    }, n._updateTextLabel = function(e) {
                        if (e) {
                            var t = e.font;
                            t = !t || t instanceof mW ? e.fontFamily : t._fontFamily;
                            var n = e.fontSize * e.node.scale.y;
                            if ((this._textLabelFont !== t || this._textLabelFontSize !== n || this._textLabelFontColor !== e.fontColor || this._textLabelAlign !== e.horizontalAlign) && (this._textLabelFont = t, this._textLabelFontSize = n, this._textLabelFontColor = e.fontColor, this._textLabelAlign = e.horizontalAlign, this._edTxt)) {
                                var i = this._edTxt;
                                switch (i.style.fontSize = n + "px", i.style.color = e.color.toCSS(), i.style.fontFamily = t, e.horizontalAlign) {
                                    case Zq.HorizontalAlign.LEFT:
                                        i.style.textAlign = "left";
                                        break;
                                    case Zq.HorizontalAlign.CENTER:
                                        i.style.textAlign = "center";
                                        break;
                                    case Zq.HorizontalAlign.RIGHT:
                                        i.style.textAlign = "right"
                                }
                            }
                        }
                    }, n._updatePlaceholderLabel = function(e) {
                        if (e) {
                            var t = e.font;
                            t = !t || t instanceof mW ? e.fontFamily : e.font._fontFamily;
                            var n = e.fontSize * e.node.scale.y;
                            if (this._placeholderLabelFont !== t || this._placeholderLabelFontSize !== n || this._placeholderLabelFontColor !== e.fontColor || this._placeholderLabelAlign !== e.horizontalAlign || this._placeholderLineHeight !== e.fontSize) {
                                this._placeholderLabelFont = t, this._placeholderLabelFontSize = n, this._placeholderLabelFontColor = e.fontColor, this._placeholderLabelAlign = e.horizontalAlign, this._placeholderLineHeight = e.fontSize;
                                var i = this._placeholderStyleSheet,
                                    r = e.color.toCSS(),
                                    o = e.fontSize,
                                    a = "";
                                switch (e.horizontalAlign) {
                                    case Zq.HorizontalAlign.LEFT:
                                        a = "left";
                                        break;
                                    case Zq.HorizontalAlign.CENTER:
                                        a = "center";
                                        break;
                                    case Zq.HorizontalAlign.RIGHT:
                                        a = "right"
                                }
                                i.innerHTML = "#" + this._domId + "::-webkit-input-placeholder{text-transform: initial;-family: " + t + ";font-size: " + n + "px;color: " + r + ";line-height: " + o + "px;text-align: " + a + ";}#" + this._domId + "::-moz-placeholder{text-transform: initial;-family: " + t + ";font-size: " + n + "px;color: " + r + ";line-height: " + o + "px;text-align: " + a + ";}#" + this._domId + "::-ms-input-placeholder{text-transform: initial;-family: " + t + ";font-size: " + n + "px;color: " + r + ";line-height: " + o + "px;text-align: " + a + ";}", Ei.browserType === fi.EDGE && (i.innerHTML += "#" + this._domId + "::-ms-clear{display: none;}")
                            }
                        }
                    }, n._registerEventListeners = function() {
                        var e = this;
                        if (this._edTxt) {
                            var t = this._edTxt,
                                n = !1,
                                i = this.__eventListeners;
                            i.compositionStart = function() {
                                n = !0
                            }, i.compositionEnd = function() {
                                n = !1, e._delegate._editBoxTextChanged(t.value)
                            }, i.onInput = function() {
                                if (!n) {
                                    var i = e._delegate,
                                        r = i.maxLength;
                                    r >= 0 && (t.value = t.value.slice(0, r)), i._editBoxTextChanged(t.value)
                                }
                            }, i.onClick = function() {
                                e._editing && oS.isMobile && e._adjustWindowScroll()
                            }, i.onKeydown = function(n) {
                                n.keyCode === rt.KEY.enter ? (n.propagationStopped = !0, e._delegate._editBoxEditingReturn(), e._isTextArea || t.blur()) : n.keyCode === rt.KEY.tab && (n.propagationStopped = !0, n.preventDefault(), v1.next(e))
                            }, i.onBlur = function() {
                                oS.isMobile && n && i.compositionEnd(), e._editing = !1, P2 = null, e._hideDom(), e._delegate._editBoxEditingDidEnded()
                            }, t.addEventListener("compositionstart", i.compositionStart), t.addEventListener("compositionend", i.compositionEnd), t.addEventListener("input", i.onInput), t.addEventListener("keydown", i.onKeydown), t.addEventListener("blur", i.onBlur), t.addEventListener("touchstart", i.onClick)
                        }
                    }, n._removeEventListeners = function() {
                        if (this._edTxt) {
                            var e = this._edTxt,
                                t = this.__eventListeners;
                            e.removeEventListener("compositionstart", t.compositionStart), e.removeEventListener("compositionend", t.compositionEnd), e.removeEventListener("input", t.onInput), e.removeEventListener("keydown", t.onKeydown), e.removeEventListener("blur", t.onBlur), e.removeEventListener("touchstart", t.onClick), t.compositionStart = null, t.compositionEnd = null, t.onInput = null, t.onKeydown = null, t.onBlur = null, t.onClick = null
                        }
                    }, t
                }(b2);
            ! function(e) {
                e.EDITING_DID_BEGAN = "editing-did-began", e.EDITING_DID_ENDED = "editing-did-ended", e.TEXT_CHANGED = "text-changed", e.EDITING_RETURN = "editing-return"
            }(C2 || (C2 = {}));
            var N2, M2, L2, B2, F2, z2, U2, G2, H2, k2, V2, W2, j2, q2, X2, Y2, K2, Z2, Q2, J2, $2, e4, t4, n4, i4, r4, o4, a4, s4, c4, l4, u4, h4, _4, f4, d4, p4, m4, g4, v4, y4, S4, E4, T4, A4, x4, C4, b4, R4, w4, I4, P4, O4, D4, N4 = function(t) {
                return e({
                    EditBox: t,
                    EditBoxComponent: t
                }), t
            }((y1 = A_("cc.EditBox"), S1 = B_(), E1 = C_(110), T1 = D_(), A1 = x_(pj), x1 = q_(), C1 = G_(), b1 = q_(), R1 = G_(), w1 = ef(Zq), I1 = q_(), P1 = G_(), O1 = ef(Zq), D1 = q_(), N1 = G_(), M1 = ef(KV), L1 = q_(), B1 = G_(), F1 = ef(m1), z1 = q_(), U1 = G_(), G1 = ef(p1), H1 = q_(), k1 = G_(), V1 = ef(d1), W1 = q_(), j1 = G_(), q1 = q_(), X1 = G_(), Y1 = q_(), K1 = G_(), Z1 = ef([uM]), Q1 = q_(), J1 = G_(), $1 = ef([uM]), e2 = q_(), t2 = G_(), n2 = ef([uM]), i2 = q_(), r2 = G_(), o2 = ef([uM]), a2 = q_(), s2 = G_(), y1(c2 = S1(c2 = E1(c2 = T1(c2 = A1(c2 = O_((x2 = A2 = function(e) {
                function t() {
                    for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                    return ne(t = e.call.apply(e, [this].concat(i)) || this, "editingDidBegan", u2, $(t)), ne(t, "textChanged", h2, $(t)), ne(t, "editingDidEnded", _2, $(t)), ne(t, "editingReturn", f2, $(t)), t._impl = null, t._background = null, ne(t, "_textLabel", d2, $(t)), ne(t, "_placeholderLabel", p2, $(t)), ne(t, "_returnType", m2, $(t)), ne(t, "_string", g2, $(t)), ne(t, "_tabIndex", v2, $(t)), ne(t, "_backgroundImage", y2, $(t)), ne(t, "_inputFlag", S2, $(t)), ne(t, "_inputMode", E2, $(t)), ne(t, "_maxLength", T2, $(t)), t._isLabelVisible = !1, t
                }
                Q(t, e);
                var n = t.prototype;
                return n.__preload = function() {
                    this._init()
                }, n.onEnable = function() {
                    this._registerEvent(), this._impl && this._impl.onEnable()
                }, n.update = function() {
                    this._impl && this._impl.update()
                }, n.onDisable = function() {
                    this._unregisterEvent(), this._impl && this._impl.onDisable()
                }, n.onDestroy = function() {
                    this._impl && this._impl.clear()
                }, n.setFocus = function() {
                    this._impl && this._impl.setFocus(!0)
                }, n.focus = function() {
                    this._impl && this._impl.setFocus(!0)
                }, n.blur = function() {
                    this._impl && this._impl.setFocus(!1)
                }, n.isFocused = function() {
                    return !!this._impl && this._impl.isFocused()
                }, n._editBoxEditingDidBegan = function() {
                    uM.emitEvents(this.editingDidBegan, this), this.node.emit(C2.EDITING_DID_BEGAN, this)
                }, n._editBoxEditingDidEnded = function() {
                    uM.emitEvents(this.editingDidEnded, this), this.node.emit(C2.EDITING_DID_ENDED, this)
                }, n._editBoxTextChanged = function(e) {
                    e = this._updateLabelStringStyle(e, !0), this.string = e, uM.emitEvents(this.textChanged, e, this), this.node.emit(C2.TEXT_CHANGED, this)
                }, n._editBoxEditingReturn = function() {
                    uM.emitEvents(this.editingReturn, this), this.node.emit(C2.EDITING_RETURN, this)
                }, n._showLabels = function() {
                    this._isLabelVisible = !0, this._updateLabels()
                }, n._hideLabels = function() {
                    this._isLabelVisible = !1, this._textLabel && (this._textLabel.node.active = !1), this._placeholderLabel && (this._placeholderLabel.node.active = !1)
                }, n._onTouchBegan = function(e) {
                    e.propagationStopped = !0
                }, n._onTouchCancel = function(e) {
                    e.propagationStopped = !0
                }, n._onTouchEnded = function(e) {
                    this._impl && this._impl.beginEditing(), e.propagationStopped = !0
                }, n._init = function() {
                    this._createBackgroundSprite(), this._updatePlaceholderLabel(), this._updateTextLabel(), this._isLabelVisible = !0, this.node.on(Om.SIZE_CHANGED, this._resizeChildNodes, this), (this._impl = new t._EditBoxImpl).init(this), this._updateString(this._string), this._syncSize()
                }, n._createBackgroundSprite = function() {
                    this._background || (this._background = this.node.getComponent(zK), this._background || (this._background = this.node.addComponent(zK))), this._background.type = zK.Type.SLICED, this._background.spriteFrame = this._backgroundImage
                }, n._updateTextLabel = function() {
                    var e = this._textLabel;
                    if (!e) {
                        var t = this.node.getChildByName("TEXT_LABEL");
                        t || (t = new Yv("TEXT_LABEL")), (e = t.getComponent(Zq)) || (e = t.addComponent(Zq)), t.parent = this.node, this._textLabel = e
                    }
                    this._textLabel.node._uiProps.uiTransformComp.setAnchorPoint(0, 1), e.overflow = Zq.Overflow.CLAMP, this._inputMode === p1.ANY ? (e.verticalAlign = Vq.TOP, e.enableWrapText = !0) : e.enableWrapText = !1, e.string = this._updateLabelStringStyle(this._string)
                }, n._updatePlaceholderLabel = function() {
                    var e = this._placeholderLabel;
                    if (!e) {
                        var t = this.node.getChildByName("PLACEHOLDER_LABEL");
                        t || (t = new Yv("PLACEHOLDER_LABEL")), (e = t.getComponent(Zq)) || (e = t.addComponent(Zq)), t.parent = this.node, this._placeholderLabel = e
                    }
                    this._placeholderLabel.node._uiProps.uiTransformComp.setAnchorPoint(0, 1), e.overflow = Zq.Overflow.CLAMP, this._inputMode === p1.ANY ? (e.verticalAlign = Vq.TOP, e.enableWrapText = !0) : e.enableWrapText = !1, e.string = this.placeholder
                }, n._syncSize = function() {
                    var e = this.node._uiProps.uiTransformComp,
                        t = e.contentSize;
                    if (this._background) {
                        var n = this._background.node._uiProps.uiTransformComp;
                        n.anchorPoint = e.anchorPoint, n.setContentSize(t)
                    }
                    this._updateLabelPosition(t), this._impl && this._impl.setSize(t.width, t.height)
                }, n._updateLabels = function() {
                    if (this._isLabelVisible) {
                        var e = this._string;
                        this._textLabel && (this._textLabel.node.active = "" !== e), this._placeholderLabel && (this._placeholderLabel.node.active = "" === e)
                    }
                }, n._updateString = function(e) {
                    var t = this._textLabel;
                    if (t) {
                        var n = e;
                        n && (n = this._updateLabelStringStyle(n)), t.string = n, this._updateLabels()
                    }
                }, n._updateLabelStringStyle = function(e, t) {
                    void 0 === t && (t = !1);
                    var n, i = this._inputFlag;
                    if (t || i !== m1.PASSWORD) i === m1.INITIAL_CAPS_ALL_CHARACTERS ? e = e.toUpperCase() : i === m1.INITIAL_CAPS_WORD ? e = e.replace(/(?:^|\s)\S/g, (function(e) {
                        return e.toUpperCase()
                    })) : i === m1.INITIAL_CAPS_SENTENCE && (e = (n = e).charAt(0).toUpperCase() + n.slice(1));
                    else {
                        for (var r = "", o = e.length, a = 0; a < o; ++a) r += "";
                        e = r
                    }
                    return e
                }, n._registerEvent = function() {
                    this.node.on(Om.TOUCH_START, this._onTouchBegan, this), this.node.on(Om.TOUCH_END, this._onTouchEnded, this)
                }, n._unregisterEvent = function() {
                    this.node.off(Om.TOUCH_START, this._onTouchBegan, this), this.node.off(Om.TOUCH_END, this._onTouchEnded, this)
                }, n._updateLabelPosition = function(e) {
                    var t = this.node._uiProps.uiTransformComp,
                        n = -t.anchorX * t.width,
                        i = -t.anchorY * t.height,
                        r = this._placeholderLabel,
                        o = this._textLabel;
                    o && (o.node._uiProps.uiTransformComp.setContentSize(e.width - 2, e.height), o.node.setPosition(n + 2, i + e.height, o.node.position.z), this._inputMode === p1.ANY && (o.verticalAlign = Vq.TOP), o.enableWrapText = this._inputMode === p1.ANY), r && (r.node._uiProps.uiTransformComp.setContentSize(e.width - 2, e.height), r.lineHeight = e.height, r.node.setPosition(n + 2, i + e.height, r.node.position.z), this._inputMode === p1.ANY && (r.verticalAlign = Vq.TOP), r.enableWrapText = this._inputMode === p1.ANY)
                }, n._resizeChildNodes = function() {
                    var e = this.node._uiProps.uiTransformComp,
                        t = this._textLabel && this._textLabel.node;
                    t && (t.setPosition(-e.width / 2, e.height / 2, t.position.z), t._uiProps.uiTransformComp.setContentSize(e.contentSize));
                    var n = this._placeholderLabel && this._placeholderLabel.node;
                    n && (n.setPosition(-e.width / 2, e.height / 2, n.position.z), n._uiProps.uiTransformComp.setContentSize(e.contentSize));
                    var i = this._background && this._background.node;
                    i && i._uiProps.uiTransformComp.setContentSize(e.contentSize)
                }, K(t, [{
                    key: "string",
                    get: function() {
                        return this._string
                    },
                    set: function(e) {
                        this._maxLength >= 0 && e.length >= this._maxLength && (e = e.slice(0, this._maxLength)), this._string = e, this._updateString(e)
                    }
                }, {
                    key: "placeholder",
                    get: function() {
                        return this._placeholderLabel ? this._placeholderLabel.string : ""
                    },
                    set: function(e) {
                        this._placeholderLabel && (this._placeholderLabel.string = e)
                    }
                }, {
                    key: "textLabel",
                    get: function() {
                        return this._textLabel
                    },
                    set: function(e) {
                        this._textLabel !== e && (this._textLabel = e, this._textLabel && (this._updateTextLabel(), this._updateLabels()))
                    }
                }, {
                    key: "placeholderLabel",
                    get: function() {
                        return this._placeholderLabel
                    },
                    set: function(e) {
                        this._placeholderLabel !== e && (this._placeholderLabel = e, this._placeholderLabel && (this._updatePlaceholderLabel(), this._updateLabels()))
                    }
                }, {
                    key: "backgroundImage",
                    get: function() {
                        return this._backgroundImage
                    },
                    set: function(e) {
                        this._backgroundImage !== e && (this._backgroundImage = e, this._createBackgroundSprite())
                    }
                }, {
                    key: "inputFlag",
                    get: function() {
                        return this._inputFlag
                    },
                    set: function(e) {
                        this._inputFlag = e, this._updateString(this._string)
                    }
                }, {
                    key: "inputMode",
                    get: function() {
                        return this._inputMode
                    },
                    set: function(e) {
                        this._inputMode !== e && (this._inputMode = e, this._updateTextLabel(), this._updatePlaceholderLabel())
                    }
                }, {
                    key: "returnType",
                    get: function() {
                        return this._returnType
                    },
                    set: function(e) {
                        this._returnType = e
                    }
                }, {
                    key: "maxLength",
                    get: function() {
                        return this._maxLength
                    },
                    set: function(e) {
                        this._maxLength = e
                    }
                }, {
                    key: "tabIndex",
                    get: function() {
                        return this._tabIndex
                    },
                    set: function(e) {
                        this._tabIndex !== e && (this._tabIndex = e, this._impl && this._impl.setTabIndex(e))
                    }
                }]), t
            }(Jd), A2._EditBoxImpl = b2, A2.KeyboardReturnType = d1, A2.InputFlag = m1, A2.InputMode = p1, A2.EventType = C2, ie((l2 = x2).prototype, "string", [x1, C1], Object.getOwnPropertyDescriptor(l2.prototype, "string"), l2.prototype), ie(l2.prototype, "placeholder", [b1, R1], Object.getOwnPropertyDescriptor(l2.prototype, "placeholder"), l2.prototype), ie(l2.prototype, "textLabel", [w1, I1, P1], Object.getOwnPropertyDescriptor(l2.prototype, "textLabel"), l2.prototype), ie(l2.prototype, "placeholderLabel", [O1, D1, N1], Object.getOwnPropertyDescriptor(l2.prototype, "placeholderLabel"), l2.prototype), ie(l2.prototype, "backgroundImage", [M1, L1, B1], Object.getOwnPropertyDescriptor(l2.prototype, "backgroundImage"), l2.prototype), ie(l2.prototype, "inputFlag", [F1, z1, U1], Object.getOwnPropertyDescriptor(l2.prototype, "inputFlag"), l2.prototype), ie(l2.prototype, "inputMode", [G1, H1, k1], Object.getOwnPropertyDescriptor(l2.prototype, "inputMode"), l2.prototype), ie(l2.prototype, "returnType", [V1, W1, j1], Object.getOwnPropertyDescriptor(l2.prototype, "returnType"), l2.prototype), ie(l2.prototype, "maxLength", [q1, X1], Object.getOwnPropertyDescriptor(l2.prototype, "maxLength"), l2.prototype), ie(l2.prototype, "tabIndex", [Y1, K1], Object.getOwnPropertyDescriptor(l2.prototype, "tabIndex"), l2.prototype), u2 = ie(l2.prototype, "editingDidBegan", [Z1, w_, Q1, J1], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return []
                }
            }), h2 = ie(l2.prototype, "textChanged", [$1, w_, e2, t2], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return []
                }
            }), _2 = ie(l2.prototype, "editingDidEnded", [n2, w_, i2, r2], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return []
                }
            }), f2 = ie(l2.prototype, "editingReturn", [o2, w_, a2, s2], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return []
                }
            }), d2 = ie(l2.prototype, "_textLabel", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return null
                }
            }), p2 = ie(l2.prototype, "_placeholderLabel", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return null
                }
            }), m2 = ie(l2.prototype, "_returnType", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return d1.DEFAULT
                }
            }), g2 = ie(l2.prototype, "_string", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return ""
                }
            }), v2 = ie(l2.prototype, "_tabIndex", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return 0
                }
            }), y2 = ie(l2.prototype, "_backgroundImage", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return null
                }
            }), S2 = ie(l2.prototype, "_inputFlag", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return m1.DEFAULT
                }
            }), E2 = ie(l2.prototype, "_inputMode", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return p1.ANY
                }
            }), T2 = ie(l2.prototype, "_maxLength", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return 20
                }
            }), c2 = l2)) || c2) || c2) || c2) || c2) || c2) || c2));
            "object" == typeof window && "object" == typeof document && (N4._EditBoxImpl = D2);
            var M4, L4, B4, F4, z4, U4, G4 = Om;
            ! function(e) {
                e[e.NONE = 0] = "NONE", e[e.HORIZONTAL = 1] = "HORIZONTAL", e[e.VERTICAL = 2] = "VERTICAL", e[e.GRID = 3] = "GRID"
            }(M4 || (M4 = {})), nt(M4),
                function(e) {
                    e[e.NONE = 0] = "NONE", e[e.CONTAINER = 1] = "CONTAINER", e[e.CHILDREN = 2] = "CHILDREN"
                }(L4 || (L4 = {})), nt(L4),
                function(e) {
                    e[e.HORIZONTAL = 0] = "HORIZONTAL", e[e.VERTICAL = 1] = "VERTICAL"
                }(B4 || (B4 = {})), nt(B4),
                function(e) {
                    e[e.BOTTOM_TO_TOP = 0] = "BOTTOM_TO_TOP", e[e.TOP_TO_BOTTOM = 1] = "TOP_TO_BOTTOM"
                }(F4 || (F4 = {})), nt(F4),
                function(e) {
                    e[e.LEFT_TO_RIGHT = 0] = "LEFT_TO_RIGHT", e[e.RIGHT_TO_LEFT = 1] = "RIGHT_TO_LEFT"
                }(z4 || (z4 = {})), nt(z4),
                function(e) {
                    e[e.NONE = 0] = "NONE", e[e.FIXED_ROW = 1] = "FIXED_ROW", e[e.FIXED_COL = 2] = "FIXED_COL"
                }(U4 || (U4 = {})), nt(U4);
            var H4, k4, V4, W4, j4, q4, X4, Y4, K4, Z4, Q4, J4, $4, e3, t3, n3, i3, r3, o3, a3, s3, c3, l3, u3 = new En,
                h3 = function(t) {
                    return e({
                        Layout: t,
                        LayoutComponent: t
                    }), t
                }((N2 = A_("cc.Layout"), M2 = B_(), L2 = C_(110), B2 = D_(), F2 = x_(pj), z2 = z_(), U2 = G_(), G2 = z_(), H2 = G_(), k2 = ef(M4), V2 = G_(), W2 = ef(L4), j2 = z_(), q2 = G_(), X2 = z_(), Y2 = G_(), K2 = ef(B4), Z2 = G_(), Q2 = G_(), J2 = G_(), $2 = G_(), e4 = G_(), t4 = G_(), n4 = G_(), i4 = ef(F4), r4 = G_(), o4 = ef(z4), a4 = G_(), s4 = ef(U4), c4 = z_(), l4 = G_(), u4 = z_(), h4 = G_(), _4 = G_(), N2(f4 = M2(f4 = L2(f4 = B2(f4 = F2(f4 = O_((D4 = O4 = function(e) {
                    function t() {
                        for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                        return ne(t = e.call.apply(e, [this].concat(i)) || this, "_resizeMode", p4, $(t)), ne(t, "_layoutType", m4, $(t)), ne(t, "_cellSize", g4, $(t)), ne(t, "_startAxis", v4, $(t)), ne(t, "_paddingLeft", y4, $(t)), ne(t, "_paddingRight", S4, $(t)), ne(t, "_paddingTop", E4, $(t)), ne(t, "_paddingBottom", T4, $(t)), ne(t, "_spacingX", A4, $(t)), ne(t, "_spacingY", x4, $(t)), ne(t, "_verticalDirection", C4, $(t)), ne(t, "_horizontalDirection", b4, $(t)), ne(t, "_constraint", R4, $(t)), ne(t, "_constraintNum", w4, $(t)), ne(t, "_affectedByScale", I4, $(t)), ne(t, "_isAlign", P4, $(t)), t._layoutSize = new Xn(300, 200), t._layoutDirty = !0, t._childrenDirty = !1, t._usefulLayoutObj = [], t._init = !1, t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.updateLayout = function(e) {
                        void 0 === e && (e = !1), (this._layoutDirty || e) && this.node.children.length > 0 && (this._doLayout(), this._layoutDirty = !1)
                    }, n.onEnable = function() {
                        this._addEventListeners();
                        var e = this.node._uiProps.uiTransformComp;
                        e.contentSize.equals(Xn.ZERO) && e.setContentSize(this._layoutSize), this._childrenChanged()
                    }, n.onDisable = function() {
                        this._usefulLayoutObj.length = 0, this._removeEventListeners()
                    }, n._checkUsefulObj = function() {
                        this._usefulLayoutObj.length = 0;
                        for (var e = this.node.children, t = 0; t < e.length; ++t) {
                            var n = e[t],
                                i = n._uiProps.uiTransformComp;
                            n.activeInHierarchy && i && this._usefulLayoutObj.push(i)
                        }
                    }, n._addEventListeners = function() {
                        RO.on(bO.EVENT_AFTER_UPDATE, this.updateLayout, this), this.node.on(G4.SIZE_CHANGED, this._resized, this), this.node.on(G4.ANCHOR_CHANGED, this._doLayoutDirty, this), this.node.on(G4.CHILD_ADDED, this._childAdded, this), this.node.on(G4.CHILD_REMOVED, this._childRemoved, this), this.node.on(G4.SIBLING_ORDER_CHANGED, this._childrenChanged, this), this.node.on("childrenSiblingOrderChanged", this.updateLayout, this), this._addChildrenEventListeners()
                    }, n._removeEventListeners = function() {
                        RO.off(bO.EVENT_AFTER_UPDATE, this.updateLayout, this), this.node.off(G4.SIZE_CHANGED, this._resized, this), this.node.off(G4.ANCHOR_CHANGED, this._doLayoutDirty, this), this.node.off(G4.CHILD_ADDED, this._childAdded, this), this.node.off(G4.CHILD_REMOVED, this._childRemoved, this), this.node.off(G4.SIBLING_ORDER_CHANGED, this._childrenChanged, this), this.node.off("childrenSiblingOrderChanged", this.updateLayout, this), this._removeChildrenEventListeners()
                    }, n._addChildrenEventListeners = function() {
                        for (var e = this.node.children, t = 0; t < e.length; ++t) {
                            var n = e[t];
                            n.on(G4.SIZE_CHANGED, this._doLayoutDirty, this), n.on(G4.TRANSFORM_CHANGED, this._transformDirty, this), n.on(G4.ANCHOR_CHANGED, this._doLayoutDirty, this), n.on("active-in-hierarchy-changed", this._childrenChanged, this)
                        }
                    }, n._removeChildrenEventListeners = function() {
                        for (var e = this.node.children, t = 0; t < e.length; ++t) {
                            var n = e[t];
                            n.off(G4.SIZE_CHANGED, this._doLayoutDirty, this), n.off(G4.TRANSFORM_CHANGED, this._transformDirty, this), n.off(G4.ANCHOR_CHANGED, this._doLayoutDirty, this), n.off("active-in-hierarchy-changed", this._childrenChanged, this)
                        }
                    }, n._childAdded = function(e) {
                        e.on(G4.SIZE_CHANGED, this._doLayoutDirty, this), e.on(G4.TRANSFORM_CHANGED, this._transformDirty, this), e.on(G4.ANCHOR_CHANGED, this._doLayoutDirty, this), e.on("active-in-hierarchy-changed", this._childrenChanged, this), this._childrenChanged()
                    }, n._childRemoved = function(e) {
                        e.off(G4.SIZE_CHANGED, this._doLayoutDirty, this), e.off(G4.TRANSFORM_CHANGED, this._transformDirty, this), e.off(G4.ANCHOR_CHANGED, this._doLayoutDirty, this), e.off("active-in-hierarchy-changed", this._childrenChanged, this), this._childrenChanged()
                    }, n._resized = function() {
                        this._layoutSize.set(this.node._uiProps.uiTransformComp.contentSize), this._doLayoutDirty()
                    }, n._doLayoutHorizontally = function(e, t, n, i) {
                        var r = this.node._uiProps.uiTransformComp.anchorPoint,
                            o = this._getFixedBreakingNum(),
                            a = 1,
                            s = this._paddingLeft;
                        this._horizontalDirection === z4.RIGHT_TO_LEFT && (a = -1, s = this._paddingRight);
                        var c = (this._horizontalDirection - r.x) * e + a * s,
                            l = c - a * this._spacingX,
                            u = 0,
                            h = 0,
                            _ = 0,
                            f = 0,
                            d = !1,
                            p = this._usefulLayoutObj.length,
                            m = this._cellSize.width,
                            g = this._getPaddingH();
                        this._layoutType !== M4.GRID && this._resizeMode === L4.CHILDREN && (m = (e - g - (p - 1) * this._spacingX) / p);
                        for (var v = this._usefulLayoutObj, y = 0; y < v.length; ++y) {
                            var S = v[y],
                                E = S.node,
                                T = E.scale,
                                A = this._getUsedScaleValue(T.x),
                                x = this._getUsedScaleValue(T.y);
                            this._resizeMode === L4.CHILDREN && (S.width = m / A, this._layoutType === M4.GRID && (S.height = this._cellSize.height / x));
                            var C = Math.abs(this._horizontalDirection - S.anchorX),
                                b = S.width * A,
                                R = S.height * x;
                            R > _ && (f = Math.max(_, f), h = _ || R, _ = R), l += a * (C * b + this._spacingX);
                            var w = a * (1 - C) * b;
                            if (t) {
                                if (o > 0)(d = y / o > 0 && y % o == 0) && (h = _ > R ? _ : h);
                                else if (b > e - g) l > c + a * C * b && (d = !0);
                                else {
                                    var I = (1 - this._horizontalDirection - r.x) * e,
                                        P = l + w + a * (a > 0 ? this._paddingRight : this._paddingLeft);
                                    d = Math.abs(P) > Math.abs(I)
                                }
                                d && (l = c + a * C * b, R !== _ && (h = _), u += h + this._spacingY, h = _ = R)
                            }
                            var O = n(E, S, u);
                            i && E.setPosition(l, O), l += w
                        }
                        return h = Math.max(h, _), Math.max(f, u + h) + this._getPaddingV()
                    }, n._doLayoutVertically = function(e, t, n, i) {
                        var r = this.node._uiProps.uiTransformComp.anchorPoint,
                            o = this._getFixedBreakingNum(),
                            a = 1,
                            s = this._paddingBottom;
                        this._verticalDirection === F4.TOP_TO_BOTTOM && (a = -1, s = this._paddingTop);
                        var c = (this._verticalDirection - r.y) * e + a * s,
                            l = c - a * this._spacingY,
                            u = 0,
                            h = 0,
                            _ = 0,
                            f = 0,
                            d = !1,
                            p = this._usefulLayoutObj.length,
                            m = this._cellSize.height,
                            g = this._getPaddingV();
                        this._layoutType !== M4.GRID && this._resizeMode === L4.CHILDREN && (m = (e - g - (p - 1) * this._spacingY) / p);
                        for (var v = this._usefulLayoutObj, y = 0; y < v.length; ++y) {
                            var S = v[y],
                                E = S.node,
                                T = E.scale,
                                A = this._getUsedScaleValue(T.x),
                                x = this._getUsedScaleValue(T.y);
                            this._resizeMode === L4.CHILDREN && (S.height = m / x, this._layoutType === M4.GRID && (S.width = this._cellSize.width / A));
                            var C = Math.abs(this._verticalDirection - S.anchorY),
                                b = S.width * A,
                                R = S.height * x;
                            b > u && (h = Math.max(u, h), _ = u || b, u = b), l += a * (C * R + this._spacingY);
                            var w = a * (1 - C) * R;
                            if (t) {
                                if (o > 0)(d = y / o > 0 && y % o == 0) && (_ = u > R ? u : _);
                                else if (R > e - g) l > c + a * C * R && (d = !0);
                                else {
                                    var I = (1 - this._verticalDirection - r.y) * e,
                                        P = l + w + a * (a > 0 ? this._paddingTop : this._paddingBottom);
                                    d = Math.abs(P) > Math.abs(I)
                                }
                                d && (l = c + a * C * R, b !== u && (_ = u), f += _ + this._spacingX, _ = u = b)
                            }
                            var O = n(E, S, f);
                            i && (E.getPosition(u3), E.setPosition(O, l, u3.z)), l += w
                        }
                        return _ = Math.max(_, u), Math.max(h, f + _) + this._getPaddingH()
                    }, n._doLayoutGridAxisHorizontal = function(e, t) {
                        var n = this,
                            i = t.width,
                            r = 1,
                            o = -e.y * t.height,
                            a = this._paddingBottom;
                        this._verticalDirection === F4.TOP_TO_BOTTOM && (r = -1, o = (1 - e.y) * t.height, a = this._paddingTop);
                        var s = function(e, t, i) {
                                return o + r * (i + (1 - t.anchorY) * t.height * n._getUsedScaleValue(e.scale.y) + a)
                            },
                            c = 0;
                        this._resizeMode === L4.CONTAINER && (c = this._doLayoutHorizontally(i, !0, s, !1), o = -e.y * c, this._verticalDirection === F4.TOP_TO_BOTTOM && (r = -1, o = (1 - e.y) * c)), this._doLayoutHorizontally(i, !0, s, !0), this._resizeMode === L4.CONTAINER && this.node._uiProps.uiTransformComp.setContentSize(i, c)
                    }, n._doLayoutGridAxisVertical = function(e, t) {
                        var n = this,
                            i = t.height,
                            r = 1,
                            o = -e.x * t.width,
                            a = this._paddingLeft;
                        this._horizontalDirection === z4.RIGHT_TO_LEFT && (r = -1, o = (1 - e.x) * t.width, a = this._paddingRight);
                        var s = function(e, t, i) {
                                return o + r * (i + (1 - t.anchorX) * t.width * n._getUsedScaleValue(e.scale.x) + a)
                            },
                            c = 0;
                        this._resizeMode === L4.CONTAINER && (c = this._doLayoutVertically(i, !0, s, !1), o = -e.x * c, this._horizontalDirection === z4.RIGHT_TO_LEFT && (r = -1, o = (1 - e.x) * c)), this._doLayoutVertically(i, !0, s, !0), this._resizeMode === L4.CONTAINER && this.node._uiProps.uiTransformComp.setContentSize(c, i)
                    }, n._doLayoutGrid = function() {
                        var e = this.node._uiProps.uiTransformComp,
                            t = e.anchorPoint,
                            n = e.contentSize;
                        this.startAxis === B4.HORIZONTAL ? this._doLayoutGridAxisHorizontal(t, n) : this.startAxis === B4.VERTICAL && this._doLayoutGridAxisVertical(t, n)
                    }, n._getHorizontalBaseWidth = function() {
                        var e = this._usefulLayoutObj,
                            t = 0,
                            n = e.length;
                        if (this._resizeMode === L4.CONTAINER) {
                            for (var i = 0; i < e.length; ++i) {
                                var r = e[i],
                                    o = r.node.scale;
                                t += r.width * this._getUsedScaleValue(o.x)
                            }
                            t += (n - 1) * this._spacingX + this._getPaddingH()
                        } else t = this.node._uiProps.uiTransformComp.width;
                        return t
                    }, n._getVerticalBaseHeight = function() {
                        var e = this._usefulLayoutObj,
                            t = 0,
                            n = e.length;
                        if (this._resizeMode === L4.CONTAINER) {
                            for (var i = 0; i < e.length; ++i) {
                                var r = e[i],
                                    o = r.node.scale;
                                t += r.height * this._getUsedScaleValue(o.y)
                            }
                            t += (n - 1) * this._spacingY + this._getPaddingV()
                        } else t = this.node._uiProps.uiTransformComp.height;
                        return t
                    }, n._doLayout = function() {
                        var e = this;
                        if (this._init && !this._childrenDirty || (this._checkUsefulObj(), this._init = !0, this._childrenDirty = !1), this._layoutType === M4.HORIZONTAL) {
                            var t = this._getHorizontalBaseWidth();
                            this._doLayoutHorizontally(t, !1, (function(t) {
                                return (e._isAlign ? En.ZERO : t.position).y
                            }), !0), this.node._uiProps.uiTransformComp.width = t
                        } else if (this._layoutType === M4.VERTICAL) {
                            var n = this._getVerticalBaseHeight();
                            this._doLayoutVertically(n, !1, (function(t) {
                                return (e._isAlign ? En.ZERO : t.position).x
                            }), !0), this.node._uiProps.uiTransformComp.height = n
                        } else this._layoutType === M4.GRID && this._doLayoutGrid()
                    }, n._getUsedScaleValue = function(e) {
                        return this._affectedByScale ? Math.abs(e) : 1
                    }, n._transformDirty = function(e) {
                        e & r_.SCALE && e & r_.POSITION && this._affectedByScale && this._doLayoutDirty()
                    }, n._doLayoutDirty = function() {
                        this._layoutDirty = !0
                    }, n._childrenChanged = function() {
                        this._childrenDirty = !0, this._doLayoutDirty()
                    }, n._getPaddingH = function() {
                        return this._paddingLeft + this._paddingRight
                    }, n._getPaddingV = function() {
                        return this._paddingTop + this._paddingBottom
                    }, n._getFixedBreakingNum = function() {
                        if (this._layoutType !== M4.GRID || this._constraint === U4.NONE || this._constraintNum <= 0) return 0;
                        var e = this._constraint === U4.FIXED_ROW ? Math.ceil(this._usefulLayoutObj.length / this._constraintNum) : this._constraintNum;
                        return this._startAxis === B4.VERTICAL && (e = this._constraint === U4.FIXED_COL ? Math.ceil(this._usefulLayoutObj.length / this._constraintNum) : this._constraintNum), e
                    }, K(t, [{
                        key: "alignHorizontal",
                        get: function() {
                            return this._isAlign
                        },
                        set: function(e) {
                            this._layoutType === M4.HORIZONTAL && (this._isAlign = e, this._doLayoutDirty())
                        }
                    }, {
                        key: "alignVertical",
                        get: function() {
                            return this._isAlign
                        },
                        set: function(e) {
                            this._layoutType === M4.VERTICAL && (this._isAlign = e, this._doLayoutDirty())
                        }
                    }, {
                        key: "type",
                        get: function() {
                            return this._layoutType
                        },
                        set: function(e) {
                            this._layoutType = e, this._doLayoutDirty()
                        }
                    }, {
                        key: "resizeMode",
                        get: function() {
                            return this._resizeMode
                        },
                        set: function(e) {
                            this._layoutType !== M4.NONE && (this._resizeMode = e, this._doLayoutDirty())
                        }
                    }, {
                        key: "cellSize",
                        get: function() {
                            return this._cellSize
                        },
                        set: function(e) {
                            this._cellSize !== e && (this._cellSize.set(e), this._doLayoutDirty())
                        }
                    }, {
                        key: "startAxis",
                        get: function() {
                            return this._startAxis
                        },
                        set: function(e) {
                            this._startAxis !== e && (this._startAxis = e, this._doLayoutDirty())
                        }
                    }, {
                        key: "paddingLeft",
                        get: function() {
                            return this._paddingLeft
                        },
                        set: function(e) {
                            this._paddingLeft !== e && (this._paddingLeft = e, this._doLayoutDirty())
                        }
                    }, {
                        key: "paddingRight",
                        get: function() {
                            return this._paddingRight
                        },
                        set: function(e) {
                            this._paddingRight !== e && (this._paddingRight = e, this._doLayoutDirty())
                        }
                    }, {
                        key: "paddingTop",
                        get: function() {
                            return this._paddingTop
                        },
                        set: function(e) {
                            this._paddingTop !== e && (this._paddingTop = e, this._doLayoutDirty())
                        }
                    }, {
                        key: "paddingBottom",
                        get: function() {
                            return this._paddingBottom
                        },
                        set: function(e) {
                            this._paddingBottom !== e && (this._paddingBottom = e, this._doLayoutDirty())
                        }
                    }, {
                        key: "spacingX",
                        get: function() {
                            return this._spacingX
                        },
                        set: function(e) {
                            this._spacingX !== e && (this._spacingX = e, this._doLayoutDirty())
                        }
                    }, {
                        key: "spacingY",
                        get: function() {
                            return this._spacingY
                        },
                        set: function(e) {
                            this._spacingY !== e && (this._spacingY = e, this._doLayoutDirty())
                        }
                    }, {
                        key: "verticalDirection",
                        get: function() {
                            return this._verticalDirection
                        },
                        set: function(e) {
                            this._verticalDirection !== e && (this._verticalDirection = e, this._doLayoutDirty())
                        }
                    }, {
                        key: "horizontalDirection",
                        get: function() {
                            return this._horizontalDirection
                        },
                        set: function(e) {
                            this._horizontalDirection !== e && (this._horizontalDirection = e, this._doLayoutDirty())
                        }
                    }, {
                        key: "padding",
                        get: function() {
                            return this._paddingLeft
                        },
                        set: function(e) {
                            this.paddingLeft === e && this._paddingRight === e && this._paddingTop === e && this._paddingBottom === e || (this._paddingLeft = this._paddingRight = this._paddingTop = this._paddingBottom = e, this._doLayoutDirty())
                        }
                    }, {
                        key: "constraint",
                        get: function() {
                            return this._constraint
                        },
                        set: function(e) {
                            this._layoutType !== M4.NONE && this._constraint !== e && (this._constraint = e, this._doLayoutDirty())
                        }
                    }, {
                        key: "constraintNum",
                        get: function() {
                            return this._constraintNum
                        },
                        set: function(e) {
                            this._constraint !== U4.NONE && this._constraintNum !== e && (e <= 0 && d("Limit values to be greater than 0"), this._constraintNum = e, this._doLayoutDirty())
                        }
                    }, {
                        key: "affectedByScale",
                        get: function() {
                            return this._affectedByScale
                        },
                        set: function(e) {
                            this._affectedByScale = e, this._doLayoutDirty()
                        }
                    }]), t
                }(Jd), O4.Type = M4, O4.VerticalDirection = F4, O4.HorizontalDirection = z4, O4.ResizeMode = L4, O4.AxisDirection = B4, O4.Constraint = U4, ie((d4 = D4).prototype, "alignHorizontal", [z2, U2], Object.getOwnPropertyDescriptor(d4.prototype, "alignHorizontal"), d4.prototype), ie(d4.prototype, "alignVertical", [G2, H2], Object.getOwnPropertyDescriptor(d4.prototype, "alignVertical"), d4.prototype), ie(d4.prototype, "type", [k2, V2], Object.getOwnPropertyDescriptor(d4.prototype, "type"), d4.prototype), ie(d4.prototype, "resizeMode", [W2, j2, q2], Object.getOwnPropertyDescriptor(d4.prototype, "resizeMode"), d4.prototype), ie(d4.prototype, "cellSize", [X2, Y2], Object.getOwnPropertyDescriptor(d4.prototype, "cellSize"), d4.prototype), ie(d4.prototype, "startAxis", [K2, Z2], Object.getOwnPropertyDescriptor(d4.prototype, "startAxis"), d4.prototype), ie(d4.prototype, "paddingLeft", [Q2], Object.getOwnPropertyDescriptor(d4.prototype, "paddingLeft"), d4.prototype), ie(d4.prototype, "paddingRight", [J2], Object.getOwnPropertyDescriptor(d4.prototype, "paddingRight"), d4.prototype), ie(d4.prototype, "paddingTop", [$2], Object.getOwnPropertyDescriptor(d4.prototype, "paddingTop"), d4.prototype), ie(d4.prototype, "paddingBottom", [e4], Object.getOwnPropertyDescriptor(d4.prototype, "paddingBottom"), d4.prototype), ie(d4.prototype, "spacingX", [t4], Object.getOwnPropertyDescriptor(d4.prototype, "spacingX"), d4.prototype), ie(d4.prototype, "spacingY", [n4], Object.getOwnPropertyDescriptor(d4.prototype, "spacingY"), d4.prototype), ie(d4.prototype, "verticalDirection", [i4, r4], Object.getOwnPropertyDescriptor(d4.prototype, "verticalDirection"), d4.prototype), ie(d4.prototype, "horizontalDirection", [o4, a4], Object.getOwnPropertyDescriptor(d4.prototype, "horizontalDirection"), d4.prototype), ie(d4.prototype, "constraint", [s4, c4, l4], Object.getOwnPropertyDescriptor(d4.prototype, "constraint"), d4.prototype), ie(d4.prototype, "constraintNum", [u4, h4], Object.getOwnPropertyDescriptor(d4.prototype, "constraintNum"), d4.prototype), ie(d4.prototype, "affectedByScale", [_4], Object.getOwnPropertyDescriptor(d4.prototype, "affectedByScale"), d4.prototype), p4 = ie(d4.prototype, "_resizeMode", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return L4.NONE
                    }
                }), m4 = ie(d4.prototype, "_layoutType", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return M4.NONE
                    }
                }), g4 = ie(d4.prototype, "_cellSize", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return new Xn(40, 40)
                    }
                }), v4 = ie(d4.prototype, "_startAxis", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return B4.HORIZONTAL
                    }
                }), y4 = ie(d4.prototype, "_paddingLeft", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 0
                    }
                }), S4 = ie(d4.prototype, "_paddingRight", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 0
                    }
                }), E4 = ie(d4.prototype, "_paddingTop", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 0
                    }
                }), T4 = ie(d4.prototype, "_paddingBottom", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 0
                    }
                }), A4 = ie(d4.prototype, "_spacingX", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 0
                    }
                }), x4 = ie(d4.prototype, "_spacingY", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 0
                    }
                }), C4 = ie(d4.prototype, "_verticalDirection", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return F4.TOP_TO_BOTTOM
                    }
                }), b4 = ie(d4.prototype, "_horizontalDirection", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return z4.LEFT_TO_RIGHT
                    }
                }), R4 = ie(d4.prototype, "_constraint", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return U4.NONE
                    }
                }), w4 = ie(d4.prototype, "_constraintNum", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 2
                    }
                }), I4 = ie(d4.prototype, "_affectedByScale", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return !1
                    }
                }), P4 = ie(d4.prototype, "_isAlign", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return !1
                    }
                }), f4 = d4)) || f4) || f4) || f4) || f4) || f4) || f4));
            ! function(e) {
                e[e.HORIZONTAL = 0] = "HORIZONTAL", e[e.VERTICAL = 1] = "VERTICAL", e[e.FILLED = 2] = "FILLED"
            }(l3 || (l3 = {})), $e(l3);
            var _3, f3, d3, p3, m3, g3, v3, y3, S3, E3, T3, A3, x3, C3, b3, R3, w3, I3, P3, O3, D3, N3, M3, L3, B3, F3 = function(t) {
                    return e({
                        ProgressBar: t,
                        ProgressBarComponent: t
                    }), t
                }((H4 = A_("cc.ProgressBar"), k4 = B_(), V4 = C_(110), W4 = D_(), j4 = x_(pj), q4 = ef(zK), X4 = G_(), Y4 = ef(l3), K4 = G_(), Z4 = G_(), Q4 = H_(), J4 = G_(), $4 = G_(), H4(e3 = k4(e3 = V4(e3 = W4(e3 = j4((c3 = s3 = function(e) {
                    function t() {
                        for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                        return ne(t = e.call.apply(e, [this].concat(i)) || this, "_barSprite", n3, $(t)), ne(t, "_mode", i3, $(t)), ne(t, "_totalLength", r3, $(t)), ne(t, "_progress", o3, $(t)), ne(t, "_reverse", a3, $(t)), t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n._initBarSprite = function() {
                        if (this._barSprite) {
                            var e = this._barSprite.node;
                            if (!e) return;
                            var t = this.node._uiProps.uiTransformComp,
                                n = t.contentSize,
                                i = t.anchorPoint,
                                r = e._uiProps.uiTransformComp.contentSize;
                            if (this._barSprite.fillType === zK.FillType.RADIAL && (this._mode = l3.FILLED), this._mode === l3.HORIZONTAL ? this.totalLength = r.width : this._mode === l3.VERTICAL ? this.totalLength = r.height : this.totalLength = this._barSprite.fillRange, e.parent === this.node) {
                                var o = -n.width * i.x;
                                e.setPosition(o, 0, 0)
                            }
                        }
                    }, n._updateBarStatus = function() {
                        if (this._barSprite) {
                            var e = this._barSprite.node;
                            if (!e) return;
                            var t = e._uiProps.uiTransformComp,
                                n = t.anchorPoint,
                                i = t.contentSize,
                                r = e.getPosition(),
                                o = new Gn(0, .5),
                                a = tn(this._progress),
                                s = this._totalLength * a,
                                c = i,
                                l = 0,
                                u = 0;
                            switch (this._mode) {
                                case l3.HORIZONTAL:
                                    this._reverse && (o = new Gn(1, .5)), c = new Xn(s, i.height), l = this._totalLength, u = i.height;
                                    break;
                                case l3.VERTICAL:
                                    o = this._reverse ? new Gn(.5, 1) : new Gn(.5, 0), c = new Xn(i.width, s), l = i.width, u = this._totalLength
                            }
                            if (this._mode === l3.FILLED) this._barSprite.type !== zK.Type.FILLED ? d("ProgressBar FILLED mode only works when barSprite's Type is FILLED!") : (this._reverse && (s *= -1), this._barSprite.fillRange = s);
                            else if (this._barSprite.type !== zK.Type.FILLED) {
                                var h = o.x - n.x,
                                    _ = o.y - n.y,
                                    f = new En(l * h, u * _, 0);
                                e.setPosition(r.x + f.x, r.y + f.y, r.z), t.setAnchorPoint(o), t.setContentSize(c)
                            } else d("ProgressBar non-FILLED mode only works when barSprite's Type is non-FILLED!")
                        }
                    }, K(t, [{
                        key: "barSprite",
                        get: function() {
                            return this._barSprite
                        },
                        set: function(e) {
                            this._barSprite !== e && (this._barSprite = e, this._initBarSprite())
                        }
                    }, {
                        key: "mode",
                        get: function() {
                            return this._mode
                        },
                        set: function(e) {
                            if (this._mode !== e && (this._mode = e, this._barSprite)) {
                                var t = this._barSprite.node;
                                if (!t) return;
                                var n = t._uiProps.uiTransformComp.contentSize;
                                this._mode === l3.HORIZONTAL ? this.totalLength = n.width : this._mode === l3.VERTICAL ? this.totalLength = n.height : this._mode === l3.FILLED && (this.totalLength = this._barSprite.fillRange)
                            }
                        }
                    }, {
                        key: "totalLength",
                        get: function() {
                            return this._totalLength
                        },
                        set: function(e) {
                            this._mode === l3.FILLED && (e = tn(e)), this._totalLength = e, this._updateBarStatus()
                        }
                    }, {
                        key: "progress",
                        get: function() {
                            return this._progress
                        },
                        set: function(e) {
                            this._progress !== e && (this._progress = e, this._updateBarStatus())
                        }
                    }, {
                        key: "reverse",
                        get: function() {
                            return this._reverse
                        },
                        set: function(e) {
                            this._reverse !== e && (this._reverse = e, this._barSprite && (this._barSprite.fillStart = 1 - this._barSprite.fillStart), this._updateBarStatus())
                        }
                    }]), t
                }(Jd), s3.Mode = l3, ie((t3 = c3).prototype, "barSprite", [q4, X4], Object.getOwnPropertyDescriptor(t3.prototype, "barSprite"), t3.prototype), ie(t3.prototype, "mode", [Y4, K4], Object.getOwnPropertyDescriptor(t3.prototype, "mode"), t3.prototype), ie(t3.prototype, "totalLength", [Z4], Object.getOwnPropertyDescriptor(t3.prototype, "totalLength"), t3.prototype), ie(t3.prototype, "progress", [Q4, j_, J4], Object.getOwnPropertyDescriptor(t3.prototype, "progress"), t3.prototype), ie(t3.prototype, "reverse", [$4], Object.getOwnPropertyDescriptor(t3.prototype, "reverse"), t3.prototype), n3 = ie(t3.prototype, "_barSprite", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return null
                    }
                }), i3 = ie(t3.prototype, "_mode", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return l3.HORIZONTAL
                    }
                }), r3 = ie(t3.prototype, "_totalLength", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 1
                    }
                }), o3 = ie(t3.prototype, "_progress", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return .1
                    }
                }), a3 = ie(t3.prototype, "_reverse", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return !1
                    }
                }), e3 = t3)) || e3) || e3) || e3) || e3) || e3)),
                z3 = new En,
                U3 = new En,
                G3 = new En,
                H3 = new Gn,
                k3 = new yn,
                V3 = new Gn;
            ! function(e) {
                e[e.HORIZONTAL = 0] = "HORIZONTAL", e[e.VERTICAL = 1] = "VERTICAL"
            }(B3 || (B3 = {})), nt(B3);
            var W3, j3, q3, X3, Y3, K3, Z3, Q3, J3, $3, e5, t5, n5, i5, r5, o5, a5, s5, c5, l5, u5, h5, _5, f5, d5, p5, m5, g5, v5, y5, S5, E5, T5, A5, x5, C5, b5, R5, w5, I5, P5, O5, D5, N5, M5, L5, B5, F5, z5, U5 = function(t) {
                    return e({
                        ScrollBar: t,
                        ScrollBarComponent: t
                    }), t
                }((_3 = A_("cc.ScrollBar"), f3 = B_(), d3 = C_(110), p3 = D_(), m3 = x_(pj), g3 = ef(zK), v3 = q_(), y3 = G_(), S3 = ef(B3), E3 = q_(), T3 = G_(), A3 = q_(), x3 = G_(), C3 = q_(), b3 = G_(), _3(R3 = f3(R3 = d3(R3 = p3(R3 = m3((L3 = M3 = function(e) {
                    function t() {
                        for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                        return ne(t = e.call.apply(e, [this].concat(i)) || this, "_scrollView", I3, $(t)), ne(t, "_handle", P3, $(t)), ne(t, "_direction", O3, $(t)), ne(t, "_enableAutoHide", D3, $(t)), ne(t, "_autoHideTime", N3, $(t)), t._touching = !1, t._opacity = 255, t._autoHideRemainingTime = 0, t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.hide = function() {
                        this._autoHideRemainingTime = 0, this._setOpacity(0)
                    }, n.show = function() {
                        this._autoHideRemainingTime = this._autoHideTime, this._setOpacity(this._opacity)
                    }, n.onScroll = function(e) {
                        if (this._scrollView) {
                            var t = this._scrollView.content;
                            if (t) {
                                var n = t._uiProps.uiTransformComp.contentSize,
                                    i = this._scrollView.node._uiProps.uiTransformComp.contentSize,
                                    r = this.node._uiProps.uiTransformComp.contentSize;
                                if (!this._conditionalDisableScrollBar(n, i)) {
                                    this._enableAutoHide && (this._autoHideRemainingTime = this._autoHideTime, this._setOpacity(this._opacity));
                                    var o = 0,
                                        a = 0,
                                        s = 0,
                                        c = 0,
                                        l = 0,
                                        u = V3;
                                    u.set(0, 0), this._direction === B3.HORIZONTAL ? (o = n.width, a = i.width, l = r.width, s = e.x, this._convertToScrollViewSpace(u, t), c = -u.x) : this._direction === B3.VERTICAL && (o = n.height, a = i.height, l = r.height, s = e.y, this._convertToScrollViewSpace(u, t), c = -u.y);
                                    var h = this._calculateLength(o, a, l, s),
                                        _ = V3;
                                    this._calculatePosition(_, o, a, l, c, s, h), this._updateLength(h), this._updateHandlerPosition(_)
                                }
                            }
                        }
                    }, n.setScrollView = function(e) {
                        this._scrollView = e
                    }, n.onTouchBegan = function() {
                        this._enableAutoHide && (this._touching = !0)
                    }, n.onTouchEnded = function() {
                        if (this._enableAutoHide && (this._touching = !1, !(this._autoHideTime <= 0))) {
                            if (this._scrollView) {
                                var e = this._scrollView.content;
                                if (e) {
                                    var t = e._uiProps.uiTransformComp.contentSize,
                                        n = this._scrollView.node._uiProps.uiTransformComp.contentSize;
                                    if (this._conditionalDisableScrollBar(t, n)) return
                                }
                            }
                            this._autoHideRemainingTime = this._autoHideTime
                        }
                    }, n.onEnable = function() {
                        var e = this.node.getComponent(zK);
                        e && (this._opacity = e.color.a)
                    }, n.start = function() {
                        this._enableAutoHide && this._setOpacity(0)
                    }, n.update = function(e) {
                        this._processAutoHide(e)
                    }, n._convertToScrollViewSpace = function(e, t) {
                        var n = this._scrollView && this._scrollView.node._uiProps.uiTransformComp,
                            i = t._uiProps.uiTransformComp;
                        if (n && i) {
                            z3.set(-i.anchorX * i.width, -i.anchorY * i.height, 0), i.convertToWorldSpaceAR(z3, U3);
                            var r = n.convertToNodeSpaceAR(U3);
                            r.x += n.anchorX * n.width, r.y += n.anchorY * n.height, e.set(r.x, r.y)
                        } else e.set(Gn.ZERO)
                    }, n._setOpacity = function(e) {
                        if (this._handle) {
                            var t = this.node.getComponent(zK);
                            t && (k3.set(t.color), k3.a = e, t.color = k3), (t = this._handle.getComponent(zK)) && (k3.set(t.color), k3.a = e, t.color = k3)
                        }
                    }, n._updateHandlerPosition = function(e) {
                        if (this._handle) {
                            var t = G3;
                            this._fixupHandlerPosition(t), this._handle.node.setPosition(e.x + t.x, e.y + t.y, t.z)
                        }
                    }, n._fixupHandlerPosition = function(e) {
                        var t = this.node._uiProps.uiTransformComp,
                            n = t.contentSize,
                            i = t.anchorPoint,
                            r = this.handle.node._uiProps.uiTransformComp.contentSize,
                            o = this.handle.node.parent;
                        En.set(z3, -n.width * i.x, -n.height * i.y, 0);
                        var a = this.node._uiProps.uiTransformComp.convertToWorldSpaceAR(z3, U3),
                            s = e;
                        s.set(0, 0, 0), o._uiProps.uiTransformComp.convertToNodeSpaceAR(a, s), this.direction === B3.HORIZONTAL ? s.set(s.x, s.y + (n.height - r.height) / 2, s.z) : this.direction === B3.VERTICAL && s.set(s.x + (n.width - r.width) / 2, s.y, s.z), this.handle.node.setPosition(s)
                    }, n._conditionalDisableScrollBar = function(e, t) {
                        return e.width <= t.width && this._direction === B3.HORIZONTAL || e.height <= t.height && this._direction === B3.VERTICAL
                    }, n._calculateLength = function(e, t, n, i) {
                        var r = e;
                        return i && (r += 20 * (i > 0 ? i : -i)), n * (t / r)
                    }, n._calculatePosition = function(e, t, n, i, r, o, a) {
                        var s = t - n;
                        o && (s += Math.abs(o));
                        var c = 0;
                        s && (c = tn(c = r / s));
                        var l = (i - a) * c;
                        this._direction === B3.VERTICAL ? e.set(0, l) : e.set(l, 0)
                    }, n._updateLength = function(e) {
                        if (this._handle) {
                            var t = this._handle.node._uiProps.uiTransformComp,
                                n = t.contentSize,
                                i = t.anchorPoint;
                            i.x === H3.x && i.y === H3.y || t.setAnchorPoint(H3), this._direction === B3.HORIZONTAL ? t.setContentSize(e, n.height) : t.setContentSize(n.width, e)
                        }
                    }, n._processAutoHide = function(e) {
                        if (this._enableAutoHide && !(this._autoHideRemainingTime <= 0) && !this._touching && (this._autoHideRemainingTime -= e, this._autoHideRemainingTime <= this._autoHideTime)) {
                            this._autoHideRemainingTime = Math.max(0, this._autoHideRemainingTime);
                            var t = this._opacity * (this._autoHideRemainingTime / this._autoHideTime);
                            this._setOpacity(t)
                        }
                    }, K(t, [{
                        key: "handle",
                        get: function() {
                            return this._handle
                        },
                        set: function(e) {
                            this._handle !== e && (this._handle = e, this.onScroll(Gn.ZERO))
                        }
                    }, {
                        key: "direction",
                        get: function() {
                            return this._direction
                        },
                        set: function(e) {
                            this._direction !== e && (this._direction = e, this.onScroll(Gn.ZERO))
                        }
                    }, {
                        key: "enableAutoHide",
                        get: function() {
                            return this._enableAutoHide
                        },
                        set: function(e) {
                            this._enableAutoHide !== e && (this._enableAutoHide = e, this._enableAutoHide && this._setOpacity(0))
                        }
                    }, {
                        key: "autoHideTime",
                        get: function() {
                            return this._autoHideTime
                        },
                        set: function(e) {
                            this._autoHideTime !== e && (this._autoHideTime = e)
                        }
                    }]), t
                }(Jd), M3.Direction = B3, ie((w3 = L3).prototype, "handle", [g3, v3, y3], Object.getOwnPropertyDescriptor(w3.prototype, "handle"), w3.prototype), ie(w3.prototype, "direction", [S3, E3, T3], Object.getOwnPropertyDescriptor(w3.prototype, "direction"), w3.prototype), ie(w3.prototype, "enableAutoHide", [A3, x3], Object.getOwnPropertyDescriptor(w3.prototype, "enableAutoHide"), w3.prototype), ie(w3.prototype, "autoHideTime", [C3, b3], Object.getOwnPropertyDescriptor(w3.prototype, "autoHideTime"), w3.prototype), I3 = ie(w3.prototype, "_scrollView", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return null
                    }
                }), P3 = ie(w3.prototype, "_handle", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return null
                    }
                }), O3 = ie(w3.prototype, "_direction", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return B3.HORIZONTAL
                    }
                }), D3 = ie(w3.prototype, "_enableAutoHide", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return !1
                    }
                }), N3 = ie(w3.prototype, "_autoHideTime", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 1
                    }
                }), R3 = w3)) || R3) || R3) || R3) || R3) || R3)),
                G5 = e("ViewGroup", A_("cc.ViewGroup")(W3 = C_(110)(W3 = function(e) {
                    function t() {
                        return e.apply(this, arguments) || this
                    }
                    return Q(t, e), t
                }(Jd)) || W3) || W3);
            i.ViewGroup = G5;
            var H5, k5 = 1e-4,
                V5 = new En,
                W5 = new En,
                j5 = new Gn,
                q5 = new Gn,
                X5 = function() {
                    return (new Date).getMilliseconds()
                },
                Y5 = {
                    "scroll-to-top": 0,
                    "scroll-to-bottom": 1,
                    "scroll-to-left": 2,
                    "scroll-to-right": 3,
                    scrolling: 4,
                    "bounce-bottom": 6,
                    "bounce-left": 7,
                    "bounce-right": 8,
                    "bounce-top": 5,
                    "scroll-ended": 9,
                    "touch-up": 10,
                    "scroll-ended-with-threshold": 11,
                    "scroll-began": 12
                };
            ! function(e) {
                e.SCROLL_TO_TOP = "scroll-to-top", e.SCROLL_TO_BOTTOM = "scroll-to-bottom", e.SCROLL_TO_LEFT = "scroll-to-left", e.SCROLL_TO_RIGHT = "scroll-to-right", e.SCROLL_BEGAN = "scroll-began", e.SCROLL_ENDED = "scroll-ended", e.BOUNCE_TOP = "bounce-top", e.BOUNCE_BOTTOM = "bounce-bottom", e.BOUNCE_LEFT = "bounce-left", e.BOUNCE_RIGHT = "bounce-right", e.SCROLLING = "scrolling", e.SCROLL_ENG_WITH_THRESHOLD = "scroll-ended-with-threshold", e.TOUCH_UP = "touch-up"
            }(H5 || (H5 = {}));
            var K5, Z5, Q5, J5, $5, e8, t8, n8, i8, r8, o8, a8, s8, c8, l8, u8, h8, _8, f8, d8, p8, m8, g8 = function(t) {
                    return e({
                        ScrollView: t,
                        ScrollViewComponent: t
                    }), t
                }((j3 = A_("cc.ScrollView"), q3 = B_(), X3 = C_(110), Y3 = D_(), K3 = x_(pj), Z3 = H_(), Q3 = q_(), J3 = G_(), $3 = H_(), e5 = q_(), t5 = G_(), n5 = q_(), i5 = G_(), r5 = q_(), o5 = G_(), a5 = ef(Yv), s5 = q_(), c5 = G_(), l5 = q_(), u5 = G_(), h5 = ef(U5), _5 = q_(), f5 = G_(), d5 = q_(), p5 = G_(), m5 = ef(U5), g5 = q_(), v5 = G_(), y5 = q_(), S5 = G_(), E5 = ef([uM]), T5 = q_(), A5 = G_(), j3(x5 = q3(x5 = X3(x5 = Y3(x5 = K3((z5 = F5 = function(e) {
                    function t() {
                        for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                        return ne(t = e.call.apply(e, [this].concat(i)) || this, "bounceDuration", b5, $(t)), ne(t, "brake", R5, $(t)), ne(t, "elastic", w5, $(t)), ne(t, "inertia", I5, $(t)), ne(t, "horizontal", P5, $(t)), ne(t, "vertical", O5, $(t)), ne(t, "cancelInnerEvents", D5, $(t)), ne(t, "scrollEvents", N5, $(t)), t._autoScrolling = !1, t._scrolling = !1, ne(t, "_content", M5, $(t)), ne(t, "_horizontalScrollBar", L5, $(t)), ne(t, "_verticalScrollBar", B5, $(t)), t._topBoundary = 0, t._bottomBoundary = 0, t._leftBoundary = 0, t._rightBoundary = 0, t._touchMoveDisplacements = [], t._touchMoveTimeDeltas = [], t._touchMovePreviousTimestamp = 0, t._touchMoved = !1, t._autoScrollAttenuate = !1, t._autoScrollStartPosition = new En, t._autoScrollTargetDelta = new En, t._autoScrollTotalTime = 0, t._autoScrollAccumulatedTime = 0, t._autoScrollCurrentlyOutOfBoundary = !1, t._autoScrollBraking = !1, t._autoScrollBrakingStartPosition = new En, t._outOfBoundaryAmount = new En, t._outOfBoundaryAmountDirty = !0, t._stopMouseWheel = !1, t._mouseWheelEventElapsedTime = 0, t._isScrollEndedWithThresholdEventFired = !1, t._scrollEventEmitMask = 0, t._isBouncing = !1, t._contentPos = new En, t._deltaPos = new En, t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.scrollToBottom = function(e, t) {
                        void 0 === t && (t = !0);
                        var n = this._calculateMovePercentDelta({
                            anchor: new Gn(0, 0),
                            applyToHorizontal: !1,
                            applyToVertical: !0
                        });
                        e ? this._startAutoScroll(n, e, !1 !== t) : this._moveContent(n, !0)
                    }, n.scrollToTop = function(e, t) {
                        void 0 === t && (t = !0);
                        var n = this._calculateMovePercentDelta({
                            anchor: new Gn(0, 1),
                            applyToHorizontal: !1,
                            applyToVertical: !0
                        });
                        e ? this._startAutoScroll(n, e, !1 !== t) : this._moveContent(n)
                    }, n.scrollToLeft = function(e, t) {
                        void 0 === t && (t = !0);
                        var n = this._calculateMovePercentDelta({
                            anchor: new Gn(0, 0),
                            applyToHorizontal: !0,
                            applyToVertical: !1
                        });
                        e ? this._startAutoScroll(n, e, !1 !== t) : this._moveContent(n)
                    }, n.scrollToRight = function(e, t) {
                        void 0 === t && (t = !0);
                        var n = this._calculateMovePercentDelta({
                            anchor: new Gn(1, 0),
                            applyToHorizontal: !0,
                            applyToVertical: !1
                        });
                        e ? this._startAutoScroll(n, e, !1 !== t) : this._moveContent(n)
                    }, n.scrollToTopLeft = function(e, t) {
                        void 0 === t && (t = !0);
                        var n = this._calculateMovePercentDelta({
                            anchor: new Gn(0, 1),
                            applyToHorizontal: !0,
                            applyToVertical: !0
                        });
                        e ? this._startAutoScroll(n, e, !1 !== t) : this._moveContent(n)
                    }, n.scrollToTopRight = function(e, t) {
                        void 0 === t && (t = !0);
                        var n = this._calculateMovePercentDelta({
                            anchor: new Gn(1, 1),
                            applyToHorizontal: !0,
                            applyToVertical: !0
                        });
                        e ? this._startAutoScroll(n, e, !1 !== t) : this._moveContent(n)
                    }, n.scrollToBottomLeft = function(e, t) {
                        void 0 === t && (t = !0);
                        var n = this._calculateMovePercentDelta({
                            anchor: new Gn(0, 0),
                            applyToHorizontal: !0,
                            applyToVertical: !0
                        });
                        e ? this._startAutoScroll(n, e, !1 !== t) : this._moveContent(n)
                    }, n.scrollToBottomRight = function(e, t) {
                        void 0 === t && (t = !0);
                        var n = this._calculateMovePercentDelta({
                            anchor: new Gn(1, 0),
                            applyToHorizontal: !0,
                            applyToVertical: !0
                        });
                        e ? this._startAutoScroll(n, e, !1 !== t) : this._moveContent(n)
                    }, n.scrollToOffset = function(e, t, n) {
                        void 0 === n && (n = !0);
                        var i = this.getMaxScrollOffset(),
                            r = new Gn(0, 0);
                        0 === i.x ? r.x = 0 : r.x = e.x / i.x, 0 === i.y ? r.y = 1 : r.y = (i.y - e.y) / i.y, this.scrollTo(r, t, n)
                    }, n.getScrollOffset = function() {
                        var e = this._getContentTopBoundary() - this._topBoundary,
                            t = this._getContentLeftBoundary() - this._leftBoundary;
                        return new Gn(t, e)
                    }, n.getMaxScrollOffset = function() {
                        if (!this._content || !this.view) return Gn.ZERO;
                        var e = this._content._uiProps.uiTransformComp.contentSize,
                            t = e.width - this.view.width,
                            n = e.height - this.view.height;
                        return new Gn(t = t >= 0 ? t : 0, n = n >= 0 ? n : 0)
                    }, n.scrollToPercentHorizontal = function(e, t, n) {
                        var i = this._calculateMovePercentDelta({
                            anchor: new Gn(e, 0),
                            applyToHorizontal: !0,
                            applyToVertical: !1
                        });
                        t ? this._startAutoScroll(i, t, !1 !== n) : this._moveContent(i)
                    }, n.scrollTo = function(e, t, n) {
                        var i = this._calculateMovePercentDelta({
                            anchor: new Gn(e),
                            applyToHorizontal: !0,
                            applyToVertical: !0
                        });
                        t ? this._startAutoScroll(i, t, n) : this._moveContent(i)
                    }, n.scrollToPercentVertical = function(e, t, n) {
                        var i = this._calculateMovePercentDelta({
                            anchor: new Gn(0, e),
                            applyToHorizontal: !1,
                            applyToVertical: !0
                        });
                        t ? this._startAutoScroll(i, t, n) : this._moveContent(i)
                    }, n.stopAutoScroll = function() {
                        this._autoScrolling = !1, this._autoScrollAccumulatedTime = this._autoScrollTotalTime
                    }, n.setContentPosition = function(e) {
                        this._setContentPosition(e)
                    }, n._setContentPosition = function(e) {
                        if (this._content) {
                            var t = this._getContentPosition();
                            Math.abs(e.x - t.x) < k5 && Math.abs(e.y - t.y) < k5 || (this._content.setPosition(e), this._outOfBoundaryAmountDirty = !0)
                        }
                    }, n.getContentPosition = function() {
                        return this._getContentPosition()
                    }, n._getContentPosition = function() {
                        return this._content ? (this._contentPos.set(this._content.position), this._contentPos) : En.ZERO
                    }, n.isScrolling = function() {
                        return this._scrolling
                    }, n.isAutoScrolling = function() {
                        return this._autoScrolling
                    }, n.getScrollEndedEventTiming = function() {
                        return k5
                    }, n.start = function() {
                        this._calculateBoundary(), this._content && RO.once(bO.EVENT_BEFORE_DRAW, this._adjustContentOutOfBoundary, this)
                    }, n.onEnable = function() {
                        this._registerEvent(), this._content && (this._content.on(Yv.EventType.SIZE_CHANGED, this._calculateBoundary, this), this._content.on(Yv.EventType.TRANSFORM_CHANGED, this._scaleChanged, this), this.view && (this.view.node.on(Yv.EventType.TRANSFORM_CHANGED, this._scaleChanged, this), this.view.node.on(Yv.EventType.SIZE_CHANGED, this._calculateBoundary, this))), this._calculateBoundary(), this._updateScrollBarState()
                    }, n.update = function(e) {
                        this._autoScrolling && this._processAutoScrolling(e)
                    }, n.onDisable = function() {
                        this._unregisterEvent(), this._content && (this._content.off(Yv.EventType.SIZE_CHANGED, this._calculateBoundary, this), this._content.off(Yv.EventType.TRANSFORM_CHANGED, this._scaleChanged, this), this.view && (this.view.node.off(Yv.EventType.TRANSFORM_CHANGED, this._scaleChanged, this), this.view.node.off(Yv.EventType.SIZE_CHANGED, this._calculateBoundary, this))), this._hideScrollBar(), this.stopAutoScroll()
                    }, n._registerEvent = function() {
                        this.node.on(Yv.EventType.TOUCH_START, this._onTouchBegan, this, !0), this.node.on(Yv.EventType.TOUCH_MOVE, this._onTouchMoved, this, !0), this.node.on(Yv.EventType.TOUCH_END, this._onTouchEnded, this, !0), this.node.on(Yv.EventType.TOUCH_CANCEL, this._onTouchCancelled, this, !0), this.node.on(Yv.EventType.MOUSE_WHEEL, this._onMouseWheel, this, !0)
                    }, n._unregisterEvent = function() {
                        this.node.off(Yv.EventType.TOUCH_START, this._onTouchBegan, this, !0), this.node.off(Yv.EventType.TOUCH_MOVE, this._onTouchMoved, this, !0), this.node.off(Yv.EventType.TOUCH_END, this._onTouchEnded, this, !0), this.node.off(Yv.EventType.TOUCH_CANCEL, this._onTouchCancelled, this, !0), this.node.off(Yv.EventType.MOUSE_WHEEL, this._onMouseWheel, this, !0)
                    }, n._onMouseWheel = function(e, t) {
                        if (this.enabledInHierarchy && !this._hasNestedViewGroup(e, t)) {
                            var n = new En,
                                i = e.getScrollY();
                            this.vertical ? n.set(0, -.1 * i, 0) : this.horizontal && n.set(-.1 * i, 0, 0), this._mouseWheelEventElapsedTime = 0, this._processDeltaMove(n), this._stopMouseWheel || (this._handlePressLogic(), this.schedule(this._checkMouseWheel, 1 / 60, NaN, 0), this._stopMouseWheel = !0), this._stopPropagationIfTargetIsMe(e)
                        }
                    }, n._onTouchBegan = function(e, t) {
                        this.enabledInHierarchy && this._content && (this._hasNestedViewGroup(e, t) || (this._handlePressLogic(), this._touchMoved = !1, this._stopPropagationIfTargetIsMe(e)))
                    }, n._onTouchMoved = function(e, t) {
                        if (this.enabledInHierarchy && this._content && !this._hasNestedViewGroup(e, t)) {
                            var n = e.touch;
                            if (this._handleMoveLogic(n), this.cancelInnerEvents) {
                                var i = n.getUILocation(j5);
                                if (i.subtract(n.getUIStartLocation(q5)), i.length() > 7 && !this._touchMoved && e.target !== this.node) {
                                    var r = new Oy(e.getTouches(), e.bubbles);
                                    r.type = Yv.EventType.TOUCH_CANCEL, r.touch = e.touch, r.simulate = !0, e.target.dispatchEvent(r), this._touchMoved = !0
                                }
                                this._stopPropagationIfTargetIsMe(e)
                            }
                        }
                    }, n._onTouchEnded = function(e, t) {
                        if (this.enabledInHierarchy && this._content && e && !this._hasNestedViewGroup(e, t)) {
                            this._dispatchEvent(H5.TOUCH_UP);
                            var n = e.touch;
                            this._handleReleaseLogic(n), this._touchMoved ? e.propagationStopped = !0 : this._stopPropagationIfTargetIsMe(e)
                        }
                    }, n._onTouchCancelled = function(e, t) {
                        if (this.enabledInHierarchy && this._content && !this._hasNestedViewGroup(e, t)) {
                            if (e && !e.simulate) {
                                var n = e.touch;
                                this._handleReleaseLogic(n)
                            }
                            this._stopPropagationIfTargetIsMe(e)
                        }
                    }, n._calculateBoundary = function() {
                        if (this._content && this.view) {
                            var e = this._content.getComponent(h3);
                            e && e.enabledInHierarchy && e.updateLayout();
                            var t = this.view,
                                n = t.width * t.anchorX,
                                i = t.height * t.anchorY;
                            this._leftBoundary = -n, this._bottomBoundary = -i, this._rightBoundary = this._leftBoundary + t.width, this._topBoundary = this._bottomBoundary + t.height, this._moveContentToTopLeft(t.contentSize)
                        }
                    }, n._hasNestedViewGroup = function(e, t) {
                        if (!e || e.eventPhase !== Df.CAPTURING_PHASE) return !1;
                        if (t)
                            for (var n, i = te(t); !(n = i()).done;) {
                                var r = n.value;
                                if (this.node === r) return !(!e.target || !e.target.getComponent(G5));
                                if (r.getComponent(G5)) return !0
                            }
                        return !1
                    }, n._startInertiaScroll = function(e) {
                        var t = new En(e);
                        t.multiplyScalar(.7), this._startAttenuatingAutoScroll(t, e)
                    }, n._calculateAttenuatedFactor = function(e) {
                        return this.brake <= 0 ? 1 - this.brake : (1 - this.brake) * (1 / (1 + 14e-6 * e + e * e * 8e-9))
                    }, n._startAttenuatingAutoScroll = function(e, t) {
                        var n = e.clone();
                        if (n.normalize(), this._content && this.view) {
                            var i = this._content._uiProps.uiTransformComp.contentSize,
                                r = this.view.contentSize,
                                o = i.width - r.width,
                                a = i.height - r.height,
                                s = this._calculateAttenuatedFactor(o),
                                c = this._calculateAttenuatedFactor(a);
                            n.x = n.x * o * (1 - this.brake) * s, n.y = n.y * a * c * (1 - this.brake), n.z = 0
                        }
                        var l = e.length(),
                            u = n.length() / l;
                        if (n.add(e), this.brake > 0 && u > 7) {
                            u = Math.sqrt(u);
                            var h = e.clone();
                            h.multiplyScalar(u), n.set(h), n.add(e)
                        }
                        var _ = this._calculateAutoScrollTimeByInitialSpeed(t.length());
                        this.brake > 0 && u > 3 && (_ *= u = 3), 0 === this.brake && u > 1 && (_ *= u), this._startAutoScroll(n, _, !0)
                    }, n._calculateAutoScrollTimeByInitialSpeed = function(e) {
                        return Math.sqrt(Math.sqrt(e / 5))
                    }, n._startAutoScroll = function(e, t, n) {
                        void 0 === n && (n = !1);
                        var i = this._flattenVectorByDirection(e);
                        this._autoScrolling = !0, this._autoScrollTargetDelta = i, this._autoScrollAttenuate = n, En.copy(this._autoScrollStartPosition, this._getContentPosition()), this._autoScrollTotalTime = t, this._autoScrollAccumulatedTime = 0, this._autoScrollBraking = !1, this._isScrollEndedWithThresholdEventFired = !1, this._autoScrollBrakingStartPosition.set(0, 0, 0), this._getHowMuchOutOfBoundary().equals(En.ZERO, k5) || (this._autoScrollCurrentlyOutOfBoundary = !0)
                    }, n._calculateTouchMoveVelocity = function() {
                        var e = new En,
                            t = 0;
                        if ((t = this._touchMoveTimeDeltas.reduce((function(e, t) {
                                return e + t
                            }), t)) <= 0 || t >= .5) e.set(En.ZERO);
                        else {
                            var n = new En;
                            n = this._touchMoveDisplacements.reduce((function(e, t) {
                                return e.add(t), e
                            }), n), e.set(n.x * (1 - this.brake) / t, n.y * (1 - this.brake) / t, n.z)
                        }
                        return e
                    }, n._flattenVectorByDirection = function(e) {
                        var t = e;
                        return t.x = this.horizontal ? t.x : 0, t.y = this.vertical ? t.y : 0, t
                    }, n._moveContent = function(e, t) {
                        var n = this._flattenVectorByDirection(e);
                        V5.set(this._getContentPosition()), V5.add(n), V5.set(Math.floor(1e4 * V5.x) * k5, Math.floor(1e4 * V5.y) * k5, V5.z), this._setContentPosition(V5);
                        var i = this._getHowMuchOutOfBoundary();
                        j5.set(i.x, i.y), this._updateScrollBar(j5), this.elastic && t && this._startBounceBackIfNeeded()
                    }, n._getContentLeftBoundary = function() {
                        if (!this._content) return -1;
                        var e = this._getContentPosition(),
                            t = this._content._uiProps.uiTransformComp;
                        return e.x - t.anchorX * t.width
                    }, n._getContentRightBoundary = function() {
                        if (!this._content) return -1;
                        var e = this._content._uiProps.uiTransformComp;
                        return this._getContentLeftBoundary() + e.width
                    }, n._getContentTopBoundary = function() {
                        if (!this._content) return -1;
                        var e = this._content._uiProps.uiTransformComp;
                        return this._getContentBottomBoundary() + e.height
                    }, n._getContentBottomBoundary = function() {
                        if (!this._content) return -1;
                        var e = this._getContentPosition(),
                            t = this._content._uiProps.uiTransformComp;
                        return e.y - t.anchorY * t.height
                    }, n._getHowMuchOutOfBoundary = function(e) {
                        if ((e = e || new En).equals(En.ZERO, k5) && !this._outOfBoundaryAmountDirty) return this._outOfBoundaryAmount;
                        var t = new En;
                        return this._getContentLeftBoundary() + e.x > this._leftBoundary ? t.x = this._leftBoundary - (this._getContentLeftBoundary() + e.x) : this._getContentRightBoundary() + e.x < this._rightBoundary && (t.x = this._rightBoundary - (this._getContentRightBoundary() + e.x)), this._getContentTopBoundary() + e.y < this._topBoundary ? t.y = this._topBoundary - (this._getContentTopBoundary() + e.y) : this._getContentBottomBoundary() + e.y > this._bottomBoundary && (t.y = this._bottomBoundary - (this._getContentBottomBoundary() + e.y)), e.equals(En.ZERO, k5) && (this._outOfBoundaryAmount = t, this._outOfBoundaryAmountDirty = !1), this._clampDelta(t), t
                    }, n._updateScrollBar = function(e) {
                        this._horizontalScrollBar && this._horizontalScrollBar.onScroll(e), this.verticalScrollBar && this.verticalScrollBar.onScroll(e)
                    }, n._onScrollBarTouchBegan = function() {
                        this._horizontalScrollBar && this._horizontalScrollBar.onTouchBegan(), this.verticalScrollBar && this.verticalScrollBar.onTouchBegan()
                    }, n._onScrollBarTouchEnded = function() {
                        this._horizontalScrollBar && this._horizontalScrollBar.onTouchEnded(), this.verticalScrollBar && this.verticalScrollBar.onTouchEnded()
                    }, n._dispatchEvent = function(e) {
                        if (e === H5.SCROLL_ENDED) this._scrollEventEmitMask = 0;
                        else if (e === H5.SCROLL_TO_TOP || e === H5.SCROLL_TO_BOTTOM || e === H5.SCROLL_TO_LEFT || e === H5.SCROLL_TO_RIGHT) {
                            var t = 1 << Y5[e];
                            if (this._scrollEventEmitMask & t) return;
                            this._scrollEventEmitMask |= t
                        }
                        uM.emitEvents(this.scrollEvents, this, Y5[e]), this.node.emit(e, this)
                    }, n._adjustContentOutOfBoundary = function() {
                        if (this._content && (this._outOfBoundaryAmountDirty = !0, this._isOutOfBoundary())) {
                            var e = this._getHowMuchOutOfBoundary();
                            V5.set(this._getContentPosition()), V5.add(e), this._content.setPosition(V5), this._updateScrollBar(Gn.ZERO)
                        }
                    }, n._hideScrollBar = function() {
                        this._horizontalScrollBar && this._horizontalScrollBar.hide(), this._verticalScrollBar && this._verticalScrollBar.hide()
                    }, n._updateScrollBarState = function() {
                        if (this._content && this.view) {
                            var e = this.view,
                                t = this._content._uiProps.uiTransformComp;
                            this.verticalScrollBar && (t.height < e.height ? this.verticalScrollBar.hide() : this.verticalScrollBar.show()), this.horizontalScrollBar && (t.width < e.width ? this.horizontalScrollBar.hide() : this.horizontalScrollBar.show())
                        }
                    }, n._stopPropagationIfTargetIsMe = function(e) {
                        e.eventPhase === Df.AT_TARGET && e.target === this.node && (e.propagationStopped = !0)
                    }, n._processDeltaMove = function(e) {
                        this._scrollChildren(e), this._gatherTouchMove(e)
                    }, n._handleMoveLogic = function(e) {
                        this._getLocalAxisAlignDelta(this._deltaPos, e), this._processDeltaMove(this._deltaPos)
                    }, n._handleReleaseLogic = function(e) {
                        this._getLocalAxisAlignDelta(this._deltaPos, e), this._gatherTouchMove(this._deltaPos), this._processInertiaScroll(), this._scrolling && (this._scrolling = !1, this._autoScrolling || this._dispatchEvent(H5.SCROLL_ENDED))
                    }, n._getLocalAxisAlignDelta = function(e, t) {
                        var n = this.node._uiProps.uiTransformComp,
                            i = new En;
                        n && (t.getUILocation(j5), t.getUIPreviousLocation(q5), V5.set(j5.x, j5.y, 0), W5.set(q5.x, q5.y, 0), n.convertToNodeSpaceAR(V5, V5), n.convertToNodeSpaceAR(W5, W5), En.subtract(i, V5, W5)), e.set(i)
                    }, n._scrollChildren = function(e) {
                        this._clampDelta(e);
                        var t, n, i = e;
                        if (this.elastic && (t = this._getHowMuchOutOfBoundary(), i.x *= 0 === t.x ? 1 : .5, i.y *= 0 === t.y ? 1 : .5), this.elastic || (t = this._getHowMuchOutOfBoundary(i), i.add(t)), this._content) {
                            var r = this._content._uiProps.uiTransformComp,
                                o = r.anchorX,
                                a = r.anchorY,
                                s = r.width,
                                c = r.height,
                                l = this._content.position || En.ZERO;
                            i.y > 0 ? l.y - a * c + i.y >= this._bottomBoundary && (n = H5.SCROLL_TO_BOTTOM) : i.y < 0 && l.y - a * c + c + i.y <= this._topBoundary && (n = H5.SCROLL_TO_TOP), i.x < 0 ? l.x - o * s + s + i.x <= this._rightBoundary && (n = H5.SCROLL_TO_RIGHT) : i.x > 0 && l.x - o * s + i.x >= this._leftBoundary && (n = H5.SCROLL_TO_LEFT)
                        }
                        this._moveContent(i, !1), 0 === i.x && 0 === i.y || (this._scrolling || (this._scrolling = !0, this._dispatchEvent(H5.SCROLL_BEGAN)), this._dispatchEvent(H5.SCROLLING)), n && n.length > 0 && this._dispatchEvent(n)
                    }, n._handlePressLogic = function() {
                        this._autoScrolling && this._dispatchEvent(H5.SCROLL_ENDED), this._autoScrolling = !1, this._isBouncing = !1, this._touchMovePreviousTimestamp = X5(), this._touchMoveDisplacements.length = 0, this._touchMoveTimeDeltas.length = 0, this._onScrollBarTouchBegan()
                    }, n._clampDelta = function(e) {
                        if (this._content && this.view) {
                            var t = this.view.contentSize,
                                n = this._content._uiProps.uiTransformComp;
                            n.width < t.width && (e.x = 0), n.height < t.height && (e.y = 0)
                        }
                    }, n._gatherTouchMove = function(e) {
                        var t = e.clone();
                        for (this._clampDelta(t); this._touchMoveDisplacements.length >= 5;) this._touchMoveDisplacements.shift(), this._touchMoveTimeDeltas.shift();
                        this._touchMoveDisplacements.push(t);
                        var n = X5();
                        this._touchMoveTimeDeltas.push((n - this._touchMovePreviousTimestamp) / 1e3), this._touchMovePreviousTimestamp = n
                    }, n._startBounceBackIfNeeded = function() {
                        if (!this.elastic) return !1;
                        var e = this._getHowMuchOutOfBoundary();
                        if (this._clampDelta(e), e.equals(En.ZERO, k5)) return !1;
                        var t = Math.max(this.bounceDuration, 0);
                        return this._startAutoScroll(e, t, !0), this._isBouncing || (e.y > 0 && this._dispatchEvent(H5.BOUNCE_TOP), e.y < 0 && this._dispatchEvent(H5.BOUNCE_BOTTOM), e.x > 0 && this._dispatchEvent(H5.BOUNCE_RIGHT), e.x < 0 && this._dispatchEvent(H5.BOUNCE_LEFT), this._isBouncing = !0), !0
                    }, n._processInertiaScroll = function() {
                        if (!this._startBounceBackIfNeeded() && this.inertia) {
                            var e = this._calculateTouchMoveVelocity();
                            !e.equals(V5, k5) && this.brake < 1 && this._startInertiaScroll(e)
                        }
                        this._onScrollBarTouchEnded()
                    }, n._isOutOfBoundary = function() {
                        return !this._getHowMuchOutOfBoundary().equals(En.ZERO, k5)
                    }, n._isNecessaryAutoScrollBrake = function() {
                        if (this._autoScrollBraking) return !0;
                        if (this._isOutOfBoundary()) {
                            if (!this._autoScrollCurrentlyOutOfBoundary) return this._autoScrollCurrentlyOutOfBoundary = !0, this._autoScrollBraking = !0, this._autoScrollBrakingStartPosition = this._getContentPosition(), !0
                        } else this._autoScrollCurrentlyOutOfBoundary = !1;
                        return !1
                    }, n._processAutoScrolling = function(e) {
                        var t = this._isNecessaryAutoScrollBrake(),
                            n = t ? .05 : 1;
                        this._autoScrollAccumulatedTime += e * (1 / n);
                        var i, r = Math.min(1, this._autoScrollAccumulatedTime / this._autoScrollTotalTime);
                        this._autoScrollAttenuate && (i = r, r = (i -= 1) * i * i * i * i + 1);
                        var o = this._autoScrollTargetDelta.clone();
                        o.multiplyScalar(r);
                        var a = this._autoScrollStartPosition.clone();
                        a.add(o);
                        var s = Math.abs(r - 1) <= k5;
                        if (Math.abs(r - 1) <= this.getScrollEndedEventTiming() && !this._isScrollEndedWithThresholdEventFired && (this._dispatchEvent(H5.SCROLL_ENG_WITH_THRESHOLD), this._isScrollEndedWithThresholdEventFired = !0), this.elastic) {
                            var c = a.clone();
                            c.subtract(this._autoScrollBrakingStartPosition), t && c.multiplyScalar(n), a.set(this._autoScrollBrakingStartPosition), a.add(c)
                        } else {
                            var l = a.clone();
                            l.subtract(this.getContentPosition());
                            var u = this._getHowMuchOutOfBoundary(l);
                            u.equals(En.ZERO, k5) || (a.add(u), s = !0)
                        }
                        s && (this._autoScrolling = !1);
                        var h = a.clone();
                        h.subtract(this._getContentPosition()), this._clampDelta(h), this._moveContent(h, s), this._dispatchEvent(H5.SCROLLING), this._autoScrolling || (this._isBouncing = !1, this._scrolling = !1, this._dispatchEvent(H5.SCROLL_ENDED))
                    }, n._checkMouseWheel = function(e) {
                        if (!this._getHowMuchOutOfBoundary().equals(En.ZERO, k5)) return this._processInertiaScroll(), this.unschedule(this._checkMouseWheel), this._dispatchEvent(H5.SCROLL_ENDED), void(this._stopMouseWheel = !1);
                        this._mouseWheelEventElapsedTime += e, this._mouseWheelEventElapsedTime > .1 && (this._onScrollBarTouchEnded(), this.unschedule(this._checkMouseWheel), this._dispatchEvent(H5.SCROLL_ENDED), this._stopMouseWheel = !1)
                    }, n._calculateMovePercentDelta = function(e) {
                        var t = e.anchor,
                            n = e.applyToHorizontal,
                            i = e.applyToVertical;
                        this._calculateBoundary(), t.clampf(Gn.ZERO, Gn.ONE);
                        var r = this._getContentBottomBoundary() - this._bottomBoundary;
                        r = -r;
                        var o = this._getContentLeftBoundary() - this._leftBoundary;
                        o = -o;
                        var a = new En;
                        if (this._content && this.view) {
                            var s = 0,
                                c = this._content._uiProps.uiTransformComp.contentSize,
                                l = this.view.contentSize;
                            n && (s = c.width - l.width, a.x = o - s * t.x), i && (s = c.height - l.height, a.y = r - s * t.y)
                        }
                        return a
                    }, n._moveContentToTopLeft = function(e) {
                        var t = this._getContentBottomBoundary() - this._bottomBoundary;
                        t = -t;
                        var n = new En,
                            i = 0,
                            r = this._getContentLeftBoundary() - this._leftBoundary;
                        if (r = -r, this._content) {
                            var o = this._content._uiProps.uiTransformComp.contentSize;
                            o.height < e.height && (i = o.height - e.height, n.y = t - i), o.width < e.width && (i = o.width - e.width, n.x = r)
                        }
                        this._updateScrollBarState(), this._moveContent(n), this._adjustContentOutOfBoundary()
                    }, n._scaleChanged = function(e) {
                        e === r_.SCALE && this._calculateBoundary()
                    }, K(t, [{
                        key: "content",
                        get: function() {
                            return this._content
                        },
                        set: function(e) {
                            if (this._content !== e) {
                                var t = e && e.parent && e.parent._uiProps.uiTransformComp;
                                !e || e && t ? (this._content = e, this._calculateBoundary()) : T(4302)
                            }
                        }
                    }, {
                        key: "horizontalScrollBar",
                        get: function() {
                            return this._horizontalScrollBar
                        },
                        set: function(e) {
                            this._horizontalScrollBar !== e && (this._horizontalScrollBar = e, this._horizontalScrollBar && (this._horizontalScrollBar.setScrollView(this), this._updateScrollBar(Gn.ZERO)))
                        }
                    }, {
                        key: "verticalScrollBar",
                        get: function() {
                            return this._verticalScrollBar
                        },
                        set: function(e) {
                            this._verticalScrollBar !== e && (this._verticalScrollBar = e, this._verticalScrollBar && (this._verticalScrollBar.setScrollView(this), this._updateScrollBar(Gn.ZERO)))
                        }
                    }, {
                        key: "view",
                        get: function() {
                            var e = this._content && this._content.parent;
                            return e ? e._uiProps.uiTransformComp : null
                        }
                    }]), t
                }(G5), F5.EventType = H5, b5 = ie((C5 = z5).prototype, "bounceDuration", [w_, Z3, Q3, J3], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 1
                    }
                }), R5 = ie(C5.prototype, "brake", [w_, $3, e5, t5], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return .5
                    }
                }), w5 = ie(C5.prototype, "elastic", [w_, n5, i5], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return !0
                    }
                }), I5 = ie(C5.prototype, "inertia", [w_, r5, o5], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return !0
                    }
                }), ie(C5.prototype, "content", [a5, s5, c5], Object.getOwnPropertyDescriptor(C5.prototype, "content"), C5.prototype), P5 = ie(C5.prototype, "horizontal", [w_, l5, u5], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return !0
                    }
                }), ie(C5.prototype, "horizontalScrollBar", [h5, _5, f5], Object.getOwnPropertyDescriptor(C5.prototype, "horizontalScrollBar"), C5.prototype), O5 = ie(C5.prototype, "vertical", [w_, d5, p5], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return !0
                    }
                }), ie(C5.prototype, "verticalScrollBar", [m5, g5, v5], Object.getOwnPropertyDescriptor(C5.prototype, "verticalScrollBar"), C5.prototype), D5 = ie(C5.prototype, "cancelInnerEvents", [w_, y5, S5], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return !0
                    }
                }), N5 = ie(C5.prototype, "scrollEvents", [E5, w_, T5, A5], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return []
                    }
                }), M5 = ie(C5.prototype, "_content", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return null
                    }
                }), L5 = ie(C5.prototype, "_horizontalScrollBar", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return null
                    }
                }), B5 = ie(C5.prototype, "_verticalScrollBar", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return null
                    }
                }), x5 = C5)) || x5) || x5) || x5) || x5) || x5)),
                v8 = new En;
            ! function(e) {
                e[e.Horizontal = 0] = "Horizontal", e[e.Vertical = 1] = "Vertical"
            }(m8 || (m8 = {})), nt(m8);
            var y8, S8, E8, T8, A8, x8, C8, b8, R8, w8, I8, P8, O8, D8, N8, M8, L8, B8, F8, z8, U8 = function(t) {
                return e({
                    Slider: t,
                    SliderComponent: t
                }), t
            }((K5 = A_("cc.Slider"), Z5 = B_(), Q5 = C_(110), J5 = D_(), $5 = x_(pj), e8 = ef(zK), t8 = G_(), n8 = ef(m8), i8 = G_(), r8 = H_(), o8 = G_(), a8 = ef([uM]), s8 = G_(), K5(c8 = Z5(c8 = Q5(c8 = J5(c8 = $5((p8 = d8 = function(e) {
                function t() {
                    for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                    return ne(t = e.call.apply(e, [this].concat(i)) || this, "slideEvents", u8, $(t)), ne(t, "_handle", h8, $(t)), ne(t, "_direction", _8, $(t)), ne(t, "_progress", f8, $(t)), t._offset = new En, t._dragging = !1, t._touchHandle = !1, t._handleLocalPos = new En, t._touchPos = new En, t
                }
                Q(t, e);
                var n = t.prototype;
                return n.__preload = function() {
                    this._updateHandlePosition()
                }, n.onEnable = function() {
                    this._updateHandlePosition(), this.node.on(Om.TOUCH_START, this._onTouchBegan, this), this.node.on(Om.TOUCH_MOVE, this._onTouchMoved, this), this.node.on(Om.TOUCH_END, this._onTouchEnded, this), this.node.on(Om.TOUCH_CANCEL, this._onTouchCancelled, this), this._handle && this._handle.isValid && (this._handle.node.on(Om.TOUCH_START, this._onHandleDragStart, this), this._handle.node.on(Om.TOUCH_MOVE, this._onTouchMoved, this), this._handle.node.on(Om.TOUCH_END, this._onTouchEnded, this))
                }, n.onDisable = function() {
                    this.node.off(Om.TOUCH_START, this._onTouchBegan, this), this.node.off(Om.TOUCH_MOVE, this._onTouchMoved, this), this.node.off(Om.TOUCH_END, this._onTouchEnded, this), this.node.off(Om.TOUCH_CANCEL, this._onTouchCancelled, this), this._handle && this._handle.isValid && (this._handle.node.off(Om.TOUCH_START, this._onHandleDragStart, this), this._handle.node.off(Om.TOUCH_MOVE, this._onTouchMoved, this), this._handle.node.off(Om.TOUCH_END, this._onTouchEnded, this))
                }, n._onHandleDragStart = function(e) {
                    if (e && this._handle && this._handle.node._uiProps.uiTransformComp) {
                        this._dragging = !0, this._touchHandle = !0;
                        var t = e.touch.getUILocation();
                        En.set(this._touchPos, t.x, t.y, 0), this._handle.node._uiProps.uiTransformComp.convertToNodeSpaceAR(this._touchPos, this._offset), e.propagationStopped = !0
                    }
                }, n._onTouchBegan = function(e) {
                    this._handle && e && (this._dragging = !0, this._touchHandle || this._handleSliderLogic(e.touch), e.propagationStopped = !0)
                }, n._onTouchMoved = function(e) {
                    this._dragging && e && (this._handleSliderLogic(e.touch), e.propagationStopped = !0)
                }, n._onTouchEnded = function(e) {
                    this._dragging = !1, this._touchHandle = !1, this._offset = new En, e && (e.propagationStopped = !0)
                }, n._onTouchCancelled = function(e) {
                    this._dragging = !1, e && (e.propagationStopped = !0)
                }, n._handleSliderLogic = function(e) {
                    this._updateProgress(e), this._emitSlideEvent()
                }, n._emitSlideEvent = function() {
                    uM.emitEvents(this.slideEvents, this), this.node.emit("slide", this)
                }, n._updateProgress = function(e) {
                    if (this._handle && e) {
                        var t = e.getUILocation();
                        En.set(this._touchPos, t.x, t.y, 0);
                        var n = this.node._uiProps.uiTransformComp,
                            i = n.convertToNodeSpaceAR(this._touchPos, v8);
                        this.direction === m8.Horizontal ? this.progress = tn(.5 + (i.x - this._offset.x) / n.width) : this.progress = tn(.5 + (i.y - this._offset.y) / n.height)
                    }
                }, n._updateHandlePosition = function() {
                    if (this._handle) {
                        this._handleLocalPos.set(this._handle.node.getPosition());
                        var e = this.node._uiProps.uiTransformComp;
                        this._direction === m8.Horizontal ? this._handleLocalPos.x = -e.width * e.anchorX + this.progress * e.width : this._handleLocalPos.y = -e.height * e.anchorY + this.progress * e.height, this._handle.node.setPosition(this._handleLocalPos)
                    }
                }, n._changeLayout = function() {
                    var e = this.node._uiProps.uiTransformComp,
                        t = e.contentSize;
                    if (e.setContentSize(t.height, t.width), this._handle) {
                        var n = this._handle.node.position;
                        this._direction === m8.Horizontal ? this._handle.node.setPosition(n.x, 0, n.z) : this._handle.node.setPosition(0, n.y, n.z), this._updateHandlePosition()
                    }
                }, K(t, [{
                    key: "handle",
                    get: function() {
                        return this._handle
                    },
                    set: function(e) {
                        this._handle !== e && (this._handle = e)
                    }
                }, {
                    key: "direction",
                    get: function() {
                        return this._direction
                    },
                    set: function(e) {
                        this._direction !== e && (this._direction = e, this._changeLayout())
                    }
                }, {
                    key: "progress",
                    get: function() {
                        return this._progress
                    },
                    set: function(e) {
                        this._progress !== e && (this._progress = e, this._updateHandlePosition())
                    }
                }]), t
            }(Jd), d8.Direction = m8, ie((l8 = p8).prototype, "handle", [e8, t8], Object.getOwnPropertyDescriptor(l8.prototype, "handle"), l8.prototype), ie(l8.prototype, "direction", [n8, i8], Object.getOwnPropertyDescriptor(l8.prototype, "direction"), l8.prototype), ie(l8.prototype, "progress", [j_, r8, o8], Object.getOwnPropertyDescriptor(l8.prototype, "progress"), l8.prototype), u8 = ie(l8.prototype, "slideEvents", [a8, w_, s8], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return []
                }
            }), h8 = ie(l8.prototype, "_handle", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return null
                }
            }), _8 = ie(l8.prototype, "_direction", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return m8.Horizontal
                }
            }), f8 = ie(l8.prototype, "_progress", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return .1
                }
            }), c8 = l8)) || c8) || c8) || c8) || c8) || c8));

            function G8() {
                for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
                return Object.assign.apply(Object, [{}].concat(t))
            }! function(e) {
                e.TOGGLE = "toggle"
            }(z8 || (z8 = {}));
            var H8, k8, V8, W8, j8, q8, X8, Y8, K8, Z8, Q8, J8, $8, e6, t6, n6, i6, r6, o6, a6, s6, c6, l6, u6, h6, _6, f6, d6, p6, m6, g6, v6, y6, S6, E6, T6, A6, x6, C6, b6, R6, w6, I6, P6, O6, D6, N6, M6, L6, B6, F6, z6, U6, G6, H6, k6, V6, W6, j6, q6 = function(t) {
                    return e({
                        Toggle: t,
                        ToggleComponent: t
                    }), t
                }((y8 = A_("cc.Toggle"), S8 = B_(), E8 = C_(110), T8 = D_(), A8 = x_(pj), x8 = q_(), C8 = G_(), b8 = ef(zK), R8 = q_(), w8 = G_(), I8 = ef([uM]), P8 = G_(), y8(O8 = S8(O8 = E8(O8 = T8(O8 = A8((F8 = B8 = function(e) {
                    function t() {
                        for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                        return ne(t = e.call.apply(e, [this].concat(i)) || this, "checkEvents", N8, $(t)), ne(t, "_isChecked", M8, $(t)), ne(t, "_checkMark", L8, $(t)), t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n._internalToggle = function() {
                        this.isChecked = !this.isChecked
                    }, n._set = function(e, t) {
                        if (void 0 === t && (t = !0), this._isChecked != e) {
                            this._isChecked = e;
                            var n = this._toggleContainer;
                            n && n.enabled && this.enabled && (e || !n.anyTogglesChecked() && !n.allowSwitchOff) && (this._isChecked = !0, n.notifyToggleCheck(this, t)), this.playEffect(), t && this._emitToggleEvents()
                        }
                    }, n.playEffect = function() {
                        this._checkMark && (this._checkMark.node.active = this._isChecked)
                    }, n.setIsCheckedWithoutNotify = function(e) {
                        this._set(e, !1)
                    }, n.onEnable = function() {
                        e.prototype.onEnable.call(this), this.playEffect(), this.node.on(t.EventType.CLICK, this._internalToggle, this)
                    }, n.onDisable = function() {
                        e.prototype.onDisable.call(this), this.node.off(t.EventType.CLICK, this._internalToggle, this)
                    }, n.OnDestroy = function() {
                        var e = this._toggleContainer;
                        e && e.ensureValidState()
                    }, n._emitToggleEvents = function() {
                        this.node.emit(t.EventType.TOGGLE, this), this.checkEvents && uM.emitEvents(this.checkEvents, this)
                    }, K(t, [{
                        key: "isChecked",
                        get: function() {
                            return this._isChecked
                        },
                        set: function(e) {
                            this._set(e)
                        }
                    }, {
                        key: "checkMark",
                        get: function() {
                            return this._checkMark
                        },
                        set: function(e) {
                            this._checkMark !== e && (this._checkMark = e)
                        }
                    }, {
                        key: "_resizeToTarget",
                        set: function(e) {
                            e && this._resizeNodeToTargetNode()
                        }
                    }, {
                        key: "_toggleContainer",
                        get: function() {
                            var e = this.node.parent;
                            return i.Node.isNode(e) ? e.getComponent("cc.ToggleContainer") : null
                        }
                    }]), t
                }(g1), B8.EventType = G8(z8, _1), ie((D8 = F8).prototype, "isChecked", [x8, C8], Object.getOwnPropertyDescriptor(D8.prototype, "isChecked"), D8.prototype), ie(D8.prototype, "checkMark", [b8, R8, w8], Object.getOwnPropertyDescriptor(D8.prototype, "checkMark"), D8.prototype), N8 = ie(D8.prototype, "checkEvents", [I8, w_, P8], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return []
                    }
                }), M8 = ie(D8.prototype, "_isChecked", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return !0
                    }
                }), L8 = ie(D8.prototype, "_checkMark", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return null
                    }
                }), O8 = D8)) || O8) || O8) || O8) || O8) || O8)),
                X6 = function(t) {
                    return e({
                        ToggleContainer: t,
                        ToggleContainerComponent: t
                    }), t
                }((H8 = A_("cc.ToggleContainer"), k8 = B_(), V8 = C_(110), W8 = D_(), j8 = G_(), q8 = ef([uM]), X8 = G_(), H8(Y8 = k8(Y8 = V8(Y8 = W8(Y8 = O_((J8 = function(e) {
                    function t() {
                        for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                        return ne(t = e.call.apply(e, [this].concat(i)) || this, "_allowSwitchOff", Z8, $(t)), ne(t, "checkEvents", Q8, $(t)), t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.onEnable = function() {
                        this.ensureValidState(), this.node.on(Om.CHILD_ADDED, this.ensureValidState, this), this.node.on(Om.CHILD_REMOVED, this.ensureValidState, this)
                    }, n.onDisable = function() {
                        this.node.off(Om.CHILD_ADDED, this.ensureValidState, this), this.node.off(Om.CHILD_REMOVED, this.ensureValidState, this)
                    }, n.activeToggles = function() {
                        return this.toggleItems.filter((function(e) {
                            return e.isChecked
                        }))
                    }, n.anyTogglesChecked = function() {
                        return !!this.toggleItems.find((function(e) {
                            return e.isChecked
                        }))
                    }, n.notifyToggleCheck = function(e, t) {
                        if (void 0 === t && (t = !0), this.enabledInHierarchy) {
                            for (var n = 0; n < this.toggleItems.length; n++) {
                                var r = this.toggleItems[n];
                                r !== e && (t ? r.isChecked = !1 : r.setIsCheckedWithoutNotify(!1))
                            }
                            this.checkEvents && i.Component.EventHandler.emitEvents(this.checkEvents, e)
                        }
                    }, n.ensureValidState = function() {
                        var e = this.toggleItems;
                        if (!this._allowSwitchOff && !this.anyTogglesChecked() && 0 !== e.length) {
                            var t = e[0];
                            t.isChecked = !0, this.notifyToggleCheck(t)
                        }
                        var n = this.activeToggles();
                        if (n.length > 1)
                            for (var i = n[0], r = 0; r < n.length; ++r) {
                                var o = n[r];
                                o !== i && (o.isChecked = !1)
                            }
                    }, K(t, [{
                        key: "allowSwitchOff",
                        get: function() {
                            return this._allowSwitchOff
                        },
                        set: function(e) {
                            this._allowSwitchOff = e
                        }
                    }, {
                        key: "toggleItems",
                        get: function() {
                            return this.node.children.map((function(e) {
                                var t = e.getComponent("cc.Toggle");
                                return t && t.enabled ? t : null
                            })).filter(Boolean)
                        }
                    }]), t
                }(Jd), Z8 = ie((K8 = J8).prototype, "_allowSwitchOff", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return !1
                    }
                }), ie(K8.prototype, "allowSwitchOff", [j8], Object.getOwnPropertyDescriptor(K8.prototype, "allowSwitchOff"), K8.prototype), Q8 = ie(K8.prototype, "checkEvents", [q8, w_, X8], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return []
                    }
                }), Y8 = K8)) || Y8) || Y8) || Y8) || Y8) || Y8)),
                Y6 = new Gn;

            function K6(e) {
                return e instanceof zP ? jC : e._uiProps.uiTransformComp ? e._uiProps.uiTransformComp.contentSize : Xn.ZERO
            }

            function Z6(e, t, n, i) {
                e.parent ? Y6.set(e.parent.getScale().x, e.parent.getScale().y) : Y6.set(0, 0);
                for (var r = Y6.x, o = Y6.y, a = 0, s = 0, c = e.parent;;) {
                    if (!c) return n.x = n.y = 0, void(i.x = i.y = 1);
                    var l = c.getPosition();
                    if (a += l.x, s += l.y, (c = c.parent) === t) break;
                    c ? Y6.set(c.getScale().x, c.getScale().y) : Y6.set(0, 0);
                    var u = Y6.x,
                        h = Y6.y;
                    a *= u, s *= h, r *= u, o *= h
                }
                i.x = 0 !== r ? 1 / r : 1, i.y = 0 !== o ? 1 / o : 1, n.x = -a, n.y = -s
            }! function(e) {
                e[e.ONCE = 0] = "ONCE", e[e.ALWAYS = 1] = "ALWAYS", e[e.ON_WINDOW_RESIZE = 2] = "ON_WINDOW_RESIZE"
            }(W6 || (W6 = {})), nt(W6),
                function(e) {
                    e[e.TOP = 1] = "TOP", e[e.MID = 2] = "MID", e[e.BOT = 4] = "BOT", e[e.LEFT = 8] = "LEFT", e[e.CENTER = 16] = "CENTER", e[e.RIGHT = 32] = "RIGHT", e[e.HORIZONTAL = 56] = "HORIZONTAL", e[e.VERTICAL = 7] = "VERTICAL"
                }(j6 || (j6 = {}));
            var Q6, J6, $6, e7, t7, n7, i7, r7, o7, a7, s7, c7, l7, u7, h7, _7, f7, d7, p7, m7 = j6.TOP | j6.BOT,
                g7 = j6.LEFT | j6.RIGHT,
                v7 = function(t) {
                    return e({
                        Widget: t,
                        WidgetComponent: t
                    }), t
                }(($8 = A_("cc.Widget"), e6 = B_(), t6 = C_(110), n6 = D_(), i6 = x_(pj), r6 = ef(Yv), o6 = G_(), a6 = G_(), s6 = G_(), c6 = G_(), l6 = G_(), u6 = G_(), h6 = G_(), _6 = z_(), f6 = z_(), d6 = G_(), p6 = G_(), m6 = G_(), g6 = G_(), v6 = G_(), y6 = G_(), S6 = ef(W6), E6 = G_(), $8(T6 = e6(T6 = t6(T6 = n6(T6 = i6(T6 = O_((V6 = k6 = function(e) {
                    function t() {
                        for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                        return (t = e.call.apply(e, [this].concat(i)) || this)._lastPos = new En, t._lastSize = new Xn, t._dirty = !0, t._hadAlignOnce = !1, ne(t, "_alignFlags", x6, $(t)), ne(t, "_target", C6, $(t)), ne(t, "_left", b6, $(t)), ne(t, "_right", R6, $(t)), ne(t, "_top", w6, $(t)), ne(t, "_bottom", I6, $(t)), ne(t, "_horizontalCenter", P6, $(t)), ne(t, "_verticalCenter", O6, $(t)), ne(t, "_isAbsLeft", D6, $(t)), ne(t, "_isAbsRight", N6, $(t)), ne(t, "_isAbsTop", M6, $(t)), ne(t, "_isAbsBottom", L6, $(t)), ne(t, "_isAbsHorizontalCenter", B6, $(t)), ne(t, "_isAbsVerticalCenter", F6, $(t)), ne(t, "_originalWidth", z6, $(t)), ne(t, "_originalHeight", U6, $(t)), ne(t, "_alignMode", G6, $(t)), ne(t, "_lockFlags", H6, $(t)), t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.updateAlignment = function() {
                        i._widgetManager.updateAlignment(this.node)
                    }, n._validateTargetInDEV = function() {}, n.setDirty = function() {
                        this._recursiveDirty()
                    }, n.onEnable = function() {
                        this.node.getPosition(this._lastPos), this._lastSize.set(this.node._uiProps.uiTransformComp.contentSize), i._widgetManager.add(this), this._hadAlignOnce = !1, this._registerEvent(), this._registerTargetEvents()
                    }, n.onDisable = function() {
                        i._widgetManager.remove(this), this._unregisterEvent(), this._unregisterTargetEvents()
                    }, n.onDestroy = function() {
                        this._removeParentEvent()
                    }, n._adjustWidgetToAllowMovingInEditor = function() {}, n._adjustWidgetToAllowResizingInEditor = function() {}, n._adjustWidgetToAnchorChanged = function() {
                        this.setDirty()
                    }, n._adjustTargetToParentChanged = function(e) {
                        e && this._unregisterOldParentEvents(e), this.node.getParent() && this._registerTargetEvents(), this._setDirtyByMode()
                    }, n._registerEvent = function() {
                        this.node.on(Om.TRANSFORM_CHANGED, this._setDirtyByMode, this), this.node.on(Om.SIZE_CHANGED, this._setDirtyByMode, this), this.node.on(Om.ANCHOR_CHANGED, this._adjustWidgetToAnchorChanged, this), this.node.on(Om.PARENT_CHANGED, this._adjustTargetToParentChanged, this)
                    }, n._unregisterEvent = function() {
                        this.node.off(Om.TRANSFORM_CHANGED, this._setDirtyByMode, this), this.node.off(Om.SIZE_CHANGED, this._setDirtyByMode, this), this.node.off(Om.ANCHOR_CHANGED, this._adjustWidgetToAnchorChanged, this)
                    }, n._removeParentEvent = function() {
                        this.node.off(Om.PARENT_CHANGED, this._adjustTargetToParentChanged, this)
                    }, n._autoChangedValue = function(e, t) {
                        if ((this._alignFlags & e) > 0) {
                            var n = this.node.parent && this.node.parent._uiProps,
                                i = n && n.uiTransformComp,
                                r = i ? i.contentSize : jC;
                            this.isAlignLeft && e === j6.LEFT ? this._left = t ? this._left * r.width : this._left / r.width : this.isAlignRight && e === j6.RIGHT ? this._right = t ? this._right * r.width : this._right / r.width : this.isAlignHorizontalCenter && e === j6.CENTER ? this._horizontalCenter = t ? this._horizontalCenter * r.width : this._horizontalCenter / r.width : this.isAlignTop && e === j6.TOP ? this._top = t ? this._top * r.height : this._top / r.height : this.isAlignBottom && e === j6.BOT ? this._bottom = t ? this._bottom * r.height : this._bottom / r.height : this.isAbsoluteVerticalCenter && e === j6.MID && (this._verticalCenter = this._verticalCenter / r.height), this._recursiveDirty()
                        }
                    }, n._registerTargetEvents = function() {
                        var e = this._target || this.node.parent;
                        e && e.getComponent(pj) && (e.on(Om.TRANSFORM_CHANGED, this._setDirtyByMode, this), e.on(Om.SIZE_CHANGED, this._setDirtyByMode, this))
                    }, n._unregisterTargetEvents = function() {
                        var e = this._target || this.node.parent;
                        e && (e.off(Om.TRANSFORM_CHANGED, this._setDirtyByMode, this), e.off(Om.SIZE_CHANGED, this._setDirtyByMode, this))
                    }, n._unregisterOldParentEvents = function(e) {
                        var t = this._target || e;
                        t && (t.off(Om.TRANSFORM_CHANGED, this._setDirtyByMode, this), t.off(Om.SIZE_CHANGED, this._setDirtyByMode, this))
                    }, n._setDirtyByMode = function() {
                        this.alignMode === W6.ALWAYS && this._recursiveDirty()
                    }, n._setAlign = function(e, t) {
                        if (t !== (this._alignFlags & e) > 0) {
                            var n = (e & g7) > 0,
                                i = this.node._uiProps.uiTransformComp;
                            t ? (this._alignFlags |= e, n ? (this.isAlignHorizontalCenter = !1, this.isStretchWidth && (this._originalWidth = i.width)) : (this.isAlignVerticalCenter = !1, this.isStretchHeight && (this._originalHeight = i.height))) : (n ? this.isStretchWidth && (i.width = this._originalWidth) : this.isStretchHeight && (i.height = this._originalHeight), this._alignFlags &= ~e)
                        }
                    }, n._recursiveDirty = function() {
                        this._dirty || (this._dirty = !0)
                    }, K(t, [{
                        key: "target",
                        get: function() {
                            return this._target
                        },
                        set: function(e) {
                            this._target !== e && (this._unregisterTargetEvents(), this._target = e, this._registerTargetEvents(), this._validateTargetInDEV(), this._recursiveDirty())
                        }
                    }, {
                        key: "isAlignTop",
                        get: function() {
                            return (this._alignFlags & j6.TOP) > 0
                        },
                        set: function(e) {
                            this._setAlign(j6.TOP, e), this._recursiveDirty()
                        }
                    }, {
                        key: "isAlignBottom",
                        get: function() {
                            return (this._alignFlags & j6.BOT) > 0
                        },
                        set: function(e) {
                            this._setAlign(j6.BOT, e), this._recursiveDirty()
                        }
                    }, {
                        key: "isAlignLeft",
                        get: function() {
                            return (this._alignFlags & j6.LEFT) > 0
                        },
                        set: function(e) {
                            this._setAlign(j6.LEFT, e), this._recursiveDirty()
                        }
                    }, {
                        key: "isAlignRight",
                        get: function() {
                            return (this._alignFlags & j6.RIGHT) > 0
                        },
                        set: function(e) {
                            this._setAlign(j6.RIGHT, e), this._recursiveDirty()
                        }
                    }, {
                        key: "isAlignVerticalCenter",
                        get: function() {
                            return (this._alignFlags & j6.MID) > 0
                        },
                        set: function(e) {
                            e ? (this.isAlignTop = !1, this.isAlignBottom = !1, this._alignFlags |= j6.MID) : this._alignFlags &= ~j6.MID, this._recursiveDirty()
                        }
                    }, {
                        key: "isAlignHorizontalCenter",
                        get: function() {
                            return (this._alignFlags & j6.CENTER) > 0
                        },
                        set: function(e) {
                            e ? (this.isAlignLeft = !1, this.isAlignRight = !1, this._alignFlags |= j6.CENTER) : this._alignFlags &= ~j6.CENTER, this._recursiveDirty()
                        }
                    }, {
                        key: "isStretchWidth",
                        get: function() {
                            return (this._alignFlags & g7) === g7
                        }
                    }, {
                        key: "isStretchHeight",
                        get: function() {
                            return (this._alignFlags & m7) === m7
                        }
                    }, {
                        key: "top",
                        get: function() {
                            return this._top
                        },
                        set: function(e) {
                            this._top = e, this._recursiveDirty()
                        }
                    }, {
                        key: "editorTop",
                        get: function() {
                            return this._isAbsTop ? this._top : 100 * this._top
                        },
                        set: function(e) {
                            this._top = this._isAbsTop ? e : e / 100, this._recursiveDirty()
                        }
                    }, {
                        key: "bottom",
                        get: function() {
                            return this._bottom
                        },
                        set: function(e) {
                            this._bottom = e, this._recursiveDirty()
                        }
                    }, {
                        key: "editorBottom",
                        get: function() {
                            return this._isAbsBottom ? this._bottom : 100 * this._bottom
                        },
                        set: function(e) {
                            this._bottom = this._isAbsBottom ? e : e / 100, this._recursiveDirty()
                        }
                    }, {
                        key: "left",
                        get: function() {
                            return this._left
                        },
                        set: function(e) {
                            this._left = e, this._recursiveDirty()
                        }
                    }, {
                        key: "editorLeft",
                        get: function() {
                            return this._isAbsLeft ? this._left : 100 * this._left
                        },
                        set: function(e) {
                            this._left = this._isAbsLeft ? e : e / 100, this._recursiveDirty()
                        }
                    }, {
                        key: "right",
                        get: function() {
                            return this._right
                        },
                        set: function(e) {
                            this._right = e, this._recursiveDirty()
                        }
                    }, {
                        key: "editorRight",
                        get: function() {
                            return this._isAbsRight ? this._right : 100 * this._right
                        },
                        set: function(e) {
                            this._right = this._isAbsRight ? e : e / 100, this._recursiveDirty()
                        }
                    }, {
                        key: "horizontalCenter",
                        get: function() {
                            return this._horizontalCenter
                        },
                        set: function(e) {
                            this._horizontalCenter = e, this._recursiveDirty()
                        }
                    }, {
                        key: "editorHorizontalCenter",
                        get: function() {
                            return this._isAbsHorizontalCenter ? this._horizontalCenter : 100 * this._horizontalCenter
                        },
                        set: function(e) {
                            this._horizontalCenter = this._isAbsHorizontalCenter ? e : e / 100, this._recursiveDirty()
                        }
                    }, {
                        key: "verticalCenter",
                        get: function() {
                            return this._verticalCenter
                        },
                        set: function(e) {
                            this._verticalCenter = e, this._recursiveDirty()
                        }
                    }, {
                        key: "editorVerticalCenter",
                        get: function() {
                            return this._isAbsVerticalCenter ? this._verticalCenter : 100 * this._verticalCenter
                        },
                        set: function(e) {
                            this._verticalCenter = this._isAbsVerticalCenter ? e : e / 100, this._recursiveDirty()
                        }
                    }, {
                        key: "isAbsoluteTop",
                        get: function() {
                            return this._isAbsTop
                        },
                        set: function(e) {
                            this._isAbsTop !== e && (this._isAbsTop = e, this._autoChangedValue(j6.TOP, this._isAbsTop))
                        }
                    }, {
                        key: "isAbsoluteBottom",
                        get: function() {
                            return this._isAbsBottom
                        },
                        set: function(e) {
                            this._isAbsBottom !== e && (this._isAbsBottom = e, this._autoChangedValue(j6.BOT, this._isAbsBottom))
                        }
                    }, {
                        key: "isAbsoluteLeft",
                        get: function() {
                            return this._isAbsLeft
                        },
                        set: function(e) {
                            this._isAbsLeft !== e && (this._isAbsLeft = e, this._autoChangedValue(j6.LEFT, this._isAbsLeft))
                        }
                    }, {
                        key: "isAbsoluteRight",
                        get: function() {
                            return this._isAbsRight
                        },
                        set: function(e) {
                            this._isAbsRight !== e && (this._isAbsRight = e, this._autoChangedValue(j6.RIGHT, this._isAbsRight))
                        }
                    }, {
                        key: "isAbsoluteHorizontalCenter",
                        get: function() {
                            return this._isAbsHorizontalCenter
                        },
                        set: function(e) {
                            this._isAbsHorizontalCenter !== e && (this._isAbsHorizontalCenter = e, this._autoChangedValue(j6.CENTER, this._isAbsHorizontalCenter))
                        }
                    }, {
                        key: "isAbsoluteVerticalCenter",
                        get: function() {
                            return this._isAbsVerticalCenter
                        },
                        set: function(e) {
                            this._isAbsVerticalCenter !== e && (this._isAbsVerticalCenter = e, this._autoChangedValue(j6.MID, this._isAbsVerticalCenter))
                        }
                    }, {
                        key: "alignMode",
                        get: function() {
                            return this._alignMode
                        },
                        set: function(e) {
                            this._alignMode = e, this._recursiveDirty()
                        }
                    }, {
                        key: "alignFlags",
                        get: function() {
                            return this._alignFlags
                        },
                        set: function(e) {
                            this._alignFlags !== e && (this._alignFlags = e, this._recursiveDirty())
                        }
                    }]), t
                }(Jd), k6.AlignMode = W6, ie((A6 = V6).prototype, "target", [r6, o6], Object.getOwnPropertyDescriptor(A6.prototype, "target"), A6.prototype), ie(A6.prototype, "isAlignTop", [a6], Object.getOwnPropertyDescriptor(A6.prototype, "isAlignTop"), A6.prototype), ie(A6.prototype, "isAlignBottom", [s6], Object.getOwnPropertyDescriptor(A6.prototype, "isAlignBottom"), A6.prototype), ie(A6.prototype, "isAlignLeft", [c6], Object.getOwnPropertyDescriptor(A6.prototype, "isAlignLeft"), A6.prototype), ie(A6.prototype, "isAlignRight", [l6], Object.getOwnPropertyDescriptor(A6.prototype, "isAlignRight"), A6.prototype), ie(A6.prototype, "isAlignVerticalCenter", [u6], Object.getOwnPropertyDescriptor(A6.prototype, "isAlignVerticalCenter"), A6.prototype), ie(A6.prototype, "isAlignHorizontalCenter", [h6], Object.getOwnPropertyDescriptor(A6.prototype, "isAlignHorizontalCenter"), A6.prototype), ie(A6.prototype, "isStretchWidth", [_6], Object.getOwnPropertyDescriptor(A6.prototype, "isStretchWidth"), A6.prototype), ie(A6.prototype, "isStretchHeight", [f6], Object.getOwnPropertyDescriptor(A6.prototype, "isStretchHeight"), A6.prototype), ie(A6.prototype, "top", [d6], Object.getOwnPropertyDescriptor(A6.prototype, "top"), A6.prototype), ie(A6.prototype, "editorTop", [F_], Object.getOwnPropertyDescriptor(A6.prototype, "editorTop"), A6.prototype), ie(A6.prototype, "bottom", [p6], Object.getOwnPropertyDescriptor(A6.prototype, "bottom"), A6.prototype), ie(A6.prototype, "editorBottom", [F_], Object.getOwnPropertyDescriptor(A6.prototype, "editorBottom"), A6.prototype), ie(A6.prototype, "left", [m6], Object.getOwnPropertyDescriptor(A6.prototype, "left"), A6.prototype), ie(A6.prototype, "editorLeft", [F_], Object.getOwnPropertyDescriptor(A6.prototype, "editorLeft"), A6.prototype), ie(A6.prototype, "right", [g6], Object.getOwnPropertyDescriptor(A6.prototype, "right"), A6.prototype), ie(A6.prototype, "editorRight", [F_], Object.getOwnPropertyDescriptor(A6.prototype, "editorRight"), A6.prototype), ie(A6.prototype, "horizontalCenter", [v6], Object.getOwnPropertyDescriptor(A6.prototype, "horizontalCenter"), A6.prototype), ie(A6.prototype, "editorHorizontalCenter", [F_], Object.getOwnPropertyDescriptor(A6.prototype, "editorHorizontalCenter"), A6.prototype), ie(A6.prototype, "verticalCenter", [y6], Object.getOwnPropertyDescriptor(A6.prototype, "verticalCenter"), A6.prototype), ie(A6.prototype, "editorVerticalCenter", [F_], Object.getOwnPropertyDescriptor(A6.prototype, "editorVerticalCenter"), A6.prototype), ie(A6.prototype, "isAbsoluteTop", [F_], Object.getOwnPropertyDescriptor(A6.prototype, "isAbsoluteTop"), A6.prototype), ie(A6.prototype, "isAbsoluteBottom", [F_], Object.getOwnPropertyDescriptor(A6.prototype, "isAbsoluteBottom"), A6.prototype), ie(A6.prototype, "isAbsoluteLeft", [F_], Object.getOwnPropertyDescriptor(A6.prototype, "isAbsoluteLeft"), A6.prototype), ie(A6.prototype, "isAbsoluteRight", [F_], Object.getOwnPropertyDescriptor(A6.prototype, "isAbsoluteRight"), A6.prototype), ie(A6.prototype, "isAbsoluteHorizontalCenter", [F_], Object.getOwnPropertyDescriptor(A6.prototype, "isAbsoluteHorizontalCenter"), A6.prototype), ie(A6.prototype, "isAbsoluteVerticalCenter", [F_], Object.getOwnPropertyDescriptor(A6.prototype, "isAbsoluteVerticalCenter"), A6.prototype), ie(A6.prototype, "alignMode", [S6, E6], Object.getOwnPropertyDescriptor(A6.prototype, "alignMode"), A6.prototype), ie(A6.prototype, "alignFlags", [F_], Object.getOwnPropertyDescriptor(A6.prototype, "alignFlags"), A6.prototype), x6 = ie(A6.prototype, "_alignFlags", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 0
                    }
                }), C6 = ie(A6.prototype, "_target", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return null
                    }
                }), b6 = ie(A6.prototype, "_left", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 0
                    }
                }), R6 = ie(A6.prototype, "_right", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 0
                    }
                }), w6 = ie(A6.prototype, "_top", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 0
                    }
                }), I6 = ie(A6.prototype, "_bottom", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 0
                    }
                }), P6 = ie(A6.prototype, "_horizontalCenter", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 0
                    }
                }), O6 = ie(A6.prototype, "_verticalCenter", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 0
                    }
                }), D6 = ie(A6.prototype, "_isAbsLeft", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return !0
                    }
                }), N6 = ie(A6.prototype, "_isAbsRight", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return !0
                    }
                }), M6 = ie(A6.prototype, "_isAbsTop", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return !0
                    }
                }), L6 = ie(A6.prototype, "_isAbsBottom", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return !0
                    }
                }), B6 = ie(A6.prototype, "_isAbsHorizontalCenter", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return !0
                    }
                }), F6 = ie(A6.prototype, "_isAbsVerticalCenter", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return !0
                    }
                }), z6 = ie(A6.prototype, "_originalWidth", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 0
                    }
                }), U6 = ie(A6.prototype, "_originalHeight", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 0
                    }
                }), G6 = ie(A6.prototype, "_alignMode", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return W6.ON_WINDOW_RESIZE
                    }
                }), H6 = ie(A6.prototype, "_lockFlags", [w_, I_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 0
                    }
                }), T6 = A6)) || T6) || T6) || T6) || T6) || T6) || T6));
            i.internal.computeInverseTransForTarget = Z6, i.internal.getReadonlyNodeSize = K6;
            var y7, S7 = new yn;
            ! function(e) {
                e[e.HORIZONTAL = 0] = "HORIZONTAL", e[e.VERTICAL = 1] = "VERTICAL"
            }(y7 || (y7 = {})), nt(y7);
            var E7, T7, A7, x7, C7, b7, R7, w7, I7, P7, O7, D7, N7, M7, L7, B7, F7, z7, U7, G7, H7, k7, V7, W7, j7, q7, X7, Y7, K7, Z7, Q7, J7, $7, e9, t9, n9, i9, r9, o9, a9, s9, c9, l9, u9, h9, _9 = function(t) {
                    return e({
                        PageViewIndicator: t,
                        PageViewIndicatorComponent: t
                    }), t
                }((Q6 = A_("cc.PageViewIndicator"), J6 = B_(), $6 = C_(110), e7 = D_(), t7 = ef(KV), n7 = G_(), i7 = ef(y7), r7 = G_(), o7 = ef(Xn), a7 = G_(), s7 = G_(), Q6(c7 = J6(c7 = $6(c7 = e7((p7 = d7 = function(e) {
                    function t() {
                        for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                        return ne(t = e.call.apply(e, [this].concat(i)) || this, "spacing", u7, $(t)), ne(t, "_spriteFrame", h7, $(t)), ne(t, "_direction", _7, $(t)), ne(t, "_cellSize", f7, $(t)), t._layout = null, t._pageView = null, t._indicators = [], t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.onLoad = function() {
                        this._updateLayout()
                    }, n.setPageView = function(e) {
                        this._pageView = e, this._refresh()
                    }, n._updateLayout = function() {
                        this._layout = this.getComponent(h3), this._layout || (this._layout = this.addComponent(h3));
                        var e = this._layout;
                        this.direction === y7.HORIZONTAL ? (e.type = h3.Type.HORIZONTAL, e.spacingX = this.spacing) : this.direction === y7.VERTICAL && (e.type = h3.Type.VERTICAL, e.spacingY = this.spacing), e.resizeMode = h3.ResizeMode.CONTAINER
                    }, n._createIndicator = function() {
                        var e = new Yv;
                        e.layer = this.node.layer;
                        var t = e.addComponent(zK);
                        return t.spriteFrame = this.spriteFrame, t.sizeMode = zK.SizeMode.CUSTOM, e.parent = this.node, e._uiProps.uiTransformComp.setContentSize(this._cellSize), e
                    }, n._changedState = function() {
                        var e = this._indicators;
                        if (0 !== e.length && this._pageView) {
                            var t = this._pageView.curPageIdx;
                            if (!(t >= e.length)) {
                                for (var n = 0; n < e.length; ++n) {
                                    var i = e[n];
                                    if (i._uiProps.uiComp) {
                                        var r = i._uiProps.uiComp;
                                        S7.set(r.color), S7.a = 127.5, r.color = S7
                                    }
                                }
                                if (e[t]._uiProps.uiComp) {
                                    var o = e[t]._uiProps.uiComp;
                                    S7.set(o.color), S7.a = 255, o.color = S7
                                }
                            }
                        }
                    }, n._refresh = function() {
                        if (this._pageView) {
                            var e = this._indicators,
                                t = this._pageView.getPages();
                            if (t.length !== e.length) {
                                var n = 0;
                                if (t.length > e.length)
                                    for (n = 0; n < t.length; ++n) e[n] || (e[n] = this._createIndicator());
                                else
                                    for (n = e.length - t.length; n > 0; --n) {
                                        var i = e[n - 1];
                                        this.node.removeChild(i), e.splice(n - 1, 1)
                                    }
                                this._layout && this._layout.enabledInHierarchy && this._layout.updateLayout(), this._changedState()
                            }
                        }
                    }, K(t, [{
                        key: "spriteFrame",
                        get: function() {
                            return this._spriteFrame
                        },
                        set: function(e) {
                            this._spriteFrame !== e && (this._spriteFrame = e)
                        }
                    }, {
                        key: "direction",
                        get: function() {
                            return this._direction
                        },
                        set: function(e) {
                            this._direction !== e && (this._direction = e)
                        }
                    }, {
                        key: "cellSize",
                        get: function() {
                            return this._cellSize
                        },
                        set: function(e) {
                            this._cellSize !== e && (this._cellSize = e)
                        }
                    }]), t
                }(Jd), d7.Direction = y7, ie((l7 = p7).prototype, "spriteFrame", [t7, n7], Object.getOwnPropertyDescriptor(l7.prototype, "spriteFrame"), l7.prototype), ie(l7.prototype, "direction", [i7, r7], Object.getOwnPropertyDescriptor(l7.prototype, "direction"), l7.prototype), ie(l7.prototype, "cellSize", [o7, a7], Object.getOwnPropertyDescriptor(l7.prototype, "cellSize"), l7.prototype), u7 = ie(l7.prototype, "spacing", [w_, s7], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 0
                    }
                }), h7 = ie(l7.prototype, "_spriteFrame", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return null
                    }
                }), _7 = ie(l7.prototype, "_direction", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return y7.HORIZONTAL
                    }
                }), f7 = ie(l7.prototype, "_cellSize", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return new Xn(20, 20)
                    }
                }), c7 = l7)) || c7) || c7) || c7) || c7)),
                f9 = new Gn;
            ! function(e) {
                e[e.Unified = 0] = "Unified", e[e.Free = 1] = "Free"
            }(l9 || (l9 = {})), nt(l9),
                function(e) {
                    e[e.Horizontal = 0] = "Horizontal", e[e.Vertical = 1] = "Vertical"
                }(u9 || (u9 = {})), nt(u9),
                function(e) {
                    e.PAGE_TURNING = "page-turning"
                }(h9 || (h9 = {}));
            var d9 = function(t) {
                    return e({
                        PageView: t,
                        PageViewComponent: t
                    }), t
                }((E7 = A_("cc.PageView"), T7 = B_(), A7 = C_(110), x7 = D_(), C7 = ef(l9), b7 = G_(), R7 = ef(u9), w7 = G_(), I7 = H_(), P7 = G_(), O7 = H_(), D7 = G_(), N7 = ef(_9), M7 = G_(), L7 = G_(), B7 = ef(U5), F7 = z_(), z7 = ef(U5), U7 = z_(), G7 = z_(), H7 = z_(), k7 = z_(), V7 = ef([uM]), W7 = z_(), j7 = ef([uM]), q7 = G_(), E7(X7 = T7(X7 = A7(X7 = x7((c9 = s9 = function(e) {
                    function t() {
                        for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                        return ne(t = e.call.apply(e, [this].concat(i)) || this, "autoPageTurningThreshold", K7, $(t)), ne(t, "horizontal", Z7, $(t)), ne(t, "vertical", Q7, $(t)), ne(t, "cancelInnerEvents", J7, $(t)), ne(t, "scrollEvents", $7, $(t)), ne(t, "pageTurningSpeed", e9, $(t)), ne(t, "pageEvents", t9, $(t)), ne(t, "_sizeMode", n9, $(t)), ne(t, "_direction", i9, $(t)), ne(t, "_scrollThreshold", r9, $(t)), ne(t, "_pageTurningEventTiming", o9, $(t)), ne(t, "_indicator", a9, $(t)), t._curPageIdx = 0, t._lastPageIdx = 0, t._pages = [], t._initContentPos = new En, t._scrollCenterOffsetX = [], t._scrollCenterOffsetY = [], t._touchBeganPosition = new Gn, t._touchEndPosition = new Gn, t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.onEnable = function() {
                        e.prototype.onEnable.call(this), this.node.on(Om.SIZE_CHANGED, this._updateAllPagesSize, this), this.node.on(t.EventType.SCROLL_ENG_WITH_THRESHOLD, this._dispatchPageTurningEvent, this)
                    }, n.onDisable = function() {
                        e.prototype.onDisable.call(this), this.node.off(Om.SIZE_CHANGED, this._updateAllPagesSize, this), this.node.off(t.EventType.SCROLL_ENG_WITH_THRESHOLD, this._dispatchPageTurningEvent, this)
                    }, n.onLoad = function() {
                        this._initPages(), this.indicator && this.indicator.setPageView(this)
                    }, n.getCurrentPageIndex = function() {
                        return this._curPageIdx
                    }, n.setCurrentPageIndex = function(e) {
                        this.scrollToPage(e, 1)
                    }, n.getPages = function() {
                        return this._pages
                    }, n.addPage = function(e) {
                        e && -1 === this._pages.indexOf(e) && this.content && (e._uiProps.uiTransformComp ? (this.content.addChild(e), this._pages.push(e), this._updatePageView()) : T(4301))
                    }, n.insertPage = function(e, t) {
                        if (!(t < 0) && e && -1 === this._pages.indexOf(e) && this.content)
                            if (t >= this._pages.length) this.addPage(e);
                            else {
                                if (!e._uiProps.uiTransformComp) return void T(4301);
                                this._pages.splice(t, 0, e), this.content.insertChild(e, t), this._updatePageView()
                            }
                    }, n.removePage = function(e) {
                        if (e && this.content) {
                            var t = this._pages.indexOf(e); - 1 !== t ? this.removePageAtIndex(t) : x(4300, e.name)
                        }
                    }, n.removePageAtIndex = function(e) {
                        var t = this._pages;
                        if (!(e < 0 || e >= t.length)) {
                            var n = t[e];
                            n && this.content && (this.content.removeChild(n), t.splice(e, 1), this._updatePageView())
                        }
                    }, n.removeAllPages = function() {
                        if (this.content) {
                            for (var e = this._pages, t = 0, n = e.length; t < n; t++) this.content.removeChild(e[t]);
                            this._pages.length = 0, this._updatePageView()
                        }
                    }, n.scrollToPage = function(e, t) {
                        void 0 === t && (t = .3), e < 0 || e >= this._pages.length || (this._curPageIdx = e, this.scrollToOffset(this._moveOffsetValue(e), t, !0), this.indicator && this.indicator._changedState())
                    }, n.getScrollEndedEventTiming = function() {
                        return this.pageTurningEventTiming
                    }, n._updatePageView = function() {
                        if (this.content) {
                            var e = this.content.getComponent(h3);
                            e && e.enabled && e.updateLayout();
                            var t = this._pages.length;
                            this._curPageIdx >= t && (this._curPageIdx = 0 === t ? 0 : t - 1, this._lastPageIdx = this._curPageIdx);
                            for (var n = this._initContentPos, i = 0; i < t; ++i) {
                                var r = this._pages[i].position;
                                this.direction === u9.Horizontal ? this._scrollCenterOffsetX[i] = Math.abs(n.x + r.x) : this._scrollCenterOffsetY[i] = Math.abs(n.y + r.y)
                            }
                            this.indicator && this.indicator._refresh()
                        }
                    }, n._updateAllPagesSize = function() {
                        var e = this.view;
                        if (this.content && e && this._sizeMode === l9.Unified)
                            for (var t = this._pages, n = e.contentSize, i = 0, r = t.length; i < r; i++) t[i]._uiProps.uiTransformComp.setContentSize(n)
                    }, n._handleReleaseLogic = function() {
                        this._autoScrollToPage(), this._scrolling && (this._scrolling = !1, this._autoScrolling || this._dispatchEvent(t.EventType.SCROLL_ENDED))
                    }, n._onTouchBegan = function(t, n) {
                        t.touch.getUILocation(f9), Gn.set(this._touchBeganPosition, f9.x, f9.y), e.prototype._onTouchBegan.call(this, t, n)
                    }, n._onTouchMoved = function(t, n) {
                        e.prototype._onTouchMoved.call(this, t, n)
                    }, n._onTouchEnded = function(t, n) {
                        t.touch.getUILocation(f9), Gn.set(this._touchEndPosition, f9.x, f9.y), e.prototype._onTouchEnded.call(this, t, n)
                    }, n._onTouchCancelled = function(t, n) {
                        t.touch.getUILocation(f9), Gn.set(this._touchEndPosition, f9.x, f9.y), e.prototype._onTouchCancelled.call(this, t, n)
                    }, n._onMouseWheel = function() {}, n._syncScrollDirection = function() {
                        this.horizontal = this.direction === u9.Horizontal, this.vertical = this.direction === u9.Vertical
                    }, n._syncSizeMode = function() {
                        var e = this.view;
                        if (this.content && e) {
                            var t = this.content.getComponent(h3);
                            if (t) {
                                if (this._sizeMode === l9.Free && this._pages.length > 0) {
                                    var n = this._pages[0]._uiProps.uiTransformComp,
                                        i = this._pages[this._pages.length - 1]._uiProps.uiTransformComp;
                                    this.direction === u9.Horizontal ? (t.paddingLeft = (e.width - n.width) / 2, t.paddingRight = (e.width - i.width) / 2) : this.direction === u9.Vertical && (t.paddingTop = (e.height - n.height) / 2, t.paddingBottom = (e.height - i.height) / 2)
                                }
                                t.updateLayout()
                            }
                        }
                    }, n._initPages = function() {
                        if (this.content) {
                            this._initContentPos = this.content.position;
                            for (var e = this.content.children, t = 0; t < e.length; ++t) {
                                var n = e[t];
                                this._pages.indexOf(n) >= 0 || this._pages.push(n)
                            }
                            this._syncScrollDirection(), this._syncSizeMode(), this._updatePageView()
                        }
                    }, n._dispatchPageTurningEvent = function() {
                        this._lastPageIdx !== this._curPageIdx && (this._lastPageIdx = this._curPageIdx, uM.emitEvents(this.pageEvents, this, h9.PAGE_TURNING), this.node.emit(h9.PAGE_TURNING, this))
                    }, n._isQuicklyScrollable = function(e) {
                        if (this.direction === u9.Horizontal) {
                            if (Math.abs(e.x) > this.autoPageTurningThreshold) return !0
                        } else if (this.direction === u9.Vertical && Math.abs(e.y) > this.autoPageTurningThreshold) return !0;
                        return !1
                    }, n._moveOffsetValue = function(e) {
                        var t = new Gn;
                        if (this._sizeMode === l9.Free) this.direction === u9.Horizontal ? t.x = this._scrollCenterOffsetX[e] : this.direction === u9.Vertical && (t.y = this._scrollCenterOffsetY[e]);
                        else {
                            var n = this.view;
                            if (!n) return t;
                            this.direction === u9.Horizontal ? t.x = e * n.width : this.direction === u9.Vertical && (t.y = e * n.height)
                        }
                        return t
                    }, n._getDragDirection = function(e) {
                        return this._direction === u9.Horizontal ? 0 === e.x ? 0 : e.x > 0 ? 1 : -1 : 0 === e.y ? 0 : e.y < 0 ? 1 : -1
                    }, n._isScrollable = function(e, t, n) {
                        if (this._sizeMode === l9.Free) {
                            var i = 0,
                                r = 0;
                            if (this.direction === u9.Horizontal) return i = this._scrollCenterOffsetX[t], r = this._scrollCenterOffsetX[n], Math.abs(e.x) >= Math.abs(i - r) * this.scrollThreshold;
                            if (this.direction === u9.Vertical) return i = this._scrollCenterOffsetY[t], r = this._scrollCenterOffsetY[n], Math.abs(e.y) >= Math.abs(i - r) * this.scrollThreshold
                        } else {
                            var o = this.view;
                            if (!o) return !1;
                            if (this.direction === u9.Horizontal) return Math.abs(e.x) >= o.width * this.scrollThreshold;
                            if (this.direction === u9.Vertical) return Math.abs(e.y) >= o.height * this.scrollThreshold
                        }
                        return !1
                    }, n._autoScrollToPage = function() {
                        if (this._startBounceBackIfNeeded()) {
                            var e = this._getHowMuchOutOfBoundary();
                            this._clampDelta(e), (e.x > 0 || e.y < 0) && (this._curPageIdx = 0 === this._pages.length ? 0 : this._pages.length - 1), (e.x < 0 || e.y > 0) && (this._curPageIdx = 0), this.indicator && this.indicator._changedState()
                        } else {
                            var t = new Gn;
                            Gn.subtract(t, this._touchBeganPosition, this._touchEndPosition);
                            var n = this._curPageIdx,
                                i = n + this._getDragDirection(t),
                                r = this.pageTurningSpeed * Math.abs(n - i);
                            if (i < this._pages.length) {
                                if (this._isScrollable(t, n, i)) return void this.scrollToPage(i, r);
                                var o = this._calculateTouchMoveVelocity();
                                if (this._isQuicklyScrollable(o)) return void this.scrollToPage(i, r)
                            }
                            this.scrollToPage(n, r)
                        }
                    }, K(t, [{
                        key: "sizeMode",
                        get: function() {
                            return this._sizeMode
                        },
                        set: function(e) {
                            this._sizeMode !== e && (this._sizeMode = e, this._syncSizeMode())
                        }
                    }, {
                        key: "direction",
                        get: function() {
                            return this._direction
                        },
                        set: function(e) {
                            this._direction !== e && (this._direction = e, this._syncScrollDirection())
                        }
                    }, {
                        key: "scrollThreshold",
                        get: function() {
                            return this._scrollThreshold
                        },
                        set: function(e) {
                            this._scrollThreshold !== e && (this._scrollThreshold = e)
                        }
                    }, {
                        key: "pageTurningEventTiming",
                        get: function() {
                            return this._pageTurningEventTiming
                        },
                        set: function(e) {
                            this._pageTurningEventTiming !== e && (this._pageTurningEventTiming = e)
                        }
                    }, {
                        key: "indicator",
                        get: function() {
                            return this._indicator
                        },
                        set: function(e) {
                            this._indicator !== e && (this._indicator = e, this.indicator && this.indicator.setPageView(this))
                        }
                    }, {
                        key: "curPageIdx",
                        get: function() {
                            return this._curPageIdx
                        }
                    }, {
                        key: "verticalScrollBar",
                        get: function() {
                            return e.prototype.verticalScrollBar
                        },
                        set: function(e) {
                            this.verticalScrollBar = e
                        }
                    }, {
                        key: "horizontalScrollBar",
                        get: function() {
                            return e.prototype.horizontalScrollBar
                        },
                        set: function(e) {
                            this.horizontalScrollBar = e
                        }
                    }]), t
                }(g8), s9.SizeMode = l9, s9.Direction = u9, s9.EventType = G8(h9, H5), ie((Y7 = c9).prototype, "sizeMode", [C7, b7], Object.getOwnPropertyDescriptor(Y7.prototype, "sizeMode"), Y7.prototype), ie(Y7.prototype, "direction", [R7, w7], Object.getOwnPropertyDescriptor(Y7.prototype, "direction"), Y7.prototype), ie(Y7.prototype, "scrollThreshold", [j_, I7, P7], Object.getOwnPropertyDescriptor(Y7.prototype, "scrollThreshold"), Y7.prototype), ie(Y7.prototype, "pageTurningEventTiming", [j_, O7, D7], Object.getOwnPropertyDescriptor(Y7.prototype, "pageTurningEventTiming"), Y7.prototype), ie(Y7.prototype, "indicator", [N7, M7], Object.getOwnPropertyDescriptor(Y7.prototype, "indicator"), Y7.prototype), K7 = ie(Y7.prototype, "autoPageTurningThreshold", [w_, L7], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 100
                    }
                }), ie(Y7.prototype, "verticalScrollBar", [B7, tf, F7], Object.getOwnPropertyDescriptor(Y7.prototype, "verticalScrollBar"), Y7.prototype), ie(Y7.prototype, "horizontalScrollBar", [z7, tf, U7], Object.getOwnPropertyDescriptor(Y7.prototype, "horizontalScrollBar"), Y7.prototype), Z7 = ie(Y7.prototype, "horizontal", [tf, w_, G7], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return !0
                    }
                }), Q7 = ie(Y7.prototype, "vertical", [tf, w_, H7], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return !0
                    }
                }), J7 = ie(Y7.prototype, "cancelInnerEvents", [tf, w_, k7], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return !0
                    }
                }), $7 = ie(Y7.prototype, "scrollEvents", [V7, w_, tf, W7], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return []
                    }
                }), e9 = ie(Y7.prototype, "pageTurningSpeed", [w_, F_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return .3
                    }
                }), t9 = ie(Y7.prototype, "pageEvents", [j7, w_, q7], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return []
                    }
                }), n9 = ie(Y7.prototype, "_sizeMode", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return l9.Unified
                    }
                }), i9 = ie(Y7.prototype, "_direction", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return u9.Horizontal
                    }
                }), r9 = ie(Y7.prototype, "_scrollThreshold", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return .5
                    }
                }), o9 = ie(Y7.prototype, "_pageTurningEventTiming", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return .1
                    }
                }), a9 = ie(Y7.prototype, "_indicator", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return null
                    }
                }), X7 = Y7)) || X7) || X7) || X7) || X7)),
                p9 = new En,
                m9 = new Gn,
                g9 = new Gn,
                v9 = new Gn(1, 1),
                y9 = new Gn,
                S9 = new Gn;

            function E9(e, t) {
                if (!t._hadAlignOnce) {
                    t.alignMode === W6.ONCE && (t._hadAlignOnce = !0);
                    var n, i = t.target,
                        r = g9,
                        o = v9;
                    i ? Z6(e, n = i, r, o) : n = e.parent;
                    var a = K6(n),
                        s = n instanceof zP || !n.getComponent(pj),
                        c = s ? m9 : n.getComponent(pj).anchorPoint,
                        l = s;
                    e.getPosition(p9);
                    var u = e._uiProps.uiTransformComp,
                        h = p9.x,
                        _ = p9.y,
                        f = u.anchorPoint,
                        d = e.getScale();
                    if (t.alignFlags & j6.HORIZONTAL) {
                        var p = 0,
                            m = 0,
                            g = a.width;
                        l ? (p = jC.left.x, m = jC.right.x) : (m = (p = -c.x * g) + g, p += t.isAbsoluteLeft ? t.left : t.left * g, m -= t.isAbsoluteRight ? t.right : t.right * g), i && (p += r.x, p *= o.x, m += r.x, m *= o.x);
                        var v = 0,
                            y = f.x,
                            S = d.x;
                        if (S < 0 && (y = 1 - y, S = -S), t.isStretchWidth) v = m - p, 0 !== S && (u.width = v / S), h = p + y * v;
                        else if (v = u.width * S, t.isAlignHorizontalCenter) {
                            var E = t.isAbsoluteHorizontalCenter ? t.horizontalCenter : t.horizontalCenter * g,
                                T = (.5 - c.x) * a.width;
                            i && (E *= o.x, T += r.x, T *= o.x), h = T + (y - .5) * v + E
                        } else h = t.isAlignLeft ? p + y * v : m + (y - 1) * v;
                        t._lastSize.width = v
                    }
                    if (t.alignFlags & j6.VERTICAL) {
                        var A = 0,
                            x = 0,
                            C = a.height;
                        l ? (x = jC.bottom.y, A = jC.top.y) : (A = (x = -c.y * C) + C, x += t.isAbsoluteBottom ? t.bottom : t.bottom * C, A -= t.isAbsoluteTop ? t.top : t.top * C), i && (x += r.y, x *= o.y, A += r.y, A *= o.y);
                        var b = 0,
                            R = f.y,
                            w = d.y;
                        if (w < 0 && (R = 1 - R, w = -w), t.isStretchHeight) b = A - x, 0 !== w && (u.height = b / w), _ = x + R * b;
                        else if (b = u.height * w, t.isAlignVerticalCenter) {
                            var I = t.isAbsoluteVerticalCenter ? t.verticalCenter : t.verticalCenter * C,
                                P = (.5 - c.y) * a.height;
                            i && (I *= o.y, P += r.y, P *= o.y), _ = P + (R - .5) * b + I
                        } else _ = t.isAlignBottom ? x + R * b : A + (R - 1) * b;
                        t._lastSize.height = b
                    }
                    e.setPosition(h, _, p9.z), En.set(t._lastPos, h, _, p9.z)
                }
            }

            function T9(e) {
                var t = e.getComponent(v7);
                if (t && t.enabled) {
                    if (!i.isValid(e, !0)) return;
                    C9.push(t)
                }
                for (var n, r = te(e.children); !(n = r()).done;) {
                    var o = n.value;
                    o.active && T9(o)
                }
            }

            function A9() {
                var e = RO.getScene();
                if (e) {
                    b9.isAligning = !0, b9._nodesOrderDirty && (C9.length = 0, T9(e), b9._nodesOrderDirty = !1);
                    var t = null,
                        n = b9._activeWidgetsIterator;
                    for (n.i = 0; n.i < C9.length; ++n.i)(t = C9[n.i])._dirty && (E9(t.node, t), t._dirty = !1);
                    b9.isAligning = !1
                }
            }
            var x9, C9 = [],
                b9 = e("widgetManager", i._widgetManager = {
                    isAligning: !1,
                    _nodesOrderDirty: !1,
                    _activeWidgetsIterator: new Ze.MutableForwardIterator(C9),
                    animationState: null,
                    init: function() {
                        RO.on(bO.EVENT_AFTER_UPDATE, A9), XC.instance.on("design-resolution-changed", this.onResized, this);
                        var e = this.onResized.bind(this);
                        XC.instance.on("canvas-resize", e), Ei.onOrientationChange(e)
                    },
                    add: function() {
                        this._nodesOrderDirty = !0
                    },
                    remove: function(e) {
                        this._activeWidgetsIterator.remove(e)
                    },
                    onResized: function() {
                        var e = RO.getScene();
                        e && this.refreshWidgetOnResized(e)
                    },
                    refreshWidgetOnResized: function(e) {
                        var t = Yv.isNode(e) && e.getComponent(v7);
                        t && t.enabled && (t.alignMode === W6.ON_WINDOW_RESIZE || t.alignMode === W6.ALWAYS) && t.setDirty();
                        for (var n, i = te(e.children); !(n = i()).done;) {
                            var r = n.value;
                            this.refreshWidgetOnResized(r)
                        }
                    },
                    updateOffsetsToStayPut: function(e, t) {
                        function n(e, t) {
                            return Math.abs(e - t) > 1e-10 ? t : e
                        }
                        var i = e.node,
                            r = i.parent;
                        if (r) {
                            var o = y9;
                            o.set(0, 0);
                            var a = S9;
                            if (a.set(1, 1), e.target && Z6(i, r = e.target, o, a), !t) return;
                            var s = r._uiProps && r._uiProps.uiTransformComp,
                                c = s ? s.anchorPoint : m9,
                                l = i._uiProps.uiTransformComp,
                                u = K6(r),
                                h = l.anchorPoint,
                                _ = i.getPosition(),
                                f = j6,
                                d = i.getScale(),
                                p = 0;
                            if (t & f.LEFT) {
                                var m = -c.x * u.width;
                                m += o.x, m *= a.x, p = _.x - h.x * l.width * d.x - m, e.isAbsoluteLeft || (p /= u.width), p /= a.x, e.left = n(e.left, p)
                            }
                            if (t & f.RIGHT) {
                                var g = (1 - c.x) * u.width;
                                g += o.x, p = (g *= a.x) - (_.x + (1 - h.x) * l.width * d.x), e.isAbsoluteRight || (p /= u.width), p /= a.x, e.right = n(e.right, p)
                            }
                            if (t & f.TOP) {
                                var v = (1 - c.y) * u.height;
                                v += o.y, p = (v *= a.y) - (_.y + (1 - h.y) * l.height * d.y), e.isAbsoluteTop || (p /= u.height), p /= a.y, e.top = n(e.top, p)
                            }
                            if (t & f.BOT) {
                                var y = -c.y * u.height;
                                y += o.y, y *= a.y, p = _.y - h.y * l.height * d.y - y, e.isAbsoluteBottom || (p /= u.height), p /= a.y, e.bottom = n(e.bottom, p)
                            }
                        }
                    },
                    updateAlignment: function e(t) {
                        var n = t.parent;
                        n && Yv.isNode(n) && e(n);
                        var i = t.getComponent(v7);
                        i && n && E9(t, i)
                    },
                    AlignMode: W6,
                    AlignFlags: j6
                });
            RO.on(bO.EVENT_INIT, (function() {
                b9.init()
            }));
            var R9, w9, I9, P9, O9, D9, N9, M9, L9, B9, F9, z9, U9, G9, H9, k9, V9, W9, j9, q9, X9 = function(t) {
                    return e({
                        SafeArea: t,
                        SafeAreaComponent: t
                    }), t
                }(A_("cc.SafeArea")(x9 = B_()(x9 = C_(110)(x9 = O_(x9 = D_()(x9 = x_(v7)(x9 = function(e) {
                    function t() {
                        return e.apply(this, arguments) || this
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.onEnable = function() {
                        this.updateArea(), QC.on("canvas-resize", this.updateArea, this)
                    }, n.onDisable = function() {
                        QC.off("canvas-resize", this.updateArea, this)
                    }, n.updateArea = function() {
                        var e = this.node.getComponent(v7),
                            t = this.node.getComponent(pj);
                        if (e && t) {
                            e.updateAlignment();
                            var n = this.node.position.clone(),
                                r = t.anchorPoint.clone();
                            e.isAlignTop = e.isAlignBottom = e.isAlignLeft = e.isAlignRight = !0;
                            var o = i.winSize.width,
                                a = i.winSize.height,
                                s = oS.getSafeAreaRect();
                            e.top = a - s.y - s.height, e.bottom = s.y, e.left = s.x, e.right = o - s.x - s.width, e.updateAlignment();
                            var c = this.node.position.clone(),
                                l = r.x - (c.x - n.x) / t.width,
                                u = r.y - (c.y - n.y) / t.height;
                            t.setAnchorPoint(l, u), b9.add(e)
                        }
                    }, t
                }(Jd)) || x9) || x9) || x9) || x9) || x9) || x9),
                Y9 = function(t) {
                    return e({
                        UICoordinateTracker: t,
                        UICoordinateTrackerComponent: t
                    }), t
                }((R9 = A_("cc.UICoordinateTracker"), w9 = B_(), I9 = D_(), P9 = C_(110), O9 = ef(Yv), D9 = G_(), N9 = ef(IM), M9 = G_(), L9 = G_(), B9 = G_(), F9 = ef([uM]), z9 = G_(), R9(U9 = w9(U9 = I9(U9 = P9((ie((G9 = function(e) {
                    function t() {
                        for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                        return ne(t = e.call.apply(e, [this].concat(i)) || this, "syncEvents", H9, $(t)), ne(t, "_target", k9, $(t)), ne(t, "_camera", V9, $(t)), ne(t, "_useScale", W9, $(t)), ne(t, "_distance", j9, $(t)), t._transformPos = new En, t._viewPos = new En, t._canMove = !0, t._lastWPos = new En, t._lastCameraPos = new En, t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.onEnable = function() {
                        this._checkCanMove()
                    }, n.update = function() {
                        var e = this.node.worldPosition,
                            t = this._camera;
                        if (this._canMove && t && t.camera && (!this._lastWPos.equals(e) || !this._lastCameraPos.equals(t.node.worldPosition)) && (this._lastWPos.set(e), this._lastCameraPos.set(t.node.worldPosition), t.camera.update(), t.convertToUINode(e, this._target, this._transformPos), this._useScale && En.transformMat4(this._viewPos, this.node.worldPosition, t.camera.matView), this.syncEvents.length > 0)) {
                            var n = this._distance / Math.abs(this._viewPos.z);
                            uM.emitEvents(this.syncEvents, this._transformPos, n)
                        }
                    }, n._checkCanMove = function() {
                        this._canMove = !(!this._camera || !this._target)
                    }, K(t, [{
                        key: "target",
                        get: function() {
                            return this._target
                        },
                        set: function(e) {
                            this._target !== e && (this._target = e, this._checkCanMove())
                        }
                    }, {
                        key: "camera",
                        get: function() {
                            return this._camera
                        },
                        set: function(e) {
                            this._camera !== e && (this._camera = e, this._checkCanMove())
                        }
                    }, {
                        key: "useScale",
                        get: function() {
                            return this._useScale
                        },
                        set: function(e) {
                            this._useScale !== e && (this._useScale = e)
                        }
                    }, {
                        key: "distance",
                        get: function() {
                            return this._distance
                        },
                        set: function(e) {
                            this._distance !== e && (this._distance = e)
                        }
                    }]), t
                }(Jd)).prototype, "target", [O9, D9], Object.getOwnPropertyDescriptor(G9.prototype, "target"), G9.prototype), ie(G9.prototype, "camera", [N9, M9], Object.getOwnPropertyDescriptor(G9.prototype, "camera"), G9.prototype), ie(G9.prototype, "useScale", [L9], Object.getOwnPropertyDescriptor(G9.prototype, "useScale"), G9.prototype), ie(G9.prototype, "distance", [B9], Object.getOwnPropertyDescriptor(G9.prototype, "distance"), G9.prototype), H9 = ie(G9.prototype, "syncEvents", [F9, w_, z9], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return []
                    }
                }), k9 = ie(G9.prototype, "_target", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return null
                    }
                }), V9 = ie(G9.prototype, "_camera", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return null
                    }
                }), W9 = ie(G9.prototype, "_useScale", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return !0
                    }
                }), j9 = ie(G9.prototype, "_distance", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 1
                    }
                }), U9 = G9)) || U9) || U9) || U9) || U9)),
                K9 = [Om.TOUCH_START, Om.TOUCH_END, Om.TOUCH_MOVE, Om.MOUSE_DOWN, Om.MOUSE_MOVE, Om.MOUSE_UP, Om.MOUSE_ENTER, Om.MOUSE_LEAVE, Om.MOUSE_WHEEL];

            function Z9(e) {
                e.propagationStopped = !0
            }
            var Q9, J9, $9, eee, tee, nee, iee, ree, oee, aee, see, cee, lee = function(t) {
                    return e({
                        BlockInputEvents: t,
                        BlockInputEventsComponent: t
                    }), t
                }(A_("cc.BlockInputEvents")(q9 = B_()(q9 = D_()(q9 = function(e) {
                    function t() {
                        return e.apply(this, arguments) || this
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.onEnable = function() {
                        for (var e = 0; e < K9.length; e++) this.node.on(K9[e], Z9, this)
                    }, n.onDisable = function() {
                        for (var e = 0; e < K9.length; e++) this.node.off(K9[e], Z9, this)
                    }, t
                }(Jd)) || q9) || q9) || q9),
                uee = {},
                hee = e("SubContextView", (Q9 = A_("cc.SubContextView"), J9 = B_(), $9 = C_(110), eee = x_(pj), tee = D_(), nee = G_(), iee = G_(), Q9(ree = J9(ree = $9(ree = eee(ree = tee((ie((oee = function(e) {
                    function t() {
                        var t;
                        return ne(t = e.call(this) || this, "_fps", aee, $(t)), t._sprite = void 0, t._imageAsset = void 0, t._updatedTime = 0, t._updateInterval = 0, t._openDataContext = void 0, t._content = void 0, ne(t, "_designResolutionSize", see, $(t)), t._content = new Yv("content"), t._content.hideFlags |= ni.Flags.DontSave | ni.Flags.HideInHierarchy, t._sprite = null, t._imageAsset = new Wf, t._openDataContext = null, t._updatedTime = performance.now(), t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.onLoad = function() {
                        uee.getOpenDataContext ? (this._updateInterval = 1e3 / this._fps, this._openDataContext = uee.getOpenDataContext(), this._initSharedCanvas(), this._initContentNode(), this._updateSubContextView()) : this.enabled = !1
                    }, n.onEnable = function() {
                        this._registerNodeEvent()
                    }, n.onDisable = function() {
                        this._unregisterNodeEvent()
                    }, n._initSharedCanvas = function() {
                        if (this._openDataContext) {
                            var e = this._openDataContext.canvas;
                            e.width = this._designResolutionSize.width, e.height = this._designResolutionSize.height
                        }
                    }, n._initContentNode = function() {
                        if (this._openDataContext) {
                            var e = this._openDataContext.canvas,
                                t = this._imageAsset;
                            if (t.reset(e), t._texture.create(e.width, e.height), this._sprite = this._content.getComponent(zK), this._sprite || (this._sprite = this._content.addComponent(zK)), this._sprite.spriteFrame) this._sprite.spriteFrame.texture = this._imageAsset._texture;
                            else {
                                var n = new KV;
                                n.texture = this._imageAsset._texture, this._sprite.spriteFrame = n
                            }
                            this._content.parent = this.node
                        }
                    }, n._updateSubContextView = function() {
                        if (this._openDataContext && uee.getSystemInfoSync) {
                            var e = this.node.getComponent(pj),
                                t = this._content.getComponent(pj),
                                n = e.width / t.width,
                                i = e.height / t.height,
                                r = n > i ? i : n;
                            t.width *= r, t.height *= r;
                            var o = uee.getSystemInfoSync(),
                                a = t.getBoundingBoxToWorld(),
                                s = QC.getVisibleSize(),
                                c = o.screenWidth * (a.x / s.width),
                                l = o.screenHeight * (a.y / s.height),
                                u = o.screenWidth * (a.width / s.width),
                                h = o.screenHeight * (a.height / s.height);
                            this._openDataContext.postMessage({
                                fromEngine: !0,
                                type: "engine",
                                event: "viewport",
                                x: c,
                                y: l,
                                width: u,
                                height: h
                            })
                        }
                    }, n._updateSubContextTexture = function() {
                        var e = this._imageAsset;
                        if (e && this._openDataContext && !(e.width <= 0 || e.height <= 0)) {
                            var t = this._openDataContext.canvas;
                            e.reset(t), (t.width > e.width || t.height > e.height) && this._imageAsset._texture.create(t.width, t.height), this._imageAsset._texture.uploadData(t)
                        }
                    }, n._registerNodeEvent = function() {
                        this.node.on(Yv.EventType.TRANSFORM_CHANGED, this._updateSubContextView, this), this.node.on(Yv.EventType.SIZE_CHANGED, this._updateSubContextView, this)
                    }, n._unregisterNodeEvent = function() {
                        this.node.off(Yv.EventType.TRANSFORM_CHANGED, this._updateSubContextView, this), this.node.off(Yv.EventType.SIZE_CHANGED, this._updateSubContextView, this)
                    }, n.update = function(e) {
                        void 0 === e ? this._updateSubContextTexture() : performance.now() - this._updatedTime >= this._updateInterval && (this._updatedTime += this._updateInterval, this._updateSubContextTexture())
                    }, K(t, [{
                        key: "designResolutionSize",
                        get: function() {
                            return this._designResolutionSize
                        },
                        set: function() {}
                    }, {
                        key: "fps",
                        get: function() {
                            return this._fps
                        },
                        set: function(e) {
                            this._fps !== e && (this._fps = e, this._updateInterval = 1e3 / e)
                        }
                    }]), t
                }(Jd)).prototype, "designResolutionSize", [nee], Object.getOwnPropertyDescriptor(oee.prototype, "designResolutionSize"), oee.prototype), ie(oee.prototype, "fps", [iee], Object.getOwnPropertyDescriptor(oee.prototype, "fps"), oee.prototype), aee = ie(oee.prototype, "_fps", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 60
                    }
                }), see = ie(oee.prototype, "_designResolutionSize", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return new Xn(640, 960)
                    }
                }), ree = oee)) || ree) || ree) || ree) || ree) || ree));
            i.SubContextView = hee;
            var _ee = e("UIReorderComponent", A_("cc.UIReorderComponent")(cee = function() {
                x(1408, "UIReorderComponent")
            }) || cee);

            function fee(e) {
                return void 0 === (e = e || {}).includeNormal && (e.includeNormal = !0), void 0 === e.includeUV && (e.includeUV = !0), e
            }
            i.UIReorderComponent = _ee, i.ButtonComponent = g1, Qe.setClassAlias(g1, "cc.ButtonComponent"), i.EditBoxComponent = N4, Qe.setClassAlias(N4, "cc.EditBoxComponent"), i.LayoutComponent = h3, Qe.setClassAlias(h3, "cc.LayoutComponent"), i.ProgressBarComponent = F3, Qe.setClassAlias(F3, "cc.ProgressBarComponent"), i.ScrollViewComponent = g8, Qe.setClassAlias(g8, "cc.ScrollViewComponent"), i.ScrollBarComponent = U5, Qe.setClassAlias(U5, "cc.ScrollBarComponent"), i.SliderComponent = U8, Qe.setClassAlias(U8, "cc.SliderComponent"), i.ToggleComponent = q6, Qe.setClassAlias(q6, "cc.ToggleComponent"), i.ToggleContainerComponent = X6, Qe.setClassAlias(X6, "cc.ToggleContainerComponent"), i.WidgetComponent = v7, Qe.setClassAlias(v7, "cc.WidgetComponent"), i.PageViewComponent = d9, Qe.setClassAlias(d9, "cc.PageViewComponent"), i.PageViewIndicatorComponent = _9, Qe.setClassAlias(_9, "cc.PageViewIndicatorComponent"), i.SafeAreaComponent = X9, Qe.setClassAlias(X9, "cc.SafeAreaComponent"), Qe.setClassAlias(Y9, "cc.UICoordinateTrackerComponent"), i.BlockInputEventsComponent = lee, Qe.setClassAlias(lee, "cc.BlockInputEventsComponent");
            var dee = new En,
                pee = new En,
                mee = new En,
                gee = new En,
                vee = new En,
                yee = new En,
                See = new En,
                Eee = new En,
                Tee = new En,
                Aee = new En,
                xee = new En,
                Cee = new En,
                bee = new En(0, 0, 0),
                Ree = new En(0, 0, 0);

            function wee(e, t, n, i) {
                void 0 === e && (e = .5), void 0 === t && (t = .5), void 0 === n && (n = 2), void 0 === i && (i = {});
                var r = .5 * n,
                    o = i.radialSegments || 32,
                    a = i.heightSegments || 1,
                    s = void 0 === i.capped || i.capped,
                    c = i.arc || 2 * Math.PI,
                    l = 0;
                s || (e > 0 && l++, t > 0 && l++);
                var u = (o + 1) * (a + 1);
                s && (u += (o + 1) * l + o * l);
                var h = o * a * 6;
                s && (h += o * l * 3);
                var _ = new Array(h),
                    f = new Array(3 * u),
                    d = new Array(3 * u),
                    p = new Array(2 * u),
                    m = Math.max(e, t),
                    g = new En(-m, -r, -m),
                    v = new En(m, r, m),
                    y = Math.sqrt(m * m + r * r),
                    S = 0,
                    E = 0;
                return function() {
                    for (var i = [], s = e - t, l = s * s / n * Math.sign(s), u = 0; u <= a; u++) {
                        for (var h = [], m = u / a, g = m * s + t, v = 0; v <= o; ++v) {
                            var y = v / o,
                                T = y * c,
                                A = Math.sin(T),
                                x = Math.cos(T);
                            f[3 * S] = g * A, f[3 * S + 1] = m * n - r, f[3 * S + 2] = g * x, En.normalize(bee, En.set(Ree, A, -l, x)), d[3 * S] = bee.x, d[3 * S + 1] = bee.y, d[3 * S + 2] = bee.z, p[2 * S] = 2 * (1 - y) % 1, p[2 * S + 1] = m, h.push(S), ++S
                        }
                        i.push(h)
                    }
                    for (var C = 0; C < a; ++C)
                        for (var b = 0; b < o; ++b) {
                            var R = i[C][b],
                                w = i[C + 1][b],
                                I = i[C + 1][b + 1],
                                P = i[C][b + 1];
                            _[E] = R, ++E, _[E] = P, ++E, _[E] = w, ++E, _[E] = P, ++E, _[E] = I, ++E, _[E] = w, ++E
                        }
                }(), s && (t > 0 && T(!1), e > 0 && T(!0)), {
                    positions: f,
                    normals: d,
                    uvs: p,
                    indices: _,
                    minPos: g,
                    maxPos: v,
                    boundingRadius: y
                };

                function T(n) {
                    for (var i = n ? e : t, a = n ? 1 : -1, s = S, l = 1; l <= o; ++l) f[3 * S] = 0, f[3 * S + 1] = r * a, f[3 * S + 2] = 0, d[3 * S] = 0, d[3 * S + 1] = a, d[3 * S + 2] = 0, p[2 * S] = .5, p[2 * S + 1] = .5, ++S;
                    for (var u = S, h = 0; h <= o; ++h) {
                        var m = h / o * c,
                            g = Math.cos(m),
                            v = Math.sin(m);
                        f[3 * S] = i * v, f[3 * S + 1] = r * a, f[3 * S + 2] = i * g, d[3 * S] = 0, d[3 * S + 1] = a, d[3 * S + 2] = 0, p[2 * S] = .5 - .5 * v * a, p[2 * S + 1] = .5 + .5 * g, ++S
                    }
                    for (var y = 0; y < o; ++y) {
                        var T = s + y,
                            A = u + y;
                        n ? (_[E] = A + 1, ++E, _[E] = T, ++E, _[E] = A, ++E) : (_[E] = T, ++E, _[E] = A + 1, ++E, _[E] = A, ++E)
                    }
                }
            }
            var Iee, Pee, Oee, Dee, Nee, Mee, Lee, Bee, Fee, zee = new En(0, 0, 0),
                Uee = new En(0, 0, 0),
                Gee = new En(0, 0, 0),
                Hee = new En(0, 0, 0),
                kee = new En(0, 0, 0),
                Vee = new En(0, 0, 0),
                Wee = new En(0, 0, 0),
                jee = new En(0, 0, 0),
                qee = new En(0, 0, 0),
                Xee = Object.freeze({
                    __proto__: null,
                    box: function(e) {
                        var t = (e = e || {}).widthSegments || 1,
                            n = e.heightSegments || 1,
                            i = e.lengthSegments || 1,
                            r = (e.width || 1) / 2,
                            o = (e.height || 1) / 2,
                            a = (e.length || 1) / 2,
                            s = [En.set(vee, -r, -o, a), En.set(yee, r, -o, a), En.set(See, r, o, a), En.set(Eee, -r, o, a), En.set(Tee, r, -o, -a), En.set(Aee, -r, -o, -a), En.set(xee, -r, o, -a), En.set(Cee, r, o, -a)],
                            c = [
                                [2, 3, 1],
                                [4, 5, 7],
                                [7, 6, 2],
                                [1, 0, 4],
                                [1, 4, 2],
                                [5, 0, 6]
                            ],
                            l = [
                                [0, 0, 1],
                                [0, 0, -1],
                                [0, 1, 0],
                                [0, -1, 0],
                                [1, 0, 0],
                                [-1, 0, 0]
                            ],
                            u = [
                                [-1, 0, 0, 1],
                                [-1, 0, 0, 1],
                                [-1, 0, 0, 1],
                                [-1, 0, 0, 1],
                                [0, 0, -1, 1],
                                [0, 0, 1, 1]
                            ],
                            h = [],
                            _ = [],
                            f = [],
                            d = [],
                            p = [],
                            m = new En(-r, -o, -a),
                            g = new En(r, o, a),
                            v = Math.sqrt(r * r + o * o + a * a);

                        function y(e, t, n) {
                            var i, r, o, a, m = h.length / 3,
                                g = c[e],
                                v = l[e],
                                y = u[e];
                            for (a = 0; a <= n; a++)
                                for (o = 0; o <= t; o++)
                                    if (i = o / t, r = a / n, En.lerp(dee, s[g[0]], s[g[1]], i), En.lerp(pee, s[g[0]], s[g[2]], r), En.subtract(mee, pee, s[g[0]]), En.add(gee, dee, mee), h.push(gee.x, gee.y, gee.z), _.push(v[0], v[1], v[2]), f.push(i, r), d.push(y[0], y[1], y[2], y[3]), o < t && a < n) {
                                        var S = t + 1,
                                            E = o + a * S,
                                            T = o + (a + 1) * S,
                                            A = o + 1 + (a + 1) * S,
                                            x = o + 1 + a * S;
                                        p.push(m + E, m + x, m + T), p.push(m + T, m + x, m + A)
                                    }
                        }
                        return y(0, t, n), y(4, i, n), y(1, t, n), y(5, i, n), y(3, t, i), y(2, t, i), {
                            positions: h,
                            normals: _,
                            uvs: f,
                            tangents: d,
                            indices: p,
                            minPos: m,
                            maxPos: g,
                            boundingRadius: v
                        }
                    },
                    cone: function(e, t, n) {
                        return void 0 === e && (e = .5), void 0 === t && (t = 1), void 0 === n && (n = {}), wee(0, e, t, n)
                    },
                    cylinder: wee,
                    plane: function(e) {
                        var t = function(e) {
                                return (e = fee(e)).width = e.width || 10, e.length = e.length || 10, e.widthSegments = e.widthSegments || 10, e.lengthSegments = e.lengthSegments || 10, e
                            }(e),
                            n = t.width,
                            i = t.length,
                            r = t.widthSegments,
                            o = t.lengthSegments,
                            a = .5 * n,
                            s = .5 * i,
                            c = [],
                            l = [],
                            u = [],
                            h = new En(-a, 0, -s),
                            _ = new En(a, 0, s),
                            f = Math.sqrt(n * n + i * i);
                        En.set(kee, -a, 0, s), En.set(Vee, a, 0, s), En.set(Wee, -a, 0, -s);
                        for (var d = 0; d <= o; d++)
                            for (var p = 0; p <= r; p++) {
                                var m = p / r,
                                    g = d / o;
                                if (En.lerp(zee, kee, Vee, m), En.lerp(Uee, kee, Wee, g), En.subtract(Gee, Uee, kee), En.add(Hee, zee, Gee), c.push(Hee.x, Hee.y, Hee.z), t.includeUV && l.push(m, g), p < r && d < o) {
                                    var v = r + 1,
                                        y = p + d * v,
                                        S = p + (d + 1) * v,
                                        E = p + 1 + (d + 1) * v,
                                        T = p + 1 + d * v;
                                    u.push(y, T, S), u.push(T, E, S)
                                }
                            }
                        var A = {
                            positions: c,
                            indices: u,
                            minPos: h,
                            maxPos: _,
                            boundingRadius: f
                        };
                        if (t.includeNormal) {
                            var x = (o + 1) * (r + 1),
                                C = new Array(3 * x);
                            A.normals = C;
                            for (var b = 0; b < x; ++b) C[3 * b + 0] = 0, C[3 * b + 1] = 1, C[3 * b + 2] = 0
                        }
                        return t.includeUV && (A.uvs = l), A
                    },
                    quad: function(e) {
                        var t = fee(e),
                            n = {
                                positions: [-.5, -.5, 0, -.5, .5, 0, .5, .5, 0, .5, -.5, 0],
                                indices: [0, 3, 1, 3, 2, 1],
                                minPos: {
                                    x: -.5,
                                    y: -.5,
                                    z: 0
                                },
                                maxPos: {
                                    x: .5,
                                    y: .5,
                                    z: 0
                                },
                                boundingRadius: Math.sqrt(.5)
                            };
                        return !1 !== t.includeNormal && (n.normals = [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]), !1 !== t.includeUV && (n.uvs = [0, 0, 0, 1, 1, 1, 1, 0]), n
                    },
                    sphere: function(e, t) {
                        void 0 === e && (e = .5), void 0 === t && (t = {});
                        for (var n = void 0 !== t.segments ? t.segments : 32, i = [], r = [], o = [], a = [], s = new En(-e, -e, -e), c = new En(e, e, e), l = e, u = 0; u <= n; ++u)
                            for (var h = u * Math.PI / n, _ = Math.sin(h), f = -Math.cos(h), d = 0; d <= n; ++d) {
                                var p = 2 * d * Math.PI / n - Math.PI / 2,
                                    m = Math.sin(p) * _,
                                    g = f,
                                    v = Math.cos(p) * _,
                                    y = d / n,
                                    S = u / n;
                                if (i.push(m * e, g * e, v * e), r.push(m, g, v), o.push(y, S), u < n && d < n) {
                                    var E = n + 1,
                                        T = E * u + d,
                                        A = E * (u + 1) + d,
                                        x = E * (u + 1) + d + 1,
                                        C = E * u + d + 1;
                                    a.push(T, C, A), a.push(C, x, A)
                                }
                            }
                        return {
                            positions: i,
                            indices: a,
                            normals: r,
                            uvs: o,
                            minPos: s,
                            maxPos: c,
                            boundingRadius: l
                        }
                    },
                    torus: function(e, t, n) {
                        void 0 === e && (e = .4), void 0 === t && (t = .1), void 0 === n && (n = {});
                        for (var i = n.radialSegments || 32, r = n.tubularSegments || 32, o = n.arc || 2 * Math.PI, a = [], s = [], c = [], l = [], u = new En(-e - t, -t, -e - t), h = new En(e + t, t, e + t), _ = e + t, f = 0; f <= i; f++)
                            for (var d = 0; d <= r; d++) {
                                var p = d / r,
                                    m = f / i,
                                    g = p * o,
                                    v = m * Math.PI * 2,
                                    y = (e + t * Math.cos(v)) * Math.sin(g),
                                    S = t * Math.sin(v),
                                    E = (e + t * Math.cos(v)) * Math.cos(g),
                                    T = Math.sin(g) * Math.cos(v),
                                    A = Math.sin(v),
                                    x = Math.cos(g) * Math.cos(v);
                                if (a.push(y, S, E), s.push(T, A, x), c.push(p, m), d < r && f < i) {
                                    var C = r + 1,
                                        b = C * f + d,
                                        R = C * (f + 1) + d,
                                        w = C * (f + 1) + d + 1,
                                        I = C * f + d + 1;
                                    l.push(b, I, R), l.push(I, w, R)
                                }
                            }
                        return {
                            positions: a,
                            normals: s,
                            uvs: c,
                            indices: l,
                            minPos: u,
                            maxPos: h,
                            boundingRadius: _
                        }
                    },
                    capsule: function(e, t, n, i) {
                        void 0 === e && (e = .5), void 0 === t && (t = .5), void 0 === n && (n = 2), void 0 === i && (i = {});
                        var r = n - e - t,
                            o = i.sides || 32,
                            a = i.heightSegments || 32,
                            s = t / n,
                            c = r / n,
                            l = e / n,
                            u = Math.floor(a * s),
                            h = Math.floor(a * l),
                            _ = Math.floor(a * c),
                            f = r + t - n / 2,
                            d = t - n / 2,
                            p = t - n / 2,
                            m = i.arc || 2 * Math.PI,
                            g = [],
                            v = [],
                            y = [],
                            S = [],
                            E = Math.max(e, t),
                            T = new En(-E, -n / 2, -E),
                            A = new En(E, n / 2, E),
                            x = n / 2,
                            C = 0,
                            b = [];
                        return function() {
                                for (var e = 0; e <= u; ++e)
                                    for (var n = e * Math.PI / u / 2, i = Math.sin(n), r = -Math.cos(n), s = 0; s <= o; ++s) {
                                        var c = 2 * s * Math.PI / o - Math.PI / 2,
                                            l = Math.sin(c) * i,
                                            h = r,
                                            _ = Math.cos(c) * i,
                                            f = s / o,
                                            d = e / a;
                                        if (g.push(l * t, h * t + p, _ * t), v.push(l, h, _), y.push(f, d), e < u && s < o) {
                                            var m = o + 1,
                                                E = m * e + s,
                                                T = m * (e + 1) + s,
                                                A = m * (e + 1) + s + 1,
                                                x = m * e + s + 1;
                                            S.push(E, x, T), S.push(x, A, T)
                                        }++C
                                    }
                            }(),
                            function() {
                                for (var n = (e - t) / r, i = 0; i <= _; i++) {
                                    for (var a = [], l = i / _, u = l * (e - t) + t, h = 0; h <= o; ++h) {
                                        var f = h / o,
                                            p = l * c + s,
                                            E = f * m - m / 4,
                                            T = Math.sin(E),
                                            A = Math.cos(E);
                                        g.push(u * T), g.push(l * r + d), g.push(u * A), En.normalize(jee, En.set(qee, T, -n, A)), v.push(jee.x), v.push(jee.y), v.push(jee.z), y.push(f, p), a.push(C), ++C
                                    }
                                    b.push(a)
                                }
                                for (var x = 0; x < _; ++x)
                                    for (var R = 0; R < o; ++R) {
                                        var w = b[x][R],
                                            I = b[x + 1][R],
                                            P = b[x + 1][R + 1],
                                            O = b[x][R + 1];
                                        S.push(w), S.push(O), S.push(I), S.push(O), S.push(P), S.push(I)
                                    }
                            }(),
                            function() {
                                for (var t = 0; t <= h; ++t)
                                    for (var n = t * Math.PI / h / 2 + Math.PI / 2, i = Math.sin(n), r = -Math.cos(n), s = 0; s <= o; ++s) {
                                        var c = 2 * s * Math.PI / o - Math.PI / 2,
                                            u = Math.sin(c) * i,
                                            d = r,
                                            p = Math.cos(c) * i,
                                            m = s / o,
                                            E = t / a + (1 - l);
                                        if (g.push(u * e, d * e + f, p * e), v.push(u, d, p), y.push(m, E), t < h && s < o) {
                                            var T = o + 1,
                                                A = T * t + s + b[_][o] + 1,
                                                x = T * (t + 1) + s + b[_][o] + 1,
                                                C = T * (t + 1) + s + 1 + b[_][o] + 1,
                                                R = T * t + s + 1 + b[_][o] + 1;
                                            S.push(A, R, x), S.push(R, C, x)
                                        }
                                    }
                            }(), {
                                positions: g,
                                normals: v,
                                uvs: y,
                                indices: S,
                                minPos: T,
                                maxPos: A,
                                boundingRadius: x
                            }
                    },
                    circle: function(e) {
                        var t = function(e) {
                                return (e = fee(e)).segments = 64, e
                            }(e).segments,
                            n = new Array(3 * (t + 1));
                        n[0] = 0, n[1] = 0, n[2] = 0;
                        var i = new Array(1 + 2 * t);
                        i[0] = 0;
                        for (var r = 2 * Math.PI / t, o = 0; o < t; ++o) {
                            var a = r * o,
                                s = Math.cos(a),
                                c = Math.sin(a),
                                l = 3 * (o + 1);
                            n[l + 0] = s, n[l + 1] = c, n[l + 2] = 0;
                            var u = 2 * o;
                            i[1 + u] = o + 1, i[1 + (u + 1)] = o + 2
                        }
                        return t > 0 && (i[i.length - 1] = 1), {
                            positions: n,
                            indices: i,
                            minPos: {
                                x: 1,
                                y: 1,
                                z: 0
                            },
                            maxPos: {
                                x: -1,
                                y: -1,
                                z: 0
                            },
                            boundingRadius: 1,
                            primitiveMode: Wa.TRIANGLE_FAN
                        }
                    },
                    translate: function(e, t) {
                        for (var n = t.x || 0, i = t.y || 0, r = t.z || 0, o = Math.floor(e.positions.length / 3), a = 0; a < o; ++a) {
                            var s = 3 * a,
                                c = 3 * a + 1,
                                l = 3 * a + 2;
                            e.positions[s] += n, e.positions[c] += i, e.positions[l] += r
                        }
                        return e.minPos && (e.minPos.x += n, e.minPos.y += i, e.minPos.z += r), e.maxPos && (e.maxPos.x += n, e.maxPos.y += i, e.maxPos.z += r), e
                    },
                    scale: function(e, t) {
                        for (var n = t.x || 0, i = t.y || 0, r = t.z || 0, o = Math.floor(e.positions.length / 3), a = 0; a < o; ++a) {
                            var s = 3 * a,
                                c = 3 * a + 1,
                                l = 3 * a + 2;
                            e.positions[s] *= n, e.positions[c] *= i, e.positions[l] *= r
                        }
                        return e.minPos && (e.minPos.x *= n, e.minPos.y *= i, e.minPos.z *= r), e.maxPos && (e.maxPos.x *= n, e.maxPos.y *= i, e.maxPos.z *= r), e.boundingRadius = Math.max(Math.max(n, i), r), e
                    },
                    wireframed: function(e) {
                        var t = e.indices;
                        if (!t) return e;
                        if (e.primitiveMode && e.primitiveMode !== Wa.TRIANGLE_LIST) return e;
                        for (var n = [
                                [0, 1],
                                [1, 2],
                                [2, 0]
                            ], i = [], r = {}, o = 0; o < t.length; o += 3)
                            for (var a = 0; a < 3; ++a) {
                                var s = t[o + n[a][0]],
                                    c = t[o + n[a][1]],
                                    l = s > c ? c << 16 | s : s << 16 | c;
                                void 0 === r[l] && (r[l] = 0, i.push(s, c))
                            }
                        return e.indices = i, e.primitiveMode = Wa.LINE_LIST, e
                    },
                    wireframe: function(e) {
                        for (var t = [
                                [0, 1],
                                [1, 2],
                                [2, 0]
                            ], n = [], i = {}, r = 0; r < e.length; r += 3)
                            for (var o = 0; o < 3; ++o) {
                                var a = e[r + t[o][0]],
                                    s = e[r + t[o][1]],
                                    c = a > s ? s << 16 | a : a << 16 | s;
                                void 0 === i[c] && (i[c] = 0, n.push(a, s))
                            }
                        return n
                    },
                    invWinding: function(e) {
                        for (var t = [], n = 0; n < e.length; n += 3) t.push(e[n], e[n + 2], e[n + 1]);
                        return t
                    },
                    toWavefrontOBJ: function(e, t) {
                        if (void 0 === t && (t = 1), !e.indices || !e.uvs || !e.normals || void 0 !== e.primitiveMode && e.primitiveMode !== Wa.TRIANGLE_LIST) return "";
                        for (var n = e.positions, i = e.uvs, r = e.normals, o = e.indices, a = function(e) {
                                return o[e] + 1 + "/" + (o[e] + 1) + "/" + (o[e] + 1)
                            }, s = "", c = 0; c < n.length; c += 3) s += "v " + n[c] * t + " " + n[c + 1] * t + " " + n[c + 2] * t + "\n";
                        for (var l = 0; l < i.length; l += 2) s += "vt " + i[l] + " " + i[l + 1] + "\n";
                        for (var u = 0; u < r.length; u += 3) s += "vn " + r[u] + " " + r[u + 1] + " " + r[u + 2] + "\n";
                        for (var h = 0; h < o.length; h += 3) s += "f " + a(h) + " " + a(h + 1) + " " + a(h + 2) + "\n";
                        return s
                    },
                    normals: function(e, t, n) {
                        void 0 === n && (n = 1);
                        for (var i = new Array(2 * e.length), r = 0; r < e.length / 3; ++r) {
                            var o = 3 * r,
                                a = 6 * r;
                            i[a + 0] = e[o + 0], i[a + 1] = e[o + 1], i[a + 2] = e[o + 2], i[a + 3] = e[o + 0] + t[o + 0] * n, i[a + 4] = e[o + 1] + t[o + 1] * n, i[a + 5] = e[o + 2] + t[o + 2] * n
                        }
                        return i
                    },
                    applyDefaultGeometryOptions: fee
                });
            e("primitives", Xee),
                function(e) {
                    e[e.BOX = 0] = "BOX", e[e.SPHERE = 1] = "SPHERE", e[e.CYLINDER = 2] = "CYLINDER", e[e.CONE = 3] = "CONE", e[e.CAPSULE = 4] = "CAPSULE", e[e.TORUS = 5] = "TORUS", e[e.PLANE = 6] = "PLANE", e[e.QUAD = 7] = "QUAD"
                }(Fee || (Fee = {})), nt(Fee);
            var Yee = e("Primitive", (Iee = A_("cc.Primitive"), Pee = ef(Fee), Iee((Bee = Lee = function(e) {
                function t(t) {
                    var n;
                    return void 0 === t && (t = Fee.BOX), ne(n = e.call(this) || this, "type", Nee, $(n)), ne(n, "info", Mee, $(n)), n.type = t, n
                }
                return Q(t, e), t.prototype.onLoaded = function() {
                    SU(Xee[Fee[this.type].toLowerCase()](this.info), this)
                }, t
            }(_U), Lee.PrimitiveType = Fee, Nee = ie((Dee = Bee).prototype, "type", [Pee], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return Fee.BOX
                }
            }), Mee = ie(Dee.prototype, "info", [w_, F_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return {}
                }
            }), Oee = Dee)) || Oee));
            i.Primitive = Yee, i.primitives = Xee;
            var Kee, Zee, Qee, Jee, $ee = function() {
                    function e(e, t, n) {
                        this._id = void 0, this._opts = void 0, this._accumStart = void 0, this._total = 0, this._value = 0, this._averageValue = 0, this._accumValue = 0, this._accumSamples = 0, this._id = e, this._opts = t, this._accumStart = n
                    }
                    var t = e.prototype;
                    return t.sample = function(e) {
                        this._average(this._value, e)
                    }, t.human = function() {
                        var e = this._opts,
                            t = e.average,
                            n = e.isInteger,
                            i = t ? this._averageValue : this._value;
                        return n ? Math.round(i) : Math.round(100 * i) / 100
                    }, t.alarm = function() {
                        return this._opts.below && this._value < this._opts.below || this._opts.over && this._value > this._opts.over
                    }, t._average = function(e, t) {
                        if (void 0 === t && (t = 0), this._opts.average) {
                            this._accumValue += e, ++this._accumSamples;
                            var n = t;
                            n - this._accumStart >= this._opts.average && (this._averageValue = this._accumValue / this._accumSamples, this._accumValue = 0, this._accumStart = n, this._accumSamples = 0)
                        }
                    }, K(e, [{
                        key: "value",
                        get: function() {
                            return this._value
                        },
                        set: function(e) {
                            this._value = e
                        }
                    }]), e
                }(),
                ete = A_("cc.PerfCounter")(Kee = function(e) {
                    function t(t, n, i) {
                        var r;
                        return (r = e.call(this, t, n, i) || this)._time = void 0, r._time = i, r
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.start = function(e) {
                        void 0 === e && (e = 0), this._time = e
                    }, n.end = function(e) {
                        void 0 === e && (e = 0), this._value = e - this._time, this._average(this._value)
                    }, n.tick = function() {
                        this.end(), this.start()
                    }, n.frame = function(e) {
                        var t = e,
                            n = t - this._time;
                        this._total++, n > (this._opts.average || 1e3) && (this._value = 1e3 * this._total / n, this._total = 0, this._time = t, this._average(this._value))
                    }, t
                }($ee)) || Kee,
                tte = "0123456789. ",
                nte = {
                    0: 0,
                    1: 1,
                    2: 2,
                    3: 3,
                    4: 4,
                    5: 5,
                    6: 6,
                    7: 7,
                    8: 8,
                    9: 9,
                    ".": 10
                },
                ite = {
                    fps: {
                        desc: "Framerate (FPS)",
                        below: 30,
                        average: 500,
                        isInteger: !0
                    },
                    draws: {
                        desc: "Draw call",
                        isInteger: !0
                    },
                    frame: {
                        desc: "Frame time (ms)",
                        min: 0,
                        max: 50,
                        average: 500
                    },
                    instances: {
                        desc: "Instance Count",
                        isInteger: !0
                    },
                    tricount: {
                        desc: "Triangle",
                        isInteger: !0
                    },
                    logic: {
                        desc: "Game Logic (ms)",
                        min: 0,
                        max: 50,
                        average: 500,
                        color: "#080"
                    },
                    physics: {
                        desc: "Physics (ms)",
                        min: 0,
                        max: 50,
                        average: 500
                    },
                    render: {
                        desc: "Renderer (ms)",
                        min: 0,
                        max: 50,
                        average: 500,
                        color: "#f90"
                    },
                    textureMemory: {
                        desc: "GFX Texture Mem(M)"
                    },
                    bufferMemory: {
                        desc: "GFX Buffer Mem(M)"
                    }
                },
                rte = e("Profiler", function() {
                    function e() {
                        this._stats = null, this.id = "__Profiler__", this._showFPS = !1, this._rootNode = null, this._device = null, this._canvas = null, this._ctx = null, this._texture = null, this._region = new fs, this._canvasArr = [], this._regionArr = [this._region], this.digitsData = null, this.offsetData = null, this.pass = null, this._canvasDone = !1, this._statsDone = !1, this._inited = !1, this._lineHeight = 256 / (Object.keys(ite).length + 1), this._wordHeight = 0, this._eachNumWidth = 0, this._totalLines = 0, this.lastTime = 0, this._canvas = document.createElement("canvas"), this._ctx = this._canvas.getContext("2d"), this._canvasArr.push(this._canvas)
                    }
                    var t = e.prototype;
                    return t.isShowingStats = function() {
                        return this._showFPS
                    }, t.hideStats = function() {
                        this._showFPS && (this._rootNode && (this._rootNode.active = !1), i.game.off(i.Game.EVENT_RESTART, this.generateNode, this), i.director.off(i.Director.EVENT_BEFORE_UPDATE, this.beforeUpdate, this), i.director.off(i.Director.EVENT_AFTER_UPDATE, this.afterUpdate, this), i.director.off(i.Director.EVENT_BEFORE_PHYSICS, this.beforePhysics, this), i.director.off(i.Director.EVENT_AFTER_PHYSICS, this.afterPhysics, this), i.director.off(i.Director.EVENT_BEFORE_DRAW, this.beforeDraw, this), i.director.off(i.Director.EVENT_AFTER_DRAW, this.afterDraw, this), this._showFPS = !1)
                    }, t.showStats = function() {
                        this._showFPS || (this._device || (this._device = i.director.root.device), this.generateCanvas(), this.generateStats(), i.game.once(i.Game.EVENT_ENGINE_INITED, this.generateNode, this), i.game.on(i.Game.EVENT_RESTART, this.generateNode, this), this._rootNode && (this._rootNode.active = !0), i.director.on(i.Director.EVENT_BEFORE_UPDATE, this.beforeUpdate, this), i.director.on(i.Director.EVENT_AFTER_UPDATE, this.afterUpdate, this), i.director.on(i.Director.EVENT_BEFORE_PHYSICS, this.beforePhysics, this), i.director.on(i.Director.EVENT_AFTER_PHYSICS, this.afterPhysics, this), i.director.on(i.Director.EVENT_BEFORE_DRAW, this.beforeDraw, this), i.director.on(i.Director.EVENT_AFTER_DRAW, this.afterDraw, this), this._showFPS = !0, this._canvasDone = !0, this._statsDone = !0)
                    }, t.generateCanvas = function() {
                        if (!this._canvasDone) {
                            this._ctx && this._canvas && (this._canvas.width = 256, this._canvas.height = 256, this._canvas.style.width = "" + this._canvas.width, this._canvas.style.height = "" + this._canvas.height, this._ctx.font = "23px Arial", this._ctx.textBaseline = "top", this._ctx.fillStyle = "#fff", this._texture = this._device.createTexture(new Ts(wa.TEX2D, Ia.SAMPLED | Ia.TRANSFER_DST, Ea.RGBA8, 256, 256)), this._region.texExtent.width = 256, this._region.texExtent.height = 256)
                        }
                    }, t.generateStats = function() {
                        if (!this._statsDone && this._ctx && this._canvas) {
                            this._stats = null;
                            var e = performance.now();
                            this._ctx.textAlign = "left";
                            var t = 0;
                            for (var n in ite) {
                                var i = ite[n];
                                this._ctx.fillText(i.desc, 0, t * this._lineHeight), i.counter = new ete(n, i, e), t++
                            }
                            this._totalLines = t, this._wordHeight = this._totalLines * this._lineHeight / this._canvas.height;
                            for (var r = 0; r < tte.length; ++r) {
                                var o = this._ctx.measureText(tte[r]).width;
                                this._eachNumWidth = Math.max(this._eachNumWidth, o)
                            }
                            for (var a = 0; a < tte.length; ++a) this._ctx.fillText(tte[a], a * this._eachNumWidth, this._totalLines * this._lineHeight);
                            this._eachNumWidth /= this._canvas.width, this._stats = ite, this._canvasArr[0] = this._canvas, this._device.copyTexImagesToTexture(this._canvasArr, this._texture, this._regionArr)
                        }
                    }, t.generateNode = function() {
                        if (!this._rootNode || !this._rootNode.isValid) {
                            this._rootNode = new Yv("PROFILER_NODE"), i.game.addPersistRootNode(this._rootNode);
                            var e = new Yv("Profiler_Camera");
                            e.setPosition(0, 0, 1.5), e.parent = this._rootNode;
                            var t = e.addComponent("cc.Camera");
                            t.projection = IM.ProjectionType.ORTHO, t.orthoHeight = 1, t.near = 1, t.far = 2, t.visibility = Pu.BitMask.PROFILER, t.clearFlags = $a.NONE, t.priority = 4294967295;
                            var n = new Yv("Profiler_Root");
                            n.parent = this._rootNode;
                            for (var r = .4, o = r / this._totalLines, a = r / this._wordHeight, s = o / 23, c = this._eachNumWidth * this._canvas.width * s, l = [0, r, 0, a, r, 0, a, 0, 0, 0, 0, 0], u = [0, 2, 1, 0, 3, 2], h = [0, 0, -1, 0, 1, 0, -1, 0, 1, this._wordHeight, -1, 0, 0, this._wordHeight, -1, 0], _ = 0, f = 0; f < this._totalLines; f++)
                                for (var d = 0; d < 8; d++) {
                                    l.push(a + d * c, r - f * o, 0), l.push(a + (d + 1) * c, r - f * o, 0), l.push(a + (d + 1) * c, r - (f + 1) * o, 0), l.push(a + d * c, r - (f + 1) * o, 0), _ = 4 * (8 * f + d + 1), u.push(0 + _, 2 + _, 1 + _, 0 + _, 3 + _, 2 + _);
                                    var p = 8 * f + d,
                                        m = Math.floor(p / 4),
                                        g = p - 4 * m;
                                    h.push(0, this._wordHeight, m, g), h.push(this._eachNumWidth, this._wordHeight, m, g), h.push(this._eachNumWidth, 1, m, g), h.push(0, 1, m, g)
                                }
                            var v = n.addComponent(_G);
                            v.mesh = SU({
                                positions: l,
                                indices: u,
                                colors: h
                            });
                            var y = new nE;
                            y.initialize({
                                effectName: "profiler"
                            });
                            var S = this.pass = y.passes[0],
                                E = S.getBinding("mainTexture"),
                                T = S.getBinding("digits"),
                                A = S.getBinding("offset");
                            S.bindTexture(E, this._texture), this.digitsData = S.blocks[T], this.offsetData = S.blocks[A], this.offsetData[3] = -1, v.material = y, v.node.layer = Pu.Enum.PROFILER, this._inited = !0
                        }
                    }, t.beforeUpdate = function() {
                        if (this._stats) {
                            var e = performance.now();
                            this._stats.frame.counter.end(e), this._stats.frame.counter.start(e), this._stats.logic.counter.start(e)
                        }
                    }, t.afterUpdate = function() {
                        if (this._stats) {
                            var e = performance.now();
                            i.director.isPaused() ? this._stats.frame.counter.start(e) : this._stats.logic.counter.end(e)
                        }
                    }, t.beforePhysics = function() {
                        if (this._stats) {
                            var e = performance.now();
                            this._stats.physics.counter.start(e)
                        }
                    }, t.afterPhysics = function() {
                        if (this._stats) {
                            var e = performance.now();
                            this._stats.physics.counter.end(e)
                        }
                    }, t.beforeDraw = function() {
                        if (this._stats) {
                            var e = this._device.surfaceTransform,
                                t = this._device.capabilities.clipSpaceSignY;
                            if (e !== this.offsetData[3]) {
                                var n = Ln[e],
                                    i = -.9 * t;
                                this.offsetData[0] = -.9 * n[0] + i * n[2], this.offsetData[1] = -.9 * n[1] + i * n[3], this.offsetData[2] = this._eachNumWidth, this.offsetData[3] = e
                            }
                            this.pass._rootBufferDirty = !0;
                            var r = performance.now();
                            this._stats.render.counter.start(r)
                        }
                    }, t.afterDraw = function() {
                        if (this._stats && this._inited) {
                            var e = performance.now();
                            if (this._stats.fps.counter.frame(e), this._stats.render.counter.end(e), !(e - this.lastTime < 500)) {
                                this.lastTime = e;
                                var t = this._device;
                                this._stats.draws.counter.value = t.numDrawCalls, this._stats.instances.counter.value = t.numInstances, this._stats.bufferMemory.counter.value = t.memoryStatus.bufferSize / 1048576, this._stats.textureMemory.counter.value = t.memoryStatus.textureSize / 1048576, this._stats.tricount.counter.value = t.numTris;
                                var n = 0,
                                    i = this.digitsData;
                                for (var r in this._stats) {
                                    var o = this._stats[r];
                                    o.counter.sample(e);
                                    for (var a = o.counter.human().toString(), s = 7; s >= 0; s--) {
                                        var c = 8 * n + s,
                                            l = a[a.length - (8 - s)],
                                            u = nte[l];
                                        void 0 === u && (u = 11), i[c] = u
                                    }
                                    n++
                                }
                            }
                        }
                    }, e
                }()),
                ote = e("profiler", new rte);
            i.profiler = ote,
                function(e) {
                    e.PLAYED = "play", e.PAUSED = "pause", e.STOPPED = "stop", e.SEEKED = "seeked", e.ENDED = "ended", e.INTERRUPTION_BEGIN = "interruptionBegin", e.INTERRUPTION_END = "interruptionEnd", e.USER_GESTURE = "on_gesture"
                }(Zee || (Zee = {})),
                function(e) {
                    e[e.DOM_AUDIO = 0] = "DOM_AUDIO", e[e.WEB_AUDIO = 1] = "WEB_AUDIO", e[e.MINIGAME_AUDIO = 2] = "MINIGAME_AUDIO", e[e.NATIVE_AUDIO = 3] = "NATIVE_AUDIO", e[e.UNKNOWN_AUDIO = 4] = "UNKNOWN_AUDIO"
                }(Qee || (Qee = {})),
                function(e) {
                    e[e.INIT = 0] = "INIT", e[e.PLAYING = 1] = "PLAYING", e[e.PAUSED = 2] = "PAUSED", e[e.STOPPED = 3] = "STOPPED", e[e.INTERRUPTED = 4] = "INTERRUPTED"
                }(Jee || (Jee = {}));
            var ate, ste = 0;

            function cte(e, t) {
                var n;
                t.invoking || (t.invoking = !0, (n = t.func).call.apply(n, [e].concat(t.args)).then((function() {
                    t.invoking = !1, e._operationQueue.shift(), e._eventTarget.emit(t.id.toString());
                    var n = e._operationQueue[0];
                    n && cte(e, n)
                })).catch((function() {})))
            }

            function lte(e, t, n) {
                var i = n.value;
                n.value = function() {
                    for (var e = this, t = arguments.length, n = new Array(t), r = 0; r < t; r++) n[r] = arguments[r];
                    return new Promise((function(t) {
                        var r = ste++,
                            o = e;
                        o._operationQueue.push({
                            id: r,
                            func: i,
                            args: n,
                            invoking: !1
                        }), o._eventTarget.once(r.toString(), t), cte(o, o._operationQueue[0])
                    }))
                }
            }

            function ute(e) {
                return new Promise((function(t) {
                    var n = e.play();
                    return void 0 === n ? t() : (n.then(t).catch((function() {
                        var n = function() {
                                e.play().catch((function() {})), t()
                            },
                            i = document.getElementById("GameCanvas");
                        null == i || i.addEventListener("touchend", n, {
                            once: !0
                        }), null == i || i.addEventListener("mousedown", n, {
                            once: !0
                        })
                    })), null)
                }))
            }
            var hte, _te, fte = function() {
                    function e(e, t) {
                        this._domAudio = void 0, this._onPlayCb = void 0, this._onEndCb = void 0, this._domAudio = e, e.volume = t
                    }
                    var t = e.prototype;
                    return t.play = function() {
                        var e = this;
                        ute(this._domAudio).then((function() {
                            var t;
                            null === (t = e.onPlay) || void 0 === t || t.call(e)
                        })).catch((function() {}))
                    }, t.stop = function() {
                        this._domAudio.pause()
                    }, K(e, [{
                        key: "onPlay",
                        get: function() {
                            return this._onPlayCb
                        },
                        set: function(e) {
                            this._onPlayCb = e
                        }
                    }, {
                        key: "onEnd",
                        get: function() {
                            return this._onEndCb
                        },
                        set: function(e) {
                            this._onEndCb && this._domAudio.removeEventListener("ended", this._onEndCb), this._onEndCb = e, e && this._domAudio.addEventListener("ended", e)
                        }
                    }]), e
                }(),
                dte = (ie((ate = function() {
                    function e(e) {
                        var t = this;
                        this._domAudio = void 0, this._state = Jee.INIT, this._onHide = void 0, this._onShow = void 0, this._onEnded = void 0, this._eventTarget = new Si, this._operationQueue = [], this._domAudio = e, this._onHide = function() {
                            t._state === Jee.PLAYING && t.pause().then((function() {
                                t._state = Jee.INTERRUPTED, t._eventTarget.emit(Zee.INTERRUPTION_BEGIN)
                            })).catch((function() {}))
                        }, i.game.on(i.Game.EVENT_HIDE, this._onHide), this._onShow = function() {
                            t._state === Jee.INTERRUPTED && t.play().then((function() {
                                t._eventTarget.emit(Zee.INTERRUPTION_END)
                            })).catch((function() {}))
                        }, i.game.on(i.Game.EVENT_SHOW, this._onShow), this._onEnded = function() {
                            t.seek(0).catch((function() {})), t._state = Jee.INIT, t._eventTarget.emit(Zee.ENDED)
                        }, this._domAudio.addEventListener("ended", this._onEnded)
                    }
                    var t = e.prototype;
                    return t.destroy = function() {
                        this._onShow && (i.game.off(i.Game.EVENT_SHOW, this._onShow), this._onShow = void 0), this._onHide && (i.game.off(i.Game.EVENT_HIDE, this._onHide), this._onHide = void 0), this._onEnded && (this._domAudio.removeEventListener("ended", this._onEnded), this._onEnded = void 0), this._domAudio = void 0
                    }, e.load = function(t) {
                        return new Promise((function(n) {
                            e.loadNative(t).then((function(t) {
                                n(new e(t))
                            })).catch((function() {}))
                        }))
                    }, e.loadNative = function(e) {
                        return new Promise((function(t, n) {
                            var i = document.createElement("audio"),
                                r = "canplaythrough";
                            Ei.os === gi.IOS ? r = "loadedmetadata" : Ei.browserType === fi.FIREFOX && (r = "canplay");
                            var o = setTimeout((function() {
                                    0 === i.readyState ? c() : s()
                                }), 8e3),
                                a = function() {
                                    clearTimeout(o), i.removeEventListener(r, s, !1), i.removeEventListener("error", c, !1)
                                },
                                s = function() {
                                    a(), t(i)
                                },
                                c = function() {
                                    a(), n("load audio failure - " + e)
                                };
                            i.addEventListener(r, s, !1), i.addEventListener("error", c, !1), i.src = e
                        }))
                    }, e.loadOneShotAudio = function(t, n) {
                        return new Promise((function(i, r) {
                            e.loadNative(t).then((function(e) {
                                var t = new fte(e, n);
                                i(t)
                            })).catch(r)
                        }))
                    }, t.seek = function(e) {
                        return e = en(e, 0, this.duration), this._domAudio.currentTime = e, Promise.resolve()
                    }, t.play = function() {
                        var e = this;
                        return new Promise((function(t) {
                            ute(e._domAudio).then((function() {
                                e._state = Jee.PLAYING, t()
                            })).catch((function() {}))
                        }))
                    }, t.pause = function() {
                        return this._domAudio.pause(), this._state = Jee.PAUSED, Promise.resolve()
                    }, t.stop = function() {
                        var e = this;
                        return new Promise((function(t) {
                            e._domAudio.pause(), e._domAudio.currentTime = 0, e._state = Jee.STOPPED, t()
                        }))
                    }, t.onInterruptionBegin = function(e) {
                        this._eventTarget.on(Zee.INTERRUPTION_BEGIN, e)
                    }, t.offInterruptionBegin = function(e) {
                        this._eventTarget.off(Zee.INTERRUPTION_BEGIN, e)
                    }, t.onInterruptionEnd = function(e) {
                        this._eventTarget.on(Zee.INTERRUPTION_END, e)
                    }, t.offInterruptionEnd = function(e) {
                        this._eventTarget.off(Zee.INTERRUPTION_END, e)
                    }, t.onEnded = function(e) {
                        this._eventTarget.on(Zee.ENDED, e)
                    }, t.offEnded = function(e) {
                        this._eventTarget.off(Zee.ENDED, e)
                    }, K(e, [{
                        key: "src",
                        get: function() {
                            return this._domAudio ? this._domAudio.src : ""
                        }
                    }, {
                        key: "type",
                        get: function() {
                            return Qee.DOM_AUDIO
                        }
                    }, {
                        key: "state",
                        get: function() {
                            return this._state
                        }
                    }, {
                        key: "loop",
                        get: function() {
                            return this._domAudio.loop
                        },
                        set: function(e) {
                            this._domAudio.loop = e
                        }
                    }, {
                        key: "volume",
                        get: function() {
                            return this._domAudio.volume
                        },
                        set: function(e) {
                            e = tn(e), this._domAudio.volume = e
                        }
                    }, {
                        key: "duration",
                        get: function() {
                            return this._domAudio.duration
                        }
                    }, {
                        key: "currentTime",
                        get: function() {
                            return this._domAudio.currentTime
                        }
                    }]), e
                }()).prototype, "seek", [lte], Object.getOwnPropertyDescriptor(ate.prototype, "seek"), ate.prototype), ie(ate.prototype, "play", [lte], Object.getOwnPropertyDescriptor(ate.prototype, "play"), ate.prototype), ie(ate.prototype, "pause", [lte], Object.getOwnPropertyDescriptor(ate.prototype, "pause"), ate.prototype), ie(ate.prototype, "stop", [lte], Object.getOwnPropertyDescriptor(ate.prototype, "stop"), ate.prototype), ate),
                pte = window.AudioContext || window.webkitAudioContext || window.mozAudioContext,
                mte = function() {
                    function e() {
                        this._context = void 0, this._context = new(window.AudioContext || window.webkitAudioContext || window.mozAudioContext)
                    }
                    var t = e.prototype;
                    return t.decodeAudioData = function(e) {
                        var t = this;
                        return new Promise((function(n) {
                            var i = t._context.decodeAudioData(e, (function(e) {
                                n(e)
                            }), (function(e) {
                                console.error("failed to load Web Audio", e)
                            }));
                            null == i || i.catch((function() {}))
                        }))
                    }, t.runContext = function() {
                        var e = this;
                        return new Promise((function(t) {
                            var n = e._context;
                            if (!n.resume) return t();
                            if ("running" === n.state) return t();
                            if (n.resume().catch((function() {})), "running" !== n.state) {
                                var i = document.getElementById("GameCanvas"),
                                    r = function() {
                                        n.resume().then(t).catch((function() {}))
                                    };
                                null == i || i.addEventListener("touchend", r, {
                                    once: !0
                                }), null == i || i.addEventListener("mousedown", r, {
                                    once: !0
                                })
                            }
                            return null
                        }))
                    }, t.createBufferSource = function(e, t) {
                        var n = this._context.createBufferSource();
                        return void 0 !== e && (n.buffer = e), void 0 !== t && (n.loop = t), n
                    }, t.createGain = function(e) {
                        var t = this._context.createGain();
                        return void 0 !== e && this.setGainValue(t, e), t
                    }, t.setGainValue = function(e, t) {
                        if (e.gain.setTargetAtTime) try {
                            e.gain.setTargetAtTime(t, this._context.currentTime, 0)
                        } catch (n) {
                            e.gain.setTargetAtTime(t, this._context.currentTime, .01)
                        } else e.gain.value = t
                    }, t.connectContext = function(e) {
                        this._context && e.connect(this._context.destination)
                    }, K(e, [{
                        key: "currentTime",
                        get: function() {
                            return this._context.currentTime
                        }
                    }]), e
                }();
            mte.support = !!pte, mte.support && (_te = new mte);
            var gte, vte, yte, Ste, Ete, Tte = function() {
                    function e(e, t) {
                        this._duration = void 0, this._bufferSourceNode = void 0, this._onPlayCb = void 0, this._onEndCb = void 0, this._duration = e.duration, this._bufferSourceNode = _te.createBufferSource(e, !1);
                        var n = _te.createGain(t);
                        this._bufferSourceNode.connect(n), _te.connectContext(n)
                    }
                    var t = e.prototype;
                    return t.play = function() {
                        var e = this;
                        _te.runContext().then((function() {
                            var t;
                            e._bufferSourceNode.start(), null === (t = e.onPlay) || void 0 === t || t.call(e), window.setTimeout((function() {
                                var t;
                                null === (t = e.onEnd) || void 0 === t || t.call(e)
                            }), 1e3 * e._duration)
                        })).catch((function() {}))
                    }, t.stop = function() {
                        this._bufferSourceNode.stop()
                    }, K(e, [{
                        key: "onPlay",
                        get: function() {
                            return this._onPlayCb
                        },
                        set: function(e) {
                            this._onPlayCb = e
                        }
                    }, {
                        key: "onEnd",
                        get: function() {
                            return this._onEndCb
                        },
                        set: function(e) {
                            this._onEndCb = e
                        }
                    }]), e
                }(),
                Ate = (ie((hte = function() {
                    function e(e, t) {
                        var n = this;
                        this._src = void 0, this._audioBuffer = void 0, this._sourceNode = void 0, this._gainNode = void 0, this._currentTimer = 0, this._volume = 1, this._loop = !1, this._startTime = 0, this._playTimeOffset = 0, this._state = Jee.INIT, this._eventTarget = new Si, this._operationQueue = [], this._onHide = void 0, this._onShow = void 0, this._audioBuffer = e, this._gainNode = _te.createGain(), _te.connectContext(this._gainNode), this._src = t, this._onHide = function() {
                            n._state === Jee.PLAYING && n.pause().then((function() {
                                n._state = Jee.INTERRUPTED, n._eventTarget.emit(Zee.INTERRUPTION_BEGIN)
                            })).catch((function() {}))
                        }, i.game.on(i.Game.EVENT_HIDE, this._onHide), this._onShow = function() {
                            n._state === Jee.INTERRUPTED && n.play().then((function() {
                                n._eventTarget.emit(Zee.INTERRUPTION_END)
                            })).catch((function() {}))
                        }, i.game.on(i.Game.EVENT_SHOW, this._onShow)
                    }
                    var t = e.prototype;
                    return t.destroy = function() {
                        this._audioBuffer && (this._audioBuffer = void 0), this._onShow && (i.game.off(i.Game.EVENT_SHOW, this._onShow), this._onShow = void 0), this._onHide && (i.game.off(i.Game.EVENT_HIDE, this._onHide), this._onHide = void 0)
                    }, e.load = function(t) {
                        return new Promise((function(n) {
                            e.loadNative(t).then((function(i) {
                                n(new e(i, t))
                            })).catch((function() {}))
                        }))
                    }, e.loadNative = function(e) {
                        return new Promise((function(t, n) {
                            var i = new XMLHttpRequest,
                                r = "load audio failed: " + e + ", status: ";
                            i.open("GET", e, !0), i.responseType = "arraybuffer", i.onload = function() {
                                200 === i.status || 0 === i.status ? _te.decodeAudioData(i.response).then((function(e) {
                                    t(e)
                                })).catch((function() {})) : n(new Error("" + r + i.status + "(no response)"))
                            }, i.onerror = function() {
                                n(new Error("" + r + i.status + "(error)"))
                            }, i.ontimeout = function() {
                                n(new Error("" + r + i.status + "(time out)"))
                            }, i.onabort = function() {
                                n(new Error("" + r + i.status + "(abort)"))
                            }, i.send(null)
                        }))
                    }, e.loadOneShotAudio = function(t, n) {
                        return new Promise((function(i, r) {
                            e.loadNative(t).then((function(e) {
                                var t = new Tte(e, n);
                                i(t)
                            })).catch(r)
                        }))
                    }, t.seek = function(e) {
                        var t = this;
                        return new Promise((function(n) {
                            t._playTimeOffset = en(e, 0, t._audioBuffer.duration), t._state === Jee.PLAYING ? t._doPlay().then(n).catch((function() {})) : n()
                        }))
                    }, t.play = function() {
                        return this._doPlay()
                    }, t._doPlay = function() {
                        var e = this;
                        return new Promise((function(t) {
                            _te.runContext().then((function() {
                                e._stopSourceNode(), e._sourceNode = _te.createBufferSource(e._audioBuffer, e.loop), e._sourceNode.connect(e._gainNode), e._sourceNode.start(0, e._playTimeOffset), e._state = Jee.PLAYING, e._startTime = _te.currentTime, window.clearTimeout(e._currentTimer), e._currentTimer = window.setTimeout((function t() {
                                    e._playTimeOffset = 0, e._startTime = _te.currentTime, e.loop ? e._currentTimer = window.setTimeout(t, 1e3 * e._audioBuffer.duration) : (e._eventTarget.emit(Zee.ENDED), e._state = Jee.INIT)
                                }), 1e3 * (e._audioBuffer.duration - e._playTimeOffset)), t()
                            })).catch((function() {}))
                        }))
                    }, t._stopSourceNode = function() {
                        try {
                            var e;
                            null === (e = this._sourceNode) || void 0 === e || e.stop()
                        } catch (e) {}
                    }, t.pause = function() {
                        return this._state === Jee.PLAYING && this._sourceNode ? (this._playTimeOffset = (_te.currentTime - this._startTime + this._playTimeOffset) % this._audioBuffer.duration, this._state = Jee.PAUSED, window.clearTimeout(this._currentTimer), this._stopSourceNode(), Promise.resolve()) : Promise.resolve()
                    }, t.stop = function() {
                        return this._sourceNode ? (this._playTimeOffset = 0, this._state = Jee.STOPPED, window.clearTimeout(this._currentTimer), this._stopSourceNode(), Promise.resolve()) : Promise.resolve()
                    }, t.onInterruptionBegin = function(e) {
                        this._eventTarget.on(Zee.INTERRUPTION_BEGIN, e)
                    }, t.offInterruptionBegin = function(e) {
                        this._eventTarget.off(Zee.INTERRUPTION_BEGIN, e)
                    }, t.onInterruptionEnd = function(e) {
                        this._eventTarget.on(Zee.INTERRUPTION_END, e)
                    }, t.offInterruptionEnd = function(e) {
                        this._eventTarget.off(Zee.INTERRUPTION_END, e)
                    }, t.onEnded = function(e) {
                        this._eventTarget.on(Zee.ENDED, e)
                    }, t.offEnded = function(e) {
                        this._eventTarget.off(Zee.ENDED, e)
                    }, K(e, [{
                        key: "src",
                        get: function() {
                            return this._src
                        }
                    }, {
                        key: "type",
                        get: function() {
                            return Qee.WEB_AUDIO
                        }
                    }, {
                        key: "state",
                        get: function() {
                            return this._state
                        }
                    }, {
                        key: "loop",
                        get: function() {
                            return this._loop
                        },
                        set: function(e) {
                            this._loop = e, this._sourceNode && (this._sourceNode.loop = e)
                        }
                    }, {
                        key: "volume",
                        get: function() {
                            return this._volume
                        },
                        set: function(e) {
                            e = tn(e), this._volume = e, _te.setGainValue(this._gainNode, e)
                        }
                    }, {
                        key: "duration",
                        get: function() {
                            return this._audioBuffer.duration
                        }
                    }, {
                        key: "currentTime",
                        get: function() {
                            return this._state !== Jee.PLAYING ? this._playTimeOffset : (_te.currentTime - this._startTime + this._playTimeOffset) % this._audioBuffer.duration
                        }
                    }]), e
                }()).prototype, "seek", [lte], Object.getOwnPropertyDescriptor(hte.prototype, "seek"), hte.prototype), ie(hte.prototype, "play", [lte], Object.getOwnPropertyDescriptor(hte.prototype, "play"), hte.prototype), ie(hte.prototype, "pause", [lte], Object.getOwnPropertyDescriptor(hte.prototype, "pause"), hte.prototype), ie(hte.prototype, "stop", [lte], Object.getOwnPropertyDescriptor(hte.prototype, "stop"), hte.prototype), hte),
                xte = function() {
                    function e(e) {
                        this._audio = void 0, this._audio = e
                    }
                    var t = e.prototype;
                    return t.play = function() {
                        this._audio.play()
                    }, t.stop = function() {
                        this._audio.stop()
                    }, K(e, [{
                        key: "onPlay",
                        get: function() {
                            return this._audio.onPlay
                        },
                        set: function(e) {
                            this._audio.onPlay = e
                        }
                    }, {
                        key: "onEnd",
                        get: function() {
                            return this._audio.onEnd
                        },
                        set: function(e) {
                            this._audio.onEnd = e
                        }
                    }]), e
                }(),
                Cte = function() {
                    function e(e) {
                        this._player = void 0, this._player = e
                    }
                    e.load = function(t, n) {
                        return new Promise((function(i) {
                            (null == n ? void 0 : n.audioLoadMode) !== Qee.DOM_AUDIO && mte.support ? Ate.load(t).then((function(t) {
                                i(new e(t))
                            })).catch((function() {})) : (mte.support || x(5201), dte.load(t).then((function(t) {
                                i(new e(t))
                            })).catch((function() {})))
                        }))
                    };
                    var t = e.prototype;
                    return t.destroy = function() {
                        this._player.destroy()
                    }, e.loadNative = function(e, t) {
                        return (null == t ? void 0 : t.audioLoadMode) !== Qee.DOM_AUDIO && mte.support ? Ate.loadNative(e) : (mte.support || x(5201), dte.loadNative(e))
                    }, e.loadOneShotAudio = function(e, t, n) {
                        return new Promise((function(i, r) {
                            (null == n ? void 0 : n.audioLoadMode) !== Qee.DOM_AUDIO && mte.support ? Ate.loadOneShotAudio(e, t).then((function(e) {
                                i(new xte(e))
                            })).catch(r) : (mte.support || x(5201), dte.loadOneShotAudio(e, t).then((function(e) {
                                i(new xte(e))
                            })).catch(r))
                        }))
                    }, t.seek = function(e) {
                        return this._player.seek(e)
                    }, t.play = function() {
                        return this._player.play()
                    }, t.pause = function() {
                        return this._player.pause()
                    }, t.stop = function() {
                        return this._player.stop()
                    }, t.onInterruptionBegin = function(e) {
                        this._player.onInterruptionBegin(e)
                    }, t.offInterruptionBegin = function(e) {
                        this._player.offInterruptionBegin(e)
                    }, t.onInterruptionEnd = function(e) {
                        this._player.onInterruptionEnd(e)
                    }, t.offInterruptionEnd = function(e) {
                        this._player.offInterruptionEnd(e)
                    }, t.onEnded = function(e) {
                        this._player.onEnded(e)
                    }, t.offEnded = function(e) {
                        this._player.offEnded(e)
                    }, K(e, [{
                        key: "src",
                        get: function() {
                            return this._player.src
                        }
                    }, {
                        key: "type",
                        get: function() {
                            return this._player.type
                        }
                    }, {
                        key: "state",
                        get: function() {
                            return this._player.state
                        }
                    }, {
                        key: "loop",
                        get: function() {
                            return this._player.loop
                        },
                        set: function(e) {
                            this._player.loop = e
                        }
                    }, {
                        key: "volume",
                        get: function() {
                            return this._player.volume
                        },
                        set: function(e) {
                            this._player.volume = e
                        }
                    }, {
                        key: "duration",
                        get: function() {
                            return this._player.duration
                        }
                    }, {
                        key: "currentTime",
                        get: function() {
                            return this._player.currentTime
                        }
                    }]), e
                }();
            Cte.maxAudioChannel = 24;
            var bte = e("AudioClip", A_("cc.AudioClip")((Ete = Ste = function(e) {
                function t() {
                    var t;
                    return ne(t = e.call(this) || this, "_duration", yte, $(t)), t._loadMode = Qee.UNKNOWN_AUDIO, t._meta = null, t.loaded = !1, t
                }
                Q(t, e);
                var n = t.prototype;
                return n.validate = function() {
                    return !!this._meta
                }, n.getDuration = function() {
                    return this._duration ? this._duration : this._meta ? this._meta.duration : 0
                }, K(t, [{
                    key: "_nativeAsset",
                    get: function() {
                        return this._meta
                    },
                    set: function(e) {
                        this._meta = e, e ? (this.loaded = !0, this._loadMode = e.type, this.emit("load")) : (this._meta = null, this._loadMode = Qee.UNKNOWN_AUDIO, this._duration = 0, this.loaded = !1)
                    }
                }, {
                    key: "_nativeDep",
                    get: function() {
                        return {
                            uuid: this._uuid,
                            audioLoadMode: this.loadMode,
                            ext: this._native,
                            __isNative__: !0
                        }
                    }
                }, {
                    key: "loadMode",
                    get: function() {
                        return this._loadMode
                    }
                }]), t
            }(Nf), Ste.AudioType = Qee, yte = ie((vte = Ete).prototype, "_duration", [w_], {
                configurable: !0,
                enumerable: !0,
                writable: !0,
                initializer: function() {
                    return 0
                }
            }), ie(vte.prototype, "_nativeDep", [tf], Object.getOwnPropertyDescriptor(vte.prototype, "_nativeDep"), vte.prototype), gte = vte)) || gte);

            function Rte(e, t, n) {
                Cte.load(e, {
                    audioLoadMode: t.audioLoadMode
                }).then((function(t) {
                    var i = {
                        url: e,
                        duration: t.duration,
                        type: t.type
                    };
                    t.destroy(), n(null, i)
                })).catch((function(e) {
                    n(e)
                }))
            }

            function wte(e, t, n, i) {
                var r = new bte;
                r._nativeUrl = e, r._nativeAsset = t, r._duration = t.duration, i(null, r)
            }
            i.AudioClip = bte, oD.register({
                ".mp3": Rte,
                ".ogg": Rte,
                ".wav": Rte,
                ".m4a": Rte
            }), _D.register({
                ".mp3": wte,
                ".ogg": wte,
                ".wav": wte,
                ".m4a": wte
            });
            var Ite, Pte, Ote, Dte, Nte, Mte, Lte, Bte, Fte, zte, Ute, Gte, Hte, kte, Vte, Wte, jte, qte, Xte = new(function() {
                    function e() {
                        this._oneShotAudioInfoList = [], this._audioPlayerInfoList = []
                    }
                    var t = e.prototype;
                    return t._findIndex = function(e, t) {
                        return e.findIndex((function(e) {
                            return e.audio === t
                        }))
                    }, t._tryAddPlaying = function(e, t) {
                        var n = this._findIndex(e, t);
                        return n > -1 ? (e[n].playTime = performance.now(), !1) : (e.push({
                            audio: t,
                            playTime: performance.now()
                        }), !0)
                    }, t.addPlaying = function(e) {
                        if (e instanceof Cte) {
                            if (this._tryAddPlaying(this._audioPlayerInfoList, e)) return
                        } else this._tryAddPlaying(this._oneShotAudioInfoList, e)
                    }, t._tryRemovePlaying = function(e, t) {
                        var n = this._findIndex(e, t);
                        return -1 !== n && (ae(e, n), !0)
                    }, t.removePlaying = function(e) {
                        if (e instanceof Cte) {
                            if (this._tryRemovePlaying(this._audioPlayerInfoList, e)) return
                        } else this._tryRemovePlaying(this._oneShotAudioInfoList, e)
                    }, t.discardOnePlayingIfNeeded = function() {
                        var e;
                        this._audioPlayerInfoList.length + this._oneShotAudioInfoList.length < Cte.maxAudioChannel || (this._oneShotAudioInfoList.length > 0 ? this._oneShotAudioInfoList.forEach((function(t) {
                            (!e || t.playTime < e.playTime) && (e = t)
                        })) : this._audioPlayerInfoList.forEach((function(t) {
                            (!e || t.playTime < e.playTime) && (e = t)
                        })), e && (e.audio.stop(), this.removePlaying(e.audio)))
                    }, e
                }()),
                Yte = function(t) {
                    return e({
                        AudioSource: t,
                        AudioSourceComponent: t
                    }), t
                }((Ite = A_("cc.AudioSource"), Pte = B_(), Ote = D_(), Dte = ef(bte), Nte = ef(bte), Mte = G_(), Lte = G_(), Bte = G_(), Fte = H_(), zte = G_(), Ite(Ute = Pte(Ute = Ote((qte = jte = function(e) {
                    function t() {
                        for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                        return ne(t = e.call.apply(e, [this].concat(i)) || this, "_clip", Hte, $(t)), t._player = null, ne(t, "_loop", kte, $(t)), ne(t, "_playOnAwake", Vte, $(t)), ne(t, "_volume", Wte, $(t)), t._cachedCurrentTime = 0, t._operationsBeforeLoading = [], t._isLoaded = !1, t._lastSetClip = void 0, t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n._syncPlayer = function() {
                        var e = this,
                            t = this._clip;
                        this._isLoaded = !1, t && this._lastSetClip !== t && (t._nativeAsset ? (this._lastSetClip = t, Cte.load(t._nativeAsset.url, {
                            audioLoadMode: t.loadMode
                        }).then((function(n) {
                            e._lastSetClip === t && (e._isLoaded = !0, e._player && (e._player.offEnded(), e._player.offInterruptionBegin(), e._player.offInterruptionEnd(), e._player.destroy()), e._player = n, n.onEnded((function() {
                                Xte.removePlaying(n)
                            })), n.onInterruptionBegin((function() {
                                Xte.removePlaying(n)
                            })), n.onInterruptionEnd((function() {
                                Xte.addPlaying(n)
                            })), e._syncStates())
                        })).catch((function() {}))) : console.error("Invalid audio clip"))
                    }, n.onLoad = function() {
                        this._syncPlayer()
                    }, n.onEnable = function() {
                        this._playOnAwake && !this.playing && this.play()
                    }, n.onDisable = function() {
                        this.pause()
                    }, n.onDestroy = function() {
                        this.stop()
                    }, n.play = function() {
                        var e, t, n = this;
                        this._isLoaded ? (Xte.discardOnePlayingIfNeeded(), this.state === Jee.PLAYING && (null === (t = this._player) || void 0 === t || t.stop().catch((function() {}))), null === (e = this._player) || void 0 === e || e.play().then((function() {
                            Xte.addPlaying(n._player)
                        })).catch((function() {}))) : this._operationsBeforeLoading.push("play")
                    }, n.pause = function() {
                        var e, t = this;
                        this._isLoaded ? null === (e = this._player) || void 0 === e || e.pause().then((function() {
                            Xte.removePlaying(t._player)
                        })).catch((function() {})) : this._operationsBeforeLoading.push("pause")
                    }, n.stop = function() {
                        var e, t = this;
                        this._isLoaded ? null === (e = this._player) || void 0 === e || e.stop().then((function() {
                            Xte.removePlaying(t._player)
                        })).catch((function() {})) : this._operationsBeforeLoading.push("stop")
                    }, n.playOneShot = function(e, t) {
                        void 0 === t && (t = 1), e._nativeAsset ? Cte.loadOneShotAudio(e._nativeAsset.url, this._volume * t, {
                            audioLoadMode: e.loadMode
                        }).then((function(e) {
                            Xte.discardOnePlayingIfNeeded(), e.onPlay = function() {
                                Xte.addPlaying(e)
                            }, e.onEnd = function() {
                                Xte.removePlaying(e)
                            }, e.play()
                        })).catch((function() {})) : console.error("Invalid audio clip")
                    }, n._syncStates = function() {
                        var e = this;
                        this._player && this._player.seek(this._cachedCurrentTime).then((function() {
                            e._player && (e._player.loop = e._loop, e._player.volume = e._volume, e._operationsBeforeLoading.forEach((function(t) {
                                var n;
                                null === (n = e[t]) || void 0 === n || n.call(e)
                            })), e._operationsBeforeLoading.length = 0)
                        })).catch((function() {}))
                    }, K(t, [{
                        key: "clip",
                        get: function() {
                            return this._clip
                        },
                        set: function(e) {
                            e !== this._clip && (this._clip = e, this._syncPlayer())
                        }
                    }, {
                        key: "loop",
                        get: function() {
                            return this._loop
                        },
                        set: function(e) {
                            this._loop = e, this._player && (this._player.loop = e)
                        }
                    }, {
                        key: "playOnAwake",
                        get: function() {
                            return this._playOnAwake
                        },
                        set: function(e) {
                            this._playOnAwake = e
                        }
                    }, {
                        key: "volume",
                        get: function() {
                            return this._volume
                        },
                        set: function(e) {
                            Number.isNaN(e) ? console.warn("illegal audio volume!") : (e = en(e, 0, 1), this._player ? (this._player.volume = e, this._volume = this._player.volume) : this._volume = e)
                        }
                    }, {
                        key: "currentTime",
                        get: function() {
                            return this._player ? this._player.currentTime : this._cachedCurrentTime
                        },
                        set: function(e) {
                            var t;
                            Number.isNaN(e) ? console.warn("illegal audio time!") : (e = en(e, 0, this.duration), this._cachedCurrentTime = e, null === (t = this._player) || void 0 === t || t.seek(this._cachedCurrentTime).catch((function() {})))
                        }
                    }, {
                        key: "duration",
                        get: function() {
                            var e, t;
                            return null !== (e = null === (t = this._clip) || void 0 === t ? void 0 : t.getDuration()) && void 0 !== e ? e : this._player ? this._player.currentTime : 0
                        }
                    }, {
                        key: "state",
                        get: function() {
                            return this._player ? this._player.state : Jee.INIT
                        }
                    }, {
                        key: "playing",
                        get: function() {
                            return this.state === t.AudioState.PLAYING
                        }
                    }], [{
                        key: "maxAudioChannel",
                        get: function() {
                            return Cte.maxAudioChannel
                        }
                    }]), t
                }(Jd), jte.AudioState = Jee, Hte = ie((Gte = qte).prototype, "_clip", [Dte], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return null
                    }
                }), kte = ie(Gte.prototype, "_loop", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return !1
                    }
                }), Vte = ie(Gte.prototype, "_playOnAwake", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return !0
                    }
                }), Wte = ie(Gte.prototype, "_volume", [w_], {
                    configurable: !0,
                    enumerable: !0,
                    writable: !0,
                    initializer: function() {
                        return 1
                    }
                }), ie(Gte.prototype, "clip", [Nte, Mte], Object.getOwnPropertyDescriptor(Gte.prototype, "clip"), Gte.prototype), ie(Gte.prototype, "loop", [Lte], Object.getOwnPropertyDescriptor(Gte.prototype, "loop"), Gte.prototype), ie(Gte.prototype, "playOnAwake", [Bte], Object.getOwnPropertyDescriptor(Gte.prototype, "playOnAwake"), Gte.prototype), ie(Gte.prototype, "volume", [Fte, zte], Object.getOwnPropertyDescriptor(Gte.prototype, "volume"), Gte.prototype), Ute = Gte)) || Ute) || Ute) || Ute));
            U(bte, "AudioClip", [{
                name: "PlayingState",
                newName: "AudioState",
                target: Yte,
                targetName: "AudioSource"
            }]), U(bte.prototype, "AudioClip.prototype", [{
                name: "state",
                targetName: "AudioSource.prototype",
                customGetter: function() {
                    return Jee.INIT
                }
            }]), U(bte.prototype, "AudioClip.prototype", [{
                name: "getCurrentTime",
                targetName: "AudioSource.prototype",
                customFunction: function() {
                    return 0
                }
            }, {
                name: "getVolume",
                targetName: "AudioSource.prototype",
                customFunction: function() {
                    return 0
                }
            }, {
                name: "getLoop",
                targetName: "AudioSource.prototype",
                customFunction: function() {
                    return !1
                }
            }]), U(bte.prototype, "AudioClip.prototype", ["play", "pause", "stop", "playOneShot", "setCurrentTime", "setVolume", "setLoop"].map((function(e) {
                return {
                    name: e,
                    targetName: "AudioSource.prototype",
                    customFunction: function() {}
                }
            }))), i.AudioSourceComponent = Yte, Qe.setClassAlias(Yte, "cc.AudioSourceComponent");
            var Kte = function() {
                function e() {
                    this.originalTarget = null, this.target = null, this.tag = e.TAG_INVALID
                }
                var t = e.prototype;
                return t.clone = function() {
                    var t = new e;
                    return t.originalTarget = null, t.target = null, t.tag = this.tag, t
                }, t.isDone = function() {
                    return !0
                }, t.startWithTarget = function(e) {
                    this.originalTarget = e, this.target = e
                }, t.stop = function() {
                    this.target = null
                }, t.step = function() {
                    T(1006)
                }, t.update = function() {
                    T(1007)
                }, t.getTarget = function() {
                    return this.target
                }, t.setTarget = function(e) {
                    this.target = e
                }, t.getOriginalTarget = function() {
                    return this.originalTarget
                }, t.setOriginalTarget = function(e) {
                    this.originalTarget = e
                }, t.getTag = function() {
                    return this.tag
                }, t.setTag = function(e) {
                    this.tag = e
                }, t.reverse = function() {
                    return T(1008), null
                }, t.retain = function() {}, t.release = function() {}, e
            }();
            Kte.TAG_INVALID = -1;
            var Zte = function(e) {
                    function t() {
                        for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                        return (t = e.call.apply(e, [this].concat(i)) || this)._duration = 0, t._timesForRepeat = 1, t
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.getDuration = function() {
                        return this._duration * (this._timesForRepeat || 1)
                    }, n.setDuration = function(e) {
                        this._duration = e
                    }, n.clone = function() {
                        return new t
                    }, t
                }(Kte),
                Qte = (function(e) {
                    function t(t, n) {
                        var i;
                        return void 0 === n && (n = 1), (i = e.call(this) || this)._speed = 0, i._innerAction = null, t && i.initWithAction(t, n), i
                    }
                    Q(t, e);
                    var n = t.prototype;
                    n.getSpeed = function() {
                        return this._speed
                    }, n.setSpeed = function(e) {
                        this._speed = e
                    }, n.initWithAction = function(e, t) {
                        return e ? (this._innerAction = e, this._speed = t, !0) : (b(1021), !1)
                    }, n.clone = function() {
                        var e = new t;
                        return e.initWithAction(this._innerAction.clone(), this._speed), e
                    }, n.startWithTarget = function(e) {
                        Kte.prototype.startWithTarget.call(this, e), this._innerAction.startWithTarget(e)
                    }, n.stop = function() {
                        this._innerAction.stop(), Kte.prototype.stop.call(this)
                    }, n.step = function(e) {
                        this._innerAction.step(e * this._speed)
                    }, n.isDone = function() {
                        return this._innerAction.isDone()
                    }, n.reverse = function() {
                        return new t(this._innerAction.reverse(), this._speed)
                    }, n.setInnerAction = function(e) {
                        this._innerAction !== e && (this._innerAction = e)
                    }, n.getInnerAction = function() {
                        return this._innerAction
                    }
                }(Kte), 0),
                Jte = function() {
                    this.actions = [], this.target = null, this.actionIndex = 0, this.currentAction = null, this.paused = !1, this.lock = !1
                },
                $te = function() {
                    function e() {
                        this._hashTargets = new Map, this._arrayTargets = [], this._elementPool = []
                    }
                    var t = e.prototype;
                    return t._searchElementByTarget = function(e, t) {
                        for (var n = 0; n < e.length; n++)
                            if (t === e[n].target) return e[n];
                        return null
                    }, t._getElement = function(e, t) {
                        var n = this._elementPool.pop();
                        return n || (n = new Jte), n.target = e, n.paused = !!t, n
                    }, t._putElement = function(e) {
                        e.actions.length = 0, e.actionIndex = 0, e.currentAction = null, e.paused = !1, e.target = null, e.lock = !1, this._elementPool.push(e)
                    }, t.addAction = function(e, t, n) {
                        if (e && t) {
                            null == t.uuid && (t.uuid = "_TWEEN_UUID_" + Qte++);
                            var i = this._hashTargets.get(t);
                            i ? i.actions || (i.actions = []) : (i = this._getElement(t, n), this._hashTargets.set(t, i), this._arrayTargets.push(i)), i.target = t, i.actions.push(e), e.startWithTarget(t)
                        } else b(1e3)
                    }, t.removeAllActions = function() {
                        for (var e = this._arrayTargets, t = 0; t < e.length; t++) {
                            var n = e[t];
                            n && this._putElement(n)
                        }
                        this._arrayTargets.length = 0, this._hashTargets = new Map
                    }, t.removeAllActionsFromTarget = function(e) {
                        if (null != e) {
                            var t = this._hashTargets.get(e);
                            t && (t.actions.length = 0, this._deleteHashElement(t))
                        }
                    }, t.removeAction = function(e) {
                        if (null != e) {
                            var t = e.getOriginalTarget(),
                                n = this._hashTargets.get(t);
                            if (n)
                                for (var i = 0; i < n.actions.length; i++)
                                    if (n.actions[i] === e) {
                                        n.actions.splice(i, 1), n.actionIndex >= i && n.actionIndex--;
                                        break
                                    }
                        }
                    }, t._removeActionByTag = function(e, t, n) {
                        for (var i = 0, r = t.actions.length; i < r; ++i) {
                            var o = t.actions[i];
                            if (o && o.getTag() === e) {
                                if (n && o.getOriginalTarget() !== n) continue;
                                this._removeActionAtIndex(i, t);
                                break
                            }
                        }
                    }, t.removeActionByTag = function(e, t) {
                        var n = this;
                        e === Kte.TAG_INVALID && T(1002);
                        var i = this._hashTargets;
                        if (t) {
                            var r = i.get(t);
                            r && this._removeActionByTag(e, r, t)
                        } else i.forEach((function(t) {
                            n._removeActionByTag(e, t)
                        }))
                    }, t.getActionByTag = function(e, t) {
                        e === Kte.TAG_INVALID && T(1004);
                        var n = this._hashTargets.get(t);
                        if (n) {
                            if (null != n.actions)
                                for (var i = 0; i < n.actions.length; ++i) {
                                    var r = n.actions[i];
                                    if (r && r.getTag() === e) return r
                                }
                            T(1005, e)
                        }
                        return null
                    }, t.getNumberOfRunningActionsInTarget = function(e) {
                        var t = this._hashTargets.get(e);
                        return t && t.actions ? t.actions.length : 0
                    }, t.pauseTarget = function(e) {
                        var t = this._hashTargets.get(e);
                        t && (t.paused = !0)
                    }, t.resumeTarget = function(e) {
                        var t = this._hashTargets.get(e);
                        t && (t.paused = !1)
                    }, t.pauseAllRunningActions = function() {
                        for (var e = [], t = this._arrayTargets, n = 0; n < t.length; n++) {
                            var i = t[n];
                            i && !i.paused && (i.paused = !0, e.push(i.target))
                        }
                        return e
                    }, t.resumeTargets = function(e) {
                        if (e)
                            for (var t = 0; t < e.length; t++) e[t] && this.resumeTarget(e[t])
                    }, t.pauseTargets = function(e) {
                        if (e)
                            for (var t = 0; t < e.length; t++) e[t] && this.pauseTarget(e[t])
                    }, t.purgeSharedManager = function() {
                        i.director.getScheduler().unscheduleUpdate(this)
                    }, t._removeActionAtIndex = function(e, t) {
                        t.actions[e], t.actions.splice(e, 1), t.actionIndex >= e && t.actionIndex--, 0 === t.actions.length && this._deleteHashElement(t)
                    }, t._deleteHashElement = function(e) {
                        var t = !1;
                        if (e && !e.lock && this._hashTargets.get(e.target)) {
                            this._hashTargets.delete(e.target);
                            for (var n = this._arrayTargets, i = 0, r = n.length; i < r; i++)
                                if (n[i] === e) {
                                    n.splice(i, 1);
                                    break
                                }
                            this._putElement(e), t = !0
                        }
                        return t
                    }, t.update = function(e) {
                        for (var t, n = this._arrayTargets, i = 0; i < n.length; i++) {
                            this._currentTarget = n[i];
                            var r = (t = this._currentTarget).target;
                            if (r instanceof ni && !r.isValid) this.removeAllActionsFromTarget(r), i--;
                            else {
                                if (!t.paused && t.actions) {
                                    for (t.lock = !0, t.actionIndex = 0; t.actionIndex < t.actions.length; t.actionIndex++)
                                        if (t.currentAction = t.actions[t.actionIndex], t.currentAction) {
                                            if (t.currentAction.step(e * (t.currentAction._speedMethod ? t.currentAction._speed : 1)), t.currentAction && t.currentAction.isDone()) {
                                                t.currentAction.stop();
                                                var o = t.currentAction;
                                                t.currentAction = null, this.removeAction(o)
                                            }
                                            t.currentAction = null
                                        }
                                    t.lock = !1
                                }
                                0 === t.actions.length && this._deleteHashElement(t) && i--
                            }
                        }
                    }, e
                }(),
                ene = e("TweenSystem", function(e) {
                    function t() {
                        for (var t, n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                        return (t = e.call.apply(e, [this].concat(i)) || this).actionMgr = new $te, t
                    }
                    return Q(t, e), t.prototype.update = function(e) {
                        this.actionMgr.update(e)
                    }, K(t, [{
                        key: "ActionManager",
                        get: function() {
                            return this.actionMgr
                        }
                    }]), t
                }(oR));
            ene.ID = "TWEEN", ene.instance = void 0, RO.on(bO.EVENT_INIT, (function() {
                var e = new ene;
                ene.instance = e, RO.registerSystem(ene.ID, e, 100)
            }));
            var tne = function(e) {
                    function t() {
                        return e.apply(this, arguments) || this
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.isDone = function() {
                        return !0
                    }, n.step = function() {
                        this.update(1)
                    }, n.update = function() {}, n.reverse = function() {
                        return this.clone()
                    }, n.clone = function() {
                        return new t
                    }, t
                }(Zte),
                nne = function(e) {
                    function t() {
                        return e.apply(this, arguments) || this
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.update = function() {
                        for (var e = this.target.getComponentsInChildren(UM), t = 0; t < e.length; ++t) e[t].enabled = !0
                    }, n.reverse = function() {
                        return new ine
                    }, n.clone = function() {
                        return new t
                    }, t
                }(tne),
                ine = function(e) {
                    function t() {
                        return e.apply(this, arguments) || this
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.update = function() {
                        for (var e = this.target.getComponentsInChildren(UM), t = 0; t < e.length; ++t) e[t].enabled = !1
                    }, n.reverse = function() {
                        return new nne
                    }, n.clone = function() {
                        return new t
                    }, t
                }(tne);
            ! function(e) {
                function t() {
                    return e.apply(this, arguments) || this
                }
                Q(t, e);
                var n = t.prototype;
                n.update = function() {
                    for (var e = this.target.getComponentsInChildren(UM), t = 0; t < e.length; ++t) {
                        var n = e[t];
                        n.enabled = !n.enabled
                    }
                }, n.reverse = function() {
                    return new t
                }, n.clone = function() {
                    return new t
                }
            }(tne);
            var rne = function(e) {
                    function t(t) {
                        var n;
                        return (n = e.call(this) || this)._isNeedCleanUp = !0, void 0 !== t && n.init(t), n
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.update = function() {
                        this.target.removeFromParent(), this._isNeedCleanUp && this.target.destroy()
                    }, n.init = function(e) {
                        return this._isNeedCleanUp = e, !0
                    }, n.reverse = function() {
                        return new t(this._isNeedCleanUp)
                    }, n.clone = function() {
                        return new t(this._isNeedCleanUp)
                    }, t
                }(tne),
                one = function(e) {
                    function t(t, n, i) {
                        var r;
                        return (r = e.call(this) || this)._selectorTarget = null, r._function = null, r._data = null, r.initWithFunction(t, n, i), r
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.initWithFunction = function(e, t, n) {
                        return e && (this._function = e), t && (this._selectorTarget = t), void 0 !== n && (this._data = n), !0
                    }, n.execute = function() {
                        this._function && this._function.call(this._selectorTarget, this.target, this._data)
                    }, n.update = function() {
                        this.execute()
                    }, n.getTargetCallback = function() {
                        return this._selectorTarget
                    }, n.setTargetCallback = function(e) {
                        e !== this._selectorTarget && (this._selectorTarget && (this._selectorTarget = null), this._selectorTarget = e)
                    }, n.clone = function() {
                        var e = new t;
                        return e.initWithFunction(this._function, this._selectorTarget, this._data), e
                    }, t
                }(tne),
                ane = function(e) {
                    function t(t) {
                        var n;
                        return (n = e.call(this) || this).MAX_VALUE = 2, n._elapsed = 0, n._firstTick = !1, n._easeList = [], n._speed = 1, n._repeatForever = !1, n._repeatMethod = !1, n._speedMethod = !1, void 0 === t || isNaN(t) || n.initWithDuration(t), n
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.getElapsed = function() {
                        return this._elapsed
                    }, n.initWithDuration = function(e) {
                        return this._duration = 0 === e ? rt.FLT_EPSILON : e, this._elapsed = 0, this._firstTick = !0, !0
                    }, n.isDone = function() {
                        return this._elapsed >= this._duration
                    }, n._cloneDecoration = function(e) {
                        e._repeatForever = this._repeatForever, e._speed = this._speed, e._timesForRepeat = this._timesForRepeat, e._easeList = this._easeList, e._speedMethod = this._speedMethod, e._repeatMethod = this._repeatMethod
                    }, n._reverseEaseList = function(e) {
                        if (this._easeList) {
                            e._easeList = [];
                            for (var t = 0; t < this._easeList.length; t++) e._easeList.push(this._easeList[t])
                        }
                    }, n.clone = function() {
                        var e = new t(this._duration);
                        return this._cloneDecoration(e), e
                    }, n.easing = function(e) {
                        this._easeList ? this._easeList.length = 0 : this._easeList = [];
                        for (var t = 0; t < arguments.length; t++) this._easeList.push(arguments[t]);
                        return this
                    }, n._computeEaseTime = function(e) {
                        return e
                    }, n.step = function(e) {
                        this._firstTick ? (this._firstTick = !1, this._elapsed = 0) : this._elapsed += e;
                        var t = this._elapsed / (this._duration > 1.192092896e-7 ? this._duration : 1.192092896e-7);
                        t = t < 1 ? t : 1, this.update(t > 0 ? t : 0), this._repeatMethod && this._timesForRepeat > 1 && this.isDone() && (this._repeatForever || this._timesForRepeat--, this.startWithTarget(this.target), this.step(this._elapsed - this._duration))
                    }, n.startWithTarget = function(e) {
                        Kte.prototype.startWithTarget.call(this, e), this._elapsed = 0, this._firstTick = !0
                    }, n.reverse = function() {
                        return T(1010), this
                    }, n.setAmplitudeRate = function() {
                        T(1011)
                    }, n.getAmplitudeRate = function() {
                        return T(1012), 0
                    }, n.speed = function(e) {
                        return e <= 0 ? (T(1013), this) : (this._speedMethod = !0, this._speed *= e, this)
                    }, n.getSpeed = function() {
                        return this._speed
                    }, n.setSpeed = function(e) {
                        return this._speed = e, this
                    }, n.repeat = function(e) {
                        return e = Math.round(e), isNaN(e) || e < 1 ? (T(1014), this) : (this._repeatMethod = !0, this._timesForRepeat *= e, this)
                    }, n.repeatForever = function() {
                        return this._repeatMethod = !0, this._timesForRepeat = this.MAX_VALUE, this._repeatForever = !0, this
                    }, t
                }(Zte),
                sne = function(e) {
                    function t(n) {
                        var i;
                        (i = e.call(this) || this)._actions = [], i._split = 0, i._last = 0, i._reversed = !1;
                        var r = n instanceof Array ? n : arguments;
                        if (1 === r.length) return b(1019), $(i);
                        var o = r.length - 1;
                        if (o >= 0 && null == r[o] && T(1015), o >= 0) {
                            for (var a, s = r[0], c = 1; c < o; c++) r[c] && (a = s, s = t._actionOneTwo(a, r[c]));
                            i.initWithTwoActions(s, r[o])
                        }
                        return i
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.initWithTwoActions = function(e, t) {
                        if (!e || !t) return b(1025), !1;
                        var n = e._duration,
                            i = t._duration,
                            r = (n *= e._repeatMethod ? e._timesForRepeat : 1) + (i *= t._repeatMethod ? t._timesForRepeat : 1);
                        return this.initWithDuration(r), this._actions[0] = e, this._actions[1] = t, !0
                    }, n.clone = function() {
                        var e = new t;
                        return this._cloneDecoration(e), e.initWithTwoActions(this._actions[0].clone(), this._actions[1].clone()), e
                    }, n.startWithTarget = function(e) {
                        ane.prototype.startWithTarget.call(this, e), this._split = this._actions[0]._duration / this._duration, this._split *= this._actions[0]._repeatMethod ? this._actions[0]._timesForRepeat : 1, this._last = -1
                    }, n.stop = function() {
                        -1 !== this._last && this._actions[this._last].stop(), Kte.prototype.stop.call(this)
                    }, n.update = function(e) {
                        var t, n, i = 0,
                            r = this._split,
                            o = this._actions,
                            a = this._last;
                        (e = this._computeEaseTime(e)) < r ? (t = 0 !== r ? e / r : 1, 0 === i && 1 === a && this._reversed && (o[1].update(0), o[1].stop())) : (i = 1, t = 1 === r ? 1 : (e - r) / (1 - r), -1 === a && (o[0].startWithTarget(this.target), o[0].update(1), o[0].stop()), 0 === a && (o[0].update(1), o[0].stop())), n = o[i], a === i && n.isDone() || (a !== i && n.startWithTarget(this.target), t *= n._timesForRepeat, n.update(t > 1 ? t % 1 : t), this._last = i)
                    }, n.reverse = function() {
                        var e = t._actionOneTwo(this._actions[1].reverse(), this._actions[0].reverse());
                        return this._cloneDecoration(e), this._reverseEaseList(e), e._reversed = !0, e
                    }, t
                }(ane);

            function cne(e) {
                var t = e instanceof Array ? e : arguments;
                if (1 === t.length) return b(1019), null;
                var n = t.length - 1;
                n >= 0 && null == t[n] && T(1015);
                var i = null;
                if (n >= 0) {
                    i = t[0];
                    for (var r = 1; r <= n; r++) t[r] && (i = sne._actionOneTwo(i, t[r]))
                }
                return i
            }
            sne._actionOneTwo = function(e, t) {
                var n = new sne;
                return n.initWithTwoActions(e, t), n
            };
            var lne = function(e) {
                    function t(t, n) {
                        var i;
                        return (i = e.call(this) || this)._times = 0, i._total = 0, i._nextDt = 0, i._actionInstant = !1, i._innerAction = null, void 0 !== n && i.initWithAction(t, n), i
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.initWithAction = function(e, t) {
                        var n = e._duration * t;
                        return !!this.initWithDuration(n) && (this._times = t, this._innerAction = e, e instanceof tne && (this._actionInstant = !0, this._times -= 1), this._total = 0, !0)
                    }, n.clone = function() {
                        var e = new t;
                        return this._cloneDecoration(e), e.initWithAction(this._innerAction.clone(), this._times), e
                    }, n.startWithTarget = function(e) {
                        this._total = 0, this._nextDt = this._innerAction._duration / this._duration, ane.prototype.startWithTarget.call(this, e), this._innerAction.startWithTarget(e)
                    }, n.stop = function() {
                        this._innerAction.stop(), Kte.prototype.stop.call(this)
                    }, n.update = function(e) {
                        e = this._computeEaseTime(e);
                        var t = this._innerAction,
                            n = this._duration,
                            i = this._times,
                            r = this._nextDt;
                        if (e >= r) {
                            for (; e > r && this._total < i;) t.update(1), this._total++, t.stop(), t.startWithTarget(this.target), r += t._duration / n, this._nextDt = r > 1 ? 1 : r;
                            e >= 1 && this._total < i && (t.update(1), this._total++), this._actionInstant || (this._total === i ? t.stop() : t.update(e - (r - t._duration / n)))
                        } else t.update(e * i % 1)
                    }, n.isDone = function() {
                        return this._total === this._times
                    }, n.reverse = function() {
                        var e = new t(this._innerAction.reverse(), this._times);
                        return this._cloneDecoration(e), this._reverseEaseList(e), e
                    }, n.setInnerAction = function(e) {
                        this._innerAction !== e && (this._innerAction = e)
                    }, n.getInnerAction = function() {
                        return this._innerAction
                    }, t
                }(ane),
                une = function(e) {
                    function t(t) {
                        var n;
                        return (n = e.call(this) || this)._innerAction = null, t && n.initWithAction(t), n
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.initWithAction = function(e) {
                        return e ? (this._innerAction = e, !0) : (b(1026), !1)
                    }, n.clone = function() {
                        var e = new t;
                        return this._cloneDecoration(e), e.initWithAction(this._innerAction.clone()), e
                    }, n.startWithTarget = function(e) {
                        ane.prototype.startWithTarget.call(this, e), this._innerAction.startWithTarget(e)
                    }, n.step = function(e) {
                        var t = this._innerAction;
                        t.step(e), t.isDone() && (t.startWithTarget(this.target), t.step(t.getElapsed() - t._duration))
                    }, n.isDone = function() {
                        return !1
                    }, n.reverse = function() {
                        var e = new t(this._innerAction.reverse());
                        return this._cloneDecoration(e), this._reverseEaseList(e), e
                    }, n.setInnerAction = function(e) {
                        this._innerAction !== e && (this._innerAction = e)
                    }, n.getInnerAction = function() {
                        return this._innerAction
                    }, t
                }(ane),
                hne = function(e) {
                    function t(n) {
                        var i;
                        (i = e.call(this) || this)._one = null, i._two = null;
                        var r = n instanceof Array ? n : arguments;
                        if (1 === r.length) return b(1020), $(i);
                        var o = r.length - 1;
                        if (o >= 0 && null == r[o] && T(1015), o >= 0) {
                            for (var a, s = r[0], c = 1; c < o; c++) r[c] && (a = s, s = t._actionOneTwo(a, r[c]));
                            i.initWithTwoActions(s, r[o])
                        }
                        return i
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.initWithTwoActions = function(e, t) {
                        if (!e || !t) return b(1027), !1;
                        var n = !1,
                            i = e._duration,
                            r = t._duration;
                        return this.initWithDuration(Math.max(i, r)) && (this._one = e, this._two = t, i > r ? this._two = sne._actionOneTwo(t, dne(i - r)) : i < r && (this._one = sne._actionOneTwo(e, dne(r - i))), n = !0), n
                    }, n.clone = function() {
                        var e = new t;
                        return this._cloneDecoration(e), e.initWithTwoActions(this._one.clone(), this._two.clone()), e
                    }, n.startWithTarget = function(e) {
                        ane.prototype.startWithTarget.call(this, e), this._one.startWithTarget(e), this._two.startWithTarget(e)
                    }, n.stop = function() {
                        this._one.stop(), this._two.stop(), Kte.prototype.stop.call(this)
                    }, n.update = function(e) {
                        e = this._computeEaseTime(e), this._one && this._one.update(e), this._two && this._two.update(e)
                    }, n.reverse = function() {
                        var e = t._actionOneTwo(this._one.reverse(), this._two.reverse());
                        return this._cloneDecoration(e), this._reverseEaseList(e), e
                    }, t
                }(ane);

            function _ne(e) {
                var t = e instanceof Array ? e : arguments;
                if (1 === t.length) return b(1020), null;
                t.length > 0 && null == t[t.length - 1] && T(1015);
                for (var n = t[0], i = 1; i < t.length; i++) null != t[i] && (n = hne._actionOneTwo(n, t[i]));
                return n
            }
            hne._actionOneTwo = function(e, t) {
                var n = new hne;
                return n.initWithTwoActions(e, t), n
            };
            var fne = function(e) {
                function t() {
                    return e.apply(this, arguments) || this
                }
                Q(t, e);
                var n = t.prototype;
                return n.update = function() {}, n.reverse = function() {
                    var e = new t(this._duration);
                    return this._cloneDecoration(e), this._reverseEaseList(e), e
                }, n.clone = function() {
                    var e = new t;
                    return this._cloneDecoration(e), e.initWithDuration(this._duration), e
                }, t
            }(ane);

            function dne(e) {
                return new fne(e)
            }
            var pne = function(e) {
                    function t(t) {
                        var n;
                        return (n = e.call(this) || this)._other = null, t && n.initWithAction(t), n
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.initWithAction = function(e) {
                        return e ? e === this._other ? (b(1029), !1) : !!ane.prototype.initWithDuration.call(this, e._duration) && (this._other = e, !0) : (b(1028), !1)
                    }, n.clone = function() {
                        var e = new t;
                        return this._cloneDecoration(e), e.initWithAction(this._other.clone()), e
                    }, n.startWithTarget = function(e) {
                        ane.prototype.startWithTarget.call(this, e), this._other.startWithTarget(e)
                    }, n.update = function(e) {
                        e = this._computeEaseTime(e), this._other && this._other.update(1 - e)
                    }, n.reverse = function() {
                        return this._other.clone()
                    }, n.stop = function() {
                        this._other.stop(), Kte.prototype.stop.call(this)
                    }, t
                }(ane),
                mne = function(e) {
                    function t(t, n, i) {
                        var o;
                        if ((o = e.call(this) || this)._opts = void 0, o._props = void 0, o._originProps = void 0, null == i) i = Object.create(null);
                        else if (function(e) {
                                var t = " [Tween:] ",
                                    n = " option is not support in v + " + r,
                                    i = e;
                                i.delay && d(t + "delay" + n), i.repeat && d(t + "repeat" + n), i.repeatDelay && d(t + "repeatDelay" + n), i.interpolation && d(t + "interpolation" + n), i.onStop && d(t + "onStop" + n)
                            }(i), i.easing && "string" == typeof i.easing && (i.easing = function(e) {
                                var t = e.charAt(0);
                                if (/[A-Z]/.test(t)) {
                                    var n = (e = e.replace(t, t.toLowerCase())).split("-");
                                    if (2 === n.length) {
                                        var i = n[0];
                                        if ("linear" === i) e = "linear";
                                        else {
                                            var r = n[1];
                                            switch (i) {
                                                case "quadratic":
                                                    e = "quad" + r;
                                                    break;
                                                case "quartic":
                                                    e = "quart" + r;
                                                    break;
                                                case "quintic":
                                                    e = "quint" + r;
                                                    break;
                                                case "sinusoidal":
                                                    e = "sine" + r;
                                                    break;
                                                case "exponential":
                                                    e = "expo" + r;
                                                    break;
                                                case "circular":
                                                    e = "circ" + r;
                                                    break;
                                                default:
                                                    e = i + r
                                            }
                                        }
                                    }
                                }
                                return e
                            }(i.easing)), i.progress || (i.progress = o.progress), i.easing && "string" == typeof i.easing) {
                            var a = i.easing;
                            i.easing = nR[a], i.easing || x(1031, a)
                        }
                        for (var s in o._opts = i, o._props = Object.create(null), n)
                            if (n.hasOwnProperty(s)) {
                                var c = n[s];
                                if (null != c && "string" != typeof c && "function" != typeof c) {
                                    var l = void 0,
                                        u = void 0;
                                    void 0 !== c.value && (c.easing || c.progress) && ("string" == typeof c.easing ? (l = nR[c.easing]) || x(1031, c.easing) : l = c.easing, u = c.progress, c = c.value);
                                    var h = Object.create(null);
                                    h.value = c, h.easing = l, h.progress = u, o._props[s] = h
                                }
                            }
                        return o._originProps = n, o.initWithDuration(t), o
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.clone = function() {
                        var e = new t(this._duration, this._originProps, this._opts);
                        return this._cloneDecoration(e), e
                    }, n.startWithTarget = function(e) {
                        ane.prototype.startWithTarget.call(this, e);
                        var t = !!this._opts.relative,
                            n = this._props;
                        for (var i in n) {
                            var r = e[i];
                            if (void 0 !== r) {
                                var o = n[i],
                                    a = o.value;
                                if ("number" == typeof r) o.start = r, o.current = r, o.end = t ? r + a : a;
                                else if ("object" == typeof r)
                                    for (var s in null == o.start && (o.start = {}, o.current = {}, o.end = {}), a) isNaN(r[s]) || (o.start[s] = r[s], o.current[s] = r[s], o.end[s] = t ? r[s] + a[s] : a[s])
                            }
                        }
                        this._opts.onStart && this._opts.onStart(this.target)
                    }, n.update = function(e) {
                        var t = this.target;
                        if (t) {
                            var n = this._props,
                                i = this._opts,
                                r = e;
                            i.easing && (r = i.easing(e));
                            var o = i.progress;
                            for (var a in n) {
                                var s = n[a],
                                    c = s.easing ? s.easing(e) : r,
                                    l = s.progress ? s.progress : o,
                                    u = s.start,
                                    h = s.end;
                                if ("number" == typeof u) s.current = l(u, h, s.current, c);
                                else if ("object" == typeof u)
                                    for (var _ in u) s.current[_] = l(u[_], h[_], s.current[_], c);
                                t[a] = s.current
                            }
                            i.onUpdate && i.onUpdate(this.target, e), 1 === e && i.onComplete && i.onComplete(this.target)
                        }
                    }, n.progress = function(e, t, n, i) {
                        return e + (t - e) * i
                    }, t
                }(ane),
                gne = function(e) {
                    function t(t) {
                        var n;
                        return (n = e.call(this) || this)._props = void 0, n._props = {}, void 0 !== t && n.init(t), n
                    }
                    Q(t, e);
                    var n = t.prototype;
                    return n.init = function(e) {
                        for (var t in e) this._props[t] = e[t];
                        return !0
                    }, n.update = function() {
                        var e = this._props,
                            t = this.target;
                        for (var n in e) t[n] = e[n]
                    }, n.clone = function() {
                        var e = new t;
                        return e.init(this._props), e
                    }, t
                }(tne),
                vne = e("Tween", function() {
                    function e(e) {
                        this._actions = [], this._finalAction = null, this._target = null, this._tag = Kte.TAG_INVALID, this._target = void 0 === e ? null : e
                    }
                    var t = e.prototype;
                    return t.tag = function(e) {
                        return this._tag = e, this
                    }, t.then = function(e) {
                        return e instanceof Kte ? this._actions.push(e.clone()) : this._actions.push(e._union()), this
                    }, t.target = function(e) {
                        return this._target = e, this
                    }, t.start = function() {
                        return this._target ? (this._finalAction && ene.instance.ActionManager.removeAction(this._finalAction), this._finalAction = this._union(), this._finalAction.setTag(this._tag), ene.instance.ActionManager.addAction(this._finalAction, this._target, !1), this) : (d("Please set target to tween first"), this)
                    }, t.stop = function() {
                        return this._finalAction && ene.instance.ActionManager.removeAction(this._finalAction), this
                    }, t.clone = function(e) {
                        var t = this._union();
                        return yne(e).then(t.clone())
                    }, t.union = function() {
                        var e = this._union();
                        return this._actions.length = 0, this._actions.push(e), this
                    }, t.to = function(e, t, n) {
                        (n = n || Object.create(null)).relative = !1;
                        var i = new mne(e, t, n);
                        return this._actions.push(i), this
                    }, t.by = function(e, t, n) {
                        (n = n || Object.create(null)).relative = !0;
                        var i = new mne(e, t, n);
                        return this._actions.push(i), this
                    }, t.set = function(e) {
                        var t = new gne(e);
                        return this._actions.push(t), this
                    }, t.delay = function(e) {
                        var t = dne(e);
                        return this._actions.push(t), this
                    }, t.call = function(e) {
                        var t = new one(e, undefined, undefined);
                        return this._actions.push(t), this
                    }, t.sequence = function() {
                        var t = e._wrappedSequence.apply(e, arguments);
                        return this._actions.push(t), this
                    }, t.parallel = function() {
                        var t = e._wrappedParallel.apply(e, arguments);
                        return this._actions.push(t), this
                    }, t.repeat = function(t, n) {
                        if (t == 1 / 0) return this.repeatForever(n);
                        var i, r = this._actions;
                        return i = n instanceof e ? n._union() : r.pop(), r.push(function(e, t) {
                            return new lne(e, t)
                        }(i, t)), this
                    }, t.repeatForever = function(t) {
                        var n, i = this._actions;
                        return n = t instanceof e ? t._union() : i.pop(), i.push(function(e) {
                            return new une(e)
                        }(n)), this
                    }, t.reverseTime = function(t) {
                        var n, i = this._actions;
                        return n = t instanceof e ? t._union() : i.pop(), i.push(function(e) {
                            return new pne(e)
                        }(n)), this
                    }, t.hide = function() {
                        var e = new ine;
                        return this._actions.push(e), this
                    }, t.show = function() {
                        var e = new nne;
                        return this._actions.push(e), this
                    }, t.removeSelf = function() {
                        var e = new rne(!1);
                        return this._actions.push(e), this
                    }, e.stopAll = function() {
                        ene.instance.ActionManager.removeAllActions()
                    }, e.stopAllByTag = function(e, t) {
                        ene.instance.ActionManager.removeActionByTag(e, t)
                    }, e.stopAllByTarget = function(e) {
                        ene.instance.ActionManager.removeAllActionsFromTarget(e)
                    }, t._union = function() {
                        var e = this._actions;
                        return 1 === e.length ? e[0] : cne(e)
                    }, t._destroy = function() {
                        this.stop()
                    }, e._wrappedSequence = function() {
                        var t = e._tmp_args;
                        t.length = 0;
                        for (var n = arguments.length, i = 0; i < n; i++) {
                            var r = t[i] = i < 0 || arguments.length <= i ? void 0 : arguments[i];
                            r instanceof e && (t[i] = r._union())
                        }
                        return cne.apply(cne, t)
                    }, e._wrappedParallel = function() {
                        var t = e._tmp_args;
                        t.length = 0;
                        for (var n = arguments.length, i = 0; i < n; i++) {
                            var r = t[i] = i < 0 || arguments.length <= i ? void 0 : arguments[i];
                            r instanceof e && (t[i] = r._union())
                        }
                        return _ne.apply(_ne, t)
                    }, e
                }());

            function yne(e) {
                return new vne(e)
            }

            function Sne(e) {
                return d("tweenUtil' is deprecated, please use 'tween' instead "), new vne(e)
            }
            vne._tmp_args = [], i.Tween = vne, i.tween = yne, i.tweenUtil = Sne
        }
    }
}));