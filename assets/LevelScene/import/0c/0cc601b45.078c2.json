[1,["74Y+8HfqRNLbG+zzrx3dIe"],["_effectAsset"],[["cc.Material",["_states","_defines","_props"],1,12],["cc.EffectAsset",["_name","shaders","techniques"],0]],[[0,0,1,2,3],[1,0,1,2,4]],[[[[0,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{}],[[[{},"mainColor",8,[4,4278979596],"shadeColor1",8,[4,4278848010],"shadeColor2",8,[4,4278190080],"specular",8,[4,1275068416]]],11]]],0,0,[0],[0],[0]],[[[1,"enemyPatchMesh2",[{"hash":3513888528,"name":"enemyPatchMesh2|toon-vs|toon-fs:frag","glsl4":{"vert":"\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\n#if USE_INSTANCING\n  layout(location = 0) in vec4 a_matWorld0;\n  layout(location = 1) in vec4 a_matWorld1;\n  layout(location = 2) in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    layout(location = 3) in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  layout(location = 4) in float a_dyn_batch_id;\n  layout(set = 2, binding = 0) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\n  layout(set = 2, binding = 0) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n#endif\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 specular;\n  vec4 shadeParams;\n  vec4 emissive;\n  vec4 emissiveScaleAndStrenth;\n};\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nlayout(location = 0) out float v_fog_factor;\nlayout(location = 1) out highp vec4 v_shadowPos;\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  lowp  vec4 cc_shadowNFLSInfo;\n  lowp  vec4 cc_shadowWHPBInfo;\n  lowp  vec4 cc_shadowLPNNInfo;\n  lowp  vec4 cc_shadowColor;\n};\n#if CC_RECEIVE_SHADOW\n  layout(set = 0, binding = 3) uniform sampler2D cc_shadowMap;\n  layout(set = 0, binding = 5) uniform sampler2D cc_spotLightingMap;\n#endif\nlayout(location = 5) in vec3 a_position;\nlayout(location = 6) in vec3 a_normal;\nlayout(location = 7) in vec4 a_tangent;\nlayout(location = 8) in vec4 a_joints;\nlayout(location = 9) in vec4 a_weights;\nlayout(location = 10) in vec2 a_texCoord;\nlayout(location = 11) in vec4 a_animData;\nlayout(location = 2) out vec3 v_position;\nlayout(location = 3) out vec3 v_normal;\nlayout(location = 4) out vec2 v_uv;\nlayout(location = 5) out vec2 v_uv1;\nlayout(location = 6) out vec4 v_color;\nlayout(location = 7) out vec3 v_viewNormal;\nlayout(set = 1, binding = 1) uniform myData {\n  vec4 boneMatrix[75];\n  vec4 roleTransf[50];\n  vec4 roleColor[50];\n  vec4 playerScope;\n};\nmat4 getJointMatrix(float i) {\n  int idx = int(i);\n  vec4 v1 = boneMatrix[idx * 3];\n  vec4 v2 = boneMatrix[idx * 3 + 1];\n  vec4 v3 = boneMatrix[idx * 3 + 2];\n  return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\nmat4 skinMatrix () {\n  vec4 joints = vec4(a_joints);\n  return getJointMatrix(joints.x) * a_weights.x\n       + getJointMatrix(joints.y) * a_weights.y\n       + getJointMatrix(joints.z) * a_weights.z\n       + getJointMatrix(joints.w) * a_weights.w;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nStandardVertInput skin(){\n  StandardVertInput In;\n  In.position = vec4(a_position, 1.0);\n  In.normal = a_normal;\n  In.tangent = a_tangent;\n  int index = int(a_animData.x);\n  vec4 color = roleColor[index];\n  v_color = color;\n  mat4 m = skinMatrix();\n  In.position = m * In.position;\n  In.normal = (m * vec4(a_normal, 0.0)).xyz;\n  In.tangent.xyz = (m * vec4(a_tangent.xyz, 0.0)).xyz;\n  In.position.xyz *= color.w;\n  vec4 transf = roleTransf[index];\n  float x = transf.x - playerScope.x;\n  float z = transf.z - playerScope.z;\n  float s = step(0.0, playerScope.w - x * x - z * z);\n  float sr = transf.y;\n  float cr = transf.w;\n  x = In.position.x;\n  z = In.position.z;\n  In.position.x = x * cr + z * sr;\n  In.position.z = -x * sr + z * cr;\n  x = In.normal.x;\n  z = In.normal.z;\n  In.normal.x = x * cr + z * sr;\n  In.normal.z = -x * sr + z * cr;\n  x = In.tangent.x;\n  z = In.tangent.z;\n  In.tangent.x = x * cr + z * sr;\n  In.tangent.z = -x * sr + z * cr;\n  In.position.xz += transf.xz;\n  In.position.xyz *= s;\n  return In;\n}\nvoid main () {\n  StandardVertInput In = skin();\n  vec4 pos = In.position;\n  v_position = pos.xyz;\n  v_normal = In.normal;\n  v_uv = a_texCoord;\n  v_viewNormal = normalize((cc_matView * vec4(In.normal, 0.0)).xyz);\n    #if CC_USE_FOG == 0\n      v_fog_factor = LinearFog(pos);\n    #elif CC_USE_FOG == 1\n      v_fog_factor = ExpFog(pos);\n    #elif CC_USE_FOG == 2\n      v_fog_factor = ExpSquaredFog(pos);\n    #elif CC_USE_FOG == 3\n      v_fog_factor = LayeredFog(pos);\n    #else\n      v_fog_factor = 1.0;\n    #endif\n  v_shadowPos = cc_matLightViewProj * pos;\n  gl_Position = cc_matProj * cc_matView * In.position;\n}","frag":"\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nstruct ToonSurface {\n  vec4 baseColor;\n  vec4 specular;\n  vec3 position;\n  vec3 normal;\n  vec3 shade1;\n  vec3 shade2;\n  vec3 emissive;\n  float baseStep;\n  float baseFeather;\n  float shadeStep;\n  float shadeFeather;\n};\n#if CC_FORWARD_ADD\n  #if CC_PIPELINE_TYPE == 0\n  # define LIGHTS_PER_PASS 1\n  #else\n  # define LIGHTS_PER_PASS 10\n  #endif\n  layout(set = 2, binding = 1) uniform CCForwardLight {\n    highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n    vec4 cc_lightColor[LIGHTS_PER_PASS];\n    vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n    vec4 cc_lightDir[LIGHTS_PER_PASS];\n  };\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  vec4 CCToonShading (ToonSurface s) {\n    vec3 V = normalize(cc_cameraPos.xyz - s.position);\n    vec3 N = normalize(s.normal);\n    float specularWeight = 1.0 - pow(s.specular.a, 5.0);\n    vec3 finalColor = vec3(0.0);\n    for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n      vec3 SLU = cc_lightPos[i].xyz - s.position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = 0.5 * dot(N, SL) + 0.5;\n      float SNH = 0.5 * dot(N, SH) + 0.5;\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = litRadiusSqr / max(litRadiusSqr , distSqr);\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 diffuse = mix(s.shade1, s.shade2,\n        clamp(1.0 + (s.shadeStep - s.shadeFeather - SNL) / s.shadeFeather, 0.0, 1.0));\n      diffuse = mix(s.baseColor.rgb, diffuse,\n        clamp(1.0 + (s.baseStep - s.baseFeather - SNL) / s.baseFeather, 0.0, 1.0));\n      float specularMask = step(specularWeight, SNH);\n      vec3 specular = s.specular.rgb * specularMask;\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      finalColor += SNL * cc_lightColor[i].rgb * cc_lightColor[i].a * illum * att * s.baseStep * (diffuse + specular);\n    }\n    return vec4(finalColor, 0.0);\n  }\n#else\n  #if CC_RECEIVE_SHADOW\n    layout(location = 1) in highp vec4 v_shadowPos;\n    layout(set = 0, binding = 2) uniform CCShadow {\n      highp mat4 cc_matLightPlaneProj;\n      highp mat4 cc_matLightView;\n      highp mat4 cc_matLightViewProj;\n      lowp  vec4 cc_shadowNFLSInfo;\n      lowp  vec4 cc_shadowWHPBInfo;\n      lowp  vec4 cc_shadowLPNNInfo;\n      lowp  vec4 cc_shadowColor;\n    };\n    #if CC_RECEIVE_SHADOW\n      layout(set = 0, binding = 3) uniform sampler2D cc_shadowMap;\n      layout(set = 0, binding = 5) uniform sampler2D cc_spotLightingMap;\n      float CCGetShadowFactorX1 (vec4 shadowPos) {\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n            clipPos.y < 0.0 || clipPos.y > 1.0 ||\n            clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n        float shadow = 0.0;\n        float closestDepth = 0.0;\n        clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n        if (cc_shadowLPNNInfo.y > 0.000001) {\n          closestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n        } else {\n          closestDepth = texture(cc_shadowMap, clipPos.xy).x;\n        }\n        shadow = step(closestDepth, clipPos.z- cc_shadowWHPBInfo.w);\n        return shadow;\n      }\n      float CCGetShadowFactorX5 (vec4 shadowPos) {\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n            clipPos.y < 0.0 || clipPos.y > 1.0 ||\n            clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n        float offsetx = 1.0 / cc_shadowWHPBInfo.x;\n        float offsety = 1.0 / cc_shadowWHPBInfo.y;\n        float shadow = 0.0;\n        clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n        if (cc_shadowLPNNInfo.y > 0.000001) {\n          float closestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          closestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          closestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          closestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          closestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n        } else {\n          float closestDepth = texture(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)).x;\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          closestDepth = texture(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)).x;\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          closestDepth = texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x;\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          closestDepth = texture(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)).x;\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          closestDepth = texture(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)).x;\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n        }\n        return shadow / 5.0;\n      }\n      float CCGetShadowFactorX9 (vec4 shadowPos) {\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n            clipPos.y < 0.0 || clipPos.y > 1.0 ||\n            clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n        float offsetx = 1.0 / cc_shadowWHPBInfo.x;\n        float offsety = 1.0 / cc_shadowWHPBInfo.y;\n        float shadow = 0.0;\n        float closestDepth = 0.0;\n        clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n        if (cc_shadowLPNNInfo.y > 0.000001) {\n          for (int i = -1; i <= 1; i++) {\n              for (int j = -1; j <= 1; j++) {\n                float closestDepth = dot(texture(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n                shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n              }\n          }\n        } else {\n          for (int i = -1; i <= 1; i++) {\n              for (int j = -1; j <= 1; j++) {\n                float closestDepth = texture(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)).x;\n                shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n              }\n          }\n        }\n        return shadow / 9.0;\n      }\n      float CCGetShadowFactorX25 (vec4 shadowPos) {\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n            clipPos.y < 0.0 || clipPos.y > 1.0 ||\n            clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n        float offsetx = 1.0 / cc_shadowWHPBInfo.x;\n        float offsety = 1.0 / cc_shadowWHPBInfo.y;\n        float shadow = 0.0;\n        clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n        if (cc_shadowLPNNInfo.y > 0.000001) {\n          for (int i = -2; i <= 2; i++) {\n            for (int j = -2; j <= 2; j++) {\n              float closestDepth = dot(texture(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n              shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n            }\n          }\n        } else {\n          for (int i = -2; i <= 2; i++) {\n            for (int j = -2; j <= 2; j++) {\n              float closestDepth = texture(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)).x;\n              shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n            }\n          }\n        }\n        return shadow / 25.0;\n      }\n    #endif\n  #endif\n  vec4 CCToonShading (ToonSurface s) {\n    vec3 V = normalize(cc_cameraPos.xyz - s.position);\n    vec3 N = normalize(s.normal);\n    vec3 L = normalize(-cc_mainLitDir.xyz);\n    float NL = 0.5 * dot(N, L) + 0.5;\n    float NH = 0.5 * dot(normalize(V + L), N) + 0.5;\n    vec3 lightColor = cc_mainLitColor.rgb * cc_mainLitColor.w * s.baseStep;\n    vec3 diffuse = mix(s.shade1, s.shade2,\n      clamp(1.0 + (s.shadeStep - s.shadeFeather - NL) / s.shadeFeather, 0.0, 1.0));\n    diffuse = mix(s.baseColor.rgb, diffuse,\n      clamp(1.0 + (s.baseStep - s.baseFeather - NL) / s.baseFeather, 0.0, 1.0));\n    float specularWeight = 1.0 - pow(s.specular.a, 5.0);\n    float specularMask = step(specularWeight, NH);\n    vec3 specular = s.specular.rgb * specularMask;\n    vec3 finalColor = lightColor * (diffuse + specular);\n    #if CC_USE_HDR\n      s.emissive *= cc_exposure.w;\n    #endif\n    finalColor += s.emissive;\n    #if CC_RECEIVE_SHADOW\n              {\n                float pcf = cc_shadowWHPBInfo.z + 0.001;\n                float shadowAttenuation = 0.0;\n                float cosAngle = clamp(1.0 - dot(N, cc_mainLitDir.xyz), 0.0, 1.0);\n                vec3 projWorldPos = v_shadowPos.xyz + cosAngle * cc_shadowLPNNInfo.z * N;\n                vec4 pos = vec4(projWorldPos.xyz, v_shadowPos.w);\n                if (pcf > 3.0) shadowAttenuation = CCGetShadowFactorX25(pos);\n                else if (pcf > 2.0) shadowAttenuation = CCGetShadowFactorX9(pos);\n                else if (pcf > 1.0) shadowAttenuation = CCGetShadowFactorX5(pos);\n                else shadowAttenuation = CCGetShadowFactorX1(pos);\n                vec3 shadowColor = cc_shadowColor.rgb * cc_shadowColor.a + finalColor.rgb * (1.0 - cc_shadowColor.a);\n                if (cc_shadowNFLSInfo.w > 0.000001) {\n                  finalColor.rgb = shadowColor.rgb * shadowAttenuation + finalColor.rgb * (1.0 - shadowAttenuation);\n                } else {\n                  finalColor.rgb = shadowColor.rgb * shadowAttenuation * NL + finalColor.rgb * (1.0 - shadowAttenuation * NL);\n                }\n              }\n    #endif\n    return vec4(finalColor, s.baseColor.a);\n  }\n#endif\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 specular;\n  vec4 shadeParams;\n  vec4 emissive;\n  vec4 emissiveScaleAndStrenth;\n};\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if !CC_USE_HDR\n    color.rgb = sqrt(ACESToneMap(color.rgb));\n  #endif\n  return color;\n}\nlayout(location = 2) in vec3 v_position;\nlayout(location = 4) in vec2 v_uv;\nlayout(location = 6) in vec4 v_color;\nlayout(location = 3) in vec3 v_normal;\nlayout(location = 7) in vec3 v_viewNormal;\nvoid surf (out ToonSurface s) {\n  s.baseColor = v_color;\n  s.shade1 = v_color.xyz * 0.5;\n  s.shade2 = v_color.xyz * 0.3;\n  s.normal = v_normal;\n  s.position = v_position;\n  s.specular = specular;\n  s.emissive = emissive.rgb * emissiveScaleAndStrenth.xyz;\n  s.baseStep = shadeParams.x;\n  s.baseFeather = shadeParams.y;\n  s.shadeStep = shadeParams.z;\n  s.shadeFeather = shadeParams.w;\n}\nvec4 frag () {\n  ToonSurface s; surf(s);\n  vec4 color = CCToonShading(s);\n  float a = 1.0 - sign(v_color.x + v_color.y + v_color.z);\n  float z = 1.0 - abs(v_viewNormal.z);\n  vec4 w = vec4(1.0, 1.0, 1.0, 1.0);\n  w *= z;\n  color = mix(color, w, a);\n  return CCFragOutput(color);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl3":{"vert":"\nprecision highp float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\n#if USE_INSTANCING\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n  layout(std140) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n#endif\nlayout(std140) uniform Constants {\n  vec4 specular;\n  vec4 shadeParams;\n  vec4 emissive;\n  vec4 emissiveScaleAndStrenth;\n};\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nout float v_fog_factor;\nout highp vec4 v_shadowPos;\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  lowp  vec4 cc_shadowNFLSInfo;\n  lowp  vec4 cc_shadowWHPBInfo;\n  lowp  vec4 cc_shadowLPNNInfo;\n  lowp  vec4 cc_shadowColor;\n};\n#if CC_RECEIVE_SHADOW\n  uniform sampler2D cc_shadowMap;\n  uniform sampler2D cc_spotLightingMap;\n#endif\nin vec3 a_position;\nin vec3 a_normal;\nin vec4 a_tangent;\nin vec4 a_joints;\nin vec4 a_weights;\nin vec2 a_texCoord;\nin vec4 a_animData;\nout vec3 v_position;\nout vec3 v_normal;\nout vec2 v_uv;\nout vec2 v_uv1;\nout vec4 v_color;\nout vec3 v_viewNormal;\nlayout(std140) uniform myData {\n  vec4 boneMatrix[75];\n  vec4 roleTransf[50];\n  vec4 roleColor[50];\n  vec4 playerScope;\n};\nmat4 getJointMatrix(float i) {\n  int idx = int(i);\n  vec4 v1 = boneMatrix[idx * 3];\n  vec4 v2 = boneMatrix[idx * 3 + 1];\n  vec4 v3 = boneMatrix[idx * 3 + 2];\n  return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\nmat4 skinMatrix () {\n  vec4 joints = vec4(a_joints);\n  return getJointMatrix(joints.x) * a_weights.x\n       + getJointMatrix(joints.y) * a_weights.y\n       + getJointMatrix(joints.z) * a_weights.z\n       + getJointMatrix(joints.w) * a_weights.w;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nStandardVertInput skin(){\n  StandardVertInput In;\n  In.position = vec4(a_position, 1.0);\n  In.normal = a_normal;\n  In.tangent = a_tangent;\n  int index = int(a_animData.x);\n  vec4 color = roleColor[index];\n  v_color = color;\n  mat4 m = skinMatrix();\n  In.position = m * In.position;\n  In.normal = (m * vec4(a_normal, 0.0)).xyz;\n  In.tangent.xyz = (m * vec4(a_tangent.xyz, 0.0)).xyz;\n  In.position.xyz *= color.w;\n  vec4 transf = roleTransf[index];\n  float x = transf.x - playerScope.x;\n  float z = transf.z - playerScope.z;\n  float s = step(0.0, playerScope.w - x * x - z * z);\n  float sr = transf.y;\n  float cr = transf.w;\n  x = In.position.x;\n  z = In.position.z;\n  In.position.x = x * cr + z * sr;\n  In.position.z = -x * sr + z * cr;\n  x = In.normal.x;\n  z = In.normal.z;\n  In.normal.x = x * cr + z * sr;\n  In.normal.z = -x * sr + z * cr;\n  x = In.tangent.x;\n  z = In.tangent.z;\n  In.tangent.x = x * cr + z * sr;\n  In.tangent.z = -x * sr + z * cr;\n  In.position.xz += transf.xz;\n  In.position.xyz *= s;\n  return In;\n}\nvoid main () {\n  StandardVertInput In = skin();\n  vec4 pos = In.position;\n  v_position = pos.xyz;\n  v_normal = In.normal;\n  v_uv = a_texCoord;\n  v_viewNormal = normalize((cc_matView * vec4(In.normal, 0.0)).xyz);\n    #if CC_USE_FOG == 0\n      v_fog_factor = LinearFog(pos);\n    #elif CC_USE_FOG == 1\n      v_fog_factor = ExpFog(pos);\n    #elif CC_USE_FOG == 2\n      v_fog_factor = ExpSquaredFog(pos);\n    #elif CC_USE_FOG == 3\n      v_fog_factor = LayeredFog(pos);\n    #else\n      v_fog_factor = 1.0;\n    #endif\n  v_shadowPos = cc_matLightViewProj * pos;\n  gl_Position = cc_matProj * cc_matView * In.position;\n}","frag":"\nprecision highp float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nstruct ToonSurface {\n  vec4 baseColor;\n  vec4 specular;\n  vec3 position;\n  vec3 normal;\n  vec3 shade1;\n  vec3 shade2;\n  vec3 emissive;\n  float baseStep;\n  float baseFeather;\n  float shadeStep;\n  float shadeFeather;\n};\n#if CC_FORWARD_ADD\n  #if CC_PIPELINE_TYPE == 0\n  # define LIGHTS_PER_PASS 1\n  #else\n  # define LIGHTS_PER_PASS 10\n  #endif\n  layout(std140) uniform CCForwardLight {\n    highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n    vec4 cc_lightColor[LIGHTS_PER_PASS];\n    vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n    vec4 cc_lightDir[LIGHTS_PER_PASS];\n  };\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  vec4 CCToonShading (ToonSurface s) {\n    vec3 V = normalize(cc_cameraPos.xyz - s.position);\n    vec3 N = normalize(s.normal);\n    float specularWeight = 1.0 - pow(s.specular.a, 5.0);\n    vec3 finalColor = vec3(0.0);\n    for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n      vec3 SLU = cc_lightPos[i].xyz - s.position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = 0.5 * dot(N, SL) + 0.5;\n      float SNH = 0.5 * dot(N, SH) + 0.5;\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = litRadiusSqr / max(litRadiusSqr , distSqr);\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 diffuse = mix(s.shade1, s.shade2,\n        clamp(1.0 + (s.shadeStep - s.shadeFeather - SNL) / s.shadeFeather, 0.0, 1.0));\n      diffuse = mix(s.baseColor.rgb, diffuse,\n        clamp(1.0 + (s.baseStep - s.baseFeather - SNL) / s.baseFeather, 0.0, 1.0));\n      float specularMask = step(specularWeight, SNH);\n      vec3 specular = s.specular.rgb * specularMask;\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      finalColor += SNL * cc_lightColor[i].rgb * cc_lightColor[i].a * illum * att * s.baseStep * (diffuse + specular);\n    }\n    return vec4(finalColor, 0.0);\n  }\n#else\n  #if CC_RECEIVE_SHADOW\n    in highp vec4 v_shadowPos;\n    layout(std140) uniform CCShadow {\n      highp mat4 cc_matLightPlaneProj;\n      highp mat4 cc_matLightView;\n      highp mat4 cc_matLightViewProj;\n      lowp  vec4 cc_shadowNFLSInfo;\n      lowp  vec4 cc_shadowWHPBInfo;\n      lowp  vec4 cc_shadowLPNNInfo;\n      lowp  vec4 cc_shadowColor;\n    };\n    #if CC_RECEIVE_SHADOW\n      uniform sampler2D cc_shadowMap;\n      uniform sampler2D cc_spotLightingMap;\n      float CCGetShadowFactorX1 (vec4 shadowPos) {\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n            clipPos.y < 0.0 || clipPos.y > 1.0 ||\n            clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n        float shadow = 0.0;\n        float closestDepth = 0.0;\n        clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n        if (cc_shadowLPNNInfo.y > 0.000001) {\n          closestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n        } else {\n          closestDepth = texture(cc_shadowMap, clipPos.xy).x;\n        }\n        shadow = step(closestDepth, clipPos.z- cc_shadowWHPBInfo.w);\n        return shadow;\n      }\n      float CCGetShadowFactorX5 (vec4 shadowPos) {\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n            clipPos.y < 0.0 || clipPos.y > 1.0 ||\n            clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n        float offsetx = 1.0 / cc_shadowWHPBInfo.x;\n        float offsety = 1.0 / cc_shadowWHPBInfo.y;\n        float shadow = 0.0;\n        clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n        if (cc_shadowLPNNInfo.y > 0.000001) {\n          float closestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          closestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          closestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          closestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          closestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n        } else {\n          float closestDepth = texture(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)).x;\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          closestDepth = texture(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)).x;\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          closestDepth = texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x;\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          closestDepth = texture(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)).x;\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          closestDepth = texture(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)).x;\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n        }\n        return shadow / 5.0;\n      }\n      float CCGetShadowFactorX9 (vec4 shadowPos) {\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n            clipPos.y < 0.0 || clipPos.y > 1.0 ||\n            clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n        float offsetx = 1.0 / cc_shadowWHPBInfo.x;\n        float offsety = 1.0 / cc_shadowWHPBInfo.y;\n        float shadow = 0.0;\n        float closestDepth = 0.0;\n        clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n        if (cc_shadowLPNNInfo.y > 0.000001) {\n          for (int i = -1; i <= 1; i++) {\n              for (int j = -1; j <= 1; j++) {\n                float closestDepth = dot(texture(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n                shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n              }\n          }\n        } else {\n          for (int i = -1; i <= 1; i++) {\n              for (int j = -1; j <= 1; j++) {\n                float closestDepth = texture(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)).x;\n                shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n              }\n          }\n        }\n        return shadow / 9.0;\n      }\n      float CCGetShadowFactorX25 (vec4 shadowPos) {\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n            clipPos.y < 0.0 || clipPos.y > 1.0 ||\n            clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n        float offsetx = 1.0 / cc_shadowWHPBInfo.x;\n        float offsety = 1.0 / cc_shadowWHPBInfo.y;\n        float shadow = 0.0;\n        clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n        if (cc_shadowLPNNInfo.y > 0.000001) {\n          for (int i = -2; i <= 2; i++) {\n            for (int j = -2; j <= 2; j++) {\n              float closestDepth = dot(texture(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n              shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n            }\n          }\n        } else {\n          for (int i = -2; i <= 2; i++) {\n            for (int j = -2; j <= 2; j++) {\n              float closestDepth = texture(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)).x;\n              shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n            }\n          }\n        }\n        return shadow / 25.0;\n      }\n    #endif\n  #endif\n  vec4 CCToonShading (ToonSurface s) {\n    vec3 V = normalize(cc_cameraPos.xyz - s.position);\n    vec3 N = normalize(s.normal);\n    vec3 L = normalize(-cc_mainLitDir.xyz);\n    float NL = 0.5 * dot(N, L) + 0.5;\n    float NH = 0.5 * dot(normalize(V + L), N) + 0.5;\n    vec3 lightColor = cc_mainLitColor.rgb * cc_mainLitColor.w * s.baseStep;\n    vec3 diffuse = mix(s.shade1, s.shade2,\n      clamp(1.0 + (s.shadeStep - s.shadeFeather - NL) / s.shadeFeather, 0.0, 1.0));\n    diffuse = mix(s.baseColor.rgb, diffuse,\n      clamp(1.0 + (s.baseStep - s.baseFeather - NL) / s.baseFeather, 0.0, 1.0));\n    float specularWeight = 1.0 - pow(s.specular.a, 5.0);\n    float specularMask = step(specularWeight, NH);\n    vec3 specular = s.specular.rgb * specularMask;\n    vec3 finalColor = lightColor * (diffuse + specular);\n    #if CC_USE_HDR\n      s.emissive *= cc_exposure.w;\n    #endif\n    finalColor += s.emissive;\n    #if CC_RECEIVE_SHADOW\n              {\n                float pcf = cc_shadowWHPBInfo.z + 0.001;\n                float shadowAttenuation = 0.0;\n                float cosAngle = clamp(1.0 - dot(N, cc_mainLitDir.xyz), 0.0, 1.0);\n                vec3 projWorldPos = v_shadowPos.xyz + cosAngle * cc_shadowLPNNInfo.z * N;\n                vec4 pos = vec4(projWorldPos.xyz, v_shadowPos.w);\n                if (pcf > 3.0) shadowAttenuation = CCGetShadowFactorX25(pos);\n                else if (pcf > 2.0) shadowAttenuation = CCGetShadowFactorX9(pos);\n                else if (pcf > 1.0) shadowAttenuation = CCGetShadowFactorX5(pos);\n                else shadowAttenuation = CCGetShadowFactorX1(pos);\n                vec3 shadowColor = cc_shadowColor.rgb * cc_shadowColor.a + finalColor.rgb * (1.0 - cc_shadowColor.a);\n                if (cc_shadowNFLSInfo.w > 0.000001) {\n                  finalColor.rgb = shadowColor.rgb * shadowAttenuation + finalColor.rgb * (1.0 - shadowAttenuation);\n                } else {\n                  finalColor.rgb = shadowColor.rgb * shadowAttenuation * NL + finalColor.rgb * (1.0 - shadowAttenuation * NL);\n                }\n              }\n    #endif\n    return vec4(finalColor, s.baseColor.a);\n  }\n#endif\nlayout(std140) uniform Constants {\n  vec4 specular;\n  vec4 shadeParams;\n  vec4 emissive;\n  vec4 emissiveScaleAndStrenth;\n};\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if !CC_USE_HDR\n    color.rgb = sqrt(ACESToneMap(color.rgb));\n  #endif\n  return color;\n}\nin vec3 v_position;\nin vec2 v_uv;\nin vec4 v_color;\nin vec3 v_normal;\nin vec3 v_viewNormal;\nvoid surf (out ToonSurface s) {\n  s.baseColor = v_color;\n  s.shade1 = v_color.xyz * 0.5;\n  s.shade2 = v_color.xyz * 0.3;\n  s.normal = v_normal;\n  s.position = v_position;\n  s.specular = specular;\n  s.emissive = emissive.rgb * emissiveScaleAndStrenth.xyz;\n  s.baseStep = shadeParams.x;\n  s.baseFeather = shadeParams.y;\n  s.shadeStep = shadeParams.z;\n  s.shadeFeather = shadeParams.w;\n}\nvec4 frag () {\n  ToonSurface s; surf(s);\n  vec4 color = CCToonShading(s);\n  float a = 1.0 - sign(v_color.x + v_color.y + v_color.z);\n  float z = 1.0 - abs(v_viewNormal.z);\n  vec4 w = vec4(1.0, 1.0, 1.0, 1.0);\n  w *= z;\n  color = mix(color, w, a);\n  return CCFragOutput(color);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n  uniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_fogBase;\n  uniform mediump vec4 cc_fogAdd;\n#if USE_INSTANCING\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n  #else\n  #endif\nfloat LinearFog(vec4 pos) {\n  vec4 wPos = pos;\n  float cam_dis = distance(cc_cameraPos, wPos);\n  float fogStart = cc_fogBase.x;\n  float fogEnd = cc_fogBase.y;\n  return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n  float f = exp(-cam_dis * fogDensity);\n  return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float fogDensity = cc_fogBase.z;\n  float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n  float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n  return f;\n}\nfloat LayeredFog(vec4 pos) {\n  vec4 wPos = pos;\n  float fogAtten = cc_fogAdd.z;\n  float _FogTop = cc_fogAdd.x;\n  float _FogRange = cc_fogAdd.y;\n  vec3 camWorldProj = cc_cameraPos.xyz;\n  camWorldProj.y = 0.;\n  vec3 worldPosProj = wPos.xyz;\n  worldPosProj.y = 0.;\n  float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n  float fDeltaY, fDensityIntegral;\n  if (cc_cameraPos.y > _FogTop) {\n    if (wPos.y < _FogTop) {\n      fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n      fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n    } else {\n      fDeltaY = 0.;\n      fDensityIntegral = 0.;\n    }\n  } else {\n    if (wPos.y < _FogTop) {\n      float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n      fDeltaY = abs(fDeltaA - fDeltaB);\n      fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n    } else {\n      fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n      fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n    }\n  }\n  float fDensity;\n  if (fDeltaY != 0.) {\n    fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n  } else {\n    fDensity = 0.;\n  }\n  float f = exp(-fDensity);\n  return f;\n}\nvarying float v_fog_factor;\nvarying highp vec4 v_shadowPos;\nuniform highp mat4 cc_matLightViewProj;\n#if CC_RECEIVE_SHADOW\n  uniform sampler2D cc_shadowMap;\n  uniform sampler2D cc_spotLightingMap;\n#endif\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec4 a_tangent;\nattribute vec4 a_joints;\nattribute vec4 a_weights;\nattribute vec2 a_texCoord;\nattribute vec4 a_animData;\nvarying vec3 v_position;\nvarying vec3 v_normal;\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\nvarying vec4 v_color;\nvarying vec3 v_viewNormal;\n    uniform vec4 boneMatrix[75];\n    uniform vec4 roleTransf[50];\n    uniform vec4 roleColor[50];\n    uniform vec4 playerScope;\nmat4 getJointMatrix(float i) {\n  int idx = int(i);\n  vec4 v1 = boneMatrix[idx * 3];\n  vec4 v2 = boneMatrix[idx * 3 + 1];\n  vec4 v3 = boneMatrix[idx * 3 + 2];\n  return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n}\nmat4 skinMatrix () {\n  vec4 joints = vec4(a_joints);\n  return getJointMatrix(joints.x) * a_weights.x\n       + getJointMatrix(joints.y) * a_weights.y\n       + getJointMatrix(joints.z) * a_weights.z\n       + getJointMatrix(joints.w) * a_weights.w;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nStandardVertInput skin(){\n  StandardVertInput In;\n  In.position = vec4(a_position, 1.0);\n  In.normal = a_normal;\n  In.tangent = a_tangent;\n  int index = int(a_animData.x);\n  vec4 color = roleColor[index];\n  v_color = color;\n  mat4 m = skinMatrix();\n  In.position = m * In.position;\n  In.normal = (m * vec4(a_normal, 0.0)).xyz;\n  In.tangent.xyz = (m * vec4(a_tangent.xyz, 0.0)).xyz;\n  In.position.xyz *= color.w;\n  vec4 transf = roleTransf[index];\n  float x = transf.x - playerScope.x;\n  float z = transf.z - playerScope.z;\n  float s = step(0.0, playerScope.w - x * x - z * z);\n  float sr = transf.y;\n  float cr = transf.w;\n  x = In.position.x;\n  z = In.position.z;\n  In.position.x = x * cr + z * sr;\n  In.position.z = -x * sr + z * cr;\n  x = In.normal.x;\n  z = In.normal.z;\n  In.normal.x = x * cr + z * sr;\n  In.normal.z = -x * sr + z * cr;\n  x = In.tangent.x;\n  z = In.tangent.z;\n  In.tangent.x = x * cr + z * sr;\n  In.tangent.z = -x * sr + z * cr;\n  In.position.xz += transf.xz;\n  In.position.xyz *= s;\n  return In;\n}\nvoid main () {\n  StandardVertInput In = skin();\n  vec4 pos = In.position;\n  v_position = pos.xyz;\n  v_normal = In.normal;\n  v_uv = a_texCoord;\n  v_viewNormal = normalize((cc_matView * vec4(In.normal, 0.0)).xyz);\n    #if CC_USE_FOG == 0\n      v_fog_factor = LinearFog(pos);\n    #elif CC_USE_FOG == 1\n      v_fog_factor = ExpFog(pos);\n    #elif CC_USE_FOG == 2\n      v_fog_factor = ExpSquaredFog(pos);\n    #elif CC_USE_FOG == 3\n      v_fog_factor = LayeredFog(pos);\n    #else\n      v_fog_factor = 1.0;\n    #endif\n  v_shadowPos = cc_matLightViewProj * pos;\n  gl_Position = cc_matProj * cc_matView * In.position;\n}","frag":"\nprecision highp float;\nuniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_exposure;\n  uniform mediump vec4 cc_mainLitDir;\n  uniform mediump vec4 cc_mainLitColor;\nstruct ToonSurface {\n  vec4 baseColor;\n  vec4 specular;\n  vec3 position;\n  vec3 normal;\n  vec3 shade1;\n  vec3 shade2;\n  vec3 emissive;\n  float baseStep;\n  float baseFeather;\n  float shadeStep;\n  float shadeFeather;\n};\n#if CC_FORWARD_ADD\n  #if CC_PIPELINE_TYPE == 0\n  # define LIGHTS_PER_PASS 1\n  #else\n  # define LIGHTS_PER_PASS 10\n  #endif\n  uniform highp vec4 cc_lightPos[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightColor[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightSizeRangeAngle[LIGHTS_PER_PASS];\n  uniform vec4 cc_lightDir[LIGHTS_PER_PASS];\n  float SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n    float factor = distSqr * invSqrAttRadius;\n    float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n    return smoothFactor * smoothFactor;\n  }\n  float GetDistAtt (float distSqr, float invSqrAttRadius) {\n    float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n    attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n    return attenuation;\n  }\n  float GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n    float cd = dot(litDir, L);\n    float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n    return (attenuation * attenuation);\n  }\n  vec4 CCToonShading (ToonSurface s) {\n    vec3 V = normalize(cc_cameraPos.xyz - s.position);\n    vec3 N = normalize(s.normal);\n    float specularWeight = 1.0 - pow(s.specular.a, 5.0);\n    vec3 finalColor = vec3(0.0);\n    for (int i = 0; i < LIGHTS_PER_PASS; i++) {\n      vec3 SLU = cc_lightPos[i].xyz - s.position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = 0.5 * dot(N, SL) + 0.5;\n      float SNH = 0.5 * dot(N, SH) + 0.5;\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = litRadiusSqr / max(litRadiusSqr , distSqr);\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 diffuse = mix(s.shade1, s.shade2,\n        clamp(1.0 + (s.shadeStep - s.shadeFeather - SNL) / s.shadeFeather, 0.0, 1.0));\n      diffuse = mix(s.baseColor.rgb, diffuse,\n        clamp(1.0 + (s.baseStep - s.baseFeather - SNL) / s.baseFeather, 0.0, 1.0));\n      float specularMask = step(specularWeight, SNH);\n      vec3 specular = s.specular.rgb * specularMask;\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      finalColor += SNL * cc_lightColor[i].rgb * cc_lightColor[i].a * illum * att * s.baseStep * (diffuse + specular);\n    }\n    return vec4(finalColor, 0.0);\n  }\n#else\n  #if CC_RECEIVE_SHADOW\n    varying highp vec4 v_shadowPos;\n    uniform lowp vec4 cc_shadowNFLSInfo;\n  uniform lowp vec4 cc_shadowWHPBInfo;\n  uniform lowp vec4 cc_shadowLPNNInfo;\n  uniform lowp vec4 cc_shadowColor;\n    #if CC_RECEIVE_SHADOW\n      uniform sampler2D cc_shadowMap;\n      uniform sampler2D cc_spotLightingMap;\n      float CCGetShadowFactorX1 (vec4 shadowPos) {\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n            clipPos.y < 0.0 || clipPos.y > 1.0 ||\n            clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n        float shadow = 0.0;\n        float closestDepth = 0.0;\n        clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n        if (cc_shadowLPNNInfo.y > 0.000001) {\n          closestDepth = dot(texture2D(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n        } else {\n          closestDepth = texture2D(cc_shadowMap, clipPos.xy).x;\n        }\n        shadow = step(closestDepth, clipPos.z- cc_shadowWHPBInfo.w);\n        return shadow;\n      }\n      float CCGetShadowFactorX5 (vec4 shadowPos) {\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n            clipPos.y < 0.0 || clipPos.y > 1.0 ||\n            clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n        float offsetx = 1.0 / cc_shadowWHPBInfo.x;\n        float offsety = 1.0 / cc_shadowWHPBInfo.y;\n        float shadow = 0.0;\n        clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n        if (cc_shadowLPNNInfo.y > 0.000001) {\n          float closestDepth = dot(texture2D(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          closestDepth = dot(texture2D(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          closestDepth = dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          closestDepth = dot(texture2D(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          closestDepth = dot(texture2D(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n        } else {\n          float closestDepth = texture2D(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)).x;\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          closestDepth = texture2D(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)).x;\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          closestDepth = texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x;\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          closestDepth = texture2D(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)).x;\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n          closestDepth = texture2D(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)).x;\n          shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n        }\n        return shadow / 5.0;\n      }\n      float CCGetShadowFactorX9 (vec4 shadowPos) {\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n            clipPos.y < 0.0 || clipPos.y > 1.0 ||\n            clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n        float offsetx = 1.0 / cc_shadowWHPBInfo.x;\n        float offsety = 1.0 / cc_shadowWHPBInfo.y;\n        float shadow = 0.0;\n        float closestDepth = 0.0;\n        clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n        if (cc_shadowLPNNInfo.y > 0.000001) {\n          for (int i = -1; i <= 1; i++) {\n              for (int j = -1; j <= 1; j++) {\n                float closestDepth = dot(texture2D(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n                shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n              }\n          }\n        } else {\n          for (int i = -1; i <= 1; i++) {\n              for (int j = -1; j <= 1; j++) {\n                float closestDepth = texture2D(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)).x;\n                shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n              }\n          }\n        }\n        return shadow / 9.0;\n      }\n      float CCGetShadowFactorX25 (vec4 shadowPos) {\n        vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n        if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n            clipPos.y < 0.0 || clipPos.y > 1.0 ||\n            clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n        float offsetx = 1.0 / cc_shadowWHPBInfo.x;\n        float offsety = 1.0 / cc_shadowWHPBInfo.y;\n        float shadow = 0.0;\n        clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n        if (cc_shadowLPNNInfo.y > 0.000001) {\n          for (int i = -2; i <= 2; i++) {\n            for (int j = -2; j <= 2; j++) {\n              float closestDepth = dot(texture2D(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n              shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n            }\n          }\n        } else {\n          for (int i = -2; i <= 2; i++) {\n            for (int j = -2; j <= 2; j++) {\n              float closestDepth = texture2D(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)).x;\n              shadow += step(closestDepth, clipPos.z - cc_shadowWHPBInfo.w);\n            }\n          }\n        }\n        return shadow / 25.0;\n      }\n    #endif\n  #endif\n  vec4 CCToonShading (ToonSurface s) {\n    vec3 V = normalize(cc_cameraPos.xyz - s.position);\n    vec3 N = normalize(s.normal);\n    vec3 L = normalize(-cc_mainLitDir.xyz);\n    float NL = 0.5 * dot(N, L) + 0.5;\n    float NH = 0.5 * dot(normalize(V + L), N) + 0.5;\n    vec3 lightColor = cc_mainLitColor.rgb * cc_mainLitColor.w * s.baseStep;\n    vec3 diffuse = mix(s.shade1, s.shade2,\n      clamp(1.0 + (s.shadeStep - s.shadeFeather - NL) / s.shadeFeather, 0.0, 1.0));\n    diffuse = mix(s.baseColor.rgb, diffuse,\n      clamp(1.0 + (s.baseStep - s.baseFeather - NL) / s.baseFeather, 0.0, 1.0));\n    float specularWeight = 1.0 - pow(s.specular.a, 5.0);\n    float specularMask = step(specularWeight, NH);\n    vec3 specular = s.specular.rgb * specularMask;\n    vec3 finalColor = lightColor * (diffuse + specular);\n    #if CC_USE_HDR\n      s.emissive *= cc_exposure.w;\n    #endif\n    finalColor += s.emissive;\n    #if CC_RECEIVE_SHADOW\n              {\n                float pcf = cc_shadowWHPBInfo.z + 0.001;\n                float shadowAttenuation = 0.0;\n                float cosAngle = clamp(1.0 - dot(N, cc_mainLitDir.xyz), 0.0, 1.0);\n                vec3 projWorldPos = v_shadowPos.xyz + cosAngle * cc_shadowLPNNInfo.z * N;\n                vec4 pos = vec4(projWorldPos.xyz, v_shadowPos.w);\n                if (pcf > 3.0) shadowAttenuation = CCGetShadowFactorX25(pos);\n                else if (pcf > 2.0) shadowAttenuation = CCGetShadowFactorX9(pos);\n                else if (pcf > 1.0) shadowAttenuation = CCGetShadowFactorX5(pos);\n                else shadowAttenuation = CCGetShadowFactorX1(pos);\n                vec3 shadowColor = cc_shadowColor.rgb * cc_shadowColor.a + finalColor.rgb * (1.0 - cc_shadowColor.a);\n                if (cc_shadowNFLSInfo.w > 0.000001) {\n                  finalColor.rgb = shadowColor.rgb * shadowAttenuation + finalColor.rgb * (1.0 - shadowAttenuation);\n                } else {\n                  finalColor.rgb = shadowColor.rgb * shadowAttenuation * NL + finalColor.rgb * (1.0 - shadowAttenuation * NL);\n                }\n              }\n    #endif\n    return vec4(finalColor, s.baseColor.a);\n  }\n#endif\n    uniform vec4 specular;\n    uniform vec4 shadeParams;\n    uniform vec4 emissive;\n    uniform vec4 emissiveScaleAndStrenth;\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if !CC_USE_HDR\n    color.rgb = sqrt(ACESToneMap(color.rgb));\n  #endif\n  return color;\n}\nvarying vec3 v_position;\nvarying vec2 v_uv;\nvarying vec4 v_color;\nvarying vec3 v_normal;\nvarying vec3 v_viewNormal;\nvoid surf (out ToonSurface s) {\n  s.baseColor = v_color;\n  s.shade1 = v_color.xyz * 0.5;\n  s.shade2 = v_color.xyz * 0.3;\n  s.normal = v_normal;\n  s.position = v_position;\n  s.specular = specular;\n  s.emissive = emissive.rgb * emissiveScaleAndStrenth.xyz;\n  s.baseStep = shadeParams.x;\n  s.baseFeather = shadeParams.y;\n  s.shadeStep = shadeParams.z;\n  s.shadeFeather = shadeParams.w;\n}\nvec4 frag () {\n  ToonSurface s; surf(s);\n  vec4 color = CCToonShading(s);\n  float a = 1.0 - sign(v_color.x + v_color.y + v_color.z);\n  float z = 1.0 - abs(v_viewNormal.z);\n  vec4 w = vec4(1.0, 1.0, 1.0, 1.0);\n  w *= z;\n  color = mix(color, w, a);\n  return CCFragOutput(color);\n}\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]},{"name":"CCShadow","defines":[]}],"samplerTextures":[{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotLightingMap","defines":["CC_RECEIVE_SHADOW"]}]},"locals":{"blocks":[{"name":"CCLocalBatched","defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"CCLocal","defines":["!USE_INSTANCING","!USE_BATCHING"]},{"name":"CCForwardLight","defines":["CC_FORWARD_ADD"]}],"samplerTextures":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":282,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":57}},"defines":[{"name":"USE_INSTANCING","type":"boolean","defines":[],"editor":{"elevated":true}},{"name":"USE_BATCHING","type":"boolean","defines":["!USE_INSTANCING"],"editor":{"elevated":true}},{"name":"USE_LIGHTMAP","type":"boolean","defines":["USE_INSTANCING"]},{"name":"CC_USE_FOG","type":"number","defines":[],"range":[0,4]},{"name":"CC_FORWARD_ADD","type":"boolean","defines":[]},{"name":"CC_RECEIVE_SHADOW","type":"boolean","defines":[]},{"name":"CC_PIPELINE_TYPE","type":"number","defines":["CC_FORWARD_ADD"],"range":[0,1]},{"name":"CC_USE_HDR","type":"boolean","defines":[]}],"blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"specular","type":16,"count":1},{"name":"shadeParams","type":16,"count":1},{"name":"emissive","type":16,"count":1},{"name":"emissiveScaleAndStrenth","type":16,"count":1}],"defines":[]},{"name":"myData","stageFlags":1,"binding":1,"members":[{"name":"boneMatrix","type":16,"count":75},{"name":"roleTransf","type":16,"count":50},{"name":"roleColor","type":16,"count":50},{"name":"playerScope","type":16,"count":1}],"defines":[]}],"samplerTextures":[],"attributes":[{"name":"a_matWorld0","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":0,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":1,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":2,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":3,"defines":["USE_INSTANCING","USE_LIGHTMAP"]},{"name":"a_dyn_batch_id","type":13,"count":1,"stageFlags":1,"format":11,"location":4,"defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"a_position","type":15,"count":1,"stageFlags":1,"format":32,"location":5,"defines":[]},{"name":"a_normal","type":15,"count":1,"stageFlags":1,"format":32,"location":6,"defines":[]},{"name":"a_tangent","type":16,"count":1,"stageFlags":1,"format":44,"location":7,"defines":[]},{"name":"a_joints","type":16,"count":1,"stageFlags":1,"format":44,"location":8,"defines":[]},{"name":"a_weights","type":16,"count":1,"stageFlags":1,"format":44,"location":9,"defines":[]},{"name":"a_texCoord","type":14,"count":1,"stageFlags":1,"format":21,"location":10,"defines":[]},{"name":"a_animData","type":16,"count":1,"stageFlags":1,"format":44,"location":11,"defines":[]}],"varyings":[{"name":"v_fog_factor","type":13,"count":1,"stageFlags":1,"location":0,"defines":[]},{"name":"v_shadowPos","type":16,"count":1,"stageFlags":1,"location":1,"defines":[]},{"name":"v_position","type":15,"count":1,"stageFlags":1,"location":2,"defines":[]},{"name":"v_normal","type":15,"count":1,"stageFlags":1,"location":3,"defines":[]},{"name":"v_uv","type":14,"count":1,"stageFlags":1,"location":4,"defines":[]},{"name":"v_uv1","type":14,"count":1,"stageFlags":1,"location":5,"defines":[]},{"name":"v_color","type":16,"count":1,"stageFlags":1,"location":6,"defines":[]},{"name":"v_viewNormal","type":15,"count":1,"stageFlags":1,"location":7,"defines":[]}]}],[{"passes":[{"program":"enemyPatchMesh2|toon-vs|toon-fs:frag","blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendSrcAlpha":2,"blendDstAlpha":4}]},"properties":{"specular":{"type":16,"value":[1,1,1,0.3],"editor":{"type":"color"}},"baseStep":{"type":13,"value":[0.8],"handleInfo":["shadeParams",0,13]},"baseFeather":{"type":13,"value":[0.001],"handleInfo":["shadeParams",1,13]},"shadeStep":{"type":13,"value":[0.5],"handleInfo":["shadeParams",2,13]},"shadeFeather":{"type":13,"value":[0.001],"handleInfo":["shadeParams",3,13]},"emissive":{"type":16,"value":[0,0,0,1],"editor":{"type":"color"}},"emissiveScale":{"type":15,"value":[1,1,1],"handleInfo":["emissiveScaleAndStrenth",0,15]},"normalStrenth":{"type":13,"value":[1],"editor":{"parent":"USE_NORMAL_MAP"},"handleInfo":["emissiveScaleAndStrenth",3,13]},"shadeParams":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[0.8,0.001,0.5,0.001]},"emissiveScaleAndStrenth":{"type":16,"editor":{"visible":false,"deprecated":true},"value":[1,1,1,1]}}}]}]]],0,0,[],[],[]]]]
